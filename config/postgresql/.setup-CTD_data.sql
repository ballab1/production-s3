--
-- PostgreSQL database dump
--

-- Dumped from database version 10.0
-- Dumped by pg_dump version 10.0

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: PIE; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA "PIE";


ALTER SCHEMA "PIE" OWNER TO postgres;

--
-- Name: accurev; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA accurev;


ALTER SCHEMA accurev OWNER TO postgres;

--
-- Name: audit_control; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA audit_control;


ALTER SCHEMA audit_control OWNER TO postgres;

--
-- Name: SCHEMA audit_control; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA audit_control IS 'This schema is used to manage lists of users under audit control.

The primary definition is ActiveDirectory/LDAP, which is used to update this schema on a regular basis. Differences are then generated between LDAP and actual, and the audit_control userlist is updated appropriately';


--
-- Name: buildlog; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA buildlog;


ALTER SCHEMA buildlog OWNER TO postgres;

--
-- Name: SCHEMA buildlog; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA buildlog IS 'standard public schema';


--
-- Name: buildlog_new; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA buildlog_new;


ALTER SCHEMA buildlog_new OWNER TO postgres;

--
-- Name: buildmetrics; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA buildmetrics;


ALTER SCHEMA buildmetrics OWNER TO postgres;

--
-- Name: cateams; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cateams;


ALTER SCHEMA cateams OWNER TO postgres;

--
-- Name: cateams2; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cateams2;


ALTER SCHEMA cateams2 OWNER TO postgres;

--
-- Name: cyclone; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA cyclone;


ALTER SCHEMA cyclone OWNER TO postgres;

--
-- Name: demo_packaging; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA demo_packaging;


ALTER SCHEMA demo_packaging OWNER TO postgres;

--
-- Name: empdata; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA empdata;


ALTER SCHEMA empdata OWNER TO postgres;

--
-- Name: github; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA github;


ALTER SCHEMA github OWNER TO postgres;

--
-- Name: jenkins; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA jenkins;


ALTER SCHEMA jenkins OWNER TO postgres;

--
-- Name: jenkinslogger; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA jenkinslogger;


ALTER SCHEMA jenkinslogger OWNER TO postgres;

--
-- Name: jira; Type: SCHEMA; Schema: -; Owner: hendrr2
--

CREATE SCHEMA jira;


ALTER SCHEMA jira OWNER TO hendrr2;

--
-- Name: netstat; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA netstat;


ALTER SCHEMA netstat OWNER TO postgres;

--
-- Name: rally; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA rally;


ALTER SCHEMA rally OWNER TO postgres;

--
-- Name: remedy; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA remedy;


ALTER SCHEMA remedy OWNER TO postgres;

--
-- Name: shares; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA shares;


ALTER SCHEMA shares OWNER TO postgres;

--
-- Name: vcenter; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA vcenter;


ALTER SCHEMA vcenter OWNER TO postgres;

--
-- Name: vdiscover; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA vdiscover;


ALTER SCHEMA vdiscover OWNER TO postgres;

--
-- Name: wscommands; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA wscommands;


ALTER SCHEMA wscommands OWNER TO postgres;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: quantile; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS quantile WITH SCHEMA public;


--
-- Name: EXTENSION quantile; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION quantile IS 'Provides quantile aggregate function.';


--
-- Name: tablefunc; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS tablefunc WITH SCHEMA public;


--
-- Name: EXTENSION tablefunc; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION tablefunc IS 'functions that manipulate whole tables, including crosstab';


SET search_path = buildlog, pg_catalog;

--
-- Name: bldinfo; Type: TYPE; Schema: buildlog; Owner: postgres
--

CREATE TYPE bldinfo AS (
  host_class text,
  build_class text,
  ntid text,
  ca text
);


ALTER TYPE bldinfo OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: change; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE change AS (
  "Modified date" timestamp with time zone,
  "Last modified by" character varying,
  note_details character varying,
  "Audit Attribute" character varying,
  "From Value" character varying,
  "To Value" character varying,
  id bigint
);


ALTER TYPE change OWNER TO postgres;

--
-- Name: historyitem; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE historyitem AS (
  "fieldType" text,
  field text,
  "from" text,
  "fromString" text,
  "to" text,
  "toString" text
);


ALTER TYPE historyitem OWNER TO postgres;

--
-- Name: jira_cascadingselect; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_cascadingselect AS (
  "0" text,
  "1" text
);


ALTER TYPE jira_cascadingselect OWNER TO postgres;

--
-- Name: jira_comment; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_comment AS (
  author text,
  body text,
  created text
);


ALTER TYPE jira_comment OWNER TO postgres;

--
-- Name: jira_customfield_array; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_customfield_array AS (
  "fieldName" text,
  "fieldType" text,
  value text[]
);


ALTER TYPE jira_customfield_array OWNER TO postgres;

--
-- Name: jira_customfield_hash; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_customfield_hash AS (
  "fieldName" text,
  "fieldType" text,
  value jira_cascadingselect
);


ALTER TYPE jira_customfield_hash OWNER TO postgres;

--
-- Name: jira_customfield_text; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_customfield_text AS (
  "fieldName" text,
  "fieldType" text,
  value text
);


ALTER TYPE jira_customfield_text OWNER TO postgres;

--
-- Name: jira_history; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_history AS (
  author text,
  created text,
  items historyitem[]
);


ALTER TYPE jira_history OWNER TO postgres;

--
-- Name: jira_issue; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_issue AS (
  "externalId" bigint,
  assignee text,
  created text,
  components text[],
  description text,
  "issueType" text,
  priority text,
  reporter text,
  resolution text,
  status text,
  summary text,
  updated text,
  watchers text[],
  comments jira_comment[],
  history jira_history[],
  "customFieldValues" jira_customfield_text[],
  "customFieldValues1" jira_customfield_array[],
  "customFieldValues2" jira_customfield_hash[]
);


ALTER TYPE jira_issue OWNER TO postgres;

--
-- Name: jira_link; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_link AS (
  name text,
  "sourceId" bigint,
  "destinationId" bigint
);


ALTER TYPE jira_link OWNER TO postgres;

--
-- Name: jira_version; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_version AS (
  archived boolean,
  released boolean,
  name text
);


ALTER TYPE jira_version OWNER TO postgres;

--
-- Name: jira_project; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_project AS (
  key text,
  name text,
  type text,
  description text,
  versions jira_version[],
  components text[],
  issues jira_issue[]
);


ALTER TYPE jira_project OWNER TO postgres;

--
-- Name: jira_user; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE jira_user AS (
  name text,
  active boolean,
  email text,
  fullname text,
  groups text[]
);


ALTER TYPE jira_user OWNER TO postgres;

--
-- Name: note; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE note AS (
  "Modified date" timestamp with time zone,
  "Last modified by" character varying,
  note_details character varying
);


ALTER TYPE note OWNER TO postgres;

--
-- Name: projversions; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE projversions AS (
  archived boolean,
  released boolean,
  name text
);


ALTER TYPE projversions OWNER TO postgres;

--
-- Name: weekly_statistics; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE weekly_statistics AS (
  "number of builds" bigint,
  "median time" interval,
  "minimum time" interval,
  "maximum time" interval,
  "average time" interval,
  "stddev time" interval
);


ALTER TYPE weekly_statistics OWNER TO postgres;

SET search_path = accurev, pg_catalog;

--
-- Name: allchildstreams(text); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION allchildstreams(streamname text) RETURNS TABLE(level integer, streamnumber bigint, basisstreamnumber bigint, type character varying)
    LANGUAGE sql
    AS $_$

WITH RECURSIVE
 x1 as (select * from accurev.stream_daily where depotname = split_part($1::text, '-', 1)),
 x2(level, streamnumber,basisstreamnumber,type)
    as (select 1 "level", streamnumber, basisstreamnumber,type from x1 where basisstreamnumber=accurev.streamnumber($1::text)
  union all
  select distinct "level"+1, x1.streamnumber, x1.basisstreamnumber,x1.type from x2,x1
   where x1.basisstreamnumber = x2.streamnumber)
select * from x2;

$_$;


ALTER FUNCTION accurev.allchildstreams(streamname text) OWNER TO postgres;

--
-- Name: childstreams(text); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION childstreams(streamname text) RETURNS TABLE(name character varying, basis character varying, basisstreamnumber bigint, depotname character varying, streamnumber bigint, isdynamic boolean, type character varying, starttime bigint, hidden boolean, hasproperties boolean, level integer)
    LANGUAGE sql
    AS $_$

WITH
a as (select * from accurev.allchildstreams($1::text)
       where type != 'workspace' AND level < 4),
b as (select z.*,a.level from a
        LEFT JOIN accurev.stream_daily z ON a.streamnumber = z.streamnumber AND z.depotname = split_part($1::text, '-', 1)
       WHERE z."name" !~* '-\d{12}$'
     )
select * from b;

$_$;


ALTER FUNCTION accurev.childstreams(streamname text) OWNER TO postgres;

--
-- Name: dailycheckins(text); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION dailycheckins(streamname text) RETURNS TABLE("Date" date, "Total_Check_ins" bigint)
    LANGUAGE sql
    AS $_$
  WITH 
    strm AS (
     SELECT DISTINCT stream_daily.streamnumber
       FROM accurev.stream_daily
      WHERE stream_daily.name::text = $1::text
    )
   , trans AS (
     SELECT DISTINCT promotion_fileversions.t_id
       FROM accurev.promotion_fileversions
      WHERE (promotion_fileversions.vstream IN ( SELECT strm.streamnumber FROM strm))
    )
  , t1 AS (
     SELECT date(to_timestamp(transactions.t_time)) as date
       FROM accurev.transactions
      WHERE transactions.t_type::text = 'promote'::text AND (transactions.t_id IN ( SELECT trans.t_id FROM trans))
    )
  , yy AS (
     SELECT t1.date, count(*) AS count
       FROM t1
      GROUP BY t1.date
      ORDER BY t1.date
    )
  SELECT yy.date AS "Date", yy.count AS "Total_Check_ins"
     FROM yy;
$_$;


ALTER FUNCTION accurev.dailycheckins(streamname text) OWNER TO postgres;

--
-- Name: developers(text); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION developers(streamname text) RETURNS SETOF character varying
    LANGUAGE sql
    AS $_$
  WITH 
   strms as (select * from accurev.childstreams($1::text))
   ,y1   as (select * from accurev.promotion_fileversions z
         left join accurev.transactions y on z.t_id = y.t_id
          where rstream in (select streamnumber from strms) and vstream in (select streamnumber from strms))
   ,y2   as (select distinct t_user from y1)
   select t_user ntlogin from y2;
$_$;


ALTER FUNCTION accurev.developers(streamname text) OWNER TO postgres;

--
-- Name: domain_stream(text); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION domain_stream(stream text) RETURNS character varying
    LANGUAGE sql
    AS $_$

    WITH RECURSIVE
     x1 as (select * from accurev.stream_daily where depotname = 'upc'
           )
    ,x2(level, streamnumber, basisstreamnumber, type, name)
        as (select 0 "level", streamnumber, basisstreamnumber, type, name
              from x1 
             where streamnumber=accurev.streamnumber($1)
        union all
        select distinct "level"+1, x1.streamnumber, x1.basisstreamnumber,x1.type, x1.name
          from x2,x1
         where x2.basisstreamnumber = x1.streamnumber
           and x2.name not in (select stream from accurev.domain_streams)
           )
    ,x3 as (select max(level) "level" from x2)
    ,x4 as (select name from x3
              left join x2 on x2.level = x3.level
            )
    select name from x4;


$_$;


ALTER FUNCTION accurev.domain_stream(stream text) OWNER TO postgres;

--
-- Name: filtered_promotions(bigint, bigint, bigint); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION filtered_promotions(filter_id bigint, start_trans bigint DEFAULT NULL::bigint, end_trans bigint DEFAULT NULL::bigint) RETURNS TABLE(transaction bigint, "time" timestamp with time zone, ntlogin character varying, name character varying, rally_name character varying, email character varying, ca character varying, project character varying, stream character varying, path character varying, version integer, comments character varying[])
    LANGUAGE sql
    AS $_$


  with
    args   as (select $1 as filter_id, $2 as start_trans, $3 as end_trans)
   ,fc     as (select y.id,
                      y.comment, 
                      y.email,
                      case 
                          when z.start_trans is null then y.last_transaction
                          when z.start_trans < 2 then 1
                          else (z.start_trans - 1)
                      end as start_trans,
                      case 
                          when z.end_trans is null then (select max(t_id) from accurev.transactions)
                          when z.end_trans is null or z.end_trans < start_trans then start_trans
                          else z.end_trans
                      end as end_trans,
                      case 
                          when z.start_trans is null then false
                          else true
                      end as start_defined,
                      case 
                          when z.end_trans is null then false
                          else true
                      end as end_defined
                 from args z, accurev.filter_comments y
                where z.filter_id is not null and y.id = z.filter_id
                )
  ,fc2     as (select z.id,
                      z.start_trans,
                      z.end_trans,
                      z.comment,
                      z.email,
                      y.file_match,
                      y.file_exclude,
                      y.stream_match,
                      y.stream_exclude,
                      CASE 
                          WHEN y.type_match IS NULL THEN NULL
                          ELSE x.type_name
                      END as type_match,
                      CASE 
                          WHEN y.type_exclude IS NULL THEN NULL
                          ELSE w.type_name
                      END as type_exclude,
                      y.ntlogin_match,
                      y.ntlogin_exclude
                 from fc z
                 left join accurev.filter_data y on z.id = y.filter_comment_id
                 left join accurev.elem_types x on x.id = y.type_match
                 left join accurev.elem_types w on w.id = y.type_exclude
              )
   ,a0   as   (select distinct y.t_id from fc2 z
                 left join accurev.initial_checkins y
                   on (z.file_match is null or y.path ~* z.file_match)
                  and (z.file_exclude is null or y.path !~* z.file_exclude)
                  and (z.stream_match is null or y.name ~* z.stream_match)
                  and (z.stream_exclude is null or y.name !~* z.stream_exclude)
                  and (z.type_match is null or y.type = z.type_match)
                  and (z.type_exclude is null or y.type != z.type_exclude)
                  and (z.ntlogin_match is null or y.t_user ~* z.ntlogin_match)
                  and (z.ntlogin_exclude is null or y.t_user !~* z.ntlogin_exclude)
              where y.t_id is not null
                and y.t_id > z.start_trans
                and y.t_id <= z.end_trans
              ) 
    ,u    as  (update accurev.filter_comments set (last_transaction) = (
               (select max(t_id) from accurev.transactions))
                 where id in (select id from fc)
                   and false in (select start_defined from fc)
                   and false in (select end_defined from fc)
                   and has_table_privilege('accurev.filter_comments', 'UPDATE')
                   and (select count(*) from a0) > 0
              )
    ,a1   as  (select z.t_id, z.t_comment, z.t_comment_line
                 from a0 y
                 left join accurev.promotion_comments z on y.t_id = z.t_id
                 order by z.t_comment_line
              )            
    ,a2  as   (select z.t_id, array_agg(z.t_comment) "comments"
                 from a1 z
                 group by z.t_id
              )            
    ,a3  as   (select y.t_id "transaction",
                      to_timestamp(y.t_time) "time",
                      y.t_user ntlogin,
                      w.name,
                      v.rally_name,
                      w.email,
                      v.ca,
                      v.project,
                      y.basis stream,
                      y.path,
                      y.vvers,
                      u.comments
                 from a0 z
                 left join accurev.initial_checkins y on y.t_id = z.t_id
                 left join fc2 x on (x.start_trans < z.t_id and x.end_trans >= z.t_id)
                 left join empdata.employee_data w on lower(w.ntlogin) = lower(y.t_user)
                 left join cateams.rally_info v on lower(v.email) = lower(w.email)
                 left join a2 u on u.t_id = z.t_id
                where (x.file_match is null or y.path ~* x.file_match)
                  and (x.stream_match is null or y.name ~* x.stream_match)
                  and (x.type_match is null or y.type = x.type_match)
                  and (x.ntlogin_match is null or y.t_user ~* x.ntlogin_match)
                  and (x.file_exclude is null or y.path !~* x.file_exclude)
                  and (x.stream_exclude is null or y.name !~* x.stream_exclude)
                  and (x.type_exclude is null or y.type != x.type_exclude)
                  and (x.ntlogin_exclude is null or y.t_user !~* x.ntlogin_exclude)
                order by "transaction"
              )
select * from a3;


$_$;


ALTER FUNCTION accurev.filtered_promotions(filter_id bigint, start_trans bigint, end_trans bigint) OWNER TO postgres;

--
-- Name: filtered_promotions(bigint, timestamp with time zone, timestamp with time zone); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION filtered_promotions(filter_id bigint, start_datetime timestamp with time zone, end_datetime timestamp with time zone) RETURNS TABLE(transaction bigint, "time" timestamp with time zone, ntlogin character varying, name character varying, rally_name character varying, email character varying, ca character varying, project character varying, stream character varying, path character varying, version integer, comments character varying[])
    LANGUAGE sql
    AS $_$

    select * from accurev.filtered_promotions($1, 
                                              (select MIN(t_id) t_id
                                                 from accurev.initial_checkins
                                                where to_timestamp(t_time) >= $2
                                               ),
                                              (select MAX(t_id) t_id
                                                 from accurev.initial_checkins
                                                where to_timestamp(t_time) <= $3
                                               )
                                              );

$_$;


ALTER FUNCTION accurev.filtered_promotions(filter_id bigint, start_datetime timestamp with time zone, end_datetime timestamp with time zone) OWNER TO postgres;

--
-- Name: getdepotmedian(text); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION getdepotmedian(depot text) RETURNS integer
    LANGUAGE sql
    AS $_$
   WITH
   summary AS (SELECT user_name, COUNT(*) AS wspaces FROM accurev.wspaces_data WHERE depot=$1 GROUP BY user_name),
   results AS (SELECT wspaces FROM summary ORDER BY wspaces OFFSET (SELECT count(*) FROM summary)/2 LIMIT 1)
   SELECT SUM(wspaces)::integer FROM results;
;
$_$;


ALTER FUNCTION accurev.getdepotmedian(depot text) OWNER TO postgres;

--
-- Name: getuserwcount(text, integer); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION getuserwcount(depot text, val integer) RETURNS integer
    LANGUAGE sql
    AS $_$
   WITH
   summary AS (SELECT user_name, COUNT(*) AS wspaces FROM accurev.wspaces_data WHERE depot=$1 GROUP BY user_name)
   SELECT COUNT(*)::integer FROM summary WHERE wspaces > $2;
;
$_$;


ALTER FUNCTION accurev.getuserwcount(depot text, val integer) OWNER TO postgres;

--
-- Name: streamnumber(text); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION streamnumber(stream text) RETURNS bigint
    LANGUAGE sql
    AS $_$
   SELECT DISTINCT stream_daily.streamnumber
     FROM accurev.stream_daily
    WHERE stream_daily.name = $1::text
      AND depotname = split_part($1::text, '-', 1);

$_$;


ALTER FUNCTION accurev.streamnumber(stream text) OWNER TO postgres;

--
-- Name: weeklycheckins(text); Type: FUNCTION; Schema: accurev; Owner: postgres
--

CREATE FUNCTION weeklycheckins(streamname text) RETURNS TABLE("Week_Number" character varying, "From_Date" date, "To_Date" date, "Total_Check_ins" bigint)
    LANGUAGE sql
    AS $_$
   WITH apps AS (
     SELECT DISTINCT stream_daily.streamnumber
       FROM accurev.stream_daily
      WHERE stream_daily.name::text = $1::text
    ), trans AS (
     SELECT DISTINCT promotion_fileversions.t_id
       FROM accurev.promotion_fileversions
      WHERE (promotion_fileversions.vstream IN ( SELECT apps.streamnumber
         FROM apps))
    ), t1 AS (
     SELECT date_part('Year'::text, to_timestamp(transactions.t_time::double precision)) AS year, date_part('Week'::text, to_timestamp(transactions.t_time::double precision)) AS week, to_timestamp(transactions.t_time::double precision) AS tm
       FROM accurev.transactions
      WHERE transactions.t_type::text = 'promote'::text AND (transactions.t_id IN ( SELECT trans.t_id
         FROM trans))
    ), yy AS (
     SELECT t1.year, t1.week, startofweek(min(t1.tm)) AS "From_Date", count(*) AS count
       FROM t1
      GROUP BY t1.year, t1.week
      ORDER BY t1.week
    )
   SELECT 'Week '::text || yy.week AS "Week_Number", yy."From_Date", date(yy."From_Date" + '6 days'::interval) AS "To_Date", yy.count AS "Total_Check_ins"
     FROM yy;
$_$;


ALTER FUNCTION accurev.weeklycheckins(streamname text) OWNER TO postgres;

SET search_path = audit_control, pg_catalog;

--
-- Name: create_tables(text); Type: FUNCTION; Schema: audit_control; Owner: postgres
--

CREATE FUNCTION create_tables(audit_type text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
  audit_type ALIAS FOR $1;
  qry_str text := '
CREATE TABLE audit_control.' || audit_type || '_ldap
(
  distinguishedname  character varying NOT NULL
)
WITH (
  OIDS=FALSE
);
ALTER TABLE audit_control.' || audit_type || '_ldap  OWNER TO postgres;
GRANT SELECT, REFERENCES ON TABLE audit_control.' || audit_type || '_ldap TO public;
GRANT ALL ON TABLE audit_control.' || audit_type || '_ldap TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE audit_control.' || audit_type || '_ldap TO postgres;

CREATE TABLE audit_control.' || audit_type || '_live
(
  ntlogin character varying
)
WITH (
  OIDS=FALSE
);
ALTER TABLE audit_control.' || audit_type || '_live  OWNER TO postgres;
GRANT SELECT, REFERENCES ON TABLE audit_control.' || audit_type || '_live TO public;
GRANT ALL ON TABLE audit_control.' || audit_type || '_live TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE audit_control.' || audit_type || '_live TO postgres;
';

BEGIN 

EXECUTE qry_str;

END; 
$_$;


ALTER FUNCTION audit_control.create_tables(audit_type text) OWNER TO postgres;

--
-- Name: FUNCTION create_tables(audit_type text); Type: COMMENT; Schema: audit_control; Owner: postgres
--

COMMENT ON FUNCTION create_tables(audit_type text) IS 'use to create a pair of tables (live, ldap) to represent the list of users from an external system with its own user database and a list of members from an LDAP distribution list';


--
-- Name: differences(text); Type: FUNCTION; Schema: audit_control; Owner: postgres
--

CREATE FUNCTION differences(list text) RETURNS TABLE(ntlogin text, state text)
    LANGUAGE plpgsql
    AS $_$
DECLARE
  list ALIAS FOR $1;
  ldap_table text := (SELECT ldap_table_name from audit_control.distro_lists WHERE friendly_name = list LIMIT 1);
  live_table text := (SELECT live_table_name from audit_control.distro_lists WHERE friendly_name = list LIMIT 1);
  qry_str text := '

with
 a as (select lower(ntlogin) ntlogin from ' || ldap_table || ' z
         left join empdata.employee_data y using (distinguishedname)
      )
,b as (select lower(ntlogin) ntlogin from ' || live_table || ' z
         left join empdata.employee_data y using (ntlogin)
        where lower(ntlogin) not in (select ntlogin from audit_control.service_accounts)
      )
,c as (select ntlogin from a except select ntlogin from b)
,d as (select ntlogin from b except select ntlogin from a)
,e as (select ntlogin, ''add''::text state from c)
,f as (select ntlogin, ''remove''::text state from d)
,g as (select * from e union select * from f)

select * from g where ntlogin is not null;
';

BEGIN 

RETURN QUERY EXECUTE qry_str;

END; 
$_$;


ALTER FUNCTION audit_control.differences(list text) OWNER TO postgres;

--
-- Name: f_dynaupdate(text, text); Type: FUNCTION; Schema: audit_control; Owner: postgres
--

CREATE FUNCTION f_dynaupdate(text, text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    list ALIAS FOR $1;
    file ALIAS FOR $2;
    ldap_table text;
BEGIN

 ldap_table := (SELECT ldap_table_name from audit_control.distro_lists WHERE friendly_name = list LIMIT 1);


EXECUTE '

TRUNCATE ' || ldap_table || ';
COPY ' || ldap_table || ' FROM ' || chr(39) || file || chr(39)  || ' ESCAPE ''\'' CSV HEADER;
';

END;
$_$;


ALTER FUNCTION audit_control.f_dynaupdate(text, text) OWNER TO postgres;

--
-- Name: report_differences(text); Type: FUNCTION; Schema: audit_control; Owner: postgres
--

CREATE FUNCTION report_differences(list text) RETURNS TABLE(comments text)
    LANGUAGE plpgsql
    AS $_$
DECLARE
  list ALIAS FOR $1;
  ldap_table text := (SELECT ldap_table_name from audit_control.distro_lists WHERE friendly_name = list LIMIT 1);
  live_table text := (SELECT live_table_name from audit_control.distro_lists WHERE friendly_name = list LIMIT 1);
  qry_str text := '

with
 a as (select lower(ntlogin) ntlogin from ' || ldap_table || ' z
         left join empdata.employee_data y using (distinguishedname)
      )
,b as (select lower(ntlogin) ntlogin from ' || live_table || ' z
         left join empdata.employee_data y using (ntlogin)
        where lower(ntlogin) not in (select ntlogin from audit_control.service_accounts)
      )
,c as (select ntlogin from a except select ntlogin from b)
,d as (select ntlogin from b except select ntlogin from a)
,e as (select ntlogin, ''add''::text state from c where ntlogin is not null)
,f as (select ntlogin, ''remove''::text state from d where ntlogin is not null)
,g as (select * from e union select * from f)

select comments from (values
 (''current ldap:    '' || (select count(*) from ' || ldap_table || '))
,(''current live:    '' || (select count(*) from ' || live_table || '))
,(''live additions:  '' || (select count(*) from e))
,(''live removals:   '' || (select count(*) from f))
) as x(comments)
';

BEGIN 

RETURN QUERY EXECUTE qry_str;

END; 
$_$;


ALTER FUNCTION audit_control.report_differences(list text) OWNER TO postgres;

SET search_path = buildlog, pg_catalog;

--
-- Name: average_components_bld(text); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION average_components_bld(build_class text) RETURNS TABLE(week date, bamxml interval, blockshim_ng interval, c4core interval, c4csx interval, cemgui interval, clariion interval, cp interval, cta interval, cumulus interval, gms interval, healthchecks interval, infrastructureproviders interval, jmi interval, kernel interval, libpsm interval, mf interval, mf_common interval, nxgui interval, observability interval, papi interval, restcommon interval, sade interval, safe interval, security interval, serviceability interval, tbn interval, tomcatcommon interval, udoctor interval, uemcli interval, unirest interval, univasa interval, vmwaresdkclient interval, vvnxdeploydual interval)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT *
               FROM buildlog.baseresults
              WHERE id NOT IN (SELECT id FROM buildlog.suspectresults)             
            )
,bcmpts  AS (SELECT z.id,
                    z.component, 
                    sum(z.duration) duration,
                    every(z.phase = 'prepare') "prepare",
                    y.component_class as packaging
               FROM buildlog.componentsbyoccurrence z
               LEFT OUTER JOIN buildlog.componentmeta y ON (y.component = z.component)
               WHERE y.component_class != 'meta'
               GROUP BY z.id, z.component, y.component_class
            )
,cmpts   AS (SELECT id,
                    component, 
                    duration,
                    packaging
               FROM bcmpts
               WHERE "prepare" = false OR "prepare" is null 
            )
,a       AS (SELECT y.week::date
                  , cmpts.component
                  , y.result
                  , cmpts.duration
                  , base.fault_component
               FROM base
               CROSS JOIN arg
               LEFT OUTER JOIN buildlog.etlresults y ON (base.id = y.id)
               LEFT OUTER JOIN buildlog.hosts x ON (base.host = x.host)
               LEFT OUTER JOIN buildlog.fault_class w ON (base.fault_class = w.fault_class)
               LEFT OUTER JOIN cmpts ON (base.id = cmpts.id)
          where y.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)
 
,ap  as (select week, component, duration from a where result = 'pass' or component != fault_component)
,p02 as (select week, (round(avg(duration),0) || ' seconds')::interval "bamxml" from ap where component = 'bamxml' group by week)
,p03 as (select week, (round(avg(duration),0) || ' seconds')::interval "blockshim_ng" from ap where component = 'blockshim_ng' group by week)
,p09 as (select week, (round(avg(duration),0) || ' seconds')::interval "c4core" from ap where component = 'c4core' group by week)
,p10 as (select week, (round(avg(duration),0) || ' seconds')::interval "c4csx" from ap where component = 'c4csx' group by week)
,p11 as (select week, (round(avg(duration),0) || ' seconds')::interval "cemgui" from ap where component = 'cemgui' group by week)
,p12 as (select week, (round(avg(duration),0) || ' seconds')::interval "clariion" from ap where component = 'clariion' group by week)
,p14 as (select week, (round(avg(duration),0) || ' seconds')::interval "cp" from ap where component = 'cp' group by week)
,p16 as (select week, (round(avg(duration),0) || ' seconds')::interval "cta" from ap where component = 'cta' group by week)
,p17 as (select week, (round(avg(duration),0) || ' seconds')::interval "cumulus" from ap where component = 'cumulus' group by week)
,p20 as (select week, (round(avg(duration),0) || ' seconds')::interval "gms" from ap where component = 'gms' group by week)
,p21 as (select week, (round(avg(duration),0) || ' seconds')::interval "healthchecks" from ap where component = 'healthchecks' group by week)
,p24 as (select week, (round(avg(duration),0) || ' seconds')::interval "infrastructureproviders" from ap where component = 'infrastructureproviders' group by week)
,p29 as (select week, (round(avg(duration),0) || ' seconds')::interval "jmi" from ap where component = 'jmi' group by week)
,p30 as (select week, (round(avg(duration),0) || ' seconds')::interval "kernel" from ap where component = 'kernel' group by week)
,p32 as (select week, (round(avg(duration),0) || ' seconds')::interval "libpsm" from ap where component = 'libpsm' group by week)
,p33 as (select week, (round(avg(duration),0) || ' seconds')::interval "mf" from ap where component = 'mf' group by week)
,p34 as (select week, (round(avg(duration),0) || ' seconds')::interval "mf_common" from ap where component = 'mf_common' group by week)
,p35 as (select week, (round(avg(duration),0) || ' seconds')::interval "nxgui" from ap where component = 'nxgui' group by week)
,p36 as (select week, (round(avg(duration),0) || ' seconds')::interval "observability" from ap where component = 'observability' group by week)
,p39 as (select week, (round(avg(duration),0) || ' seconds')::interval "papi" from ap where component = 'papi' group by week)
,p42 as (select week, (round(avg(duration),0) || ' seconds')::interval "restcommon" from ap where component = 'restcommon' group by week)
,p45 as (select week, (round(avg(duration),0) || ' seconds')::interval "sade" from ap where component = 'sade' group by week)
,p46 as (select week, (round(avg(duration),0) || ' seconds')::interval "safe" from ap where component = 'safe' group by week)
,p47 as (select week, (round(avg(duration),0) || ' seconds')::interval "security" from ap where component = 'security' group by week)
,p48 as (select week, (round(avg(duration),0) || ' seconds')::interval "serviceability" from ap where component = 'serviceability' group by week)
,p53 as (select week, (round(avg(duration),0) || ' seconds')::interval "tbn" from ap where component = 'tbn' group by week)
,p54 as (select week, (round(avg(duration),0) || ' seconds')::interval "tomcatcommon" from ap where component = 'tomcatcommon' group by week)
,p55 as (select week, (round(avg(duration),0) || ' seconds')::interval "udoctor" from ap where component = 'udoctor' group by week)
,p56 as (select week, (round(avg(duration),0) || ' seconds')::interval "uemcli" from ap where component = 'uemcli' group by week)
,p57 as (select week, (round(avg(duration),0) || ' seconds')::interval "unirest" from ap where component = 'unirest' group by week)
,p58 as (select week, (round(avg(duration),0) || ' seconds')::interval "univasa" from ap where component = 'univasa' group by week)
,p60 as (select week, (round(avg(duration),0) || ' seconds')::interval "vmwaresdkclient" from ap where component = 'vmwaresdkclient' group by week)
,p63 as (select week, (round(avg(duration),0) || ' seconds')::interval "vvnxdeploydual" from ap where component = 'vvnxdeploydual' group by week)


,pp as (select * from aa
            left join p02 using (week)
            left join p03 using (week)
            left join p09 using (week)
            left join p10 using (week)
            left join p11 using (week)
            left join p12 using (week)
            left join p14 using (week)
            left join p16 using (week)
            left join p17 using (week)
            left join p20 using (week)
            left join p21 using (week)
            left join p24 using (week)
            left join p29 using (week)
            left join p30 using (week)
            left join p32 using (week)
            left join p33 using (week)
            left join p34 using (week)
            left join p35 using (week)
            left join p36 using (week)
            left join p39 using (week)
            left join p42 using (week)
            left join p45 using (week)
            left join p46 using (week)
            left join p47 using (week)
            left join p48 using (week)
            left join p53 using (week)
            left join p54 using (week)
            left join p55 using (week)
            left join p56 using (week)
            left join p57 using (week)
            left join p58 using (week)
            left join p60 using (week)
            left join p63 using (week)
          )
select * from pp order by week;


$_$;


ALTER FUNCTION buildlog.average_components_bld(build_class text) OWNER TO postgres;

--
-- Name: average_components_meta(text); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION average_components_meta(build_class text) RETURNS TABLE(week date, "all" interval, build interval, package interval, prepare interval, setup interval)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT *
               FROM buildlog.baseresults
              WHERE id NOT IN (SELECT id FROM buildlog.suspectresults)             
            )
,cmpts  AS (SELECT z.id,
                    z.component, 
                    sum(z.duration) duration,
                    y.component_class as packaging
               FROM buildlog.componentsbyoccurrence z
               LEFT OUTER JOIN buildlog.componentmeta y ON (y.component = z.component)
               WHERE y.component_class = 'meta'
               GROUP BY z.id, z.component, y.component_class
            )
,a       AS (SELECT y.week::date
                  , cmpts.component
                  , y.result
                  , cmpts.duration
                  , base.fault_component
               FROM base
               CROSS JOIN arg
               LEFT OUTER JOIN buildlog.etlresults y ON (base.id = y.id)
               LEFT OUTER JOIN buildlog.hosts x ON (base.host = x.host)
               LEFT OUTER JOIN buildlog.fault_class w ON (base.fault_class = w.fault_class)
               LEFT OUTER JOIN cmpts ON (base.id = cmpts.id)
          where y.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)
 
,ap  as (select week, component, duration from a where result = 'pass' or component != fault_component)
,p01 as (select week, (round(avg(duration),0) || ' seconds')::interval "all" from ap where component = 'all' group by week)
,p07 as (select week, (round(avg(duration),0) || ' seconds')::interval "build" from ap where component = 'build' group by week)
,p38 as (select week, (round(avg(duration),0) || ' seconds')::interval "package" from ap where component = 'package' group by week)
,p41 as (select week, (round(avg(duration),0) || ' seconds')::interval "prepare" from ap where component = 'prepare' group by week)
,p49 as (select week, (round(avg(duration),0) || ' seconds')::interval "setup" from ap where component = 'setup' group by week)


,pp as (select * from aa
            left join p01 using (week)
            left join p07 using (week)
            left join p38 using (week)
            left join p41 using (week)
            left join p49 using (week)
          )
select * from pp order by week;


$_$;


ALTER FUNCTION buildlog.average_components_meta(build_class text) OWNER TO postgres;

--
-- Name: average_components_other(text); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION average_components_other(build_class text) RETURNS TABLE(week date, bseyecov interval, cloudarray interval, cstarball interval, driver interval, imager interval, ipreflect interval, javacli interval, jiff interval, jiffcommon interval, ofed interval, perf interval, sles interval, "sys-common" interval, upgrade interval, vsockets interval)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT *
               FROM buildlog.baseresults
              WHERE id NOT IN (SELECT id FROM buildlog.suspectresults)             
            )
,bcmpts  AS (SELECT z.id,
                    z.component, 
                    sum(z.duration) duration,
                    every(z.phase = 'prepare') "prepare",
                    y.component_class as packaging
               FROM buildlog.componentsbyoccurrence z
               LEFT OUTER JOIN buildlog.componentmeta y ON (y.component = z.component)
               WHERE y.component_class != 'meta'
               GROUP BY z.id, z.component, y.component_class
            )
,cmpts   AS (SELECT id,
                    component, 
                    duration,
                    packaging
               FROM bcmpts
               WHERE "prepare" = false OR "prepare" is null 
            )
,a       AS (SELECT y.week::date
                  , cmpts.component
                  , y.result
                  , cmpts.duration
                  , base.fault_component
               FROM base
               CROSS JOIN arg
               LEFT OUTER JOIN buildlog.etlresults y ON (base.id = y.id)
               LEFT OUTER JOIN buildlog.hosts x ON (base.host = x.host)
               LEFT OUTER JOIN buildlog.fault_class w ON (base.fault_class = w.fault_class)
               LEFT OUTER JOIN cmpts ON (base.id = cmpts.id)
          where y.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)
 
,ap  as (select week, component, duration from a where result = 'pass' or component != fault_component)
,p06 as (select week, (round(avg(duration),0) || ' seconds')::interval "bseyecov" from ap where component = 'bseyecov' group by week)
,p13 as (select week, (round(avg(duration),0) || ' seconds')::interval "cloudarray" from ap where component = 'cloudarray' group by week)
,p15 as (select week, (round(avg(duration),0) || ' seconds')::interval "cstarball" from ap where component = 'cstarball' group by week)
,p18 as (select week, (round(avg(duration),0) || ' seconds')::interval "driver" from ap where component = 'driver' group by week)
,p23 as (select week, (round(avg(duration),0) || ' seconds')::interval "imager" from ap where component = 'imager' group by week)
,p25 as (select week, (round(avg(duration),0) || ' seconds')::interval "ipreflect" from ap where component = 'ipreflect' group by week)
,p26 as (select week, (round(avg(duration),0) || ' seconds')::interval "javacli" from ap where component = 'javacli' group by week)
,p27 as (select week, (round(avg(duration),0) || ' seconds')::interval "jiff" from ap where component = 'jiff' group by week)
,p28 as (select week, (round(avg(duration),0) || ' seconds')::interval "jiffcommon" from ap where component = 'jiffcommon' group by week)
,p37 as (select week, (round(avg(duration),0) || ' seconds')::interval "ofed" from ap where component = 'ofed' group by week)
,p40 as (select week, (round(avg(duration),0) || ' seconds')::interval "perf" from ap where component = 'perf' group by week)
,p50 as (select week, (round(avg(duration),0) || ' seconds')::interval "sles" from ap where component = 'sles' group by week)
,p51 as (select week, (round(avg(duration),0) || ' seconds')::interval "sys-common" from ap where component = 'sys-common' group by week)
,p59 as (select week, (round(avg(duration),0) || ' seconds')::interval "upgrade" from ap where component = 'upgrade' group by week)
,p61 as (select week, (round(avg(duration),0) || ' seconds')::interval "vsockets" from ap where component = 'vsockets' group by week)


,pp as (select * from aa
            left join p06 using (week)
            left join p13 using (week)
            left join p15 using (week)
            left join p18 using (week)
            left join p23 using (week)
            left join p25 using (week)
            left join p26 using (week)
            left join p27 using (week)
            left join p28 using (week)
            left join p37 using (week)
            left join p40 using (week)
            left join p50 using (week)
            left join p51 using (week)
            left join p59 using (week)
            left join p61 using (week)
          )
select * from pp order by week;


$_$;


ALTER FUNCTION buildlog.average_components_other(build_class text) OWNER TO postgres;

--
-- Name: average_components_pkg(text); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION average_components_pkg(build_class text) RETURNS TABLE(week date, bootflash interval, econtrolstation interval, image interval, languages interval, rpms interval, rpmsinfq interval, systemtap interval, vtune interval)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT *
               FROM buildlog.baseresults
              WHERE id NOT IN (SELECT id FROM buildlog.suspectresults)             
            )
,bcmpts  AS (SELECT z.id,
                    z.component, 
                    sum(z.duration) duration,
                    every(z.phase = 'prepare') "prepare",
                    y.component_class as packaging
               FROM buildlog.componentsbyoccurrence z
               LEFT OUTER JOIN buildlog.componentmeta y ON (y.component = z.component)
               WHERE y.component_class != 'meta'
               GROUP BY z.id, z.component, y.component_class
            )
,cmpts   AS (SELECT id,
                    component, 
                    duration,
                    packaging
               FROM bcmpts
               WHERE "prepare" = false OR "prepare" is null 
            )
,a       AS (SELECT y.week::date
                  , cmpts.component
                  , y.result
                  , cmpts.duration
                  , base.fault_component
               FROM base
               CROSS JOIN arg
               LEFT OUTER JOIN buildlog.etlresults y ON (base.id = y.id)
               LEFT OUTER JOIN buildlog.hosts x ON (base.host = x.host)
               LEFT OUTER JOIN buildlog.fault_class w ON (base.fault_class = w.fault_class)
               LEFT OUTER JOIN cmpts ON (base.id = cmpts.id)
          where y.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)
 
,ap  as (select week, component, duration from a where result = 'pass' or component != fault_component)
,p04 as (select week, (round(avg(duration),0) || ' seconds')::interval "bootflash" from ap where component = 'bootflash' group by week)
,p19 as (select week, (round(avg(duration),0) || ' seconds')::interval "econtrolstation" from ap where component = 'econtrolstation' group by week)
,p22 as (select week, (round(avg(duration),0) || ' seconds')::interval "image" from ap where component = 'image' group by week)
,p31 as (select week, (round(avg(duration),0) || ' seconds')::interval "languages" from ap where component = 'languages' group by week)
,p43 as (select week, (round(avg(duration),0) || ' seconds')::interval "rpms" from ap where component = 'rpms' group by week)
,p44 as (select week, (round(avg(duration),0) || ' seconds')::interval "rpmsinfq" from ap where component = 'rpmsinfq' group by week)
,p52 as (select week, (round(avg(duration),0) || ' seconds')::interval "systemtap" from ap where component = 'systemtap' group by week)
,p62 as (select week, (round(avg(duration),0) || ' seconds')::interval "vtune" from ap where component = 'vtune' group by week)


,pp as (select * from aa
            left join p04 using (week)
            left join p19 using (week)
            left join p22 using (week)
            left join p31 using (week)
            left join p43 using (week)
            left join p44 using (week)
            left join p52 using (week)
            left join p62 using (week)
          )
select * from pp order by week;


$_$;


ALTER FUNCTION buildlog.average_components_pkg(build_class text) OWNER TO postgres;

--
-- Name: counts_components_bld(text); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION counts_components_bld(build_class text) RETURNS TABLE(week date, bamxml real, blockshim_ng real, c4core real, c4csx real, cemgui real, clariion real, cp real, cta real, cumulus real, gms real, healthchecks real, infrastructureproviders real, jmi real, kernel real, libpsm real, mf real, mf_common real, nxgui real, observability real, papi real, restcommon real, sade real, safe real, security real, serviceability real, tbn real, tomcatcommon real, udoctor real, uemcli real, unirest real, univasa real, vmwaresdkclient real, vvnxdeploydual real, result text)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT *
               FROM buildlog.baseresults
              WHERE id NOT IN (SELECT id FROM buildlog.suspectresults)             
            )
,bcmpts  AS (SELECT z.id,
                    z.component, 
                    sum(z.duration) duration,
                    every(z.phase = 'prepare') "prepare",
                    y.component_class as packaging
               FROM buildlog.componentsbyoccurrence z
               LEFT OUTER JOIN buildlog.componentmeta y ON (y.component = z.component)
               WHERE y.component_class != 'meta'
               GROUP BY z.id, z.component, y.component_class
            )
,cmpts   AS (SELECT id,
                    component, 
                    duration,
                    packaging
               FROM bcmpts
               WHERE "prepare" = false OR "prepare" is null 
            )
,a       AS (SELECT y.week::date
                  , cmpts.component
                  , y.result
                  , base.fault_component
               FROM base
               CROSS JOIN arg
               LEFT OUTER JOIN buildlog.etlresults y ON (base.id = y.id)
               LEFT OUTER JOIN buildlog.hosts x ON (base.host = x.host)
               LEFT OUTER JOIN buildlog.fault_class w ON (base.fault_class = w.fault_class)
               LEFT OUTER JOIN cmpts ON (base.id = cmpts.id)
          where y.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)
 
,af  as (select week, component from a where component = fault_component)
,f02 as (select week, count(*) "bamxml" from af where component = 'bamxml' group by week)
,f03 as (select week, count(*) "blockshim_ng" from af where component = 'blockshim_ng' group by week)
,f09 as (select week, count(*) "c4core" from af where component = 'c4core' group by week)
,f10 as (select week, count(*) "c4csx" from af where component = 'c4csx' group by week)
,f11 as (select week, count(*) "cemgui" from af where component = 'cemgui' group by week)
,f12 as (select week, count(*) "clariion" from af where component = 'clariion' group by week)
,f14 as (select week, count(*) "cp" from af where component = 'cp' group by week)
,f16 as (select week, count(*) "cta" from af where component = 'cta' group by week)
,f17 as (select week, count(*) "cumulus" from af where component = 'cumulus' group by week)
,f20 as (select week, count(*) "gms" from af where component = 'gms' group by week)
,f21 as (select week, count(*) "healthchecks" from af where component = 'healthchecks' group by week)
,f24 as (select week, count(*) "infrastructureproviders" from af where component = 'infrastructureproviders' group by week)
,f29 as (select week, count(*) "jmi" from af where component = 'jmi' group by week)
,f30 as (select week, count(*) "kernel" from af where component = 'kernel' group by week)
,f32 as (select week, count(*) "libpsm" from af where component = 'libpsm' group by week)
,f33 as (select week, count(*) "mf" from af where component = 'mf' group by week)
,f34 as (select week, count(*) "mf_common" from af where component = 'mf_common' group by week)
,f35 as (select week, count(*) "nxgui" from af where component = 'nxgui' group by week)
,f36 as (select week, count(*) "observability" from af where component = 'observability' group by week)
,f39 as (select week, count(*) "papi" from af where component = 'papi' group by week)
,f42 as (select week, count(*) "restcommon" from af where component = 'restcommon' group by week)
,f45 as (select week, count(*) "sade" from af where component = 'sade' group by week)
,f46 as (select week, count(*) "safe" from af where component = 'safe' group by week)
,f47 as (select week, count(*) "security" from af where component = 'security' group by week)
,f48 as (select week, count(*) "serviceability" from af where component = 'serviceability' group by week)
,f53 as (select week, count(*) "tbn" from af where component = 'tbn' group by week)
,f54 as (select week, count(*) "tomcatcommon" from af where component = 'tomcatcommon' group by week)
,f55 as (select week, count(*) "udoctor" from af where component = 'udoctor' group by week)
,f56 as (select week, count(*) "uemcli" from af where component = 'uemcli' group by week)
,f57 as (select week, count(*) "unirest" from af where component = 'unirest' group by week)
,f58 as (select week, count(*) "univasa" from af where component = 'univasa' group by week)
,f60 as (select week, count(*) "vmwaresdkclient" from af where component = 'vmwaresdkclient' group by week)
,f63 as (select week, count(*) "vvnxdeploydual" from af where component = 'vvnxdeploydual' group by week)

,ff as (select *, 'fail'::text result from aa
            left join f02 using (week)
            left join f03 using (week)
            left join f09 using (week)
            left join f10 using (week)
            left join f11 using (week)
            left join f12 using (week)
            left join f14 using (week)
            left join f16 using (week)
            left join f17 using (week)
            left join f20 using (week)
            left join f21 using (week)
            left join f24 using (week)
            left join f29 using (week)
            left join f30 using (week)
            left join f32 using (week)
            left join f33 using (week)
            left join f34 using (week)
            left join f35 using (week)
            left join f36 using (week)
            left join f39 using (week)
            left join f42 using (week)
            left join f45 using (week)
            left join f46 using (week)
            left join f47 using (week)
            left join f48 using (week)
            left join f53 using (week)
            left join f54 using (week)
            left join f55 using (week)
            left join f56 using (week)
            left join f57 using (week)
            left join f58 using (week)
            left join f60 using (week)
            left join f63 using (week)
          )

,ap  as (select week, component from a where result = 'pass' or component != fault_component)
,p02 as (select week, count(*) "bamxml" from ap where component = 'bamxml' group by week)
,p03 as (select week, count(*) "blockshim_ng" from ap where component = 'blockshim_ng' group by week)
,p09 as (select week, count(*) "c4core" from ap where component = 'c4core' group by week)
,p10 as (select week, count(*) "c4csx" from ap where component = 'c4csx' group by week)
,p11 as (select week, count(*) "cemgui" from ap where component = 'cemgui' group by week)
,p12 as (select week, count(*) "clariion" from ap where component = 'clariion' group by week)
,p14 as (select week, count(*) "cp" from ap where component = 'cp' group by week)
,p16 as (select week, count(*) "cta" from ap where component = 'cta' group by week)
,p17 as (select week, count(*) "cumulus" from ap where component = 'cumulus' group by week)
,p20 as (select week, count(*) "gms" from ap where component = 'gms' group by week)
,p21 as (select week, count(*) "healthchecks" from ap where component = 'healthchecks' group by week)
,p24 as (select week, count(*) "infrastructureproviders" from ap where component = 'infrastructureproviders' group by week)
,p29 as (select week, count(*) "jmi" from ap where component = 'jmi' group by week)
,p30 as (select week, count(*) "kernel" from ap where component = 'kernel' group by week)
,p32 as (select week, count(*) "libpsm" from ap where component = 'libpsm' group by week)
,p33 as (select week, count(*) "mf" from ap where component = 'mf' group by week)
,p34 as (select week, count(*) "mf_common" from ap where component = 'mf_common' group by week)
,p35 as (select week, count(*) "nxgui" from ap where component = 'nxgui' group by week)
,p36 as (select week, count(*) "observability" from ap where component = 'observability' group by week)
,p39 as (select week, count(*) "papi" from ap where component = 'papi' group by week)
,p42 as (select week, count(*) "restcommon" from ap where component = 'restcommon' group by week)
,p45 as (select week, count(*) "sade" from ap where component = 'sade' group by week)
,p46 as (select week, count(*) "safe" from ap where component = 'safe' group by week)
,p47 as (select week, count(*) "security" from ap where component = 'security' group by week)
,p48 as (select week, count(*) "serviceability" from ap where component = 'serviceability' group by week)
,p53 as (select week, count(*) "tbn" from ap where component = 'tbn' group by week)
,p54 as (select week, count(*) "tomcatcommon" from ap where component = 'tomcatcommon' group by week)
,p55 as (select week, count(*) "udoctor" from ap where component = 'udoctor' group by week)
,p56 as (select week, count(*) "uemcli" from ap where component = 'uemcli' group by week)
,p57 as (select week, count(*) "unirest" from ap where component = 'unirest' group by week)
,p58 as (select week, count(*) "univasa" from ap where component = 'univasa' group by week)
,p60 as (select week, count(*) "vmwaresdkclient" from ap where component = 'vmwaresdkclient' group by week)
,p63 as (select week, count(*) "vvnxdeploydual" from ap where component = 'vvnxdeploydual' group by week)

,pp as (select *, 'pass'::text from aa
            left join p02 using (week)
            left join p03 using (week)
            left join p09 using (week)
            left join p10 using (week)
            left join p11 using (week)
            left join p12 using (week)
            left join p14 using (week)
            left join p16 using (week)
            left join p17 using (week)
            left join p20 using (week)
            left join p21 using (week)
            left join p24 using (week)
            left join p29 using (week)
            left join p30 using (week)
            left join p32 using (week)
            left join p33 using (week)
            left join p34 using (week)
            left join p35 using (week)
            left join p36 using (week)
            left join p39 using (week)
            left join p42 using (week)
            left join p45 using (week)
            left join p46 using (week)
            left join p47 using (week)
            left join p48 using (week)
            left join p53 using (week)
            left join p54 using (week)
            left join p55 using (week)
            left join p56 using (week)
            left join p57 using (week)
            left join p58 using (week)
            left join p60 using (week)
            left join p63 using (week)
          )

,r02 as (select week, f02."bamxml"::real/(f02."bamxml"+p02."bamxml")::real "bamxml" from f02 left join p02 using (week))
,r03 as (select week, f03."blockshim_ng"::real/(f03."blockshim_ng"+p03."blockshim_ng")::real "blockshim_ng" from f03 left join p03 using (week))
,r09 as (select week, f09."c4core"::real/(f09."c4core"+p09."c4core")::real "c4core" from f09 left join p09 using (week))
,r10 as (select week, f10."c4csx"::real/(f10."c4csx"+p10."c4csx")::real "c4csx" from f10 left join p10 using (week))
,r11 as (select week, f11."cemgui"::real/(f11."cemgui"+p11."cemgui")::real "cemgui" from f11 left join p11 using (week))
,r12 as (select week, f12."clariion"::real/(f12."clariion"+p12."clariion")::real "clariion" from f12 left join p12 using (week))
,r14 as (select week, f14."cp"::real/(f14."cp"+p14."cp")::real "cp" from f14 left join p14 using (week))
,r16 as (select week, f16."cta"::real/(f16."cta"+p16."cta")::real "cta" from f16 left join p16 using (week))
,r17 as (select week, f17."cumulus"::real/(f17."cumulus"+p17."cumulus")::real "cumulus" from f17 left join p17 using (week))
,r20 as (select week, f20."gms"::real/(f20."gms"+p20."gms")::real "gms" from f20 left join p20 using (week))
,r21 as (select week, f21."healthchecks"::real/(f21."healthchecks"+p21."healthchecks")::real "healthchecks" from f21 left join p21 using (week))
,r24 as (select week, f24."infrastructureproviders"::real/(f24."infrastructureproviders"+p24."infrastructureproviders")::real "infrastructureproviders" from f24 left join p24 using (week))
,r29 as (select week, f29."jmi"::real/(f29."jmi"+p29."jmi")::real "jmi" from f29 left join p29 using (week))
,r30 as (select week, f30."kernel"::real/(f30."kernel"+p30."kernel")::real "kernel" from f30 left join p30 using (week))
,r32 as (select week, f32."libpsm"::real/(f32."libpsm"+p32."libpsm")::real "libpsm" from f32 left join p32 using (week))
,r33 as (select week, f33."mf"::real/(f33."mf"+p33."mf")::real "mf" from f33 left join p33 using (week))
,r34 as (select week, f34."mf_common"::real/(f34."mf_common"+p34."mf_common")::real "mf_common" from f34 left join p34 using (week))
,r35 as (select week, f35."nxgui"::real/(f35."nxgui"+p35."nxgui")::real "nxgui" from f35 left join p35 using (week))
,r36 as (select week, f36."observability"::real/(f36."observability"+p36."observability")::real "observability" from f36 left join p36 using (week))
,r39 as (select week, f39."papi"::real/(f39."papi"+p39."papi")::real "papi" from f39 left join p39 using (week))
,r42 as (select week, f42."restcommon"::real/(f42."restcommon"+p42."restcommon")::real "restcommon" from f42 left join p42 using (week))
,r45 as (select week, f45."sade"::real/(f45."sade"+p45."sade")::real "sade" from f45 left join p45 using (week))
,r46 as (select week, f46."safe"::real/(f46."safe"+p46."safe")::real "safe" from f46 left join p46 using (week))
,r47 as (select week, f47."security"::real/(f47."security"+p47."security")::real "security" from f47 left join p47 using (week))
,r48 as (select week, f48."serviceability"::real/(f48."serviceability"+p48."serviceability")::real "serviceability" from f48 left join p48 using (week))
,r53 as (select week, f53."tbn"::real/(f53."tbn"+p53."tbn")::real "tbn" from f53 left join p53 using (week))
,r54 as (select week, f54."tomcatcommon"::real/(f54."tomcatcommon"+p54."tomcatcommon")::real "tomcatcommon" from f54 left join p54 using (week))
,r55 as (select week, f55."udoctor"::real/(f55."udoctor"+p55."udoctor")::real "udoctor" from f55 left join p55 using (week))
,r56 as (select week, f56."uemcli"::real/(f56."uemcli"+p56."uemcli")::real "uemcli" from f56 left join p56 using (week))
,r57 as (select week, f57."unirest"::real/(f57."unirest"+p57."unirest")::real "unirest" from f57 left join p57 using (week))
,r58 as (select week, f58."univasa"::real/(f58."univasa"+p58."univasa")::real "univasa" from f58 left join p58 using (week))
,r60 as (select week, f60."vmwaresdkclient"::real/(f60."vmwaresdkclient"+p60."vmwaresdkclient")::real "vmwaresdkclient" from f60 left join p60 using (week))
,r63 as (select week, f63."vvnxdeploydual"::real/(f63."vvnxdeploydual"+p63."vvnxdeploydual")::real "vvnxdeploydual" from f63 left join p63 using (week))

,rr as (select *, 'reliability'::text "result" from aa
            left join r02 using (week)
            left join r03 using (week)
            left join r09 using (week)
            left join r10 using (week)
            left join r11 using (week)
            left join r12 using (week)
            left join r14 using (week)
            left join r16 using (week)
            left join r17 using (week)
            left join r20 using (week)
            left join r21 using (week)
            left join r24 using (week)
            left join r29 using (week)
            left join r30 using (week)
            left join r32 using (week)
            left join r33 using (week)
            left join r34 using (week)
            left join r35 using (week)
            left join r36 using (week)
            left join r39 using (week)
            left join r42 using (week)
            left join r45 using (week)
            left join r46 using (week)
            left join r47 using (week)
            left join r48 using (week)
            left join r53 using (week)
            left join r54 using (week)
            left join r55 using (week)
            left join r56 using (week)
            left join r57 using (week)
            left join r58 using (week)
            left join r60 using (week)
            left join r63 using (week)
          )

,bb as   (select * from ff union select * from pp union select * from rr
          )
select * from bb order by week;


$_$;


ALTER FUNCTION buildlog.counts_components_bld(build_class text) OWNER TO postgres;

--
-- Name: counts_components_meta(text); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION counts_components_meta(build_class text) RETURNS TABLE(week date, "all" real, build real, package real, prepare real, setup real, result text)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT *
               FROM buildlog.baseresults
              WHERE id NOT IN (SELECT id FROM buildlog.suspectresults)             
            )
,cmpts  AS (SELECT z.id,
                    z.component, 
                    sum(z.duration) duration,
                    y.component_class as packaging
               FROM buildlog.componentsbyoccurrence z
               LEFT OUTER JOIN buildlog.componentmeta y ON (y.component = z.component)
               WHERE y.component_class != 'meta'
               GROUP BY z.id, z.component, y.component_class
            )
,a       AS (SELECT y.week::date
                  , cmpts.component
                  , y.result
                  , base.fault_component
               FROM base
               CROSS JOIN arg
               LEFT OUTER JOIN buildlog.etlresults y ON (base.id = y.id)
               LEFT OUTER JOIN buildlog.hosts x ON (base.host = x.host)
               LEFT OUTER JOIN buildlog.fault_class w ON (base.fault_class = w.fault_class)
               LEFT OUTER JOIN cmpts ON (base.id = cmpts.id)
          where y.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)
 
,af  as (select week, component from a where component = fault_component)
,f01 as (select week, count(*) "all" from af where component = 'all' group by week)
,f07 as (select week, count(*) "build" from af where component = 'build' group by week)
,f38 as (select week, count(*) "package" from af where component = 'package' group by week)
,f41 as (select week, count(*) "prepare" from af where component = 'prepare' group by week)
,f49 as (select week, count(*) "setup" from af where component = 'setup' group by week)

,ff as (select *, 'fail'::text result from aa
            left join f01 using (week)
            left join f07 using (week)
            left join f38 using (week)
            left join f41 using (week)
            left join f49 using (week)
          )

,ap  as (select week, component from a where result = 'pass' or component != fault_component)
,p01 as (select week, count(*) "all" from ap where component = 'all' group by week)
,p07 as (select week, count(*) "build" from ap where component = 'build' group by week)
,p38 as (select week, count(*) "package" from ap where component = 'package' group by week)
,p41 as (select week, count(*) "prepare" from ap where component = 'prepare' group by week)
,p49 as (select week, count(*) "setup" from ap where component = 'setup' group by week)

,pp as (select *, 'pass'::text result from aa
            left join p01 using (week)
            left join p07 using (week)
            left join p38 using (week)
            left join p41 using (week)
            left join p49 using (week)
          )

,r01 as (select week, f01."all"::real/(f01."all"+p01."all")::real "all" from f01 left join p01 using (week))
,r07 as (select week, f07."build"::real/(f07."build"+p07."build")::real "build" from f07 left join p07 using (week))
,r38 as (select week, f38."package"::real/(f38."package"+p38."package")::real "package" from f38 left join p38 using (week))
,r41 as (select week, f41."prepare"::real/(f41."prepare"+p41."prepare")::real "prepare" from f41 left join p41 using (week))
,r49 as (select week, f49."setup"::real/(f49."setup"+p49."setup")::real "setup" from f49 left join p49 using (week))

,rr as (select *, 'reliability'::text "result" from aa
            left join r01 using (week)
            left join r07 using (week)
            left join r38 using (week)
            left join r41 using (week)
            left join r49 using (week)
          )

,bb as   (select * from ff union select * from pp union select * from rr
          )
select * from bb order by week;


$_$;


ALTER FUNCTION buildlog.counts_components_meta(build_class text) OWNER TO postgres;

--
-- Name: counts_components_other(text); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION counts_components_other(build_class text) RETURNS TABLE(week date, bseyecov real, cloudarray real, cstarball real, driver real, imager real, ipreflect real, javacli real, jiff real, jiffcommon real, ofed real, perf real, sles real, "sys-common" real, upgrade real, vsockets real, result text)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT *
               FROM buildlog.baseresults
              WHERE id NOT IN (SELECT id FROM buildlog.suspectresults)             
            )
,bcmpts  AS (SELECT z.id,
                    z.component, 
                    sum(z.duration) duration,
                    every(z.phase = 'prepare') "prepare",
                    y.component_class as packaging
               FROM buildlog.componentsbyoccurrence z
               LEFT OUTER JOIN buildlog.componentmeta y ON (y.component = z.component)
               WHERE y.component_class != 'meta'
               GROUP BY z.id, z.component, y.component_class
            )
,cmpts   AS (SELECT id,
                    component, 
                    duration,
                    packaging
               FROM bcmpts
               WHERE "prepare" = false OR "prepare" is null 
            )
,a       AS (SELECT y.week::date
                  , cmpts.component
                  , y.result
                  , base.fault_component
               FROM base
               CROSS JOIN arg
               LEFT OUTER JOIN buildlog.etlresults y ON (base.id = y.id)
               LEFT OUTER JOIN buildlog.hosts x ON (base.host = x.host)
               LEFT OUTER JOIN buildlog.fault_class w ON (base.fault_class = w.fault_class)
               LEFT OUTER JOIN cmpts ON (base.id = cmpts.id)
          where y.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)
 
,af  as (select week, component from a where component = fault_component)
,f06 as (select week, count(*) "bseyecov" from af where component = 'bseyecov' group by week)
,f13 as (select week, count(*) "cloudarray" from af where component = 'cloudarray' group by week)
,f15 as (select week, count(*) "cstarball" from af where component = 'cstarball' group by week)
,f18 as (select week, count(*) "driver" from af where component = 'driver' group by week)
,f23 as (select week, count(*) "imager" from af where component = 'imager' group by week)
,f25 as (select week, count(*) "ipreflect" from af where component = 'ipreflect' group by week)
,f26 as (select week, count(*) "javacli" from af where component = 'javacli' group by week)
,f27 as (select week, count(*) "jiff" from af where component = 'jiff' group by week)
,f28 as (select week, count(*) "jiffcommon" from af where component = 'jiffcommon' group by week)
,f37 as (select week, count(*) "ofed" from af where component = 'ofed' group by week)
,f40 as (select week, count(*) "perf" from af where component = 'perf' group by week)
,f50 as (select week, count(*) "sles" from af where component = 'sles' group by week)
,f51 as (select week, count(*) "sys-common" from af where component = 'sys-common' group by week)
,f59 as (select week, count(*) "upgrade" from af where component = 'upgrade' group by week)
,f61 as (select week, count(*) "vsockets" from af where component = 'vsockets' group by week)

,ff as (select *, 'fail'::text result from aa
            left join f06 using (week)
            left join f13 using (week)
            left join f15 using (week)
            left join f18 using (week)
            left join f23 using (week)
            left join f25 using (week)
            left join f26 using (week)
            left join f27 using (week)
            left join f28 using (week)
            left join f37 using (week)
            left join f40 using (week)
            left join f50 using (week)
            left join f51 using (week)
            left join f59 using (week)
            left join f61 using (week)
          )

,ap  as (select week, component from a where result = 'pass' or component != fault_component)
,p06 as (select week, count(*) "bseyecov" from ap where component = 'bseyecov' group by week)
,p13 as (select week, count(*) "cloudarray" from ap where component = 'cloudarray' group by week)
,p15 as (select week, count(*) "cstarball" from ap where component = 'cstarball' group by week)
,p18 as (select week, count(*) "driver" from ap where component = 'driver' group by week)
,p23 as (select week, count(*) "imager" from ap where component = 'imager' group by week)
,p25 as (select week, count(*) "ipreflect" from ap where component = 'ipreflect' group by week)
,p26 as (select week, count(*) "javacli" from ap where component = 'javacli' group by week)
,p27 as (select week, count(*) "jiff" from ap where component = 'jiff' group by week)
,p28 as (select week, count(*) "jiffcommon" from ap where component = 'jiffcommon' group by week)
,p37 as (select week, count(*) "ofed" from ap where component = 'ofed' group by week)
,p40 as (select week, count(*) "perf" from ap where component = 'perf' group by week)
,p50 as (select week, count(*) "sles" from ap where component = 'sles' group by week)
,p51 as (select week, count(*) "sys-common" from ap where component = 'sys-common' group by week)
,p59 as (select week, count(*) "upgrade" from ap where component = 'upgrade' group by week)
,p61 as (select week, count(*) "vsockets" from ap where component = 'vsockets' group by week)


,pp as (select *, 'pass'::text result from aa
            left join p06 using (week)
            left join p13 using (week)
            left join p15 using (week)
            left join p18 using (week)
            left join p23 using (week)
            left join p25 using (week)
            left join p26 using (week)
            left join p27 using (week)
            left join p28 using (week)
            left join p37 using (week)
            left join p40 using (week)
            left join p50 using (week)
            left join p51 using (week)
            left join p59 using (week)
            left join p61 using (week)
          )

,r06 as (select week, f06."bseyecov"::real/(f06."bseyecov"+p06."bseyecov")::real "bseyecov" from f06 left join p06 using (week))
,r13 as (select week, f13."cloudarray"::real/(f13."cloudarray"+p13."cloudarray")::real "cloudarray" from f13 left join p13 using (week))
,r15 as (select week, f15."cstarball"::real/(f15."cstarball"+p15."cstarball")::real "cstarball" from f15 left join p15 using (week))
,r18 as (select week, f18."driver"::real/(f18."driver"+p18."driver")::real "driver" from f18 left join p18 using (week))
,r23 as (select week, f23."imager"::real/(f23."imager"+p23."imager")::real "imager" from f23 left join p23 using (week))
,r25 as (select week, f25."ipreflect"::real/(f25."ipreflect"+p25."ipreflect")::real "ipreflect" from f25 left join p25 using (week))
,r26 as (select week, f26."javacli"::real/(f26."javacli"+p26."javacli")::real "javacli" from f26 left join p26 using (week))
,r27 as (select week, f27."jiff"::real/(f27."jiff"+p27."jiff")::real "jiff" from f27 left join p27 using (week))
,r28 as (select week, f28."jiffcommon"::real/(f28."jiffcommon"+p28."jiffcommon")::real "jiffcommon" from f28 left join p28 using (week))
,r37 as (select week, f37."ofed"::real/(f37."ofed"+p37."ofed")::real "ofed" from f37 left join p37 using (week))
,r40 as (select week, f40."perf"::real/(f40."perf"+p40."perf")::real "perf" from f40 left join p40 using (week))
,r50 as (select week, f50."sles"::real/(f50."sles"+p50."sles")::real "sles" from f50 left join p50 using (week))
,r51 as (select week, f51."sys-common"::real/(f51."sys-common"+p51."sys-common")::real "sys-common" from f51 left join p51 using (week))
,r59 as (select week, f59."upgrade"::real/(f59."upgrade"+p59."upgrade")::real "upgrade" from f59 left join p59 using (week))
,r61 as (select week, f61."vsockets"::real/(f61."vsockets"+p61."vsockets")::real "vsockets" from f61 left join p61 using (week))

,rr as (select *, 'reliability'::text "result" from aa
            left join r06 using (week)
            left join r13 using (week)
            left join r15 using (week)
            left join r18 using (week)
            left join r23 using (week)
            left join r25 using (week)
            left join r26 using (week)
            left join r27 using (week)
            left join r28 using (week)
            left join r37 using (week)
            left join r40 using (week)
            left join r50 using (week)
            left join r51 using (week)
            left join r59 using (week)
            left join r61 using (week)
          )

,bb as   (select * from ff union select * from pp union select * from rr
          )
select * from bb order by week;


$_$;


ALTER FUNCTION buildlog.counts_components_other(build_class text) OWNER TO postgres;

--
-- Name: counts_components_pkg(text); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION counts_components_pkg(build_class text) RETURNS TABLE(week date, bootflash real, econtrolstation real, image real, languages real, rpms real, rpmsinfq real, systemtap real, vtune real, result text)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT *
               FROM buildlog.baseresults
              WHERE id NOT IN (SELECT id FROM buildlog.suspectresults)             
            )
,bcmpts  AS (SELECT z.id,
                    z.component, 
                    sum(z.duration) duration,
                    every(z.phase = 'prepare') "prepare",
                    y.component_class as packaging
               FROM buildlog.componentsbyoccurrence z
               LEFT OUTER JOIN buildlog.componentmeta y ON (y.component = z.component)
               WHERE y.component_class != 'meta'
               GROUP BY z.id, z.component, y.component_class
            )
,cmpts   AS (SELECT id,
                    component, 
                    duration,
                    packaging
               FROM bcmpts
               WHERE "prepare" = false OR "prepare" is null 
            )
,a       AS (SELECT y.week::date
                  , cmpts.component
                  , y.result
                  , base.fault_component
               FROM base
               CROSS JOIN arg
               LEFT OUTER JOIN buildlog.etlresults y ON (base.id = y.id)
               LEFT OUTER JOIN buildlog.hosts x ON (base.host = x.host)
               LEFT OUTER JOIN buildlog.fault_class w ON (base.fault_class = w.fault_class)
               LEFT OUTER JOIN cmpts ON (base.id = cmpts.id)
          where y.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)
 
,af  as (select week, component from a where component = fault_component)
,f04 as (select week, count(*) "bootflash" from af where component = 'bootflash' group by week)
,f19 as (select week, count(*) "econtrolstation" from af where component = 'econtrolstation' group by week)
,f22 as (select week, count(*) "image" from af where component = 'image' group by week)
,f31 as (select week, count(*) "languages" from af where component = 'languages' group by week)
,f43 as (select week, count(*) "rpms" from af where component = 'rpms' group by week)
,f44 as (select week, count(*) "rpmsinfq" from af where component = 'rpmsinfq' group by week)
,f52 as (select week, count(*) "systemtap" from af where component = 'systemtap' group by week)
,f62 as (select week, count(*) "vtune" from af where component = 'vtune' group by week)

,ff as (select *, 'fail'::text result from aa
            left join f04 using (week)
            left join f19 using (week)
            left join f22 using (week)
            left join f31 using (week)
            left join f43 using (week)
            left join f44 using (week)
            left join f52 using (week)
            left join f62 using (week)
          )

,ap  as (select week, component from a where result = 'pass' or component != fault_component)
,p04 as (select week, count(*) "bootflash" from ap where component = 'bootflash' group by week)
,p19 as (select week, count(*) "econtrolstation" from ap where component = 'econtrolstation' group by week)
,p22 as (select week, count(*) "image" from ap where component = 'image' group by week)
,p31 as (select week, count(*) "languages" from ap where component = 'languages' group by week)
,p43 as (select week, count(*) "rpms" from ap where component = 'rpms' group by week)
,p44 as (select week, count(*) "rpmsinfq" from ap where component = 'rpmsinfq' group by week)
,p52 as (select week, count(*) "systemtap" from ap where component = 'systemtap' group by week)
,p62 as (select week, count(*) "vtune" from ap where component = 'vtune' group by week)

,pp as (select *, 'pass'::text result from aa
            left join p04 using (week)
            left join p19 using (week)
            left join p22 using (week)
            left join p31 using (week)
            left join p43 using (week)
            left join p44 using (week)
            left join p52 using (week)
            left join p62 using (week)
          )

,r04 as (select week, f04."bootflash"::real/(f04."bootflash"+p04."bootflash")::real "bootflash" from f04 left join p04 using (week))
,r19 as (select week, f19."econtrolstation"::real/(f19."econtrolstation"+p19."econtrolstation")::real "econtrolstation" from f19 left join p19 using (week))
,r22 as (select week, f22."image"::real/(f22."image"+p22."image")::real "image" from f22 left join p22 using (week))
,r31 as (select week, f31."languages"::real/(f31."languages"+p31."languages")::real "languages" from f31 left join p31 using (week))
,r43 as (select week, f43."rpms"::real/(f43."rpms"+p43."rpms")::real "rpms" from f43 left join p43 using (week))
,r44 as (select week, f44."rpmsinfq"::real/(f44."rpmsinfq"+p44."rpmsinfq")::real "rpmsinfq" from f44 left join p44 using (week))
,r52 as (select week, f52."systemtap"::real/(f52."systemtap"+p52."systemtap")::real "systemtap" from f52 left join p52 using (week))
,r62 as (select week, f62."vtune"::real/(f62."vtune"+p62."vtune")::real "vtune" from f62 left join p62 using (week))

,rr as (select *, 'reliability'::text "result" from aa
            left join r04 using (week)
            left join r19 using (week)
            left join r22 using (week)
            left join r31 using (week)
            left join r43 using (week)
            left join r44 using (week)
            left join r52 using (week)
            left join r62 using (week)
          )

,bb as   (select * from ff union select * from pp union select * from rr
          )
select * from bb order by week;


$_$;


ALTER FUNCTION buildlog.counts_components_pkg(build_class text) OWNER TO postgres;

--
-- Name: getfaultclass(text[]); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION getfaultclass(faults text[]) RETURNS text
    LANGUAGE sql
    AS $_$
   WITH
    aa AS (SELECT count(*) cnt,fault FROM unnest($1) x(fault) 
           WHERE fault IS NOT NULL 
           GROUP BY fault),
    a AS (SELECT * FROM aa ORDER BY cnt DESC),      
    b AS (SELECT 1 id, count(*) cnt_all, MAX(fault) "all" FROM a),
    c AS (SELECT 1 id, count(*) hi_nopass, MAX(fault) hi_fault FROM a WHERE fault != 'PASS'),
    f AS (SELECT 1 id, string_agg(fault,',') "multiple" FROM a WHERE fault != 'PASS'),
    g AS (SELECT cnt_all,"all",z.cnt "total",
             hi_nopass,hi_fault,y.cnt hi_total,
             "multiple"
        FROM b
        LEFT JOIN a z on z.fault = b."all"::text
        LEFT JOIN c on c.id = b.id
        LEFT JOIN a y on y.fault = c.hi_fault::text
        LEFT JOIN f on f.id = b.id)
   SELECT 
           CASE 
         WHEN cnt_all = 1 THEN "all"
         WHEN hi_nopass = 1 THEN hi_fault
         ELSE "multiple"
           END AS fault_class
   FROM g;
;
$_$;


ALTER FUNCTION buildlog.getfaultclass(faults text[]) OWNER TO postgres;

--
-- Name: gethostclass(text); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION gethostclass(host text) RETURNS text
    LANGUAGE sql
    AS $_$
   SELECT host_class FROM buildlog.host_class WHERE id in (SELECT MIN(id) FROM buildlog.host_class WHERE $1 ~* match);
;
$_$;


ALTER FUNCTION buildlog.gethostclass(host text) OWNER TO postgres;

--
-- Name: weekly_biggest_changes(text); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION weekly_biggest_changes(build_class text) RETURNS TABLE(component character varying, previous_week character varying, previous_duration interval, week character varying, duration interval, delta character varying)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT *
               FROM buildlog.baseresults
              WHERE id NOT IN (SELECT id FROM buildlog.suspectresults)             
            )
,bcmpts  AS (SELECT z.id,
                    z.component, 
                    sum(z.duration) duration,
                    every(z.phase = 'prepare') "prepare",
                    y.component_class as packaging
               FROM buildlog.componentsbyoccurrence z
               LEFT OUTER JOIN buildlog.componentmeta y ON (y.component = z.component)
               WHERE y.component_class != 'meta'
               GROUP BY z.id, z.component, y.component_class
            )
,cmpts   AS (SELECT id,
                    component, 
                    extract(epoch from (duration || 'seconds')::interval) duration,
                    packaging
               FROM bcmpts
               WHERE "prepare" = false OR "prepare" is null 
            )
,a       AS (SELECT y.week
                  , cmpts.component
                  , y.result
                  , cmpts.duration
                  , base.fault_component
               FROM base
               CROSS JOIN arg
               LEFT OUTER JOIN buildlog.etlresults y ON (base.id = y.id)
               LEFT OUTER JOIN buildlog.hosts x ON (base.host = x.host)
               LEFT OUTER JOIN buildlog.fault_class w ON (base.fault_class = w.fault_class)
               LEFT OUTER JOIN cmpts ON (base.id = cmpts.id)
          where y.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)

,ap  as (select week, component, avg(duration) duration 
           from a
          where (result = 'pass' or component != fault_component)
            and component is not null
          group by week, component)
,b   as (select component
              , week
              , (lag("week") over week_window) "previous_week"
              , round("duration"::numeric,0) "duration"
              , round((lag("duration") over week_window)::numeric,0) "previous_duration"
              , ("duration" - (lag("duration") over week_window)) delta
         from ap
       WINDOW week_window as (partition by component order by week)
        ORDER BY week
        )
,c   as (select component
              , "previous_week"
              , "previous_duration"
              , "week"
              , "duration"
              , case
                  when "duration" = 0 and "previous_duration" = 0 then '0%'::text
                  when "duration" > 0 and "previous_duration" = 0 then '999.9%'::text
                  when "duration" < 0 and "previous_duration" = 0 then '-999.9%'::text
--                  when delta::real > (50. * "duration") then '999.8%'::text
--                  when delta::real < (50. * "duration") then '-999.8%'::text
                  else (round((100. * delta::real/"previous_duration"::real)::numeric, 0) || '%')::text
                end delta
              , case
                  when "duration" = 0 and "previous_duration" = 0 then 0::real
                  when "duration" > 0 and "previous_duration" = 0 then 9.999::real
                  when "duration" > 0 and "previous_duration" = 0 then -9.999::real
--                  when delta::real > (50. * "duration") then 9.998::real
--                  when delta::real < (50. * "duration") then -9.998::real
                  else abs(delta::real/"previous_duration"::real)
                end adjusted_delta
           from b
          WHERE abs(delta) > 60
            AND "week" = ("previous_week" + '7 days'::interval)
          )
,d   as (select component
              , to_char("previous_week", 'YYYY-MM-DD') "previous_week"
              , ("previous_duration" || 'seconds')::interval "previous_duration"
              , to_char("week", 'YYYY-MM-DD') "week"
              , ("duration" || 'seconds')::interval "duration"
              , delta
           from c
          WHERE adjusted_delta > 0.05
          ORDER by adjusted_delta DESC
          )
select * from d;


$_$;


ALTER FUNCTION buildlog.weekly_biggest_changes(build_class text) OWNER TO postgres;

--
-- Name: weekly_stats(bigint[]); Type: FUNCTION; Schema: buildlog; Owner: postgres
--

CREATE FUNCTION weekly_stats(data bigint[]) RETURNS public.weekly_statistics
    LANGUAGE sql
    AS $_$

WITH
 base as  (select build_duration from unnest($1) x(build_duration) 
           )
,rslts AS (SELECT row(count(*)
                    , (round(quantile(build_duration,0.5)) || ' seconds')::interval
                    , (round(min(build_duration)) || ' seconds')::interval
                    , (round(max(build_duration)) || ' seconds')::interval
                    , (round(avg(build_duration)) || ' seconds')::interval
                    , (round(stddev_samp(build_duration)) || ' seconds')::interval
                     )::weekly_statistics as data
             FROM base
          )
SELECT * FROM rslts;

$_$;


ALTER FUNCTION buildlog.weekly_stats(data bigint[]) OWNER TO postgres;

--
-- Name: FUNCTION weekly_stats(data bigint[]); Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON FUNCTION weekly_stats(data bigint[]) IS 'return build details about specified categories';


SET search_path = buildlog_new, pg_catalog;

--
-- Name: average_components_bld(text); Type: FUNCTION; Schema: buildlog_new; Owner: postgres
--

CREATE FUNCTION average_components_bld(build_class text) RETURNS TABLE(week date, bamxml interval, blockshim_ng interval, c4core interval, c4csx interval, cemgui interval, clariion interval, cp interval, cta interval, cumulus interval, gms interval, healthchecks interval, infrastructureproviders interval, jmi interval, kernel interval, libpsm interval, mf interval, mf_common interval, nxgui interval, observability interval, papi interval, restcommon interval, sade interval, safe interval, security interval, serviceability interval, tbn interval, tomcatcommon interval, udoctor interval, uemcli interval, unirest interval, univasa interval, vmwaresdkclient interval, vvnxdeploydual interval)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT z.id
                  , y.week::date
                  , w0.name host
                  , case
                      when x.tbl_results_id is null then 'pass'
                      else 'fail'
                    end result
                  , x0.name fault_component
                  , x1.name fault_class
                  , v.name build_class
               FROM buildlog_new.tbl_results z
               LEFT JOIN buildlog_new.tbl_timeslots y on y.tbl_results_id = z.id
               LEFT JOIN buildlog_new.tbl_faults x on x.tbl_results_id = z.id
               LEFT JOIN buildlog_new.ix_component x0 on (x0.id = x.ix_fault_component_id)
               LEFT JOIN buildlog_new.usr_fault_class x1 on (x1.id = x.usr_fault_class_id)
               LEFT JOIN buildlog_new.tbl_hosts w on (w.id = z.tbl_hosts_id)
               LEFT JOIN buildlog_new.ix_host w0 on (w0.id = w.ix_host_id)
               LEFT JOIN buildlog_new.usr_build_class v on (v.id = z.usr_build_class_id)
              WHERE z.id NOT IN (SELECT tbl_results_id FROM buildlog_new.tbl_suspectresults)             
            )
,bcmpts  AS (SELECT z.tbl_results_id id,
                    y.name component, 
                    sum(z.duration) duration,
                    every(x.name = 'prepare') "prepare",
                    v.name as packaging
               FROM buildlog_new.tbl_components z
               LEFT JOIN buildlog_new.ix_component y on y.id = z.ix_component_id
               LEFT JOIN buildlog_new.ix_phase x on x.id = z.ix_phase_id
               LEFT JOIN buildlog_new.usr_component_info w using (ix_component_id)
               LEFT JOIN buildlog_new.usr_component_class v ON (v.id = w.usr_component_class_id)
               WHERE v.name != 'meta'
               GROUP BY z.tbl_results_id, y.name, v.name
            )
,cmpts   AS (SELECT id,
                    component, 
                    extract(epoch from duration)::int duration,
                    packaging
               FROM bcmpts
               WHERE "prepare" = false OR "prepare" is null 
            )
,a       AS (SELECT z.week
                  , cmpts.component
                  , z.result
                  , cmpts.duration
                  , z.fault_component
                  , z.build_class
               FROM base z
               CROSS JOIN arg
               LEFT OUTER JOIN cmpts USING (id)
          where z.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)
 
,ap  as (select week, component, duration from a where result = 'pass' or component != fault_component)
,p02 as (select week, (round(avg(duration),0) || ' seconds')::interval "bamxml" from ap where component = 'bamxml' group by week)
,p03 as (select week, (round(avg(duration),0) || ' seconds')::interval "blockshim_ng" from ap where component = 'blockshim_ng' group by week)
,p09 as (select week, (round(avg(duration),0) || ' seconds')::interval "c4core" from ap where component = 'c4core' group by week)
,p10 as (select week, (round(avg(duration),0) || ' seconds')::interval "c4csx" from ap where component = 'c4csx' group by week)
,p11 as (select week, (round(avg(duration),0) || ' seconds')::interval "cemgui" from ap where component = 'cemgui' group by week)
,p12 as (select week, (round(avg(duration),0) || ' seconds')::interval "clariion" from ap where component = 'clariion' group by week)
,p14 as (select week, (round(avg(duration),0) || ' seconds')::interval "cp" from ap where component = 'cp' group by week)
,p16 as (select week, (round(avg(duration),0) || ' seconds')::interval "cta" from ap where component = 'cta' group by week)
,p17 as (select week, (round(avg(duration),0) || ' seconds')::interval "cumulus" from ap where component = 'cumulus' group by week)
,p20 as (select week, (round(avg(duration),0) || ' seconds')::interval "gms" from ap where component = 'gms' group by week)
,p21 as (select week, (round(avg(duration),0) || ' seconds')::interval "healthchecks" from ap where component = 'healthchecks' group by week)
,p24 as (select week, (round(avg(duration),0) || ' seconds')::interval "infrastructureproviders" from ap where component = 'infrastructureproviders' group by week)
,p29 as (select week, (round(avg(duration),0) || ' seconds')::interval "jmi" from ap where component = 'jmi' group by week)
,p30 as (select week, (round(avg(duration),0) || ' seconds')::interval "kernel" from ap where component = 'kernel' group by week)
,p32 as (select week, (round(avg(duration),0) || ' seconds')::interval "libpsm" from ap where component = 'libpsm' group by week)
,p33 as (select week, (round(avg(duration),0) || ' seconds')::interval "mf" from ap where component = 'mf' group by week)
,p34 as (select week, (round(avg(duration),0) || ' seconds')::interval "mf_common" from ap where component = 'mf_common' group by week)
,p35 as (select week, (round(avg(duration),0) || ' seconds')::interval "nxgui" from ap where component = 'nxgui' group by week)
,p36 as (select week, (round(avg(duration),0) || ' seconds')::interval "observability" from ap where component = 'observability' group by week)
,p39 as (select week, (round(avg(duration),0) || ' seconds')::interval "papi" from ap where component = 'papi' group by week)
,p42 as (select week, (round(avg(duration),0) || ' seconds')::interval "restcommon" from ap where component = 'restcommon' group by week)
,p45 as (select week, (round(avg(duration),0) || ' seconds')::interval "sade" from ap where component = 'sade' group by week)
,p46 as (select week, (round(avg(duration),0) || ' seconds')::interval "safe" from ap where component = 'safe' group by week)
,p47 as (select week, (round(avg(duration),0) || ' seconds')::interval "security" from ap where component = 'security' group by week)
,p48 as (select week, (round(avg(duration),0) || ' seconds')::interval "serviceability" from ap where component = 'serviceability' group by week)
,p53 as (select week, (round(avg(duration),0) || ' seconds')::interval "tbn" from ap where component = 'tbn' group by week)
,p54 as (select week, (round(avg(duration),0) || ' seconds')::interval "tomcatcommon" from ap where component = 'tomcatcommon' group by week)
,p55 as (select week, (round(avg(duration),0) || ' seconds')::interval "udoctor" from ap where component = 'udoctor' group by week)
,p56 as (select week, (round(avg(duration),0) || ' seconds')::interval "uemcli" from ap where component = 'uemcli' group by week)
,p57 as (select week, (round(avg(duration),0) || ' seconds')::interval "unirest" from ap where component = 'unirest' group by week)
,p58 as (select week, (round(avg(duration),0) || ' seconds')::interval "univasa" from ap where component = 'univasa' group by week)
,p60 as (select week, (round(avg(duration),0) || ' seconds')::interval "vmwaresdkclient" from ap where component = 'vmwaresdkclient' group by week)
,p63 as (select week, (round(avg(duration),0) || ' seconds')::interval "vvnxdeploydual" from ap where component = 'vvnxdeploydual' group by week)


,pp as (select * from aa
            left join p02 using (week)
            left join p03 using (week)
            left join p09 using (week)
            left join p10 using (week)
            left join p11 using (week)
            left join p12 using (week)
            left join p14 using (week)
            left join p16 using (week)
            left join p17 using (week)
            left join p20 using (week)
            left join p21 using (week)
            left join p24 using (week)
            left join p29 using (week)
            left join p30 using (week)
            left join p32 using (week)
            left join p33 using (week)
            left join p34 using (week)
            left join p35 using (week)
            left join p36 using (week)
            left join p39 using (week)
            left join p42 using (week)
            left join p45 using (week)
            left join p46 using (week)
            left join p47 using (week)
            left join p48 using (week)
            left join p53 using (week)
            left join p54 using (week)
            left join p55 using (week)
            left join p56 using (week)
            left join p57 using (week)
            left join p58 using (week)
            left join p60 using (week)
            left join p63 using (week)
          )
select * from pp order by week;


$_$;


ALTER FUNCTION buildlog_new.average_components_bld(build_class text) OWNER TO postgres;

--
-- Name: average_components_pkg(text); Type: FUNCTION; Schema: buildlog_new; Owner: postgres
--

CREATE FUNCTION average_components_pkg(build_class text) RETURNS TABLE(week date, bootflash interval, econtrolstation interval, image interval, languages interval, rpms interval, rpmsinfq interval, systemtap interval, vtune interval)
    LANGUAGE sql
    AS $_$

with
 arg as (select $1 build_class)
,base    AS (SELECT z.id
                  , y.week::date
                  , w0.name host
                  , case
                      when x.tbl_results_id is null then 'pass'
                      else 'fail'
                    end result
                  , x0.name fault_component
                  , x1.name fault_class
                  , v.name build_class
               FROM buildlog_new.tbl_results z
               LEFT JOIN buildlog_new.tbl_timeslots y on y.tbl_results_id = z.id
               LEFT JOIN buildlog_new.tbl_faults x on x.tbl_results_id = z.id
               LEFT JOIN buildlog_new.ix_component x0 on (x0.id = x.ix_fault_component_id)
               LEFT JOIN buildlog_new.usr_fault_class x1 on (x1.id = x.usr_fault_class_id)
               LEFT JOIN buildlog_new.tbl_hosts w on (w.id = z.tbl_hosts_id)
               LEFT JOIN buildlog_new.ix_host w0 on (w0.id = w.ix_host_id)
               LEFT JOIN buildlog_new.usr_build_class v on (v.id = z.usr_build_class_id)
              WHERE z.id NOT IN (SELECT tbl_results_id FROM buildlog_new.tbl_suspectresults)             
            )
,bcmpts  AS (SELECT z.tbl_results_id id,
                    y.name component, 
                    sum(z.duration) duration,
                    every(x.name = 'prepare') "prepare",
                    v.name as packaging
               FROM buildlog_new.tbl_components z
               LEFT JOIN buildlog_new.ix_component y on y.id = z.ix_component_id
               LEFT JOIN buildlog_new.ix_phase x on x.id = z.ix_phase_id
               LEFT JOIN buildlog_new.usr_component_info w using (ix_component_id)
               LEFT JOIN buildlog_new.usr_component_class v ON (v.id = w.usr_component_class_id)
               WHERE v.name != 'meta'
               GROUP BY z.tbl_results_id, y.name, v.name
            )
,cmpts   AS (SELECT id,
                    component, 
                    extract(epoch from duration)::int duration,
                    packaging
               FROM bcmpts
               WHERE "prepare" = false OR "prepare" is null 
            )
,a       AS (SELECT z.week
                  , cmpts.component
                  , z.result
                  , cmpts.duration
                  , z.fault_component
                  , z.build_class
               FROM base z
               CROSS JOIN arg
               LEFT OUTER JOIN cmpts USING (id)
          where z.build_class = arg.build_class
         )
,aa  as (select week FROM a group by week)
 
,ap  as (select week, component, duration from a where result = 'pass' or component != fault_component)
,p04 as (select week, (round(avg(duration),0) || ' seconds')::interval "bootflash" from ap where component = 'bootflash' group by week)
,p19 as (select week, (round(avg(duration),0) || ' seconds')::interval "econtrolstation" from ap where component = 'econtrolstation' group by week)
,p22 as (select week, (round(avg(duration),0) || ' seconds')::interval "image" from ap where component = 'image' group by week)
,p31 as (select week, (round(avg(duration),0) || ' seconds')::interval "languages" from ap where component = 'languages' group by week)
,p43 as (select week, (round(avg(duration),0) || ' seconds')::interval "rpms" from ap where component = 'rpms' group by week)
,p44 as (select week, (round(avg(duration),0) || ' seconds')::interval "rpmsinfq" from ap where component = 'rpmsinfq' group by week)
,p52 as (select week, (round(avg(duration),0) || ' seconds')::interval "systemtap" from ap where component = 'systemtap' group by week)
,p62 as (select week, (round(avg(duration),0) || ' seconds')::interval "vtune" from ap where component = 'vtune' group by week)


,pp as (select * from aa
            left join p04 using (week)
            left join p19 using (week)
            left join p22 using (week)
            left join p31 using (week)
            left join p43 using (week)
            left join p44 using (week)
            left join p52 using (week)
            left join p62 using (week)
          )
select * from pp order by week;


$_$;


ALTER FUNCTION buildlog_new.average_components_pkg(build_class text) OWNER TO postgres;

--
-- Name: gethostindex(text); Type: FUNCTION; Schema: buildlog_new; Owner: postgres
--

CREATE FUNCTION gethostindex(rawvalue text) RETURNS bigint
    LANGUAGE sql
    AS $_$
    
    
    with
     a as (select split_part(public.fromraw( $1 ), '.', 1) as name)
    ,b as (select name from a
              where name is not null 
                and name !~* '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}' 
                and name not in (select name from buildlog.ix_host)
              limit 1
           )
    ,c as (select * from b
             left join buildlog.ix_host using (name)
           )
    ,d as (insert into buildlog.ix_host (name)
           select name from c
            where c.name is not null and c.id is null
              returning (id)
           )
    ,e as (select case
                    when name is null then null::bigint
                    when id is null then (SELECT currval('buildlog.ix_host_id'))
                    else id
                  end id
                , name
             from c
             left join d using (id)
          )
    select id from e;

$_$;


ALTER FUNCTION buildlog_new.gethostindex(rawvalue text) OWNER TO postgres;

--
-- Name: getindexof(text); Type: FUNCTION; Schema: buildlog_new; Owner: postgres
--

CREATE FUNCTION getindexof(rawvalue text, OUT id bigint) RETURNS bigint
    LANGUAGE sql
    AS $_$


with
 a as (select public.fromraw($1) as "name")
,b as (select a.name, z.name zname, id from a 
         left join buildlog.ix_environment z on z.name = a.name
        where a.name is not null
      )
,c as (insert into buildlog.ix_environment (name) 
       select b.name from b where b.id is null
          returning (id)
       )
,d as (select case
                when id is null then (SELECT currval('buildlog.ix_environment_id'))
                else id
              end id
         from b
         left join c using (id)
      )
select * from d;


$_$;


ALTER FUNCTION buildlog_new.getindexof(rawvalue text, OUT id bigint) OWNER TO postgres;

--
-- Name: getipaddrindex(text); Type: FUNCTION; Schema: buildlog_new; Owner: postgres
--

CREATE FUNCTION getipaddrindex(rawvalue text) RETURNS bigint[]
    LANGUAGE sql
    AS $_$

    with
     a as (select regexp_split_to_table(public.fromraw( $1 ), ' ') as name)
    ,b as (select distinct name from a)
    ,c as (select b.name, z.id from b
             left join buildlog.ix_ipaddress z on z.name = b.name
            where b.name is not null
           )
    ,d as (insert into buildlog.ix_ipaddress (name)
           select name from c
            where name is not null and id is null
              returning (id)
           )
    ,e as (select case
                    when name is null then null::bigint
                    when id is null then (SELECT currval('buildlog.ix_ipaddress_id'))
                    else id
                  end id
                , name
             from c
             left join d using (id)
          )
    select array_agg(id) id from e;

$_$;


ALTER FUNCTION buildlog_new.getipaddrindex(rawvalue text) OWNER TO postgres;

--
-- Name: getpathindex(text); Type: FUNCTION; Schema: buildlog_new; Owner: postgres
--

CREATE FUNCTION getpathindex(rawvalue text) RETURNS bigint[]
    LANGUAGE sql
    AS $_$
    
    with
     a as (select public.fromraw( $1 ) as "name")
    ,b as (select regexp_split_to_array(name, '[/\\]') as dirname from a)
    ,c as (select nextval('buildlog.tmp') idx, unnest(dirname) as name from b)
    ,d as (select distinct name from c)
    ,e as (select * from d
             left join buildlog.ix_pathnames using (name)
           )
    ,f as (insert into buildlog.ix_pathnames (name) 
           select e.name from e
            where e.name is not null and e.id is null
              returning (id)
           )
    ,g as (select case
                    when name is null then null::bigint
                    when id is null then (SELECT currval('buildlog.ix_pathnames_id'))
                    else id
                  end id
                , name
             from e
             left join f using (id)
          )
    ,h as (select * from buildlog.ix_pathnames union select * from g
           )
    ,i as (select c.*,h.id from c
             left join h using(name)
             order by c.idx
           )
    select array_agg(id) from i;

$_$;


ALTER FUNCTION buildlog_new.getpathindex(rawvalue text) OWNER TO postgres;

--
-- Name: is_json(character varying); Type: FUNCTION; Schema: buildlog_new; Owner: postgres
--

CREATE FUNCTION is_json(character varying) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
  DECLARE
    x jsonb;
  BEGIN
    BEGIN
      x := $1;
    EXCEPTION WHEN others THEN
      RETURN FALSE;
    END;

    RETURN TRUE;
  END;
$_$;


ALTER FUNCTION buildlog_new.is_json(character varying) OWNER TO postgres;

SET search_path = cateams, pg_catalog;

--
-- Name: member(bigint); Type: FUNCTION; Schema: cateams; Owner: postgres
--

CREATE FUNCTION member(employee_id bigint) RETURNS TABLE(ca character varying, project character varying, email character varying, employee_id bigint, ntlogin character varying)
    LANGUAGE sql
    AS $_$

    SELECT ca,project,email,employee_id,ntlogin FROM cateams.rally_info WHERE employee_id = $1;

$_$;


ALTER FUNCTION cateams.member(employee_id bigint) OWNER TO postgres;

--
-- Name: FUNCTION member(employee_id bigint); Type: COMMENT; Schema: cateams; Owner: postgres
--

COMMENT ON FUNCTION member(employee_id bigint) IS 'return details about developer';


--
-- Name: member(character varying); Type: FUNCTION; Schema: cateams; Owner: postgres
--

CREATE FUNCTION member(email_or_ntlogin character varying) RETURNS TABLE(ca character varying, project character varying, email character varying, employee_id bigint, ntlogin character varying)
    LANGUAGE sql
    AS $_$

    SELECT ca,project,email,employee_id,ntlogin FROM cateams.rally_info
     WHERE ($1 ~* '@emc.com$'  AND email = $1)
        OR ($1 !~* '@emc.com$' AND ntlogin = $1);

$_$;


ALTER FUNCTION cateams.member(email_or_ntlogin character varying) OWNER TO postgres;

--
-- Name: FUNCTION member(email_or_ntlogin character varying); Type: COMMENT; Schema: cateams; Owner: postgres
--

COMMENT ON FUNCTION member(email_or_ntlogin character varying) IS 'return details about developer';


SET search_path = cateams2, pg_catalog;

--
-- Name: getscan(bigint); Type: FUNCTION; Schema: cateams2; Owner: postgres
--

CREATE FUNCTION getscan(scan_id bigint DEFAULT NULL::bigint) RETURNS TABLE(scan_id bigint, scan_time timestamp with time zone)
    LANGUAGE sql
    AS $_$


  WITH
    args as (SELECT $1 scan_id),
    a0   as (select max(id) max_id from cateams2.ix_server_scans),
    a1   as (select min(id) min_id from cateams2.ix_server_scans),
    a2   as (SELECT case 
                       when args.scan_id IS NULL or args.scan_id > a0.max_id then a0.max_id
                       when args.scan_id < a1.min_id then a1.min_id
                       else args.scan_id
                    end scan_id
                FROM args, a0, a1
             ),
    a3   as (select y.*
               FROM a2
               LEFT JOIN cateams2.ix_server_scans y on y.id = a2.scan_id
            )
    select * from a3;


$_$;


ALTER FUNCTION cateams2.getscan(scan_id bigint) OWNER TO postgres;

--
-- Name: getscan(timestamp with time zone); Type: FUNCTION; Schema: cateams2; Owner: postgres
--

CREATE FUNCTION getscan(scan_time timestamp with time zone) RETURNS TABLE(scan_id bigint, scan_time timestamp with time zone)
    LANGUAGE sql
    AS $_$

  WITH
    args as (SELECT $1 scan_time),
    a0   as (select max(scan_time) scan_time from cateams2.ix_server_scans),
    a1   as (select min(scan_time) scan_time from cateams2.ix_server_scans),
    a2   as (SELECT case 
                       when args.scan_time IS NULL or args.scan_time >= a0.scan_time then a0.scan_time
                       when args.scan_time < a1.scan_time then a1.scan_time
                       else (select z.scan_time from cateams2.ix_server_scans z, args
                              where z.scan_time < args.scan_time
                              order by z.scan_time desc
                              limit 1)
                    end scan_time
                FROM a0, a1, args
             ),
    a3   as (select y.*
               FROM a2
               LEFT JOIN cateams2.ix_server_scans y on y.scan_time = a2.scan_time
             )
      select cateams2.getscan(a3.id) from a3;

 $_$;


ALTER FUNCTION cateams2.getscan(scan_time timestamp with time zone) OWNER TO postgres;

SET search_path = empdata, pg_catalog;

--
-- Name: direct_reports(bigint); Type: FUNCTION; Schema: empdata; Owner: postgres
--

CREATE FUNCTION direct_reports(employees_id bigint) RETURNS TABLE(employee_id bigint, direct_report_id bigint)
    LANGUAGE sql
    AS $_$

    WITH RECURSIVE
     args as (SELECT $1 id)
     ,a as (select id
                 , max(scan_time)
              from empdata.ix_scans
             group by id
            )

     ,b as (SELECT z.tbl_employees_id
                 , MAX(y.scan_time) scan_time
              FROM empdata.tbl_employees_info z
              left join empdata.ix_scans y on y.id = z.ix_scans_id
             GROUP BY tbl_employees_id
            )

     ,c as (SELECT b.tbl_employees_id
                 , b.scan_time
                 , z.id ix_scans_id
              FROM b
              left join empdata.ix_scans z using(scan_time)
            )

     ,d as (SELECT c.tbl_employees_id
                 , c.scan_time
                 , z.ix_manager_id
              FROM c
              left join empdata.tbl_employees_info z using (tbl_employees_id, ix_scans_id) 
            )
     ,employees(ix_manager_id, tbl_employees_id)
            AS  (SELECT d.ix_manager_id, d.tbl_employees_id FROM d,args
                  WHERE d.tbl_employees_id = args.id
                  UNION ALL
                 SELECT d.ix_manager_id, d.tbl_employees_id
                   FROM employees, d
                  WHERE employees.tbl_employees_id = d.ix_manager_id
            )
    SELECT ix_manager_id employee_id
         , tbl_employees_id direct_report_id
      FROM employees;


$_$;


ALTER FUNCTION empdata.direct_reports(employees_id bigint) OWNER TO postgres;

--
-- Name: direct_reports(character varying); Type: FUNCTION; Schema: empdata; Owner: postgres
--

CREATE FUNCTION direct_reports(employee character varying) RETURNS TABLE(employee_id bigint, direct_report_id bigint)
    LANGUAGE sql
    AS $_$


  WITH
     args as (SELECT public.fromraw($1) employee)
    ,a0   as (select z.id
                   , y.name badgeid
                   , x.name ntlogin
                   , w.name email
                   , v.name fullname
                   , u.name distinguishedname
                from empdata.tbl_employees z
                left join empdata.ix_badgeid y on y.id = z.ix_badgeid_id
                left join empdata.ix_ntlogin x on x.id = z.ix_ntlogin_id
                left join empdata.ix_email w on w.id = z.ix_email_id
                left join empdata.ix_fullname v on v.id = z.ix_fullname_id
                left join empdata.ix_distinguishedname u on u.id = z.ix_distinguishedname_id
              )
    ,a1   as (select case
                      when employee ~* '@' then (SELECT id from a0, args where a0.email=lower(args.employee) limit 1)
                      when employee ~* ',' then (SELECT id from a0, args where a0.fullname=args.employee limit 1)
                      when employee ~* '\d{4}' then (SELECT id from a0, args where a0.badgeid=lower(args.employee) limit 1)
                      when employee ~* '^CN=' then (SELECT id from a0, args where a0.distinguishedname=upper(args.employee) limit 1)
                      else (SELECT id from a0, args where a0.ntlogin=args.employee limit 1)
                     end id
                 FROM args
             )
    SELECT empdata.direct_reports(id) from a1;
    
    
$_$;


ALTER FUNCTION empdata.direct_reports(employee character varying) OWNER TO postgres;

--
-- Name: getemployee(bigint); Type: FUNCTION; Schema: empdata; Owner: postgres
--

CREATE FUNCTION getemployee(employees_id bigint) RETURNS TABLE(tbl_employees_id bigint, badgeid character varying, ntlogin character varying, email character varying, name character varying, phone character varying, city character varying, country character varying, mgr_name character varying, mgr_badgeid character varying, mgr_ntlogin character varying, mgr_email character varying, mgr_phone character varying)
    LANGUAGE sql
    AS $_$

    WITH
     args as (SELECT $1 id)
     ,a as (select id
                 , max(scan_time)
              from empdata.ix_scans
             group by id
            )

     ,b as (SELECT z.tbl_employees_id
                 , MAX(y.scan_time) scan_time
              FROM empdata.tbl_employees_info z
              left join empdata.ix_scans y on y.id = z.ix_scans_id
             GROUP BY tbl_employees_id
            )

     ,c as (SELECT b.tbl_employees_id
                 , b.scan_time
                 , z.id ix_scans_id
              FROM b
              left join empdata.ix_scans z using(scan_time)
            )

     ,d as (SELECT c.tbl_employees_id
                 , c.scan_time
                 , c.ix_scans_id
                 , z.ix_manager_id
                 , y.name phone
                 , x.name city
                 , w.name country
              FROM c
              left join empdata.tbl_employees_info z using (tbl_employees_id, ix_scans_id) 
              left join empdata.ix_phone y on y.id = z.ix_phone_telephonenumber_id
              left join empdata.ix_citys x on x.id = z.ix_citys_id
              left join empdata.ix_countrys w on w.id = z.ix_countrys_id
            )

     ,e as (SELECT d.tbl_employees_id
                 , d.scan_time
                 , d.ix_scans_id
                 , d.ix_manager_id
                 , y.name badgeid
                 , x.name ntlogin
                 , w.name email
                 , v.name "name"
                 , d.phone
                 , d.city
                 , d.country
              FROM d
              left join empdata.tbl_employees z on z.id = d.tbl_employees_id
              left join empdata.ix_badgeid y on y.id = z.ix_badgeid_id
              left join empdata.ix_ntlogin x on x.id = z.ix_ntlogin_id
              left join empdata.ix_email w on w.id = z.ix_email_id
              left join empdata.ix_fullname v on v.id = z.ix_fullname_id
            )
     
     ,f as (SELECT e.tbl_employees_id
                 , e.badgeid
                 , e.ntlogin
                 , e.email
                 , e.name
                 , e.phone
                 , e.city
                 , e.country
                 , mgr.name mgr_name
                 , mgr.badgeid mgr_badgeid
                 , mgr.ntlogin mgr_ntlogin
                 , mgr.email mgr_email
                 , mgr.phone mgr_phone
              FROM e
              left join e mgr on mgr.tbl_employees_id = e.ix_manager_id
              cross join args
              where e.tbl_employees_id = args.id
            )

    SELECT * FROM f;


$_$;


ALTER FUNCTION empdata.getemployee(employees_id bigint) OWNER TO postgres;

--
-- Name: getemployee(character varying); Type: FUNCTION; Schema: empdata; Owner: postgres
--

CREATE FUNCTION getemployee(employee character varying) RETURNS TABLE(tbl_employees_id bigint, badgeid character varying, ntlogin character varying, email character varying, name character varying, phone character varying, city character varying, country character varying, mgr_name character varying, mgr_badgeid character varying, mgr_ntlogin character varying, mgr_email character varying, mgr_phone character varying)
    LANGUAGE sql
    AS $_$


  WITH
     args as (SELECT public.fromraw($1) employee)
    ,a0   as (select z.id
                   , y.name badgeid
                   , x.name ntlogin
                   , w.name email
                   , v.name fullname
                   , u.name distinguishedname
                from empdata.tbl_employees z
                left join empdata.ix_badgeid y on y.id = z.ix_badgeid_id
                left join empdata.ix_ntlogin x on x.id = z.ix_ntlogin_id
                left join empdata.ix_email w on w.id = z.ix_email_id
                left join empdata.ix_fullname v on v.id = z.ix_fullname_id
                left join empdata.ix_distinguishedname u on u.id = z.ix_distinguishedname_id
              )
    ,a1   as (select case
                      when employee ~* '@' then (SELECT id from a0, args where a0.email=lower(args.employee) limit 1)
                      when employee ~* ',' then (SELECT id from a0, args where a0.fullname=args.employee limit 1)
                      when employee ~* '\d{4}' then (SELECT id from a0, args where a0.badgeid=lower(args.employee) limit 1)
                      when employee ~* '^CN=' then (SELECT id from a0, args where a0.distinguishedname=upper(args.employee) limit 1)
                      else (SELECT id from a0, args where a0.ntlogin=args.employee limit 1)
                     end id
                 FROM args
             )
    SELECT empdata.getemployee(id) from a1 limit 1;
    
    
$_$;


ALTER FUNCTION empdata.getemployee(employee character varying) OWNER TO postgres;

--
-- Name: getscan(bigint); Type: FUNCTION; Schema: empdata; Owner: postgres
--

CREATE FUNCTION getscan(scans_id bigint DEFAULT NULL::bigint) RETURNS TABLE(scans_id bigint, scan_time timestamp with time zone)
    LANGUAGE sql
    AS $_$


  WITH
    args as (SELECT $1 scans_id),
    a0   as (select max(id) max_id from empdata.ix_scans),
    a1   as (select min(id) min_id from empdata.ix_scans),
    a2   as (SELECT case 
                       when args.scans_id IS NULL or args.scans_id > a0.max_id then a0.max_id
                       when args.scans_id < a1.min_id then a1.min_id
                       else args.scans_id
                    end scans_id
                FROM args, a0, a1
             ),
    a3   as (select y.*
               FROM a2
               LEFT JOIN empdata.ix_scans y on y.id = a2.scans_id
            )
    select * from a3;


$_$;


ALTER FUNCTION empdata.getscan(scans_id bigint) OWNER TO postgres;

--
-- Name: getscan(timestamp with time zone); Type: FUNCTION; Schema: empdata; Owner: postgres
--

CREATE FUNCTION getscan(scan_time timestamp with time zone) RETURNS TABLE(scans_id bigint, scan_time timestamp with time zone)
    LANGUAGE sql
    AS $_$

  WITH
    args as (SELECT $1 scan_time),
    a0   as (select max(scan_time) scan_time from empdata.ix_scans),
    a1   as (select min(scan_time) scan_time from empdata.ix_scans),
    a2   as (SELECT case 
                       when args.scan_time IS NULL or args.scan_time >= a0.scan_time then a0.scan_time
                       when args.scan_time < a1.scan_time then a1.scan_time
                       else (select z.scan_time from empdata.ix_scans z, args
                              where z.scan_time < args.scan_time
                              order by z.scan_time desc
                              limit 1)
                    end scan_time
                FROM a0, a1, args
             ),
    a3   as (select y.*
               FROM a2
               LEFT JOIN empdata.ix_scans y on y.scan_time = a2.scan_time
             )
      select empdata.getscan(a3.id) from a3;

 $_$;


ALTER FUNCTION empdata.getscan(scan_time timestamp with time zone) OWNER TO postgres;

SET search_path = jenkins, pg_catalog;

--
-- Name: executors(bigint); Type: FUNCTION; Schema: jenkins; Owner: postgres
--

CREATE FUNCTION executors(delta bigint DEFAULT (60)::bigint) RETURNS TABLE(cmt text)
    LANGUAGE sql
    AS $_$

   with recursive
     a as (select CASE 
                    WHEN $1 <= 0::bigint THEN 60::bigint
                    ELSE $1
                  END delta)
    ,b as (select start_tm, duration/1000. duration from jenkins.cibuilds)
    ,c as (select min(start_tm) t_start, max(start_tm) t_end from b)
    ,d as (select max(duration) t_delta from b where start_tm in (select t_end from c))
    ,e as (select extract('epoch' from (c.t_end - c.t_start + (d.t_delta || ' seconds')::interval)) ms_time FROM a,c,d)
    ,f(e_time, dy) as
          (select c.t_start + (round(extract('epoch' from (b.start_tm - c.t_start))::bigint/a.delta)*a.delta || ' seconds')::interval  e_time,
             (b.duration/a.delta)::bigint dy
             from a,b,c union all
           select (f.e_time + (a.delta || ' seconds')::interval) e_time, (f.dy-1) dy
             from a,c,f where f.dy > 0 and f.e_time < c.t_end )
    ,g as (select e_time, count(*) inuse from f group by e_time)
    ,h as (select max(inuse) maxuse, count(*) cnt, sum(inuse) inuse, min(e_time) min_time, max(e_time) max_time from g)
    ,i as (select count(*) cnt from jenkins.ciservers)
    ,j as (select y.master,z.slave,z.ostype,x.tm,x.numexecutors from jenkins.cislaves z
             left join jenkins.ciservers y on y.id = z.server_id
             left join jenkins."cislave-scans" x on x.slave_id = z.slave_id
            where z.ostype is not null)
    ,k as (select master,slave,ostype,max(tm) tm, max(numexecutors) numexecutors from j group by master,slave,ostype)
    ,l as (select count(*) servers, sum(numexecutors) executors from k where slave ~* 'ci-server')
    ,m as (select count(*) windows_slaves, sum(numexecutors) executors from k where ostype ~* '^Windows')
    ,n as (select count(*) rhel_slaves, sum(numexecutors) executors from k where slave ~* 'ci-rhel-slave')
    ,o as (select count(*) linux_slaves, sum(numexecutors) executors from k where slave ~* 'ci.*slave' and ostype ~* 'linux')
    ,p as (select (o.linux_slaves - n.rhel_slaves) sles_slaves, (o.executors - n.executors) executors from n,o)
    ,q as (select (l.executors + m.executors + n.executors + p.executors) executors from l,m,n,p)
    ,r as (select trunc((h.inuse * a.delta/e.ms_time)::numeric, 2) executors from a,e,h)
        
    ,x as (select 1::int id, 'Duration:                        ' || delta info from a union
           select 2::int id, 'Start time:                      ' || t_start info from c union
           select 3::int id, 'End time:                        ' || t_end info from c union
           select 4::int id, 'Range:                           ' || trunc((ms_time/86400)::numeric,3) || ' days' info from e union
           select 5::int id, 'Average executors in use:        ' || r.executors info from r union
           select 6::int id, 'Maximum executors in use:        ' || maxuse info from h union
           select 7::int id, 'Time at least 1 executor in use: ' || trunc((h.cnt * a.delta * 100. /e.ms_time)::numeric, 2) || '%' info from a,e,h union
           select 8::int id, 'Number of active periods:        ' || cnt info from h union
           select 9::int id, 'Number of Jenkins servers:       ' || servers || ' (' || executors || ' executors)' info from l union
           select 10::int id, 'Number of Windows slaves:        ' || windows_slaves || ' (' || executors || ' executors)' info from m union
           select 11::int id, 'Number of RedHat slaves:         ' || rhel_slaves || ' (' || executors || ' executors)' info from n union
           select 12::int id, 'Number of SLES slaves:           ' || sles_slaves || ' (' || executors || ' executors)' info from p union
           select 13::int id, 'Total number of executors:       ' || q.executors info from q
           )
    select info from x order by id;

$_$;


ALTER FUNCTION jenkins.executors(delta bigint) OWNER TO postgres;

--
-- Name: find_jobid(bigint, text, timestamp without time zone); Type: FUNCTION; Schema: jenkins; Owner: postgres
--

CREATE FUNCTION find_jobid(id bigint, name text, tm timestamp without time zone) RETURNS bigint
    LANGUAGE sql
    AS $_$
     SELECT job_id
       FROM jenkins.cijobs
      WHERE server_id=$1 AND "name"=$2 AND $3>=tm
      ORDER BY tm DESC
      LIMIT 1;
;
$_$;


ALTER FUNCTION jenkins.find_jobid(id bigint, name text, tm timestamp without time zone) OWNER TO postgres;

--
-- Name: getpluginscan(bigint); Type: FUNCTION; Schema: jenkins; Owner: postgres
--

CREATE FUNCTION getpluginscan(scan_id bigint DEFAULT NULL::bigint) RETURNS TABLE(scan_id bigint, scan_timedate timestamp with time zone)
    LANGUAGE sql
    AS $_$


  WITH
    args as (SELECT $1 scan_id),
    a0   as (select max(id) max_id from jenkins.ciplugin_scans),
    a1   as (select min(id) min_id from jenkins.ciplugin_scans),
    a2   as (SELECT case 
                       when args.scan_id IS NULL or args.scan_id > a0.max_id then a0.max_id
                       when args.scan_id < a1.min_id then a1.min_id
                       else args.scan_id
                    end scan_id
                FROM args, a0, a1
             ),
    a3   as (select y.*
               FROM a2
               LEFT JOIN jenkins.ciplugin_scans y on y.id = a2.scan_id
            )
    select * from a3;


$_$;


ALTER FUNCTION jenkins.getpluginscan(scan_id bigint) OWNER TO postgres;

--
-- Name: getpluginscan(timestamp with time zone); Type: FUNCTION; Schema: jenkins; Owner: postgres
--

CREATE FUNCTION getpluginscan(scan_timedate timestamp with time zone) RETURNS TABLE(scan_id bigint, scan_timedate timestamp with time zone)
    LANGUAGE sql
    AS $_$

  WITH
    args as (SELECT $1 scan_timedate),
    a0   as (select max(scan_timedate) scan_timedate from jenkins.ciplugin_scans),
    a1   as (select min(scan_timedate) scan_timedate from jenkins.ciplugin_scans),
    a2   as (SELECT case 
                       when args.scan_timedate IS NULL or args.scan_timedate >= a0.scan_timedate then a0.scan_timedate
                       when args.scan_timedate < a1.scan_timedate then a1.scan_timedate
                       else (select z.scan_timedate from jenkins.ciplugin_scans z, args
                              where z.scan_timedate < args.scan_timedate
                              order by z.scan_timedate desc
                              limit 1)
                    end scan_timedate
                FROM a0, a1, args
             ),
    a3   as (select y.*
               FROM a2
               LEFT JOIN jenkins.ciplugin_scans y on y.scan_timedate = a2.scan_timedate
             )
      select jenkins.getpluginscan(a3.id) from a3;

 $_$;


ALTER FUNCTION jenkins.getpluginscan(scan_timedate timestamp with time zone) OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: bucketize(bigint, bigint, bigint, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bucketize(val bigint, lo_val bigint, hi_val bigint, num_elems integer) RETURNS integer[]
    LANGUAGE sql
    AS $_$

WITH RECURSIVE
params AS (select $1 val, $2 lo_val, $3 hi_val, $4 elems)
,a     AS (SELECT CASE WHEN hi_val = lo_val THEN 0::integer
                       ELSE (((val - lo_val)*(num_elems-1))::real / (hi_val - lo_val)::real)::integer
                  END val
             FROM params
         )
,b(i,v) AS (SELECT 1 i
                 , CASE WHEN (0 = a.val) THEN 1 ELSE 0 END v
              FROM a
             UNION ALL 
            SELECT (b.i+1) i
                 , CASE WHEN (b.i = a.val) THEN 1 ELSE 0 END v
              FROM b,a,params WHERE b.i < elems
            )
SELECT array_agg(v) from b;

$_$;


ALTER FUNCTION public.bucketize(val bigint, lo_val bigint, hi_val bigint, num_elems integer) OWNER TO postgres;

--
-- Name: bytea_import(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION bytea_import(p_path text, OUT p_result bytea) RETURNS bytea
    LANGUAGE plpgsql
    AS $$
    declare
      l_oid oid;
      r record;
    begin
      p_result := '';
      select lo_import(p_path) into l_oid;
      for r in ( select data 
             from pg_largeobject 
             where loid = l_oid 
             order by pageno ) loop
        p_result = p_result || r.data;
      end loop;
      perform lo_unlink(l_oid);
    end;
$$;


ALTER FUNCTION public.bytea_import(p_path text, OUT p_result bytea) OWNER TO postgres;

--
-- Name: create_indexed_table(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION create_indexed_table(schemaname text, tablename text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
  schemaname ALIAS FOR $1;
  tablename ALIAS FOR $2;
  schema_table text := schemaname || '.' || tablename;
  sequence_name text := schema_table || '_id';
  qry_str text := '
 CREATE SEQUENCE ' || sequence_name || '
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 1
  CACHE 1;
ALTER TABLE ' || sequence_name || ' OWNER TO postgres;
GRANT ALL ON SEQUENCE ' || sequence_name || ' TO public;
GRANT ALL ON SEQUENCE ' || sequence_name || ' TO postgres;

CREATE TABLE ' || schema_table || '
(
  id bigint NOT NULL DEFAULT nextval(' || quote_literal(sequence_name) || '::regclass),
  name character varying NOT NULL,
  CONSTRAINT ' || tablename || '_pkey PRIMARY KEY (id),
  CONSTRAINT ' || tablename || '_name_key UNIQUE (name)
);
ALTER TABLE ' || schema_table || ' OWNER TO postgres;
GRANT SELECT, REFERENCES, TRIGGER ON TABLE ' || schema_table || ' TO public;
GRANT ALL ON TABLE ' || schema_table || ' TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ' || schema_table || ' TO postgres;

CREATE INDEX ' || tablename || '_name_idx
  ON ' || schema_table || '
  USING btree
  (name COLLATE pg_catalog."default");

';

BEGIN 

EXECUTE qry_str;

END; 
$_$;


ALTER FUNCTION public.create_indexed_table(schemaname text, tablename text) OWNER TO postgres;

--
-- Name: FUNCTION create_indexed_table(schemaname text, tablename text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION create_indexed_table(schemaname text, tablename text) IS 'use to create sequence and indexed table using sequence';


--
-- Name: endofweek(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION endofweek(tm timestamp without time zone) RETURNS date
    LANGUAGE sql
    AS $_$
    SELECT (DATE_TRUNC('week', $1::date + '1 days'::interval) + '5 days'::interval)::date
$_$;


ALTER FUNCTION public.endofweek(tm timestamp without time zone) OWNER TO postgres;

--
-- Name: FUNCTION endofweek(tm timestamp without time zone); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION endofweek(tm timestamp without time zone) IS 'return date at the end of the week associated with specified week';


--
-- Name: endofweek(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION endofweek(tm timestamp with time zone) RETURNS date
    LANGUAGE sql
    AS $_$
    SELECT (DATE_TRUNC('week', $1::date + '1 days'::interval) + '5 days'::interval)::date
$_$;


ALTER FUNCTION public.endofweek(tm timestamp with time zone) OWNER TO postgres;

--
-- Name: FUNCTION endofweek(tm timestamp with time zone); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION endofweek(tm timestamp with time zone) IS 'return date at the end of the week associated with specified week';


--
-- Name: fromraw(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION fromraw(a text) RETURNS text
    LANGUAGE sql
    AS $_$
  SELECT CASE
         when length(trim(both ' ' from $1)) > 0 then trim(both ' ' from $1)
          else null::text
          end;
;
$_$;


ALTER FUNCTION public.fromraw(a text) OWNER TO postgres;

--
-- Name: fromunixtime(numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION fromunixtime(a numeric) RETURNS timestamp without time zone
    LANGUAGE sql
    AS $_$

    select (($1/1000) * interval '1 second') + timestamp without time zone 'epoch';

$_$;


ALTER FUNCTION public.fromunixtime(a numeric) OWNER TO postgres;

--
-- Name: getindexof(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION getindexof(rawvalue text, ix_table text, OUT idx bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$

    DECLARE
        rawvalue ALIAS FOR $1;
        ix_table ALIAS FOR $2;

        qry_str text := '
            with
             a as (select public.fromraw(' || quote_literal(rawvalue) || ') as "name")
            ,b as (select a.name, z.id from a 
                     left join ' || ix_table || ' z on z.name = a.name
                    where a.name is not null
                  )
            ,c as (insert into ' || ix_table || ' (name) 
                   select b.name from b
                    where b.name is not null and b.id is null
                      returning (id)
                   )
            ,d as (select case
                            when name is null then null::bigint
                            when id is null then (SELECT currval(' || quote_literal(ix_table || '_id') || '))
                            else id
                          end id
                     from b
                     left join c using (id)
                  )
            select id from d;
        ';

    BEGIN 

      if rawvalue is null then
          idx := rawvalue;
      else
          execute qry_str into idx;
      END IF;

    END; 

$_$;


ALTER FUNCTION public.getindexof(rawvalue text, ix_table text, OUT idx bigint) OWNER TO postgres;

--
-- Name: isboolean(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION isboolean(a text, b text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE sql
    AS $_$
    WITH
       a as (SELECT CASE
                       WHEN $2 IS NULL or $2 ~* 'Unknown' THEN null::boolean
                       WHEN $2 ~* '^Y' OR $2 ~* '^True' THEN true
                       WHEN $2 ~* '^N' OR $2 ~* '^False' THEN false
                       ELSE $2::boolean
                   END default_value
             )
      SELECT CASE
                WHEN $1 IS NULL or $1 ~* 'Unknown' THEN (select default_value from a)
                WHEN $1 ~* '^Y' OR $1 ~* '^True' THEN true
                WHEN $1 ~* '^N' OR $1 ~* '^False' THEN false
                ELSE $1::boolean
             END; 

$_$;


ALTER FUNCTION public.isboolean(a text, b text) OWNER TO postgres;

--
-- Name: issame(anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION issame(a anyelement, b anyelement) RETURNS boolean
    LANGUAGE sql
    AS $_$
      SELECT ($1=$2 OR ($1 IS NULL AND $2 IS NULL ));
;
$_$;


ALTER FUNCTION public.issame(a anyelement, b anyelement) OWNER TO postgres;

--
-- Name: remove_front(anyarray, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION remove_front(a anyarray, nremove integer) RETURNS anyarray
    LANGUAGE sql IMMUTABLE
    AS $$

select a[array_lower(a, 1) + nremove:array_upper(a, 1)];

$$;


ALTER FUNCTION public.remove_front(a anyarray, nremove integer) OWNER TO postgres;

--
-- Name: startofweek(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION startofweek(tm timestamp without time zone) RETURNS date
    LANGUAGE sql
    AS $_$
    SELECT (DATE_TRUNC('week', $1::date + '1 days'::interval) - '1 days'::interval)::date 
$_$;


ALTER FUNCTION public.startofweek(tm timestamp without time zone) OWNER TO postgres;

--
-- Name: FUNCTION startofweek(tm timestamp without time zone); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION startofweek(tm timestamp without time zone) IS 'return date at the start of the week associated with specified week';


--
-- Name: startofweek(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION startofweek(tm timestamp with time zone) RETURNS date
    LANGUAGE sql
    AS $_$
    SELECT (DATE_TRUNC('week', $1::date + '1 days'::interval) - '1 days'::interval)::date 
$_$;


ALTER FUNCTION public.startofweek(tm timestamp with time zone) OWNER TO postgres;

--
-- Name: FUNCTION startofweek(tm timestamp with time zone); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION startofweek(tm timestamp with time zone) IS 'return date at the start of the week associated with specified week';


--
-- Name: update_index_table(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION update_index_table(rawvalue text, rawtable text, ix_table text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
    DECLARE
    rawvalue ALIAS FOR $1;
    rawtable ALIAS FOR $2;
    ix_table ALIAS FOR $3;
 
    qry_str text := '
        with
         a  as (select distinct public.fromraw(' || quote_ident(rawvalue) || ') "name" from ' || rawtable || ')
        ,b  as (select "name" from a         
             where "name" not in (select "name" from ' || ix_table || ')
               and "name" is not null
             )
        insert into ' || ix_table || ' (name) select name from b;
    ';

    BEGIN 

       EXECUTE qry_str;

    END; 

$_$;


ALTER FUNCTION public.update_index_table(rawvalue text, rawtable text, ix_table text) OWNER TO postgres;

--
-- Name: urlencode(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION urlencode(in_str text, OUT _result text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    _i      int4;
    _temp   varchar;
    _ascii  int4;
BEGIN
    _result = '';
    FOR _i IN 1 .. length(in_str) LOOP
        _temp := substr(in_str, _i, 1);
        IF _temp ~ '[0-9a-zA-Z:/@._?#-]+' THEN
            _result := _result || _temp;
        ELSE
            _ascii := ascii(_temp);
            IF _ascii > x'07ff'::int4 THEN
                RAISE EXCEPTION 'Won''t deal with 3 (or more) byte sequences.';
            END IF;
            IF _ascii <= x'07f'::int4 THEN
                _temp := '%'||to_hex(_ascii);
            ELSE
                _temp := '%'||to_hex((_ascii & x'03f'::int4)+x'80'::int4);
                _ascii := _ascii >> 6;
                _temp := '%'||to_hex((_ascii & x'01f'::int4)+x'c0'::int4)
                            ||_temp;
            END IF;
            _result := _result || upper(_temp);
        END IF;
    END LOOP;
    RETURN ;
END;
$$;


ALTER FUNCTION public.urlencode(in_str text, OUT _result text) OWNER TO postgres;

--
-- Name: verify_ips(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION verify_ips(ipaddr text) RETURNS inet[]
    LANGUAGE sql
    AS $_$

with
 a as (select $1 ipaddr)
,b as (select regexp_split_to_table(ipaddr,E'\\s+')::inet ip from a)
select array_agg(ip) from b WHERE ip << '10.0.0.0/8'::inet or ip << '192.168.0.0/16'::inet;

$_$;


ALTER FUNCTION public.verify_ips(ipaddr text) OWNER TO postgres;

--
-- Name: xml_extract_val(character varying, xml); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION xml_extract_val(x_path character varying, xmldata xml) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
    SELECT 
    CASE 
      WHEN $1 ~ '@[[:alnum:]_]+$' THEN (xpath($1, $2))[1] 
      WHEN $1 ~* '/text()$'       THEN (xpath($1, $2))[1] 
      WHEN $1 LIKE '%/'           THEN (xpath($1 || 'text()', $2))[1] 
      ELSE (xpath($1 || '/text()', $2))[1] 
    END::text; 
$_$;


ALTER FUNCTION public.xml_extract_val(x_path character varying, xmldata xml) OWNER TO postgres;

SET search_path = remedy, pg_catalog;

--
-- Name: backlog_issues(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: remedy; Owner: postgres
--

CREATE FUNCTION backlog_issues(start_tm timestamp without time zone DEFAULT NULL::timestamp without time zone, end_tm timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(ix_history_id bigint, entryid bigint, create_date timestamp without time zone, modified_date timestamp without time zone, ix_major_area_id bigint, ix_ntlogin_assigned_to_id bigint, ix_priority_id bigint, ix_product_id bigint, ix_product_area_id bigint, ix_product_family_id bigint, ix_product_release_id bigint, ix_status_id bigint, ix_status_details_id bigint, ix_type_id bigint)
    LANGUAGE sql
    AS $_$


with 
-- args: provide some reasonable names for the input params
 args as (select case
                     when $1 is null or $1 < (min(z.end_tm) - '7 days'::interval) then (min(z.end_tm) - '7 days'::interval)
                     else $1
                 end start_tm
               , case
                     when $2 is null or $2 > max(z.end_tm) then max(z.end_tm)
                     else $2
                 end end_tm
             from remedy.ix_history z
            group by $1, $2
        )

-- dates: start/end dates for each week we have data
,dates as (select z.id ix_history_id
                , y.end_tm start_tm 
                , z.end_tm
             from remedy.ix_history z
             left join remedy.ix_history y on y.id = z.id-1
             cross join args
            where (args.start_tm, args.end_tm) overlaps (y.end_tm, z.end_tm)
        )

-- aa: rows from "tbl_issue_tracking" during period of interest
,aa as (select entryid
             , create_date
             , modified_date
             , ix_major_area_id
             , ix_ntlogin_assigned_to_id
             , ix_priority_id
             , ix_product_id
             , ix_product_area_id
             , ix_product_family_id
             , ix_product_release_id
             , ix_status_id
             , ix_status_details_id
             , ix_type_id
          from remedy.tbl_issue_tracking
         cross join args
         where modified_date >= args.start_tm
           and modified_date < args.end_tm
           and entryid is not null
           and (earliest_dup_bugid is null or entryid = earliest_dup_bugid)
        )

-- bb: rows from "history_issue_weekly" during period of interest
,bb as (select entryid
             , create_date
             , modified_date
             , ix_major_area_id
             , ix_ntlogin_assigned_to_id
             , ix_priority_id
             , ix_product_id
             , ix_product_area_id
             , ix_product_family_id
             , ix_product_release_id
             , ix_status_id
             , ix_status_details_id
             , ix_type_id
          from remedy.history_issue_weekly
         cross join args
         where modified_date >= args.start_tm
           and modified_date < args.end_tm
           and entryid is not null
        )


-- cc: all rows associated with period of interest
,cc as (select * from aa union select * from bb
        )

,dd as (select distinct on (y.ix_history_id, cc.entryid, cc.ix_status_id)
               y.ix_history_id
             , cc.*
          from cc 
          left join dates y on (y.start_tm, y.end_tm) overlaps (cc.modified_date, cc.modified_date)
         order by y.ix_history_id, cc.entryid, cc.ix_status_id, cc.modified_date DESC
      )

select * from dd;


$_$;


ALTER FUNCTION remedy.backlog_issues(start_tm timestamp without time zone, end_tm timestamp without time zone) OWNER TO postgres;

--
-- Name: FUNCTION backlog_issues(start_tm timestamp without time zone, end_tm timestamp without time zone); Type: COMMENT; Schema: remedy; Owner: postgres
--

COMMENT ON FUNCTION backlog_issues(start_tm timestamp without time zone, end_tm timestamp without time zone) IS 'return remedy AR history up to given date_time';


--
-- Name: current_issues(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: remedy; Owner: postgres
--

CREATE FUNCTION current_issues(start_tm timestamp without time zone DEFAULT NULL::timestamp without time zone, end_tm timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(entryid bigint, create_date timestamp without time zone, modified_date timestamp without time zone, ix_major_area_id bigint, ix_ntlogin_assigned_to_id bigint, ix_priority_id bigint, ix_product_id bigint, ix_product_area_id bigint, ix_product_family_id bigint, ix_product_release_id bigint, ix_status_id bigint, ix_status_details_id bigint, ix_type_id bigint)
    LANGUAGE sql
    AS $_$


with 
-- args: provide some reasonable names for the input params
 args as (select $1 start_tm
               , case
                     when $2 is null then now()
                     else $2
                 end end_tm
        )

-- a0: 'audit_attribute ids' that interest us (ignore the rest)
,a0 as (select distinct ix_audit_attribute_id
          from remedy.usr_issue_tracking_attributes
         where is_relevant_to_backlog = true)

-- b0: issues added to "tbl_issue_tracking" during period of interest
,b0 as (select entryid
             , create_date
             , modified_date
--             , a0.ix_audit_attribute_id
             , ix_major_area_id
             , ix_ntlogin_assigned_to_id
             , ix_priority_id
             , ix_product_id
             , ix_product_area_id
             , ix_product_family_id
             , ix_product_release_id
             , ix_status_id
             , ix_status_details_id
             , ix_type_id
          from remedy.tbl_issue_tracking z
--         cross join a0
         cross join args
         where ((args.start_tm is null and (z.create_date < args.end_tm or z.modified_date < args.end_tm))
         or (args.end_tm is null and (z.create_date >= args.start_tm or z.modified_date >= args.start_tm)
         or (z.create_date >= args.start_tm and z.create_date < args.end_tm)
         or (z.modified_date >= args.start_tm and z.modified_date < args.end_tm))
        )
            and z.entryid is not null
        )

-- c0: changes added to "tbl_share_audit" during period of interest
,c0 as (select requestid
             , entryid
             , ix_audit_attribute_id
             , ix_ntlogin_submitter_id
             , modified_date
             , ix_from_value_id
             , ix_to_value_id
          from remedy.tbl_share_audit
         cross join args
         where (args.start_tm is null or modified_date >= args.start_tm)
           and (args.end_tm is null or modified_date < args.end_tm)
           and entryid is not null
           and ix_audit_attribute_id in (select ix_audit_attribute_id from a0)
        )

-- c1: rows associated with changes in "tbl_share_audit" during period of interest
,c1 as (select entryid
             , create_date
             , modified_date
             , ix_major_area_id
             , ix_ntlogin_assigned_to_id
             , ix_priority_id
             , ix_product_id
             , ix_product_area_id
             , ix_product_family_id
             , ix_product_release_id
             , ix_status_id
             , ix_status_details_id
             , ix_type_id
          from remedy.tbl_issue_tracking
         cross join args
         where (args.start_tm is not null and modified_date < args.start_tm 
                or args.start_tm is null and args.end_tm is not null and modified_date < args.end_tm)
           and entryid is not null
           and entryid in (select distinct entryid from c0)
        )

-- c2: rows (from history) associated with changes in "tbl_share_audit" during period of interest
,c2 as (select entryid
             , create_date
             , modified_date
             , ix_major_area_id
             , ix_ntlogin_assigned_to_id
             , ix_priority_id
             , ix_product_id
             , ix_product_area_id
             , ix_product_family_id
             , ix_product_release_id
             , ix_status_id
             , ix_status_details_id
             , ix_type_id
          from remedy.history_issue_weekly
         cross join args
         where (args.start_tm is not null and modified_date < args.start_tm 
                or args.start_tm is null and args.end_tm is not null and modified_date < args.end_tm)
           and entryid is not null
           and entryid in (select distinct entryid from c0)
        )


-- b3: all rows associated with changes in "tbl_share_audit" during period of interest
,b3 as (select * from c1 union select * from c2
        )
        
-- b4: only use the latest version of old data        
,b4 as (select entryid
             , max(modified_date) modified_date
          from b3
          group by entryid
       )
,b5 as (select b3.*
          from b4
          left join b3 using (entryid, modified_date)
       )
        
-- c3: all rows associated with changes in "tbl_share_audit" during period of interest
,c3 as (select * from b0 union select * from b5
        )
-- c4: add audit_attribute_id to 'c3' so we can group with changes from "tbl_share_audit"
,c4 as (select * from c3 cross join a0)

-- c5: filter most recent change record from either 'tbl_issue_tracking' or 'history_issue_weekly'
,c5 as (select entryid
            , max(modified_date) modified_date
            , ix_audit_attribute_id
         from c4
        where entryid is not null
        group by entryid, ix_audit_attribute_id
       )

-- c6: latest rows from 'tbl_issue_tracking' or 'history_issue_weekly'
,c6 as (select *  
          from c5
          left join c4 using (entryid, modified_date, ix_audit_attribute_id)
        )

-- ag: translate row format from 'c0' (audit changes) to common structure to merge with 'c6'
,ag as (select c0.entryid
             , null::timestamp without time zone create_date
             , c0.modified_date
             , c0.ix_audit_attribute_id
             , c0.ix_audit_attribute_id real_attrib
             , case  -- convert 'full name' to ix_ntlogin.name when attribute is 'assigned to'
                   when c0.ix_audit_attribute_id = 12 then z4.name
                   else z1.name
               end as_value
          from c0
--          left join c6 using(entryid, modified_date, ix_audit_attribute_id)
--          left join remedy.ix_status z0 on z0.id = c6.ix_status_id
          left join remedy.ix_status_details z1 on z1.id = c0.ix_to_value_id
          left join remedy.ix_employee_names z2 on z2.name = z1.name
          left join remedy.tbl_share_employee z3 on z3.ix_full_name_id = z2.id
          left join remedy.ix_ntlogin z4 on z4.id = z3.ix_ntlogin_id

         where c0.entryid is not null
           and c0.ix_audit_attribute_id in (select ix_audit_attribute_id from a0)
--           and (z0.name !~* '((Fixed)|(Dismissed))' 
--                or (c0.ix_audit_attribute_id = 15 and z1.name !~* '((Fixed)|(Dismissed))')
--                or (c0.ix_audit_attribute_id = 42 and z1.name not in (select name from remedy.usr_closed_status_detail))
--                )
        )

-- ah: translate row format from 'c6' (wide table) to common structure for merge with 'c0'
,ah as (select c6.entryid
             , c6.create_date
             , c6.create_date modified_date
             , c6.ix_audit_attribute_id
             , -1::bigint real_attrib
             , case
                  when y0.tbl_issue_tracking_column = 'ix_ntlogin_assigned_to_id' then z0.name
                  when y0.tbl_issue_tracking_column = 'ix_major_area_id' then z1.name
                  when y0.tbl_issue_tracking_column = 'ix_priority_id' then z2.name
                  when y0.tbl_issue_tracking_column = 'ix_product_id' then z3.name
                  when y0.tbl_issue_tracking_column = 'ix_product_area_id' then z4.name
                  when y0.tbl_issue_tracking_column = 'ix_product_family_id' then z5.name
                  when y0.tbl_issue_tracking_column = 'ix_product_release_id' then z6.name
                  when y0.tbl_issue_tracking_column = 'ix_status_id' then z7.name
                  when y0.tbl_issue_tracking_column = 'ix_status_details_id' then z8.name
                  when y0.tbl_issue_tracking_column = 'ix_type_id' then z9.name
               end as_value
          from c6
          left join remedy.usr_issue_tracking_attributes y0 using(ix_audit_attribute_id)
          left join remedy.ix_ntlogin z0 on z0.id = c6.ix_ntlogin_assigned_to_id
          left join remedy.ix_major_area z1 on z1.id = c6.ix_major_area_id
          left join remedy.ix_priority z2 on z2.id = c6.ix_priority_id
          left join remedy.ix_product z3 on z3.id = c6.ix_product_id
          left join remedy.ix_product_area z4 on z4.id = c6.ix_product_area_id
          left join remedy.ix_product_family z5 on z5.id = c6.ix_product_family_id
          left join remedy.ix_product_release z6 on z6.id = c6.ix_product_release_id
          left join remedy.ix_status z7 on z7.id = c6.ix_status_id
          left join remedy.ix_status_details z8 on z8.id = c6.ix_status_details_id
          left join remedy.ix_type z9 on z9.id = c6.ix_type_id
         where c6.entryid is not null
           and c6.entryid in (select distinct entryid from c6)
        )

-- ai: combine all our common format rows for processing
,ai as (select * from ag union select * from ah)

-- ai: combine all our common format rows for processing
,ai0 as (select distinct entryid, modified_date from ai)


-- aj + ak: ensure we have entries for every attribute
,aj as (select entryid
             , min(create_date) create_date
             , modified_date
          from ai
         group by entryid, modified_date
       )
,ak as (select distinct entryid
                      , create_date
                      , modified_date
                      , ix_audit_attribute_id
          from aj
         cross join a0
        )
        
-- al0 thru al: combine all our common format rows for processing based on (aj + ak)
---- al0: determine row_num and idx of last good value (or 0)
,al0 as (select ak.entryid
              , first_value(ak.create_date) over entry_changes create_date
              , ak.modified_date
              , ak.ix_audit_attribute_id
              , ai.as_value as_value
              , (row_number() over entry_changes)::integer row_num
              , case
                  when ai.as_value is not null 
                    or ai.real_attrib = -1
                    or ai.real_attrib = ak.ix_audit_attribute_id  then (row_number() over entry_changes)::integer
                  else 1::integer
                end idx
           from ak
           left join ai using (entryid, modified_date, ix_audit_attribute_id)
         window entry_changes as (partition by ak.entryid, ak.ix_audit_attribute_id order by ak.ix_audit_attribute_id, ak.modified_date)
       )
---- al1: calc the last good index to valid data
,al1 as (select entryid
             , create_date
             , modified_date
             , ix_audit_attribute_id
             , as_value
             , (max(idx) over entry_changes)::integer idx    --last good index to valid data
         from al0
         window entry_changes as (partition by entryid, ix_audit_attribute_id order by ix_audit_attribute_id, modified_date)
      )
---- al: set the last known value for each parameter of each row
,al as (select entryid
             , create_date
             , modified_date
             , ix_audit_attribute_id
             , (nth_value(as_value, idx) over entry_changes) as_value
         from al1
         window entry_changes as (partition by entryid, ix_audit_attribute_id order by ix_audit_attribute_id, modified_date
                                  rows between unbounded preceding and unbounded following)
      )

-- am0 thru am: perform a crosstab to change attributes to columns
,am0 as (select entryid, create_date, modified_date, z.id ix_major_area_id
           from al
           left join remedy.ix_major_area z on z.name = al.as_value -- "Major area" 
          where ix_audit_attribute_id = 13)
,am1 as (select entryid, create_date, modified_date, z.id ix_ntlogin_assigned_to_id
           from al
           left join remedy.ix_ntlogin z on z.name = al.as_value  -- "Assigned to" 
          where ix_audit_attribute_id = 12)
,am2 as (select entryid, create_date, modified_date, z.id ix_priority_id 
           from al
           left join remedy.ix_priority z on z.name = al.as_value  -- "priority" 
          where ix_audit_attribute_id = 7)
,am3 as (select entryid, create_date, modified_date, z.id ix_product_id 
           from al
           left join remedy.ix_product z on z.name = al.as_value -- "Product"
          where ix_audit_attribute_id = 40)
,am4 as (select entryid, create_date, modified_date, z.id ix_product_area_id
           from al
           left join remedy.ix_product_area z on z.name = al.as_value -- "Product Area"
          where ix_audit_attribute_id = 33)
,am5 as (select entryid, create_date, modified_date, z.id  ix_product_family_id
           from al
           left join remedy.ix_product_family z on z.name = al.as_value -- "Product Family"
          where ix_audit_attribute_id = 34)
,am6 as (select entryid, create_date, modified_date, z.id ix_product_release_id
           from al
           left join remedy.ix_product_release z on z.name = al.as_value -- "Product Release"
          where ix_audit_attribute_id = 16)
,am7 as (select entryid, create_date, modified_date, z.id ix_status_id
           from al
           left join remedy.ix_status z on z.name = al.as_value -- "Status"
          where ix_audit_attribute_id = 15)
,am8 as (select entryid, create_date, modified_date, z.id ix_status_details_id
           from al
           left join remedy.ix_status_details z on z.name = al.as_value -- "Status Details"
          where ix_audit_attribute_id = 42)
,am9 as (select entryid, create_date, modified_date, z.id ix_type_id
           from al
           left join remedy.ix_type z on z.name = al.as_value -- "Type"
          where ix_audit_attribute_id = 36)
,am as (select ai0.entryid
             , am0.create_date
             , ai0.modified_date
             , am0.ix_major_area_id
             , am1.ix_ntlogin_assigned_to_id
             , am2.ix_priority_id
             , am3.ix_product_id
             , am4.ix_product_area_id
             , am5.ix_product_family_id
             , am6.ix_product_release_id
             , am7.ix_status_id
             , am8.ix_status_details_id
             , am9.ix_type_id
          from ai0
          left join am0 using(entryid, modified_date)
          left join am1 using(entryid, modified_date)
          left join am2 using(entryid, modified_date)
          left join am3 using(entryid, modified_date)
          left join am4 using(entryid, modified_date)
          left join am5 using(entryid, modified_date)
          left join am6 using(entryid, modified_date)
          left join am7 using(entryid, modified_date)
          left join am8 using(entryid, modified_date)
          left join am9 using(entryid, modified_date)
        )
-- an: make sure there are no unwanted entries (entryid is not null) and no duplicates
,an as (select *
          from am
         where entryid is not null
        )
-- ao: remove any rows which came from remedy.tbl_issue_tracking
,ao as (select * from am except select * from c3)

select * from ao;


$_$;


ALTER FUNCTION remedy.current_issues(start_tm timestamp without time zone, end_tm timestamp without time zone) OWNER TO postgres;

--
-- Name: FUNCTION current_issues(start_tm timestamp without time zone, end_tm timestamp without time zone); Type: COMMENT; Schema: remedy; Owner: postgres
--

COMMENT ON FUNCTION current_issues(start_tm timestamp without time zone, end_tm timestamp without time zone) IS 'return remedy AR history up to given date_time';


--
-- Name: current_issues_de(timestamp without time zone); Type: FUNCTION; Schema: remedy; Owner: postgres
--

CREATE FUNCTION current_issues_de(end_tm timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(manager character varying, create_date timestamp without time zone, modified_date timestamp without time zone, ix_major_area_id bigint, ix_priority_id bigint, ix_product_id bigint, ix_product_area_id bigint, ix_product_family_id bigint, ix_product_release_id bigint, ix_status_id bigint, ix_status_details_id bigint, ix_type_id bigint)
    LANGUAGE sql
    AS $_$


with 
 args as (select case
                     when $1 is null then now()
                     else $1
                 end end_tm
        )
,a0 as (select *
          from remedy.tbl_issue_tracking z
         cross join args
         where z.modified_date < args.end_tm
           and z.entryid is not null
        )
,a1 as (select *
          from remedy.tbl_share_audit z
         cross join args
         where z.modified_date < args.end_tm
           and z.entryid is not null
        )
,aa as (select z.id
             , x.name managerspo
             , w.name manager_name
             , u.name managerabove
          from remedy.usr_report_definitions z
          left join remedy.tbl_share_employee y on y.requestid = z.tbl_share_employee_managerspo_id
          left join remedy.ix_ntlogin x on x.id = y.ix_ntlogin_id
          left join remedy.ix_employee_names w on w.id = y.ix_full_name_id
          left join remedy.tbl_share_employee v on v.requestid = z.tbl_share_employee_managerabove_id
          left join remedy.ix_ntlogin u on u.id = v.ix_ntlogin_id
        )
,ab as (select aa.id
             , x.id ix_ntlogin_id
             , aa.managerspo
          from aa
          cross join empdata.direct_reports(aa.managerspo) z
          left join empdata.employee_data y on y.tbl_employees_id = z.direct_report_id
          left join remedy.ix_ntlogin x on x.name = y.ntlogin
         where x.name is not null
           and aa.managerabove not in (select managerspo from aa)
        )
,ac as (select distinct ix_ntlogin_id from ab)
,ad as (select distinct a0.entryid
          from ac 
          left join a0 on a0.ix_ntlogin_assigned_to_id = ac.ix_ntlogin_id
         where a0.entryid is not null
       )
,ae as (select distinct ix_audit_attribute_id
          from remedy.usr_issue_tracking_attributes
         where is_relevant_to_backlog = true)
,af as (select z.entryid
             , max(z.modified_date) modified_date
             , z.ix_audit_attribute_id
          from a1 z
         cross join args
         where z.entryid in (select entryid from ad )
--           and z.entryid in (select id from unnest(array[23699  /*, 853608, 853615, 853629 */]) x(id) )
           and z.entryid is not null
         group by z.entryid, z.ix_audit_attribute_id
        )
,ag as (select z.entryid
             , null::timestamp without time zone create_date
             , z.modified_date
             , z.ix_audit_attribute_id
             , z.ix_audit_attribute_id real_attrib
             , case
                   when z.ix_audit_attribute_id = 7 then right(w.name::text,2)
                   when z.ix_audit_attribute_id = 12 then w2.name
                   else w.name
               end as_value
          from af
          left join a1 z using(entryid, modified_date, ix_audit_attribute_id)
          left join a0 y using(entryid)
          left join remedy.ix_status y0 on y0.id = y.ix_status_id
          left join remedy.ix_status_details w on w.id = z.ix_to_value_id
          left join remedy.ix_employee_names w0 on w0.name = w.name
          left join remedy.tbl_share_employee w1 on w1.ix_full_name_id = w0.id
          left join remedy.ix_ntlogin w2 on w2.id = w1.ix_ntlogin_id
         cross join args

         where z.entryid is not null
           and z.modified_date < args.end_tm
           and ix_audit_attribute_id in (select ix_audit_attribute_id from remedy.usr_issue_tracking_attributes where is_relevant_to_backlog = true)
           and (y0.name !~* '((Fixed)|(Dismissed))' 
                or (z.ix_audit_attribute_id = 15 and w.name !~* '((Fixed)|(Dismissed))')
                or (z.ix_audit_attribute_id = 42 and w.name not in (select name from remedy.usr_closed_status_detail))
                )
        )
,ah as (select z.entryid
             , z.create_date
             , z.create_date modified_date
             , ae.ix_audit_attribute_id
             , -1::bigint real_attrib
             , case
                  when a0.tbl_issue_tracking_column = 'ix_ntlogin_assigned_to_id' then z0.name
                  when a0.tbl_issue_tracking_column = 'ix_major_area_id' then z1.name
                  when a0.tbl_issue_tracking_column = 'ix_priority_id' then z2.name
                  when a0.tbl_issue_tracking_column = 'ix_product_id' then z3.name
                  when a0.tbl_issue_tracking_column = 'ix_product_area_id' then z4.name
                  when a0.tbl_issue_tracking_column = 'ix_product_family_id' then z5.name
                  when a0.tbl_issue_tracking_column = 'ix_product_release_id' then z6.name
                  when a0.tbl_issue_tracking_column = 'ix_status_id' then z7.name
                  when a0.tbl_issue_tracking_column = 'ix_status_details_id' then z8.name
                  when a0.tbl_issue_tracking_column = 'ix_type_id' then z9.name
               end as_value
          from a0 z
          left join remedy.ix_ntlogin z0 on z0.id = z.ix_ntlogin_assigned_to_id
          left join remedy.ix_major_area z1 on z1.id = z.ix_major_area_id
          left join remedy.ix_priority z2 on z2.id = z.ix_priority_id
          left join remedy.ix_product z3 on z3.id = z.ix_product_id
          left join remedy.ix_product_area z4 on z4.id = z.ix_product_area_id
          left join remedy.ix_product_family z5 on z5.id = z.ix_product_family_id
          left join remedy.ix_product_release z6 on z6.id = z.ix_product_release_id
          left join remedy.ix_status z7 on z7.id = z.ix_status_id
          left join remedy.ix_status_details z8 on z8.id = z.ix_status_details_id
          left join remedy.ix_type z9 on z9.id = z.ix_type_id
         cross join ae
         cross join args
          left join remedy.usr_issue_tracking_attributes a0 using(ix_audit_attribute_id)
         where z.entryid in (select distinct entryid from af)
           and z.modified_date < args.end_tm
        )
,ai0 as (select ag.* from ag
          left join ah using (entryid)
         where ag.modified_date > ah.modified_date
        )
,ai as (select * from ai0 union select * from ah)
,aj as (select entryid
             , min(create_date) create_date
             , modified_date
          from ai
         group by entryid, modified_date
       )
,ak as (select distinct entryid
                      , create_date
                      , modified_date
                      , ix_audit_attribute_id
          from aj
         cross join ae
        )
,al0 as (select ak.entryid
              , ak.create_date
              , ak.modified_date
              , ak.ix_audit_attribute_id
              , ai.as_value as_value
              , row_number() over (partition by ak.ix_audit_attribute_id) row_num
              , case
                  when ai.as_value is not null 
                    or ai.real_attrib = -1
                    or ai.real_attrib = ak.ix_audit_attribute_id  then row_number() over (partition by ak.ix_audit_attribute_id)
                  else 0
                end idx
           from ak
          left join ai using (entryid, create_date, modified_date, ix_audit_attribute_id)
         WINDOW entry_changes as (partition by ak.entryid, ak.ix_audit_attribute_id, ak.modified_date order by ak.modified_date)
       )
,al1 as (select entryid
             , create_date
             , modified_date
             , ix_audit_attribute_id
             , as_value
             , max(idx) over (partition by ix_audit_attribute_id order by row_num) idx
         from al0
        WINDOW entry_changes as (partition by entryid, ix_audit_attribute_id, modified_date order by modified_date)
      )
,al as (select entryid
             , create_date
             , modified_date
             , ix_audit_attribute_id
             , nth_value(as_value, idx::integer) over (partition by ix_audit_attribute_id) as_value
          from al1
        WINDOW entry_changes as (partition by entryid, ix_audit_attribute_id order by modified_date)
         ORDER BY ix_audit_attribute_id, modified_date
      )
,am0 as (select entryid, create_date, modified_date, z.id ix_major_area_id
           from al
           left join remedy.ix_major_area z on z.name = al.as_value -- "Major area" 
          where ix_audit_attribute_id = 13)
,am1 as (select entryid, create_date, modified_date, z.id ix_ntlogin_assigned_to_id
           from al
           left join remedy.ix_ntlogin z on z.name = al.as_value  -- "Assigned to" 
          where ix_audit_attribute_id = 12)
,am2 as (select entryid, create_date, modified_date, z.id ix_priority_id 
           from al
           left join remedy.ix_priority z on z.name = al.as_value  -- "priority" 
          where ix_audit_attribute_id = 7)
,am3 as (select entryid, create_date, modified_date, z.id ix_product_id 
           from al
           left join remedy.ix_product z on z.name = al.as_value -- "Product"
          where ix_audit_attribute_id = 40)
,am4 as (select entryid, create_date, modified_date, z.id ix_product_area_id
           from al
           left join remedy.ix_product_area z on z.name = al.as_value -- "Product Area"
          where ix_audit_attribute_id = 33)
,am5 as (select entryid, create_date, modified_date, z.id  ix_product_family_id
           from al
           left join remedy.ix_product_family z on z.name = al.as_value -- "Product Family"
          where ix_audit_attribute_id = 34)
,am6 as (select entryid, create_date, modified_date, z.id ix_product_release_id
           from al
           left join remedy.ix_product_release z on z.name = al.as_value -- "Product Release"
          where ix_audit_attribute_id = 16)
,am7 as (select entryid, create_date, modified_date, z.id ix_status_id
           from al
           left join remedy.ix_status z on z.name = al.as_value -- "Status"
          where ix_audit_attribute_id = 15)
,am8 as (select entryid, create_date, modified_date, z.id ix_status_details_id
           from al
           left join remedy.ix_status_details z on z.name = al.as_value -- "Status Details"
          where ix_audit_attribute_id = 42)
,am9 as (select entryid, create_date, modified_date, z.id ix_type_id
           from al
           left join remedy.ix_type z on z.name = al.as_value -- "Type"
          where ix_audit_attribute_id = 36)
,am as (select aj.entryid
             , am0.create_date
             , aj.modified_date
             , am0.ix_major_area_id
             , am1.ix_ntlogin_assigned_to_id
             , am2.ix_priority_id
             , am3.ix_product_id
             , am4.ix_product_area_id
             , am5.ix_product_family_id
             , am6.ix_product_release_id
             , am7.ix_status_id
             , am8.ix_status_details_id
             , am9.ix_type_id
          from aj
          left join am0 using(entryid, modified_date)
          left join am1 using(entryid, modified_date)
          left join am2 using(entryid, modified_date)
          left join am3 using(entryid, modified_date)
          left join am4 using(entryid, modified_date)
          left join am5 using(entryid, modified_date)
          left join am6 using(entryid, modified_date)
          left join am7 using(entryid, modified_date)
          left join am8 using(entryid, modified_date)
          left join am9 using(entryid, modified_date)
        )
,an as (select z.entryid
             , z.create_date
             , z.modified_date
             , z.ix_major_area_id
             , z.ix_ntlogin_assigned_to_id
             , z.ix_priority_id
             , z.ix_product_id
             , z.ix_product_area_id
             , z.ix_product_family_id
             , z.ix_product_release_id
             , z.ix_status_id
             , z.ix_status_details_id
             , z.ix_type_id
          from a0 z
         where z.entryid is not null
           and z.entryid not in (select distinct entryid from af)
        )
,ao as (select * from am union select * from an)
,ap as (select entryid
             , first_value(create_date) over entries create_date
             , modified_date
             , ix_major_area_id
             , ix_ntlogin_assigned_to_id
             , ix_priority_id
             , ix_product_id
             , ix_product_area_id
             , ix_product_family_id
             , ix_product_release_id
             , ix_status_id
             , ix_status_details_id
             , ix_type_id
          from ao
         WINDOW entries as (partition by entryid order by modified_date)
        )
,aq as (select aa.manager_name
             , z.create_date
             , z.modified_date
             , z.ix_major_area_id
             , z.ix_priority_id
             , z.ix_product_id
             , z.ix_product_area_id
             , z.ix_product_family_id
             , z.ix_product_release_id
             , z.ix_status_id
             , z.ix_status_details_id
             , z.ix_type_id
         from ap z
        cross join remedy.usr_report_definitions y
         left join aa on aa.id = y.id
        where ((y.ix_product_id is null or y.ix_product_id = z.ix_product_id)
          and (y.ix_product_area_id is null or y.ix_product_area_id = z.ix_product_area_id)
          and (y.ix_product_family_id is null or y.ix_product_family_id = z.ix_product_family_id))
          or z.entryid in (select distinct entryid from af)

      )
select * from aq;


$_$;


ALTER FUNCTION remedy.current_issues_de(end_tm timestamp without time zone) OWNER TO postgres;

--
-- Name: FUNCTION current_issues_de(end_tm timestamp without time zone); Type: COMMENT; Schema: remedy; Owner: postgres
--

COMMENT ON FUNCTION current_issues_de(end_tm timestamp without time zone) IS 'return remedy AR history up to given date_time';


--
-- Name: devecosystem_ars(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: remedy; Owner: postgres
--

CREATE FUNCTION devecosystem_ars(start_tm timestamp without time zone, end_tm timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(manager_name text, "Period End" date, status text, isnew boolean, entryid bigint, priority text)
    LANGUAGE sql
    AS $_$

with 
 args as (select $1 start_tm
               , case
                    when $2 is null then now()::timestamp without time zone
                    else $2
                 end end_tm
        )
-- args as (select (null::timestamp without time zone) start_tm
--               , (now()::timestamp without time zone) end_tm
--         )
,a as (select (remedy.backlog_issues(start_tm, end_tm)).* from args)
,b as (select z.id
            , x.name managerspo
            , w.name manager_name
            , u.name managerabove
         from remedy.usr_report_definitions z
         left join remedy.tbl_share_employee y on y.requestid = z.tbl_share_employee_managerspo_id
         left join remedy.ix_ntlogin x on x.id = y.ix_ntlogin_id
         left join remedy.ix_employee_names w on w.id = y.ix_full_name_id
         left join remedy.tbl_share_employee v on v.requestid = z.tbl_share_employee_managerabove_id
         left join remedy.ix_ntlogin u on u.id = v.ix_ntlogin_id
       )
,c as (select b.id
            , x.id ix_ntlogin_id
            , b.managerspo
            , b.manager_name
         from b
         cross join empdata.direct_reports(b.managerspo) z
         left join empdata.employee_data y on y.tbl_employees_id = z.direct_report_id
         left join remedy.ix_ntlogin x on x.name = y.ntlogin
        where x.name is not null
--          and b.managerabove not in (select managerspo from b)
       )
,d as (select distinct on (c.manager_name, a0.end_tm, a1.name, a.entryid, a2.name)
              c.manager_name
            , a0.end_tm::date "Period End"
            , a1.name status
            , (a.create_date > (a0.end_tm - '7 days'::interval)) isnew
            , a.entryid
            , a2.name priority
         from a
         left join remedy.ix_history a0 on a0.id = a.ix_history_id
         left join remedy.ix_status a1 on a1.id = a.ix_status_id
         left join remedy.ix_priority a2 on a2.id = a.ix_priority_id
         left join remedy.ix_type a3 on a3.id = a.ix_type_id
         left join c on c.ix_ntlogin_id = a.ix_ntlogin_assigned_to_id
         left join remedy.usr_report_definitions y on y.id = c.id
--         left join remedy.tbl_share_employee y0 on y0.requestid = y.tbl_share_employee_managerspo_id
--         left join remedy.ix_ntlogin y1 on y1.id = y0.ix_ntlogin_id
        where a.entryid is not null
          and a2.name is not null
          and (a3.name = 'Bug' or a3.name = 'Customer Incident')
          and (a.ix_ntlogin_assigned_to_id in (select distinct ix_ntlogin_id from c)
            or ((y.ix_product_id is null or y.ix_product_id = a.ix_product_id)
            and (y.ix_product_area_id is null or y.ix_product_area_id = a.ix_product_area_id)
            and (y.ix_product_family_id is null or y.ix_product_family_id = a.ix_product_family_id)))
        order by c.manager_name, a0.end_tm, a1.name, a.entryid, a2.name
       )
select * from d;


$_$;


ALTER FUNCTION remedy.devecosystem_ars(start_tm timestamp without time zone, end_tm timestamp without time zone) OWNER TO postgres;

--
-- Name: FUNCTION devecosystem_ars(start_tm timestamp without time zone, end_tm timestamp without time zone); Type: COMMENT; Schema: remedy; Owner: postgres
--

COMMENT ON FUNCTION devecosystem_ars(start_tm timestamp without time zone, end_tm timestamp without time zone) IS 'return remedy AR history up to given date_time';


--
-- Name: entryid(bigint); Type: FUNCTION; Schema: remedy; Owner: postgres
--

CREATE FUNCTION entryid(id bigint) RETURNS character varying
    LANGUAGE sql
    AS $_$

   WITH
    a  as (SELECT $1 id)
   ,b  as (SELECT CASE
                    WHEN id is null OR id < 0 THEN '0'
                    ELSE id::text
                  END id
            FROM a)
   SELECT right('000000000000000' || id, 15) FROM b;


$_$;


ALTER FUNCTION remedy.entryid(id bigint) OWNER TO postgres;

--
-- Name: FUNCTION entryid(id bigint); Type: COMMENT; Schema: remedy; Owner: postgres
--

COMMENT ON FUNCTION entryid(id bigint) IS 'return Remedy formatted Entry-Id';


--
-- Name: rets(timestamp with time zone); Type: FUNCTION; Schema: remedy; Owner: postgres
--

CREATE FUNCTION rets(end_tm timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE("Entry ID" text, "Age" numeric, "Days since last modification" numeric, "Assigned To" character varying, "Assigned To: login" character varying, "Last Modified By" character varying, "Last Modified By: login" character varying, status character varying, "Orphaned status" text[])
    LANGUAGE sql
    AS $_$


with
-- args: provide some reasonable names for the input params
args as (select case
                 when $1 is null then now()
                 when $1 > now() then now()
                 else $1
                end end_date)
,a as (select * from remedy.tbl_share_employee where requestid != 6710)
,b as (select z.entryid
            , max(z.modified_date) modified_date
         from remedy.tbl_release_engineering_tracker z
        cross join args
        where z.modified_date < args.end_date
        group by z.entryid
       )
,c as (select z.*
         from b
         left join remedy.tbl_release_engineering_tracker z using (entryid, modified_date)
       )
,d as (select ('RET' || right(remedy.entryid(c.entryid),12)) "Entry ID"
            , extract(epoch from (args.end_date - c.create_date))/86400. "Age"
            , extract(epoch from (args.end_date - c.modified_date))/86400. "XXX"
            , case
                  when t.name = 'Inactive' then null
                  else y.name
              end assigned_to
            , case
                  when t.name = 'Inactive' then null
                  else r.name
              end assigned_to_loginid
            , case
                  when s.name = 'Inactive' then null
                  else v.name
              end last_modified_by
            , case
                  when s.name = 'Inactive' then null
                  else q.name
              end last_modified_by_loginid
            , case
                  when (t.name = 'Inactive' and s.name = 'Inactive') 
                     then ARRAY['3', y.name,  v.name]
                  when t.name = 'Inactive' then ARRAY['2', y.name, null]
                  when s.name = 'Inactive' then ARRAY['1', null, v.name]
                  else ARRAY['0', null, null]
              end orphaned_status
            , x.name status
         from c
        cross join args
         left join remedy.ix_employee_names y on y.id = c.ix_assigned_to_id
         left join remedy.ix_status x on x.id = c.ix_status_id
         left join a w on w.ix_ntlogin_id = c.ix_ntlogin_last_modified_by_id
         left join remedy.ix_employee_names v on v.id = w.ix_full_name_id
         left join a u on u.ix_full_name_id = c.ix_assigned_to_id
         left join remedy.ix_status t on t.id = u.ix_status_id
         left join remedy.ix_status s on s.id = w.ix_status_id

         left join remedy.ix_ntlogin r on r.id = u.ix_ntlogin_id
         left join remedy.ix_ntlogin q on q.id = c.ix_ntlogin_last_modified_by_id
         
         where x.name in ('New', 'Open', 'Waiting On 3rd Party', 'Waiting On Originator', '"Waiting on Originator"', 'Backlog')
      )
,e as (select "Entry ID"
            , round("Age"::numeric, 2) "Age"
            , round("XXX"::numeric, 2) "Days since last modification"
            , assigned_to "Assigned To"
            , assigned_to_loginid "Assigned To: login"
            , last_modified_by "Last Modified By"
            , last_modified_by_loginid "Last Modified By: login"
            , status
            , case
                 when orphaned_status[1] = '0' then null
                 else ARRAY[coalesce(orphaned_status[2],''), coalesce(orphaned_status[3],'')]
              end "Orphaned status"
        from d
        order by orphaned_status[1] desc, "Age" desc,"Days since last modification" desc)
select * from e;


$_$;


ALTER FUNCTION remedy.rets(end_tm timestamp with time zone) OWNER TO postgres;

--
-- Name: FUNCTION rets(end_tm timestamp with time zone); Type: COMMENT; Schema: remedy; Owner: postgres
--

COMMENT ON FUNCTION rets(end_tm timestamp with time zone) IS 'return remedy RET history up to given date_time';


SET search_path = shares, pg_catalog;

--
-- Name: lastscan_timestamp(); Type: FUNCTION; Schema: shares; Owner: postgres
--

CREATE FUNCTION lastscan_timestamp() RETURNS timestamp without time zone
    LANGUAGE sql
    AS $$
      SELECT MAX(tm) FROM shares.rpmscans;
;
$$;


ALTER FUNCTION shares.lastscan_timestamp() OWNER TO postgres;

--
-- Name: FUNCTION lastscan_timestamp(); Type: COMMENT; Schema: shares; Owner: postgres
--

COMMENT ON FUNCTION lastscan_timestamp() IS 'return the timestamp for the last scan';


SET search_path = vcenter, pg_catalog;

--
-- Name: categories(timestamp with time zone); Type: FUNCTION; Schema: vcenter; Owner: postgres
--

CREATE FUNCTION categories(scan_time timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE(vminfo_id bigint, folders_id bigint, server_scans_id bigint, esxserver character varying, name character varying, vmid character varying, hostname character varying, ipaddress character varying, folder character varying, guestos character varying, guestid character varying, numcpus integer, numnics integer, memory_size bigint, virtual_disks integer, usedspacegb real, freespacegb real, capacitygb real, powered_on boolean, category character varying, catmode character varying, tools_version character varying, tools_status character varying, tools_cfg_version bigint, tools_version_status character varying)
    LANGUAGE sql
    AS $_$


  WITH
    args      as (SELECT scan_id, scan_time from vcenter.getscan($1)
                 )
   ,vms       as (SELECT z.vminfo_id,
                         t.address esxserver,
                         x.name,
                         x.vmid,
                         y.hostname,
                         v.name category
                     from vcenter.vminfo_history z
                     left join vcenter.vminfo y on y.id = z.vminfo_id
                     left join vcenter.vms x on x.id = y.vms_id
                     left join vcenter.vmcategory w on w.vms_id = y.vms_id
                     left join vcenter.vmcategory_types v on v.id = w.vmcategory_types_id
                     left join vcenter.esxservers t on t.id = x.esxservers_id
                     where z.server_scans_id in (select scan_id from args)
                  )
   ,vm_types  as (SELECT match, name category, id from vcenter.vmcategory_types
                   WHERE match IS NOT NULL
                  )

-- separate categories (s0) not yet defined from the predefined categories (cat0)
   ,cat0     as (select *, 'assigned'::text AS catmode
                    from vms
                   where category is not null
                 )
   ,s0        as (select vminfo_id,
                         esxserver,
                         name,
                         vmid,
                         hostname
                    from vms
                   where category is null
                 )

-- match categories with the vm name
   ,s1        as (select z.esxserver, z.vmid, z.name, min(y.id) id
                    from s0 z
                    left join vm_types y on z.name ~* y.match
                    group by z.esxserver, z.vmid, z.name
                 )
   ,s2        as (SELECT z.*, y.category
                    from s0 z
                    left join s1 on s1.esxserver = z.esxserver and s1.vmid = z.vmid and s1.name = z.name
                    left join vm_types y on y.id = s1.id
                 )
   ,cat1      as (select *, 'name'::text AS catmode
                    from s2
                   where category is not null
                 )
   ,t0        as (select vminfo_id,
                         esxserver,
                         name,
                         vmid,
                         hostname
                    from s2
                   where category is null
                 )


-- match categories with the vm hostname
   ,t1        as (select z.esxserver, z.vmid, z.hostname, min(y.id) id
                    from t0 z
                    left join vm_types y on z.hostname ~* y.match
                    group by z.esxserver, z.vmid, z.hostname
                 )
   ,t2        as (SELECT z.*, y.category
                    from t0 z
                    left join t1 on t1.esxserver = z.esxserver and t1.vmid = z.vmid and t1.hostname = z.hostname
                    left join vm_types y on y.id = t1.id
                 )
   ,cat2      as (select *, 'hostname'::text AS catmode
                    from t2
                   where category is not null
                 )

-- unknowns remaining
   ,cat3      as (select *, NULL::text AS catmode
                    from t2
                   where category is null
                 )

--combine predefined and 'match from vm hostname' and 'match from vm vmid'
   ,cat4     as (select * from cat0 union 
                 select * from cat1 union 
                 select * from cat2 union 
                 select * from cat3
                 )
   ,rslts    as (select z.vminfo_id,
                        y.folders_id,
                        v.server_scans_id,
                        z.esxserver,
                        z.name,
                        z.vmid,
                        z.hostname,
                        y.ipaddress,
                        u.name folder,
                        x.name guestos,
                        w.name guestid,
                        v.numcpus,
                        v.numnics,
                        v.memory_size,
                        v.virtual_disks,
                        v.usedspacegb,
                        v.freespacegb,
                        v.capacitygb,
                        v.powered_on,
                        z.category,
                        z.catmode,
                        q.name tools_version,
                        s.name tools_status,
                        v.tools_cfg_version,
                        r.name tools_version_status
                     from cat4 z
                     left join vcenter.vminfo y on y.id = z.vminfo_id
                     left join vcenter.guestos_types x on x.id = y.guestos_types_id
                     left join vcenter.guestid_types w on w.id = y.guestid_types_id
                     left join vcenter.vminfo_history v on v.vminfo_id = z.vminfo_id
                     left join vcenter.folders u on u.id = y.folders_id
                     LEFT JOIN vcenter.tools_status s on s.id = v.tools_status_id
                     LEFT JOIN vcenter.tools_version_status r on r.id = v.tools_version_status_id
                     LEFT JOIN vcenter.tools_version q on q.id = v.tools_version_id
                     where v.server_scans_id in (select scan_id from args)
                )
   select * from rslts;



$_$;


ALTER FUNCTION vcenter.categories(scan_time timestamp with time zone) OWNER TO postgres;

--
-- Name: currentvms(timestamp with time zone); Type: FUNCTION; Schema: vcenter; Owner: postgres
--

CREATE FUNCTION currentvms(scan_time timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE(scan_id bigint, vms_id bigint, vminfo_id bigint, last_change bigint)
    LANGUAGE sql
    AS $_$

  WITH
    args as (SELECT scan_id, scan_time from vcenter.getscan($1)),

    b0   as (select y.vms_id, z.last_change
              from vcenter.vmexists z
              cross join args
              left join vcenter.vminfo y on y.id = z.vminfo_id
              where z.last_change <= args.scan_id
           ),
    b1  as (select vms_id, max(last_change) last_change
              from b0
             group by vms_id
           ),
    b2  as (select args.scan_id, x.vms_id, y.vminfo_id, y.last_change
              from b1 z
              cross join args
              left join vcenter.vmexists y on y.last_change=z.last_change
              left join vcenter.vminfo x on x.id = y.vminfo_id
              where y.exist_status = true and x.vms_id = z.vms_id
            )
    select * from b2;



$_$;


ALTER FUNCTION vcenter.currentvms(scan_time timestamp with time zone) OWNER TO postgres;

--
-- Name: getfolder(bigint); Type: FUNCTION; Schema: vcenter; Owner: postgres
--

CREATE FUNCTION getfolder(folders_id bigint) RETURNS text
    LANGUAGE sql
    AS $_$

    with recursive
     folderpath(id, name, idx)
        as   (select parent_id id, name, 0 from vcenter.folders where id = $1
               union all
                select y.parent_id id, y.name, idx+1 from folderpath  z
                  left join vcenter.folders y on y.id = z.id
                  where y.name != 'vm' and y.name is not null
              )
    ,rslt as (select * from folderpath order by idx desc)
    select string_agg(name,'/') from rslt;

$_$;


ALTER FUNCTION vcenter.getfolder(folders_id bigint) OWNER TO postgres;

--
-- Name: getscan(bigint); Type: FUNCTION; Schema: vcenter; Owner: postgres
--

CREATE FUNCTION getscan(scan_id bigint DEFAULT NULL::bigint) RETURNS TABLE(scan_id bigint, scan_time timestamp with time zone)
    LANGUAGE sql
    AS $_$


  WITH
    args as (SELECT $1 scan_id),
    a0   as (select max(id) max_id from vcenter.server_scans),
    a1   as (select min(id) min_id from vcenter.server_scans),
    a2   as (SELECT case 
                       when args.scan_id IS NULL or args.scan_id > a0.max_id then a0.max_id
                       when args.scan_id < a1.min_id then a1.min_id
                       else args.scan_id
                    end scan_id
                FROM args, a0, a1
             ),
    a3   as (select y.*
               FROM a2
               LEFT JOIN vcenter.server_scans y on y.id = a2.scan_id
            )
    select * from a3;


$_$;


ALTER FUNCTION vcenter.getscan(scan_id bigint) OWNER TO postgres;

--
-- Name: getscan(timestamp with time zone); Type: FUNCTION; Schema: vcenter; Owner: postgres
--

CREATE FUNCTION getscan(scan_time timestamp with time zone) RETURNS TABLE(scan_id bigint, scan_time timestamp with time zone)
    LANGUAGE sql
    AS $_$

  WITH
    args as (SELECT $1 scan_time),
    a0   as (select max(scan_time) scan_time from vcenter.server_scans),
    a1   as (select min(scan_time) scan_time from vcenter.server_scans),
    a2   as (SELECT case 
                       when args.scan_time IS NULL or args.scan_time >= a0.scan_time then a0.scan_time
                       when args.scan_time < a1.scan_time then a1.scan_time
                       else (select z.scan_time from vcenter.server_scans z, args
                              where z.scan_time < args.scan_time
                              order by z.scan_time desc
                              limit 1)
                    end scan_time
                FROM a0, a1, args
             ),
    a3   as (select y.*
               FROM a2
               LEFT JOIN vcenter.server_scans y on y.scan_time = a2.scan_time
             )
      select vcenter.getscan(a3.id) from a3;

 $_$;


ALTER FUNCTION vcenter.getscan(scan_time timestamp with time zone) OWNER TO postgres;

--
-- Name: ipinfo(inet); Type: FUNCTION; Schema: vcenter; Owner: postgres
--

CREATE FUNCTION ipinfo(ip inet) RETURNS TABLE(subnet inet, location character varying, site character varying, cloud character varying, widget character varying, iscec boolean)
    LANGUAGE sql
    AS $_$


  with
  
 args as (select $1 ip)
,a as (select z.subnet
            , x.location
            , w.name site
            , v.name cloud
            , u.name widget
            , case
                 when v.name ~* 'CEC' then true
                 when v.name is not null then false
                 when w.name ~* 'St Petersburg|RTP|Paris|New Jersey|Shanghai' then false
                 else null
              end isCEC
         from vcenter.usr_subnets z
         cross join args
         left join vcenter.locations x on x.id = z.ix_locations_id
         left join vcenter.ix_site w on w.id = z.ix_site_id
         left join vcenter.ix_cloud v on v.id = z.ix_cloud_id
         left join vcenter.ix_widget u on u.id = z.ix_widget_id
        where args.ip << z.subnet
        )
select * from a;
  

$_$;


ALTER FUNCTION vcenter.ipinfo(ip inet) OWNER TO postgres;

--
-- Name: vm_info(timestamp with time zone); Type: FUNCTION; Schema: vcenter; Owner: postgres
--

CREATE FUNCTION vm_info(scan_time timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE(scan_time timestamp with time zone, location character varying, locations_id bigint, esxname character varying, address character varying, esxservers_id bigint, vmid character varying, vmname character varying, vmpathname character varying, vms_id bigint, server_scans_id bigint, folders_id bigint, folder character varying, guestos_types_id bigint, guestos character varying, guestid_types_id bigint, guestid character varying, hostname character varying, ipaddress character varying, notes character varying, vminfo_id bigint, powered_on boolean, connected boolean, usedspacegb real, freespacegb real, capacitygb real, numcpus integer, numnics integer, memory_size bigint, virtual_disks integer, tools_version character varying, tools_status character varying, tools_cfg_version bigint, tools_version_status character varying)
    LANGUAGE sql
    AS $_$

  WITH
    args as (SELECT scan_id, scan_time from vcenter.getscan($1)
            )
   ,b1  as (select args.scan_time,
                   v.location,
                   w.locations_id,
                   w."name" esxname,
                   w.address,
                   x.esxservers_id,
                   x.vmid,
                   x."name" vmname,
                   x.vmpathname,
                   y.vms_id,
                   y.server_scans_id,
                   y.folders_id,
                   r."name" folder,
                   y.guestos_types_id,
                   t."name" guestos,
                   y.guestid_types_id,
                   s."name" guestid,
                   y.hostname,
                   y.ipaddress,
                   y.notes,
                   z.vminfo_id,
                   z.powered_on,
                   z.connected,
                   z.usedspacegb,
                   z.freespacegb,
                   z.capacitygb,
                   z.numcpus,
                   z.numnics,
                   z.memory_size,
                   z.virtual_disks,
                   q.name tools_version
                 , p.name tools_status
                 , z.tools_cfg_version
                 , o.name tools_version_status
              from vcenter.vminfo_history z
              cross join args
              left join vcenter.vminfo y on y.id = z.vminfo_id
              left join vcenter.vms x on x.id = y.vms_id
              left join vcenter.esxservers w on w.id = x.esxservers_id
              left join vcenter.locations v on v.id = w.locations_id
              left join vcenter.server_scans u on u.id = z.server_scans_id
              left join vcenter.guestos_types t on t.id = y.guestos_types_id
              left join vcenter.guestid_types s on s.id = y.guestid_types_id
              left join vcenter.folders r on r.id = y.folders_id
              left join vcenter.tools_version q on q.id = z.tools_version_id
              left join vcenter.tools_status p on p.id = z.tools_status_id
              left join vcenter.tools_version_status o on o.id = z.tools_version_status_id
              where u.id = args.scan_id
            )
  SELECT * FROM b1;

$_$;


ALTER FUNCTION vcenter.vm_info(scan_time timestamp with time zone) OWNER TO postgres;

--
-- Name: vmdetails(character varying, timestamp with time zone); Type: FUNCTION; Schema: vcenter; Owner: postgres
--

CREATE FUNCTION vmdetails(vm character varying, tm timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE(vm_id bigint, vmname character varying, hostname character varying, ipaddress character varying, category character varying, folder character varying, folderpath character varying, esxserver character varying, vcenter character varying)
    LANGUAGE sql
    AS $_$


  with
  
  args as (select trim(both ' ' from $1) vm, scan_id, scan_time from vcenter.getscan($2)),
  vms  as (select * from vcenter.vm_info((select scan_time from args)))

     select z.vms_id, 
           y.name vmname,
           z.hostname,
           z.ipaddress,
           v.name category,
           t.name "folder",
           t.name "folderpath",
           x.address "esxserver", 
           x.name vcenter 
      from vms z
     cross join args
      LEFT JOIN vcenter.vms y on y.id = z.vms_id
      left join vcenter.esxservers x on x.id = y.esxservers_id
      left join vcenter.vmcategory w on w.vms_id = z.vms_id
      left join vcenter.vmcategory_types v on v.id = w.vmcategory_types_id
      left join vcenter.folders t on t.id = z.folders_id
     where z.ipaddress = args.vm or z.hostname ~* args.vm or y.name ~* args.vm;
  

$_$;


ALTER FUNCTION vcenter.vmdetails(vm character varying, tm timestamp with time zone) OWNER TO postgres;

SET search_path = vdiscover, pg_catalog;

--
-- Name: categories(timestamp with time zone); Type: FUNCTION; Schema: vdiscover; Owner: postgres
--

CREATE FUNCTION categories(scan_time timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE(category character varying, server character varying, name character varying, vmpathname character varying, hostname character varying, numcpus integer, memory_size bigint, powered_on boolean)
    LANGUAGE sql
    AS $_$

  WITH
    vms       as (SELECT x.name category,
                         t.address "server",
                         w.name,
                         w.vmpathname,
                         u.hostname,
                         u.numcpus,
                         u.memory_size,
                         case
                            when u.guestos_id is null and u.guestid_id is null then false
                            else true
                         end powered_on
                     from vdiscover.currentvms($1) z
                     left join vdiscover.vmcategory y on y.vm_id = z.vm_id
                     left join vdiscover.vmcategory_types x on x.id = y.vmcategory_type_id
                     left join vdiscover.vms w on w.id = z.vm_id
                     left join vdiscover.vminfo u on u.id = z.vminfo_id
                     left join vdiscover."esx-servers" t on t.id = w.server_id
                  ),
    vm_types  as (SELECT match, name category from vdiscover.vmcategory_types
                  ),

-- separate categories (s0) not yet defined from the predefined categories (cat0)
    cat0     as (select category, server, name, vmpathname, hostname, numcpus, memory_size, powered_on
                    from vms
                   where category is not null
                 ),
    s0        as (select category, server, name, vmpathname, hostname, numcpus, memory_size, powered_on
                    from vms
                   where category is null
                 ),

-- match categories with the vm name
    s1        as (SELECT y.category, z.server, z.name, z.vmpathname, z.hostname, z.numcpus, z.memory_size, z.powered_on
                    from s0 z
                    left join vm_types y on (y.match IS NOT NULL and z.name ~* y.match)
                 ),
    cat1      as (select category, server, name, vmpathname, hostname, numcpus, memory_size, powered_on
                    from s1
                   where category is not null
                 ),
    u1        as (select category, server, name, vmpathname, hostname, numcpus, memory_size, powered_on
                    from s1
                   where category is null
                 ),

-- match categories with the vm hostname
    s2        as (SELECT y.category, z.server, z.name, z.vmpathname, z.hostname, z.numcpus, z.memory_size, z.powered_on
                    from u1 z
                    left join vm_types y on (y.match IS NOT NULL and z.hostname ~* y.match)
                 ),
    u2        as (select category, server, name, vmpathname, hostname, numcpus, memory_size, powered_on
                    from s2
                   where category is null
                 ),
    cat2      as (select category, server, name, vmpathname, hostname, numcpus, memory_size, powered_on
                    from s2
                   where category is not null
                 ),

-- get the categories which match the vm vmpathname
    cat3      as (SELECT y.category, z.server, z.name, z.vmpathname, z.hostname, z.numcpus, z.memory_size, z.powered_on
                    from u2 z
                    left join vm_types y on (y.match IS NOT NULL and z.vmpathname ~* y.match)
                 ),

--combine predefined and 'match from vm hostname' and 'match from vm vmpathname'
    cat4     as (select * from cat0 union select * from cat1 union select * from cat2 union select * from cat3
                 )

   select * from cat4;


$_$;


ALTER FUNCTION vdiscover.categories(scan_time timestamp with time zone) OWNER TO postgres;

--
-- Name: currentvms(timestamp with time zone); Type: FUNCTION; Schema: vdiscover; Owner: postgres
--

CREATE FUNCTION currentvms(scan_time timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE(scan_id bigint, vm_id bigint, vminfo_id bigint, last_change timestamp with time zone)
    LANGUAGE sql
    AS $_$

  WITH
    args as (SELECT scan_id, scan_time from vdiscover.getscan($1)),

    b0   as (select y.vm_id, z.last_change
              from vdiscover.vmexists z
              cross join args
              left join vdiscover.vminfo y on y.id = z.vminfo_id
              where z.last_change <= args.scan_time
           ),
    b1  as (select vm_id, max(last_change) last_change
              from b0
             group by vm_id
           ),
    b2  as (select args.scan_id, x.vm_id, y.vminfo_id, y.last_change
              from b1 z
              cross join args
              left join vdiscover.vmexists y on y.last_change=z.last_change
              left join vdiscover.vminfo x on x.id = y.vminfo_id
              where y.exist_status = true and x.vm_id = z.vm_id
            )
    select * from b2;



$_$;


ALTER FUNCTION vdiscover.currentvms(scan_time timestamp with time zone) OWNER TO postgres;

--
-- Name: getscan(bigint); Type: FUNCTION; Schema: vdiscover; Owner: postgres
--

CREATE FUNCTION getscan(scan_id bigint DEFAULT NULL::bigint) RETURNS TABLE(scan_id bigint, scan_time timestamp with time zone)
    LANGUAGE sql
    AS $_$


  WITH
    args as (SELECT $1 scan_id),
    a0   as (select max(id) max_id from vdiscover.server_scans),
    a1   as (select min(id) min_id from vdiscover.server_scans),
    a2   as (SELECT case 
                       when args.scan_id IS NULL or args.scan_id > a0.max_id then a0.max_id
                       when args.scan_id < a1.min_id then a1.min_id
                       else args.scan_id
                    end scan_id
                FROM args, a0, a1
             ),
    a3   as (select y.*
               FROM a2
               LEFT JOIN vdiscover.server_scans y on y.id = a2.scan_id
            )
    select * from a3;


$_$;


ALTER FUNCTION vdiscover.getscan(scan_id bigint) OWNER TO postgres;

--
-- Name: getscan(timestamp with time zone); Type: FUNCTION; Schema: vdiscover; Owner: postgres
--

CREATE FUNCTION getscan(scan_time timestamp with time zone) RETURNS TABLE(scan_id bigint, scan_time timestamp with time zone)
    LANGUAGE sql
    AS $_$

  WITH
    args as (SELECT $1 scan_time),
    a0   as (select max(scan_time) scan_time from vdiscover.server_scans),
    a1   as (select min(scan_time) scan_time from vdiscover.server_scans),
    a2   as (SELECT case 
                       when args.scan_time IS NULL or args.scan_time >= a0.scan_time then a0.scan_time
                       when args.scan_time < a1.scan_time then a1.scan_time
                       else (select z.scan_time from vdiscover.server_scans z, args
                              where z.scan_time < args.scan_time
                              order by z.scan_time desc
                              limit 1)
                    end scan_time
                FROM a0, a1, args
             ),
    a3   as (select y.*
               FROM a2
               LEFT JOIN vdiscover.server_scans y on y.scan_time = a2.scan_time
             )
      select vdiscover.getscan(a3.id) from a3;

 $_$;


ALTER FUNCTION vdiscover.getscan(scan_time timestamp with time zone) OWNER TO postgres;

--
-- Name: vm_info(timestamp with time zone); Type: FUNCTION; Schema: vdiscover; Owner: postgres
--

CREATE FUNCTION vm_info(scan_time timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE(last_change timestamp with time zone, vm_id bigint, server_id bigint, name character varying, vmpathname character varying, hostname character varying, ipaddress character varying, numcpus integer, memory_size bigint, virtual_disks integer, template integer, guestos_id bigint, guestid_id bigint, vmwaretools_id bigint, powered_on boolean)
    LANGUAGE sql
    AS $_$


  WITH
    args as (SELECT scan_id, scan_time from vdiscover.getscan($1)),
    b0   as (select y.vm_id, z.last_change
              from vdiscover.vmexists z
              cross join args
              left join vdiscover.vminfo y on y.id = z.vminfo_id
              where z.last_change <= args.scan_time
           ),
    b1  as (select vm_id, max(last_change) last_change
              from b0
             group by vm_id
           ),
    b2  as (select y.*,x.*
              from b1 z
              left join vdiscover.vmexists y on y.last_change=z.last_change
              left join vdiscover.vminfo x on x.id = y.vminfo_id
              where y.exist_status = true and x.vm_id = z.vm_id
           ),
    b3  as (select z.last_change,
                   z.vm_id,
                   x.server_id,
                   x.name,
                   x.vmpathname,
                   z.hostname,
                   z.ipaddress,
                   z.numcpus,
                   z.memory_size,
                   z.virtual_disks,
                   z.template,
                   z.guestos_id,
                   z.guestid_id,
                   z.vmwaretools_id,
                   case
                      when z.guestos_id is null and z.guestid_id is null then false
                      else true
                   end powered_on
              from b2 z
              left join vdiscover.vms x on x.id = z.vm_id
            )
    select * from b3;



$_$;


ALTER FUNCTION vdiscover.vm_info(scan_time timestamp with time zone) OWNER TO postgres;

--
-- Name: vmdetails(character varying, timestamp with time zone); Type: FUNCTION; Schema: vdiscover; Owner: postgres
--

CREATE FUNCTION vmdetails(vm character varying, tm timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE(vm_id bigint, vmname character varying, hostname character varying, ipaddress character varying, category character varying, "parent type" character varying, parent character varying, server character varying, vcenter character varying)
    LANGUAGE sql
    AS $_$

  with
  
  args as (select trim(both ' ' from $1) vm, scan_id, scan_time from vdiscover.getscan($2)),
  vms  as (select * from vdiscover.vm_info((select scan_time from args)))

     select z.vm_id, 
           y.name vmname,
           z.hostname,
           z.ipaddress,
           v.name category,
           s.name "parent type",
           t.name "parent",
           x.address "server", 
           x.name vcenter 
      from vms z
      cross join args
      LEFT JOIN vdiscover.vms y on y.id = z.vm_id
      left join vdiscover."esx-servers" x on x.id = y.server_id
      left join vdiscover.vmcategory w on w.vm_id = z.vm_id
      left join vdiscover.vmcategory_types v on v.id = w.vmcategory_type_id
      left join vdiscover.vdiscovery u on u.vobject_type_id in (select id from vdiscover.vobject_types where name = 'VM') and u.name = y.name and u.server_id = y.server_id
      left join vdiscover.vdiscovery t on t.id = u.parent_id and t.server_id = y.server_id
      left join vdiscover.vobject_types s on s.id = t.vobject_type_id
     where z.ipaddress = args.vm or z.hostname ~* args.vm or y.name ~* args.vm;
  

$_$;


ALTER FUNCTION vdiscover.vmdetails(vm character varying, tm timestamp with time zone) OWNER TO postgres;

SET search_path = wscommands, pg_catalog;

--
-- Name: getfield(text, text, text, text); Type: FUNCTION; Schema: wscommands; Owner: postgres
--

CREATE FUNCTION getfield(workspace text, host text, stream text, usr text) RETURNS text
    LANGUAGE sql
    AS $_$
 SELECT CASE
        WHEN $2 ~* '^ARTS-Client-2' THEN 'gaoh1'
  WHEN $2 ~* '^c4dev-KH-bureea2' THEN 'bureea'
  WHEN $2 ~* '^c4dev-kh-dragup2' THEN 'dragup1'
  WHEN $2 ~* '^c4dev-KH-galinr2' THEN 'galinr'
  WHEN $2 ~* '^c4dev-kh-golovi' THEN 'golovi1'
  WHEN $2 ~* '^c4dev-kh-krived2' THEN 'krived'
  WHEN $2 ~* '^c4dev-KH-kovals' THEN 'kovals1'
  WHEN $2 ~* '^c4dev-KH-medves1' THEN 'medves'
  WHEN $2 ~* '^c4dev-KH-petroa' THEN 'petroa5'
  WHEN $2 ~* '^c4dev-kh.$' AND $1 IS NULL AND $3 IS NULL THEN $4
        WHEN ($2 ~* '^csx2-s11-build' OR $2 ~* '^csx2-home') AND $1 IS NULL AND $3 IS NULL THEN (
           SELECT CASE 
                  WHEN $4 ~* '^jcaisse' THEN 'caissj'
                  WHEN $4 ~* '^chris' THEN 'dionc'
                  WHEN $4 ~* '^lchen' THEN 'chenl22'
                  WHEN $4 ~* '^vmayatskikh' THEN 'mayatv'
                  WHEN $4 ~* '^msimonov' THEN 'simonm4'
                  WHEN $4 ~* '^dkrivenok' THEN 'krived'
                  WHEN $4 ~* '^bbell' THEN 'bellro'
                  ELSE 'csxtest'
                  END )
        WHEN $2 ~* '^c4dev-KH-kb' AND $1 IS NULL AND $3 IS NULL THEN $4
        WHEN $2 ~* '^c4dev-KH-kb2' AND $1 IS NULL AND $3 IS NULL THEN $4
  WHEN $2 ~* '^ea\-poc\-' THEN $4
  WHEN $2 ~* '^jacque-kh-1' THEN 'jacque'
  WHEN $3 ~* '^jochen-dev-temp' THEN 'desmej'
        WHEN $2 ~* '^khawk-dev-ashj' THEN 'ashj1'
  WHEN $2 ~* '^khawk-dev-barrek3' THEN 'barrek1'
  WHEN $2 ~* '^khawk-dev-bretop1' THEN 'bretop'
        WHEN $2 ~* '^khawk-dev-brittm' THEN 'brittm1'
  WHEN $2 ~* '^khawk-dev-cardim' THEN 'caridm'
        WHEN $2 ~* '^khawk-dev-caridm2' THEN 'caridm'
  WHEN $2 ~* '^khawk-dev-godboc2' THEN 'godboc1'
  WHEN $2 ~* '^khawk-dev-jblaney1' THEN 'jblaney'
  WHEN $2 ~* '^khawk-dev-kophen1' THEN 'kophen'
  WHEN $2 ~* '^khawk-dev-mccork' THEN 'mccork2'
  WHEN $2 ~* '^khawk-dev-miaot' THEN 'miaot1'
  WHEN $2 ~* '^khawk-dev-mvartere2' THEN 'mvartere'
  WHEN $2 ~* '^khawk-dev-ngt' THEN 'ngt1'
  WHEN $2 ~* '^khawk-dev-petroa' THEN 'petroa5'
  WHEN $2 ~* '^khawk-dev-ShajeP1' THEN 'shajep'
  WHEN $2 ~* '^khawk-karajl2' THEN 'karajl'
        WHEN $2 ~* '^khdev-uinfra-a' THEN 'yarova1'
        WHEN $2 ~* '^khawk-uniperf' AND $1 IS NULL AND $3 IS NULL THEN $4
  WHEN $2 ~* '^linux-mjc2' THEN 'schafg'
  WHEN $2 ~* '^linux-mjc3' THEN 'caridm'
  WHEN $2 ~* '^morph-cohenl' THEN 'cohenl5'
  WHEN $2 ~* '^pulusd-kh-1' THEN 'pulusd'
        WHEN $2 ~* '^rtpur1' AND $1 IS NULL AND $3 IS NULL THEN (
           SELECT CASE 
                  WHEN $4 ~* '^root' THEN 'deanr'
                  WHEN $4 ~* '^c4dev' THEN 'deanr'
                  ELSE $4
                  END )
        WHEN $2 ~* '^vm.+c4dev' AND $1 IS NULL AND $3 IS NULL THEN (
           SELECT CASE 
                  WHEN $4 ~* '^bmo' THEN 'moqueb'
                  WHEN $4 ~* '^cal-proj' THEN 'kappso'
                  WHEN $4 ~* '^eco' THEN 'copete'
                  WHEN $4 ~* '^ede' THEN 'dequie'
                  WHEN $4 ~* '^dga' THEN 'garded'
                  WHEN $4 ~* '^fred' THEN 'cornif'
                  WHEN $4 ~* '^fro' THEN 'rochef'
                  WHEN $4 ~* '^jdo' THEN 'dornij'
                  WHEN $4 ~* '^jlr' THEN 'rochej'
                  WHEN $4 ~* '^luc' THEN 'vanbrl'
                  WHEN $4 ~* '^pdo' THEN 'donetp'
                  WHEN $4 ~* '^pro' THEN 'roncop'
                  WHEN $4 ~* '^rma' THEN 'mantcr'
                  WHEN $4 ~* '^usa' THEN 'jacque'
                  ELSE $4
                  END )
        WHEN $4 ~* '^bbell' THEN 'bellro'
        WHEN $1 IS NOT NULL AND LENGTH(TRIM($1)) > 0 THEN wscommands.getusername($1)
        WHEN $2 IS NOT NULL AND LENGTH(TRIM($2)) > 0 THEN wscommands.getusername($2)
        WHEN $3 IS NOT NULL AND LENGTH(TRIM($3)) > 0 THEN wscommands.getusername($3)
        WHEN $4 != 'root' AND $4 != 'c4dev' THEN $4
        END;
$_$;


ALTER FUNCTION wscommands.getfield(workspace text, host text, stream text, usr text) OWNER TO postgres;

--
-- Name: getusername(text); Type: FUNCTION; Schema: wscommands; Owner: postgres
--

CREATE FUNCTION getusername(workspace text) RETURNS text
    LANGUAGE sql
    AS $_$
 SELECT CASE
        WHEN $1 ~* '^khawk(\-|\_)dev(\-|\_)' THEN regexp_replace(SUBSTRING($1 from 11), '[\-\_].+$', '')
        WHEN $1 ~* '^c4dev(-|\_)kh(-|\_)' THEN regexp_replace(SUBSTRING($1 from 10), '[\-\_].+$', '')
        WHEN $1 ~* '^rtp.*morph.$' THEN regexp_replace($1, '^rtp(.*)morph.$', '\1')
        WHEN $1 ~* '^rtp.*kh.$' THEN LOWER(regexp_replace($1, '^rtp(.*)kh.$', '\1'))
        ELSE regexp_replace($1, '.+[\-\_]', '', 'g')
        END;
$_$;


ALTER FUNCTION wscommands.getusername(workspace text) OWNER TO postgres;

SET search_path = "PIE", pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: ANT-AR-Escalation; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE "ANT-AR-Escalation" (
    "Entry Id" bigint,
    "Priority" character varying,
    "Major Area" character varying,
    "Open Days" integer
);


ALTER TABLE "ANT-AR-Escalation" OWNER TO postgres;

--
-- Name: COLUMN "ANT-AR-Escalation"."Entry Id"; Type: COMMENT; Schema: PIE; Owner: postgres
--

COMMENT ON COLUMN "ANT-AR-Escalation"."Entry Id" IS 'Remedy ID';


--
-- Name: AR propagaton; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE "AR propagaton" (
    "Entry Id" character varying,
    "Major Area" character varying,
    "Promote Author" character varying,
    "Product Release" character varying
);


ALTER TABLE "AR propagaton" OWNER TO postgres;

--
-- Name: TABLE "AR propagaton"; Type: COMMENT; Schema: PIE; Owner: postgres
--

COMMENT ON TABLE "AR propagaton" IS 'the AR candicate left that may need to be propagated to Unity stream.  AR propagation is forward. The only destination is apps-cs now.  The sources are: lnbplus, vvoltp, bearcat, kh+sp2, Rocikes';


--
-- Name: Escape_Analysis; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE "Escape_Analysis" (
    "Analysis Date" date,
    "Stream" character varying,
    "Stream Locked" character varying,
    "Analysis Collected By" character varying,
    "Analysis Provided By" character varying,
    "Process Affected" character varying,
    "Analysis Notes" character varying,
    "Transactions" character varying,
    "Recommendations" character varying
);


ALTER TABLE "Escape_Analysis" OWNER TO postgres;

--
-- Name: Promotion_delay_files; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE "Promotion_delay_files" (
    "FileID" integer,
    "EID" bigint,
    "FileName" character varying,
    "Parent" character varying,
    "Child" character varying,
    "ParentTime" bigint,
    "ChildTime" bigint,
    "Summary Record" integer,
    "RealVer" character varying,
    "Delay" real
);


ALTER TABLE "Promotion_delay_files" OWNER TO postgres;

--
-- Name: TABLE "Promotion_delay_files"; Type: COMMENT; Schema: PIE; Owner: postgres
--

COMMENT ON TABLE "Promotion_delay_files" IS 'raw data of  the delay of files  files on each hop from check-in to first stream to release stream in about last two weeks timeframe';


--
-- Name: COLUMN "Promotion_delay_files"."Delay"; Type: COMMENT; Schema: PIE; Owner: postgres
--

COMMENT ON COLUMN "Promotion_delay_files"."Delay" IS 'in days';


--
-- Name: Promotion_delay_streams; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE "Promotion_delay_streams" (
    "Delivery Streams" character varying,
    "Count of files" integer,
    "Sum of Delay of DeliveredToTopStream" real,
    "Delay of DeliveredToTopStream" real,
    "Delay from Integration Stream to DeliveredToTopStream" real
);


ALTER TABLE "Promotion_delay_streams" OWNER TO postgres;

--
-- Name: TABLE "Promotion_delay_streams"; Type: COMMENT; Schema: PIE; Owner: postgres
--

COMMENT ON TABLE "Promotion_delay_streams" IS 'based on the streams that made delivery and the files reached release stream (-int) in about last two weeks timeframe';


--
-- Name: COLUMN "Promotion_delay_streams"."Sum of Delay of DeliveredToTopStream"; Type: COMMENT; Schema: PIE; Owner: postgres
--

COMMENT ON COLUMN "Promotion_delay_streams"."Sum of Delay of DeliveredToTopStream" IS 'sum of average days take all the files in the delivery stream making to top release (-int) stream. now queary based on last two week timeframe';


--
-- Name: COLUMN "Promotion_delay_streams"."Delay of DeliveredToTopStream"; Type: COMMENT; Schema: PIE; Owner: postgres
--

COMMENT ON COLUMN "Promotion_delay_streams"."Delay of DeliveredToTopStream" IS ' average days take all a files in the delivery stream making to top release (-int) stream from checkin to accurev. now queary based on last two week timeframe';


--
-- Name: COLUMN "Promotion_delay_streams"."Delay from Integration Stream to DeliveredToTopStream"; Type: COMMENT; Schema: PIE; Owner: postgres
--

COMMENT ON COLUMN "Promotion_delay_streams"."Delay from Integration Stream to DeliveredToTopStream" IS 'average days take all a files in the delivery stream making to top release (-int) stream from integration stream. now queary based on last two week timeframe';


--
-- Name: error_report; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE error_report (
    "time" timestamp without time zone,
    uid character varying,
    failure character varying,
    stream character varying,
    fail_type character varying,
    ar_number bigint,
    offending_txn bigint,
    promoted_by character varying,
    is_reverted integer,
    is_stream_delivery integer,
    "revertTxn" bigint,
    failure_date timestamp without time zone,
    resolution_date timestamp without time zone
);


ALTER TABLE error_report OWNER TO postgres;

--
-- Name: COLUMN error_report."time"; Type: COMMENT; Schema: PIE; Owner: postgres
--

COMMENT ON COLUMN error_report."time" IS 'the time that when the issue is logged by error_report engine';


--
-- Name: streamlock_stat; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE streamlock_stat (
    "Lock_time" timestamp without time zone,
    "Open_time" timestamp without time zone,
    "Stream" character varying,
    "Stream, Lock_duration(hr)" real,
    "Lock_reason" character varying,
    "AR" bigint,
    txn bigint,
    "Root_cause" character varying
);


ALTER TABLE streamlock_stat OWNER TO postgres;

SET search_path = accurev, pg_catalog;

--
-- Name: promotion_fileversions; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE promotion_fileversions (
    t_id bigint NOT NULL,
    path character varying,
    eid bigint,
    vstream bigint,
    vvers integer,
    rstream bigint,
    rvers integer,
    elem_type character varying,
    isdir boolean
);


ALTER TABLE promotion_fileversions OWNER TO postgres;

--
-- Name: TABLE promotion_fileversions; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON TABLE promotion_fileversions IS 'fileversion info associated with a promote transaction';


--
-- Name: COLUMN promotion_fileversions.t_id; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_fileversions.t_id IS 'accurev transaction number
also index into any other table using transactions';


--
-- Name: COLUMN promotion_fileversions.path; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_fileversions.path IS 'actual file name';


--
-- Name: COLUMN promotion_fileversions.eid; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_fileversions.eid IS 'unique identifier used by Accurev for this file
(evil twins have same file name but different ''eid'')';


--
-- Name: COLUMN promotion_fileversions.vstream; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_fileversions.vstream IS 'target (or virtual) stream that the file exists in as it is promoted up the tree.
This represents an index into the stream_data table (streamnumber column)';


--
-- Name: COLUMN promotion_fileversions.vvers; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_fileversions.vvers IS 'version of file in target stream';


--
-- Name: COLUMN promotion_fileversions.rstream; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_fileversions.rstream IS 'source (or real) stream/workspace that the file came from when it was initially checked in.
This represents an index into the stream_data table (streamnumber column)';


--
-- Name: COLUMN promotion_fileversions.rvers; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_fileversions.rvers IS 'version of file in original (real) stream/workspace';


--
-- Name: stream_daily; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE stream_daily (
    name character varying NOT NULL,
    basis character varying,
    basisstreamnumber bigint,
    depotname character varying NOT NULL,
    streamnumber bigint NOT NULL,
    isdynamic boolean DEFAULT false,
    type character varying NOT NULL,
    starttime bigint NOT NULL,
    hidden boolean DEFAULT false,
    hasproperties boolean DEFAULT false
);


ALTER TABLE stream_daily OWNER TO postgres;

--
-- Name: transactions; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE transactions (
    t_id bigint NOT NULL,
    t_type character varying,
    t_time bigint,
    t_user character varying
);


ALTER TABLE transactions OWNER TO postgres;

--
-- Name: TABLE transactions; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON TABLE transactions IS 'base data about accurev transactions';


--
-- Name: COLUMN transactions.t_id; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN transactions.t_id IS 'accurev transaction number
also index into any other table using transactions';


--
-- Name: COLUMN transactions.t_type; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN transactions.t_type IS 'transaction type ''promote'' or ''chstream''';


--
-- Name: COLUMN transactions.t_time; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN transactions.t_time IS 'time of transaction (secs since 1/1/1970)';


--
-- Name: COLUMN transactions.t_user; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN transactions.t_user IS 'user who performed transaction
use as a lookup into tables in empdata schema';


SET search_path = cateams, pg_catalog;

--
-- Name: rally_info; Type: TABLE; Schema: cateams; Owner: postgres
--

CREATE TABLE rally_info (
    ca character varying,
    project character varying,
    rally_name character varying,
    email character varying NOT NULL,
    employee_id bigint NOT NULL,
    ntlogin character varying NOT NULL
);


ALTER TABLE rally_info OWNER TO postgres;

SET search_path = "PIE", pg_catalog;

--
-- Name: lock_user_ca; Type: VIEW; Schema: PIE; Owner: postgres
--

CREATE VIEW lock_user_ca AS
 SELECT DISTINCT ON (ss1.txn) ss1."Lock_time",
    ss1.txn,
    ss1."AR",
    ss1."Root_cause",
    at1.t_user,
    ri1.rally_name,
    ri1.ca,
    ri1.project,
    sd1.name,
    sd1.basis
   FROM streamlock_stat ss1,
    accurev.transactions at1,
    cateams.rally_info ri1,
    accurev.promotion_fileversions pf1,
    accurev.stream_daily sd1
  WHERE (((ss1."Lock_reason")::text = 'p0'::text) AND (ss1.txn <> 0) AND ((ss1."Stream")::text ~~ '%upc-apps-cs%'::text) AND (ss1.txn = at1.t_id) AND (pf1.t_id = at1.t_id) AND (pf1.rstream = sd1.streamnumber) AND ((at1.t_user)::text = (ri1.ntlogin)::text) AND (ss1."Open_time" >= '2014-09-01 00:00:00'::timestamp without time zone));


ALTER TABLE lock_user_ca OWNER TO postgres;

--
-- Name: promo_req; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE promo_req (
    id uuid NOT NULL,
    source_stream character varying NOT NULL,
    dest_stream character varying DEFAULT 'apps-cs'::character varying NOT NULL,
    submitted_date timestamp without time zone DEFAULT now() NOT NULL,
    submitted_by character varying NOT NULL,
    change_summary text NOT NULL,
    test_description text NOT NULL,
    is_disruptive character(1) NOT NULL,
    test_set_links character varying[],
    status character varying DEFAULT 'requested'::character varying NOT NULL
);


ALTER TABLE promo_req OWNER TO postgres;

--
-- Name: revert_lock_user_ca; Type: VIEW; Schema: PIE; Owner: postgres
--

CREATE VIEW revert_lock_user_ca AS
 SELECT DISTINCT ON (er1.offending_txn) er1.failure_date,
    er1.offending_txn,
    er1.stream,
    at1.t_user,
    ri1.rally_name,
    ri1.ca,
    ri1.project,
    'R'::text AS type,
        CASE
            WHEN (er1.offending_txn IN ( SELECT ss1.txn
               FROM streamlock_stat ss1)) THEN 'Y'::text
            ELSE 'N'::text
        END AS stream_lock
   FROM error_report er1,
    accurev.transactions at1,
    cateams.rally_info ri1,
    accurev.promotion_fileversions pf1,
    accurev.stream_daily sd1
  WHERE ((er1.is_reverted = 1) AND ((er1.stream)::text ~~ '%upc-apps-cs%'::text) AND (er1.failure_date >= '2015-03-30 00:00:00'::timestamp without time zone) AND (er1.offending_txn = at1.t_id) AND (pf1.t_id = at1.t_id) AND (pf1.rstream = sd1.streamnumber) AND ((at1.t_user)::text = (ri1.ntlogin)::text))
UNION
 SELECT DISTINCT ON (ss1.txn) ss1."Lock_time" AS failure_date,
    ss1.txn AS offending_txn,
    ss1."Stream" AS stream,
    at1.t_user,
    ri1.rally_name,
    ri1.ca,
    ri1.project,
    'L'::text AS type,
    'Y'::text AS stream_lock
   FROM streamlock_stat ss1,
    error_report er1,
    accurev.transactions at1,
    cateams.rally_info ri1,
    accurev.promotion_fileversions pf1,
    accurev.stream_daily sd1
  WHERE (((ss1."Lock_reason")::text = 'p0'::text) AND (NOT (ss1.txn IN ( SELECT er1_1.offending_txn
           FROM error_report er1_1))) AND (ss1.txn <> 0) AND ((ss1."Stream")::text ~~ '%upc-apps-cs%'::text) AND (ss1.txn = at1.t_id) AND (pf1.t_id = at1.t_id) AND (pf1.rstream = sd1.streamnumber) AND ((at1.t_user)::text = (ri1.ntlogin)::text) AND (ss1."Open_time" >= '2014-09-01 00:00:00'::timestamp without time zone))
  ORDER BY 1;


ALTER TABLE revert_lock_user_ca OWNER TO postgres;

--
-- Name: revert_user_ca; Type: VIEW; Schema: PIE; Owner: postgres
--

CREATE VIEW revert_user_ca AS
 SELECT DISTINCT ON (er1.offending_txn) er1.failure_date,
    er1.offending_txn,
    er1.stream,
    at1.t_user,
    ri1.rally_name,
    ri1.ca,
    ri1.project
   FROM error_report er1,
    accurev.transactions at1,
    cateams.rally_info ri1,
    accurev.promotion_fileversions pf1,
    accurev.stream_daily sd1
  WHERE ((er1.is_reverted = 1) AND ((er1.stream)::text ~~ '%upc-apps-cs%'::text) AND (er1.failure_date >= '2015-03-30 00:00:00'::timestamp without time zone) AND (er1.offending_txn = at1.t_id) AND (pf1.t_id = at1.t_id) AND (pf1.rstream = sd1.streamnumber) AND ((at1.t_user)::text = (ri1.ntlogin)::text));


ALTER TABLE revert_user_ca OWNER TO postgres;

--
-- Name: stream_health_summary; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE stream_health_summary (
    date date,
    open real,
    close_p0 real,
    close_infra real,
    close_plan real,
    nonp_issue integer,
    pro_issue integer,
    promotions integer,
    promoted_files integer
);


ALTER TABLE stream_health_summary OWNER TO postgres;

--
-- Name: stream_promotion_delivery_streams; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE stream_promotion_delivery_streams (
    "DeliveryStream" character varying,
    "transactionCount" integer,
    "totalFile#" integer,
    "AverageTransFile#" integer,
    "IntegrationStream" character varying
);


ALTER TABLE stream_promotion_delivery_streams OWNER TO postgres;

--
-- Name: stream_promotion_details; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE stream_promotion_details (
    "Date" date,
    "transaction#" bigint,
    "file#" integer,
    "promotedFrom" character varying,
    "user" character varying,
    "IntegrationStream" character varying
);


ALTER TABLE stream_promotion_details OWNER TO postgres;

--
-- Name: stream_promotion_usr; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE stream_promotion_usr (
    "User" character varying,
    "UserName" character varying,
    "UserTransaction#" integer,
    "UserWorkspace" character varying,
    "UserWorkspaceTransaction#" integer,
    "IntegrationStream" character varying
);


ALTER TABLE stream_promotion_usr OWNER TO postgres;

--
-- Name: stream_team_lead_map; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE stream_team_lead_map (
    "Product" character varying,
    "Major Area" character varying,
    "Product Area" character varying,
    "Default Assignee" character varying,
    "DPO" character varying,
    "CA leaders/SPO" character varying,
    "CA Team" character varying,
    "ThunderBird RPO" character varying,
    "Falcon RPO" character varying
);


ALTER TABLE stream_team_lead_map OWNER TO postgres;

--
-- Name: streamlock_operation; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE streamlock_operation (
    "timestamp" timestamp without time zone,
    uid character varying,
    operation character varying,
    stream character varying,
    oper_reason character varying,
    root_cause character varying
);


ALTER TABLE streamlock_operation OWNER TO postgres;

--
-- Name: triage_accurecy; Type: TABLE; Schema: PIE; Owner: postgres
--

CREATE TABLE triage_accurecy (
    "PSI-Iteration" character varying,
    "IterationDate" character varying,
    hit integer,
    hit_rate_in_percentage numeric(4,2),
    miss integer,
    miss_rate_in_percentage numeric(4,2),
    total integer,
    CONSTRAINT chk_hit_rate_in_percentage CHECK (((hit_rate_in_percentage >= (0)::numeric) AND (hit_rate_in_percentage <= (100)::numeric))),
    CONSTRAINT chk_miss_rate_in_percentage CHECK (((miss_rate_in_percentage >= (0)::numeric) AND (miss_rate_in_percentage <= (100)::numeric)))
);


ALTER TABLE triage_accurecy OWNER TO postgres;

SET search_path = accurev, pg_catalog;

--
-- Name: apps_acignores; Type: VIEW; Schema: accurev; Owner: postgres
--

CREATE VIEW apps_acignores AS
 SELECT count(*) AS cnt,
    ((date(to_timestamp((y.t_time)::double precision)) - (date_part('dow'::text, to_timestamp((y.t_time)::double precision)) * '1 day'::interval)) + '6 days 23:59:59.99'::interval) AS week
   FROM (promotion_fileversions z
     LEFT JOIN transactions y ON ((y.t_id = z.t_id)))
  WHERE (((z.path)::text ~* '/\.acignore$'::text) AND (z.vstream IN ( SELECT allchildstreams.streamnumber
           FROM allchildstreams('upc-apps-cs'::text) allchildstreams(level, streamnumber, basisstreamnumber, type))))
  GROUP BY ((date(to_timestamp((y.t_time)::double precision)) - (date_part('dow'::text, to_timestamp((y.t_time)::double precision)) * '1 day'::interval)) + '6 days 23:59:59.99'::interval)
  ORDER BY ((date(to_timestamp((y.t_time)::double precision)) - (date_part('dow'::text, to_timestamp((y.t_time)::double precision)) * '1 day'::interval)) + '6 days 23:59:59.99'::interval);


ALTER TABLE apps_acignores OWNER TO postgres;

--
-- Name: apps_dailycheckins; Type: VIEW; Schema: accurev; Owner: postgres
--

CREATE VIEW apps_dailycheckins AS
 SELECT dailycheckins."Date",
    dailycheckins."Total_Check_ins"
   FROM dailycheckins('upc-apps-cs'::text) dailycheckins("Date", "Total_Check_ins");


ALTER TABLE apps_dailycheckins OWNER TO postgres;

--
-- Name: apps_developers; Type: VIEW; Schema: accurev; Owner: postgres
--

CREATE VIEW apps_developers AS
 SELECT developers.ntlogin
   FROM developers('upc-apps-cs'::text) developers(ntlogin)
  ORDER BY developers.ntlogin;


ALTER TABLE apps_developers OWNER TO postgres;

--
-- Name: apps_substreams; Type: VIEW; Schema: accurev; Owner: postgres
--

CREATE VIEW apps_substreams AS
 SELECT childstreams.name,
    childstreams.basis,
    childstreams.basisstreamnumber,
    childstreams.depotname,
    childstreams.streamnumber,
    childstreams.isdynamic,
    childstreams.type,
    childstreams.starttime,
    childstreams.hidden,
    childstreams.hasproperties,
    childstreams.level
   FROM childstreams('upc-apps-cs'::text) childstreams(name, basis, basisstreamnumber, depotname, streamnumber, isdynamic, type, starttime, hidden, hasproperties, level);


ALTER TABLE apps_substreams OWNER TO postgres;

--
-- Name: apps_weeklycheckins; Type: VIEW; Schema: accurev; Owner: postgres
--

CREATE VIEW apps_weeklycheckins AS
 SELECT weeklycheckins."Week_Number",
    weeklycheckins."From_Date",
    weeklycheckins."To_Date",
    weeklycheckins."Total_Check_ins"
   FROM weeklycheckins('upc-apps-cs'::text) weeklycheckins("Week_Number", "From_Date", "To_Date", "Total_Check_ins");


ALTER TABLE apps_weeklycheckins OWNER TO postgres;

--
-- Name: builders; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE builders (
    user_name character varying
);


ALTER TABLE builders OWNER TO postgres;

--
-- Name: default_group; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE default_group (
    stream bigint,
    name text,
    eid bigint,
    version bigint,
    "timestamp" bigint,
    default_group boolean
);


ALTER TABLE default_group OWNER TO postgres;

--
-- Name: depot_id; Type: SEQUENCE; Schema: accurev; Owner: postgres
--

CREATE SEQUENCE depot_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE depot_id OWNER TO postgres;

--
-- Name: depots; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE depots (
    id bigint DEFAULT nextval('depot_id'::regclass) NOT NULL,
    depotname character varying NOT NULL
);


ALTER TABLE depots OWNER TO postgres;

--
-- Name: domain_streams; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE domain_streams (
    stream character varying,
    owner character varying,
    url character varying,
    build_infra character varying,
    comment character varying,
    ntlogin character varying
);


ALTER TABLE domain_streams OWNER TO postgres;

--
-- Name: elem_types_id; Type: SEQUENCE; Schema: accurev; Owner: postgres
--

CREATE SEQUENCE elem_types_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE elem_types_id OWNER TO postgres;

--
-- Name: elem_types; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE elem_types (
    id bigint DEFAULT nextval('elem_types_id'::regclass) NOT NULL,
    type_name character varying NOT NULL
);


ALTER TABLE elem_types OWNER TO postgres;

--
-- Name: filter_comments_id; Type: SEQUENCE; Schema: accurev; Owner: postgres
--

CREATE SEQUENCE filter_comments_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE filter_comments_id OWNER TO postgres;

--
-- Name: filter_comments; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE filter_comments (
    id bigint DEFAULT nextval('filter_comments_id'::regclass) NOT NULL,
    last_transaction bigint DEFAULT 0 NOT NULL,
    comment character varying,
    email character varying,
    active boolean DEFAULT true NOT NULL,
    report_title character varying
);


ALTER TABLE filter_comments OWNER TO postgres;

--
-- Name: TABLE filter_comments; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON TABLE filter_comments IS 'top level filter definitions, actual filters are defined separate records of in ''filter_data'' table';


--
-- Name: COLUMN filter_comments.id; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN filter_comments.id IS 'unique ID for each fiter';


--
-- Name: filter_data; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE filter_data (
    filter_comment_id bigint NOT NULL,
    file_match character varying,
    stream_match character varying,
    type_match bigint,
    file_exclude character varying,
    stream_exclude character varying,
    type_exclude bigint,
    ntlogin_match character varying,
    ntlogin_exclude character varying
);


ALTER TABLE filter_data OWNER TO postgres;

--
-- Name: TABLE filter_data; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON TABLE filter_data IS 'filter records  for each top level filter defined in accurev.filter_comments';


--
-- Name: COLUMN filter_data.filter_comment_id; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN filter_data.filter_comment_id IS 'lookup into the filter_comments';


--
-- Name: COLUMN filter_data.file_match; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN filter_data.file_match IS 'regex pattern match for the "path" in accurev.promotion_fileversion';


--
-- Name: COLUMN filter_data.stream_match; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN filter_data.stream_match IS 'regex pattern match for the vstream name in accurev.promotion_fileversion';


--
-- Name: COLUMN filter_data.type_match; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN filter_data.type_match IS 'index into accurev.elem_types
defines the match on the elem_type filed in accurev.fileversions';


--
-- Name: COLUMN filter_data.file_exclude; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN filter_data.file_exclude IS 'regex pattern exclusion for the "path" in accurev.promotion_fileversion';


--
-- Name: COLUMN filter_data.stream_exclude; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN filter_data.stream_exclude IS 'regex pattern exclusion for the vstream name in accurev.promotion_fileversion';


--
-- Name: COLUMN filter_data.type_exclude; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN filter_data.type_exclude IS 'index into accurev.elem_types...';


--
-- Name: COLUMN filter_data.ntlogin_match; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN filter_data.ntlogin_match IS 'regex pattern match for the user in accurev.promotion_fileversion';


--
-- Name: COLUMN filter_data.ntlogin_exclude; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN filter_data.ntlogin_exclude IS 'regex pattern exclusion for the user in accurev.promotion_fileversion';


--
-- Name: filtertype_seq; Type: SEQUENCE; Schema: accurev; Owner: postgres
--

CREATE SEQUENCE filtertype_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE filtertype_seq OWNER TO postgres;

--
-- Name: initial_checkins; Type: VIEW; Schema: accurev; Owner: postgres
--

CREATE VIEW initial_checkins AS
 SELECT DISTINCT z.t_id,
    z.t_type,
    z.t_time,
    z.t_user,
    y.path,
    y.eid,
    y.vstream,
    y.vvers,
    y.rstream,
    y.rvers,
    y.elem_type,
    y.isdir,
    x.name,
    x.basis,
    x.type,
    x.hidden
   FROM (((transactions z
     LEFT JOIN promotion_fileversions y ON ((y.t_id = z.t_id)))
     LEFT JOIN stream_daily x ON ((x.streamnumber = y.rstream)))
     LEFT JOIN stream_daily w ON ((w.streamnumber = y.vstream)))
  WHERE ((x.basisstreamnumber = w.streamnumber) AND ((z.t_type)::text = 'promote'::text));


ALTER TABLE initial_checkins OWNER TO postgres;

--
-- Name: promotion_comments; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE promotion_comments (
    t_id bigint NOT NULL,
    t_comment_line integer NOT NULL,
    t_comment character varying
);


ALTER TABLE promotion_comments OWNER TO postgres;

--
-- Name: TABLE promotion_comments; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON TABLE promotion_comments IS 'comments associated with a promote transaction';


--
-- Name: COLUMN promotion_comments.t_id; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_comments.t_id IS 'accurev transaction number
also index into any other table using transactions';


--
-- Name: promotion_issues; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE promotion_issues (
    t_id bigint NOT NULL,
    issuenum bigint NOT NULL,
    remedy_id bigint,
    thirdparty character varying
);


ALTER TABLE promotion_issues OWNER TO postgres;

--
-- Name: TABLE promotion_issues; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON TABLE promotion_issues IS 'issues info associated with a protoe transaction';


--
-- Name: COLUMN promotion_issues.t_id; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_issues.t_id IS 'accurev transaction number
also index into any other table using transactions';


--
-- Name: COLUMN promotion_issues.issuenum; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_issues.issuenum IS 'accurev issue number associated with promotion';


--
-- Name: COLUMN promotion_issues.remedy_id; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_issues.remedy_id IS 'remedy id associated with promotion';


--
-- Name: COLUMN promotion_issues.thirdparty; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN promotion_issues.thirdparty IS 'value of property in accurev which holds either AR# or BLD#';


--
-- Name: promotions_daily; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE promotions_daily (
    filter_id bigint,
    t_id bigint,
    t_time bigint,
    ntlogin character varying,
    stream character varying,
    domain_stream character varying,
    path character varying,
    vvers integer,
    comments character varying[]
);


ALTER TABLE promotions_daily OWNER TO postgres;

--
-- Name: rebase_info; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE rebase_info (
    t_id bigint NOT NULL,
    r_streamnumber bigint,
    r_basisstreamnumber bigint,
    r_time bigint,
    r_prevtime bigint
);


ALTER TABLE rebase_info OWNER TO postgres;

--
-- Name: TABLE rebase_info; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON TABLE rebase_info IS 'rebase info associated with a chstream transaction';


--
-- Name: COLUMN rebase_info.t_id; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN rebase_info.t_id IS 'accurev transaction number
also index into any other table using transactions';


--
-- Name: stream_history; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE stream_history (
    date date,
    name character varying NOT NULL,
    basis character varying,
    basisstreamnumber bigint,
    depotname character varying NOT NULL,
    streamnumber bigint,
    isdynamic boolean DEFAULT false,
    type character varying NOT NULL,
    starttime bigint NOT NULL,
    hidden boolean DEFAULT false,
    hasproperties boolean DEFAULT false
);


ALTER TABLE stream_history OWNER TO postgres;

--
-- Name: stream_meta; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE stream_meta (
    depot_id bigint NOT NULL,
    streamnumber bigint NOT NULL,
    branch_id integer
);


ALTER TABLE stream_meta OWNER TO postgres;

--
-- Name: t_usage; Type: VIEW; Schema: accurev; Owner: postgres
--

CREATE VIEW t_usage AS
 WITH a AS (
         SELECT transactions.t_id,
            public.endofweek(('1970-01-01 00:00:00'::timestamp without time zone + ((transactions.t_time || ' seconds'::text))::interval)) AS week
           FROM transactions
        ), b AS (
         SELECT max(a.t_id) AS transaction,
            a.week
           FROM a
          GROUP BY a.week
          ORDER BY a.week
        )
 SELECT b.transaction,
    b.week
   FROM b;


ALTER TABLE t_usage OWNER TO postgres;

--
-- Name: wspaces_daily; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE wspaces_daily (
    name character varying NOT NULL,
    hidden boolean DEFAULT false,
    storage character varying NOT NULL,
    host character varying NOT NULL,
    stream bigint,
    depot character varying NOT NULL,
    target_trans bigint NOT NULL,
    trans bigint NOT NULL,
    filemodtime bigint NOT NULL,
    type integer,
    eol integer,
    user_id integer,
    user_name character varying NOT NULL,
    iswindows boolean
);


ALTER TABLE wspaces_daily OWNER TO postgres;

--
-- Name: wspaces_depots; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE wspaces_depots (
    tm timestamp without time zone,
    date timestamp without time zone,
    week timestamp without time zone,
    data_class character varying NOT NULL,
    usdrel integer,
    usdac integer,
    utest2 integer,
    usdlab integer,
    ctt integer,
    upc integer,
    cdes integer,
    fbu integer,
    efact integer,
    fd integer,
    uip integer,
    total integer
);


ALTER TABLE wspaces_depots OWNER TO postgres;

--
-- Name: wspaces_history; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE wspaces_history (
    date date,
    name character varying NOT NULL,
    hidden boolean DEFAULT false,
    storage character varying NOT NULL,
    host character varying NOT NULL,
    stream bigint,
    depot character varying NOT NULL,
    target_trans bigint NOT NULL,
    trans bigint NOT NULL,
    filemodtime bigint NOT NULL,
    type integer,
    eol integer,
    user_id integer,
    user_name character varying NOT NULL,
    iswindows boolean
);


ALTER TABLE wspaces_history OWNER TO postgres;

--
-- Name: wspaces_summary; Type: TABLE; Schema: accurev; Owner: postgres
--

CREATE TABLE wspaces_summary (
    tm time with time zone,
    date timestamp without time zone,
    week timestamp without time zone,
    builders integer,
    depots integer,
    ldis_user_cnt integer,
    wdis_user_cnt integer,
    ldis_bldr_cnt integer,
    wdis_bldr_cnt integer,
    lact_user_cnt integer,
    wact_user_cnt integer,
    lact_bldr_cnt integer,
    wact_bldr_cnt integer,
    la270_user_cnt integer,
    wa270_user_cnt integer,
    la270_bldr_cnt integer,
    wa270_bldr_cnt integer,
    la180_user_cnt integer,
    wa180_user_cnt integer,
    la180_bldr_cnt integer,
    wa180_bldr_cnt integer,
    la90_user_cnt integer,
    wa90_user_cnt integer,
    la90_bldr_cnt integer,
    wa90_bldr_cnt integer,
    loos_user1_cnt integer,
    loos_user2_cnt integer,
    loos_user3_cnt integer,
    woos_user1_cnt integer,
    woos_user2_cnt integer,
    woos_user3_cnt integer,
    loos_bldr1_cnt integer,
    loos_bldr2_cnt integer,
    loos_bldr3_cnt integer,
    woos_bldr1_cnt integer,
    woos_bldr2_cnt integer,
    woos_bldr3_cn integer
);


ALTER TABLE wspaces_summary OWNER TO postgres;

--
-- Name: COLUMN wspaces_summary.builders; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.builders IS 'Count of the user_names which are used by automation';


--
-- Name: COLUMN wspaces_summary.depots; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.depots IS 'Count of the depots maintained in our AccuRev SCCS';


--
-- Name: COLUMN wspaces_summary.ldis_user_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.ldis_user_cnt IS 'Count of inactive (de-activated, hidden) linux workspaces belonging to users';


--
-- Name: COLUMN wspaces_summary.wdis_user_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.wdis_user_cnt IS 'Count of inactive (de-activated, hidden) windows workspaces belonging to users';


--
-- Name: COLUMN wspaces_summary.ldis_bldr_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.ldis_bldr_cnt IS 'Count of inactive (de-activated, hidden) linux workspaces belonging to automation';


--
-- Name: COLUMN wspaces_summary.wdis_bldr_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.wdis_bldr_cnt IS 'Count of inactive (de-activated, hidden) windows workspaces belonging to automation';


--
-- Name: COLUMN wspaces_summary.lact_user_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.lact_user_cnt IS 'Count of active linux workspaces belonging to users';


--
-- Name: COLUMN wspaces_summary.wact_user_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.wact_user_cnt IS 'Count of active windows workspaces belonging to users';


--
-- Name: COLUMN wspaces_summary.lact_bldr_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.lact_bldr_cnt IS 'Count of active linux workspaces belonging to automation';


--
-- Name: COLUMN wspaces_summary.wact_bldr_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.wact_bldr_cnt IS 'Count of active windows workspaces belonging to users';


--
-- Name: COLUMN wspaces_summary.la270_user_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.la270_user_cnt IS 'Count of active user linux workspaces which have not been accessed in the last 270 days';


--
-- Name: COLUMN wspaces_summary.wa270_user_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.wa270_user_cnt IS 'Count of active user windows workspaces which have not been accessed in the last 270 days';


--
-- Name: COLUMN wspaces_summary.la270_bldr_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.la270_bldr_cnt IS 'Count of active automation linux workspaces which have not been accessed in the last 270 days';


--
-- Name: COLUMN wspaces_summary.wa270_bldr_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.wa270_bldr_cnt IS 'Count of active automation windows workspaces which have not been accessed in the last 270 days';


--
-- Name: COLUMN wspaces_summary.la180_user_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.la180_user_cnt IS 'Count of active user linux workspaces which have not been accessed in the last180 days';


--
-- Name: COLUMN wspaces_summary.wa180_user_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.wa180_user_cnt IS 'Count of active user windows workspaces which have not been accessed in the last 180 days';


--
-- Name: COLUMN wspaces_summary.la180_bldr_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.la180_bldr_cnt IS 'Count of active automation linux workspaces which have not been accessed in the last 180 days';


--
-- Name: COLUMN wspaces_summary.wa180_bldr_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.wa180_bldr_cnt IS 'Count of active automation windows workspaces which have not been accessed in the last 180 days';


--
-- Name: COLUMN wspaces_summary.la90_user_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.la90_user_cnt IS 'Count of active user linux workspaces which have not been accessed in the last 90 days';


--
-- Name: COLUMN wspaces_summary.wa90_user_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.wa90_user_cnt IS 'Count of active user windows workspaces which have not been accessed in the last 90 days';


--
-- Name: COLUMN wspaces_summary.la90_bldr_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.la90_bldr_cnt IS 'Count of active automation linux workspaces which have not been accessed in the last 90 days';


--
-- Name: COLUMN wspaces_summary.wa90_bldr_cnt; Type: COMMENT; Schema: accurev; Owner: postgres
--

COMMENT ON COLUMN wspaces_summary.wa90_bldr_cnt IS 'Count of active automation windows workspaces which have not been accessed in the last 90 days';


SET search_path = audit_control, pg_catalog;

--
-- Name: accurev_ldap; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE accurev_ldap (
    distinguishedname character varying NOT NULL
);


ALTER TABLE accurev_ldap OWNER TO postgres;

--
-- Name: accurev_live; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE accurev_live (
    ntlogin character varying
);


ALTER TABLE accurev_live OWNER TO postgres;

--
-- Name: clearcase_block_ldap; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE clearcase_block_ldap (
    distinguishedname character varying NOT NULL
);


ALTER TABLE clearcase_block_ldap OWNER TO postgres;

--
-- Name: clearcase_block_live; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE clearcase_block_live (
    ntlogin character varying
);


ALTER TABLE clearcase_block_live OWNER TO postgres;

--
-- Name: clearcase_unisphere_ldap; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE clearcase_unisphere_ldap (
    distinguishedname character varying NOT NULL
);


ALTER TABLE clearcase_unisphere_ldap OWNER TO postgres;

--
-- Name: clearcase_unisphere_live; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE clearcase_unisphere_live (
    ntlogin character varying
);


ALTER TABLE clearcase_unisphere_live OWNER TO postgres;

--
-- Name: cvs_ldap; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE cvs_ldap (
    distinguishedname character varying NOT NULL
);


ALTER TABLE cvs_ldap OWNER TO postgres;

--
-- Name: cvs_live; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE cvs_live (
    ntlogin character varying
);


ALTER TABLE cvs_live OWNER TO postgres;

--
-- Name: distro_lists_id; Type: SEQUENCE; Schema: audit_control; Owner: postgres
--

CREATE SEQUENCE distro_lists_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE distro_lists_id OWNER TO postgres;

--
-- Name: distro_lists; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE distro_lists (
    id bigint DEFAULT nextval('distro_lists_id'::regclass) NOT NULL,
    ldap_list character varying NOT NULL,
    ldap_table_name regclass,
    friendly_name character varying,
    live_table_name regclass
);


ALTER TABLE distro_lists OWNER TO postgres;

--
-- Name: git_ldap; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE git_ldap (
    distinguishedname character varying NOT NULL
);


ALTER TABLE git_ldap OWNER TO postgres;

--
-- Name: git_live; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE git_live (
    ntlogin character varying
);


ALTER TABLE git_live OWNER TO postgres;

--
-- Name: service_accounts; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE service_accounts (
    ntlogin character varying
);


ALTER TABLE service_accounts OWNER TO postgres;

--
-- Name: svn_ldap; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE svn_ldap (
    distinguishedname character varying NOT NULL
);


ALTER TABLE svn_ldap OWNER TO postgres;

--
-- Name: svn_live; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE svn_live (
    ntlogin character varying
);


ALTER TABLE svn_live OWNER TO postgres;

--
-- Name: test_ldap; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE test_ldap (
    distinguishedname character varying NOT NULL
);


ALTER TABLE test_ldap OWNER TO postgres;

--
-- Name: test_live; Type: TABLE; Schema: audit_control; Owner: postgres
--

CREATE TABLE test_live (
    ntlogin character varying
);


ALTER TABLE test_live OWNER TO postgres;

SET search_path = buildlog, pg_catalog;

--
-- Name: baseresults_id; Type: SEQUENCE; Schema: buildlog; Owner: postgres
--

CREATE SEQUENCE baseresults_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE baseresults_id OWNER TO postgres;

--
-- Name: baseresults; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE baseresults (
    id bigint DEFAULT nextval('baseresults_id'::regclass) NOT NULL,
    tm timestamp without time zone,
    fault_class character varying,
    ibid character varying,
    "user" character varying,
    acuser character varying,
    host character varying,
    hostname character varying,
    ipaddr character varying,
    status integer,
    stream character varying,
    fault_component character varying,
    fault_msg character varying,
    fault_detail character varying,
    init_val character varying,
    pwd character varying,
    basis character varying,
    env_type character varying,
    native_env character varying,
    run_env character varying,
    workspace character varying,
    logerr character varying,
    logout character varying,
    log_subdir character varying,
    component character varying,
    component_outdir character varying
);


ALTER TABLE baseresults OWNER TO postgres;

--
-- Name: etlresults; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE etlresults (
    id bigint NOT NULL,
    build_class character varying,
    result character varying,
    ntid character varying,
    build_duration bigint,
    comp_count integer,
    arg_count integer,
    hour integer,
    date timestamp without time zone,
    week timestamp without time zone,
    prepare_duration bigint,
    prepare_count integer,
    build2_duration bigint,
    build2_count integer,
    package_duration bigint,
    package_count integer,
    ibid_calc character varying,
    m_id bigint NOT NULL,
    mask bigint
);


ALTER TABLE etlresults OWNER TO postgres;

--
-- Name: fault_class; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE fault_class (
    fault_class character varying NOT NULL,
    fault_category character varying
);


ALTER TABLE fault_class OWNER TO postgres;

--
-- Name: hosts_id; Type: SEQUENCE; Schema: buildlog; Owner: postgres
--

CREATE SEQUENCE hosts_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hosts_id OWNER TO postgres;

--
-- Name: hosts; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE hosts (
    host character varying NOT NULL,
    host_class character varying DEFAULT 'UNKNOWN'::character varying NOT NULL,
    ipaddr character varying,
    id bigint DEFAULT nextval('hosts_id'::regclass) NOT NULL
);


ALTER TABLE hosts OWNER TO postgres;

--
-- Name: ibidextended; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE ibidextended (
    id bigint,
    ibid character varying,
    site character varying,
    cloud character varying,
    director_ntlogin character varying,
    location character varying
);


ALTER TABLE ibidextended OWNER TO postgres;

--
-- Name: ibidresults; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE ibidresults (
    id bigint NOT NULL,
    endid bigint NOT NULL,
    ibid character varying,
    status integer,
    result character varying,
    fault_class character varying,
    start_tm timestamp without time zone,
    end_tm timestamp without time zone,
    bld_count integer,
    comp_count integer,
    build_duration bigint,
    prepare_duration bigint,
    prepare_count integer,
    build2_duration bigint,
    build2_count integer,
    package_duration bigint,
    package_count integer,
    mask bigint
);


ALTER TABLE ibidresults OWNER TO postgres;

--
-- Name: suspectresults; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE suspectresults (
    id bigint NOT NULL,
    comment character varying
);


ALTER TABLE suspectresults OWNER TO postgres;

--
-- Name: metrics; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW metrics AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir
           FROM baseresults
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), ibid AS (
         SELECT z.id,
            z.start_tm AS tm,
            z.fault_class,
            z.ibid,
            y.host_class,
            x.build_class,
                CASE
                    WHEN (strpos((z.fault_class)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE w.fault_category
                END AS fault_category,
            z.result,
            z.comp_count,
            z.bld_count,
            z.prepare_count,
            z.build2_count,
            z.package_count,
            z.build_duration,
            z.prepare_duration,
            z.build2_duration,
            z.package_duration,
            x.hour,
            x.date,
            x.week,
            base.env_type,
            "substring"((base.native_env)::text, '^[^\s]*'::text) AS native_env,
            "substring"((base.native_env)::text, '\d*$'::text) AS native_ver,
            "substring"((base.run_env)::text, '^[^\s]*'::text) AS run_env,
            "substring"((base.run_env)::text, '\d*$'::text) AS run_ver,
                CASE
                    WHEN ((v.site)::text ~* 'New Jersey|Paris|RTP|Shanghai|St Petersburg'::text) THEN v.site
                    WHEN ((v.cloud)::text ~* 'CEC'::text) THEN (((v.site)::text || ' CEC'::text))::character varying
                    WHEN ((v.site)::text ~* 'Durham|Hopkinton'::text) THEN ((((v.site)::text || ' '::text) || (v.cloud)::text))::character varying
                    ELSE 'Other'::character varying
                END AS host_category
           FROM (((((ibidresults z
             LEFT JOIN base ON ((z.id = base.id)))
             LEFT JOIN hosts y ON (((base.host)::text = (y.host)::text)))
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN fault_class w ON (((z.fault_class)::text = (w.fault_class)::text)))
             LEFT JOIN ibidextended v ON (((v.id = z.id) AND ((v.ibid)::text = (z.ibid)::text))))
        )
 SELECT ibid.id,
    ibid.tm,
    ibid.fault_class,
    ibid.ibid,
    ibid.host_class,
    ibid.build_class,
    ibid.fault_category,
    ibid.result,
    ibid.comp_count,
    ibid.bld_count,
    ibid.prepare_count,
    ibid.build2_count,
    ibid.package_count,
    ibid.build_duration,
    ibid.prepare_duration,
    ibid.build2_duration,
    ibid.package_duration,
    ibid.hour,
    ibid.date,
    ibid.week,
    ibid.env_type,
    ibid.native_env,
    ibid.native_ver,
    ibid.run_env,
    ibid.run_ver,
    ibid.host_category
   FROM ibid
  ORDER BY ibid.ibid;


ALTER TABLE metrics OWNER TO postgres;

--
-- Name: ExcelMetrics1; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "ExcelMetrics1" AS
 WITH enddt AS (
         SELECT public.startofweek((('now'::text)::date)::timestamp with time zone) AS end_dt
        ), rslts AS (
         SELECT metrics.id,
            metrics.tm,
            metrics.fault_class,
            metrics.ibid,
            metrics.host_class,
            metrics.build_class,
            metrics.fault_category,
            metrics.result,
            metrics.comp_count,
            metrics.bld_count,
            metrics.prepare_count,
            metrics.build2_count,
            metrics.package_count,
            metrics.build_duration,
            metrics.prepare_duration,
            metrics.build2_duration,
            metrics.package_duration,
            metrics.hour,
            metrics.date,
            metrics.week,
            metrics.env_type,
            metrics.native_env,
            metrics.native_ver,
            metrics.run_env,
            metrics.run_ver,
            metrics.host_category,
            enddt.end_dt
           FROM (metrics
             CROSS JOIN enddt)
          WHERE (((metrics.week)::date < enddt.end_dt) AND (NOT ((metrics.prepare_count >= 0) AND (metrics.build2_count = 0) AND (metrics.package_count = 0))))
          ORDER BY metrics.id DESC
         LIMIT 1048574
        )
 SELECT rslts.id,
    rslts.tm,
    rslts.fault_class,
    rslts.ibid,
    rslts.host_class,
    rslts.build_class,
    rslts.fault_category,
    rslts.result,
    rslts.comp_count,
    rslts.bld_count,
    rslts.prepare_count,
    rslts.build2_count,
    rslts.package_count,
    rslts.build_duration,
    rslts.prepare_duration,
    rslts.build2_duration,
    rslts.package_duration,
    rslts.hour,
    rslts.date,
    rslts.week,
    rslts.env_type,
    rslts.native_env,
    rslts.native_ver,
    rslts.run_env,
    rslts.run_ver,
    rslts.host_category,
    rslts.end_dt
   FROM rslts
  ORDER BY rslts.id;


ALTER TABLE "ExcelMetrics1" OWNER TO postgres;

--
-- Name: componentmeta; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE componentmeta (
    component character varying NOT NULL,
    packaging boolean DEFAULT false,
    last_improvement timestamp without time zone,
    component_class character varying,
    dorder integer,
    "kittyhawk-all" boolean,
    build_type character varying,
    mask bigint
);


ALTER TABLE componentmeta OWNER TO postgres;

--
-- Name: componentsbyoccurrence; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE componentsbyoccurrence (
    id bigint NOT NULL,
    component character varying,
    duration integer,
    phase character varying
);


ALTER TABLE componentsbyoccurrence OWNER TO postgres;

--
-- Name: metrics_comps; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW metrics_comps AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir
           FROM baseresults
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), bcmpts AS (
         SELECT z.id,
            z.component,
            sum(z.duration) AS duration,
            every(((z.phase)::text = 'prepare'::text)) AS prepare,
            y.component_class AS packaging
           FROM (componentsbyoccurrence z
             LEFT JOIN componentmeta y ON (((y.component)::text = (z.component)::text)))
          WHERE ((y.component_class)::text <> 'meta'::text)
          GROUP BY z.id, z.component, y.component_class
        ), cmpts AS (
         SELECT bcmpts.id,
            bcmpts.component,
            bcmpts.duration,
            bcmpts.packaging
           FROM bcmpts
          WHERE ((bcmpts.prepare = false) OR (bcmpts.prepare IS NULL))
        ), rslts AS (
         SELECT base.id,
            base.tm,
            base.host,
            base.stream,
            base.fault_class,
            x.host_class,
            y.build_class,
            w.fault_category,
            y.result,
            y.build_duration,
            y.comp_count,
            y.hour,
            y.date,
            y.week,
            cmpts.component,
            cmpts.duration,
            cmpts.packaging
           FROM ((((base
             LEFT JOIN etlresults y ON ((base.id = y.id)))
             LEFT JOIN hosts x ON (((base.host)::text = (x.host)::text)))
             LEFT JOIN fault_class w ON (((base.fault_class)::text = (w.fault_class)::text)))
             LEFT JOIN cmpts ON ((base.id = cmpts.id)))
        )
 SELECT rslts.id,
    rslts.tm,
    rslts.host,
    rslts.stream,
    rslts.fault_class,
    rslts.host_class,
    rslts.build_class,
    rslts.fault_category,
    rslts.result,
    rslts.build_duration,
    rslts.comp_count,
    rslts.hour,
    rslts.date,
    rslts.week,
    rslts.component,
    rslts.duration,
    rslts.packaging
   FROM rslts
  ORDER BY rslts.id;


ALTER TABLE metrics_comps OWNER TO postgres;

--
-- Name: ExcelMetrics2; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "ExcelMetrics2" AS
 WITH enddt AS (
         SELECT public.startofweek((('now'::text)::date)::timestamp with time zone) AS end_dt
        ), rslts AS (
         SELECT metrics_comps.id,
            metrics_comps.tm,
            metrics_comps.host,
            metrics_comps.stream,
            metrics_comps.fault_class,
            metrics_comps.host_class,
            metrics_comps.build_class,
            metrics_comps.fault_category,
            metrics_comps.result,
            metrics_comps.build_duration,
            metrics_comps.comp_count,
            metrics_comps.hour,
            metrics_comps.date,
            metrics_comps.week,
            metrics_comps.component,
            metrics_comps.duration,
            metrics_comps.packaging,
            enddt.end_dt
           FROM (metrics_comps
             CROSS JOIN enddt)
          WHERE (((metrics_comps.week)::date < enddt.end_dt) AND (metrics_comps.comp_count IS NOT NULL) AND (metrics_comps.duration > 0))
          ORDER BY metrics_comps.id DESC
         LIMIT 1048574
        )
 SELECT rslts.id,
    rslts.tm,
    rslts.host,
    rslts.stream,
    rslts.fault_class,
    rslts.host_class,
    rslts.build_class,
    rslts.fault_category,
    rslts.result,
    rslts.build_duration,
    rslts.comp_count,
    rslts.hour,
    rslts.date,
    rslts.week,
    rslts.component,
    rslts.duration,
    rslts.packaging,
    rslts.end_dt
   FROM rslts
  ORDER BY rslts.id;


ALTER TABLE "ExcelMetrics2" OWNER TO postgres;

--
-- Name: ExcelMetrics3; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "ExcelMetrics3" AS
 WITH enddt AS (
         SELECT public.startofweek((('now'::text)::date)::timestamp with time zone) AS end_dt
        ), rslts AS (
         SELECT z.id,
            z.start_tm AS tm,
            z.result,
            y."user",
            y.acuser,
            x.ntid,
                CASE
                    WHEN (((y."user")::text = 'c4dev'::text) OR ((y."user")::text = 'root'::text) OR ((y."user")::text ~* '^upcBuilder$'::text)) THEN y."user"
                    WHEN ((y."user")::text = (x.ntid)::text) THEN 'emclogin'::character varying
                    ELSE 'other'::character varying
                END AS build_category,
            w.host_class,
            x.build_class,
            x.date,
            x.week
           FROM ((((ibidresults z
             CROSS JOIN enddt)
             LEFT JOIN baseresults y ON ((y.id = z.id)))
             LEFT JOIN etlresults x ON ((x.id = z.id)))
             LEFT JOIN hosts w ON (((y.host)::text = (w.host)::text)))
          WHERE ((x.week)::date < enddt.end_dt)
          ORDER BY z.id DESC
         LIMIT 1048574
        )
 SELECT rslts.id,
    rslts.tm,
    rslts.result,
    rslts."user",
    rslts.acuser,
    rslts.ntid,
    rslts.build_category,
    rslts.host_class,
    rslts.build_class,
    rslts.date,
    rslts.week
   FROM rslts
  ORDER BY rslts.id;


ALTER TABLE "ExcelMetrics3" OWNER TO postgres;

--
-- Name: ExcelMetrics4; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "ExcelMetrics4" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir
           FROM baseresults
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), rslts AS (
         SELECT base.id,
            base.tm,
            base.fault_class,
            x.host_class,
            y.build_class,
            base.ibid AS buildid,
            base."user",
            base.host,
            base.status,
            base.stream,
            base.fault_component,
            base.fault_msg,
            base.init_val,
            base.pwd,
            base.basis,
            base.env_type,
            base.native_env,
            base.run_env,
            base.workspace,
            base.logerr,
            base.logout,
            base.log_subdir,
            base.hostname,
            base.acuser,
            base.ipaddr,
            y.ntid,
            y.result,
            y.build_duration,
            y.arg_count,
            y.comp_count,
            y.hour,
            y.date,
            y.week
           FROM base,
            etlresults y,
            hosts x
          WHERE ((y.id = base.id) AND ((base.host)::text = (x.host)::text) AND ((y.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)))
          ORDER BY base.id DESC
         LIMIT 1048574
        )
 SELECT rslts.id,
    rslts.tm,
    rslts.fault_class,
    rslts.host_class,
    rslts.build_class,
    rslts.buildid,
    rslts."user",
    rslts.host,
    rslts.status,
    rslts.stream,
    rslts.fault_component,
    rslts.fault_msg,
    rslts.init_val,
    rslts.pwd,
    rslts.basis,
    rslts.env_type,
    rslts.native_env,
    rslts.run_env,
    rslts.workspace,
    rslts.logerr,
    rslts.logout,
    rslts.log_subdir,
    rslts.hostname,
    rslts.acuser,
    rslts.ipaddr,
    rslts.ntid,
    rslts.result,
    rslts.build_duration,
    rslts.arg_count,
    rslts.comp_count,
    rslts.hour,
    rslts.date,
    rslts.week
   FROM rslts
  ORDER BY rslts.id;


ALTER TABLE "ExcelMetrics4" OWNER TO postgres;

--
-- Name: Indicators Summary; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Indicators Summary" AS
 WITH ibid AS (
         SELECT z.result,
            x.build_class,
            z.build_duration,
            z.comp_count,
                CASE
                    WHEN (strpos((z.fault_class)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE w.fault_category
                END AS fault_category,
            (x.week)::date AS week
           FROM (((ibidresults z
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN fault_class w USING (fault_class))
             LEFT JOIN ibidextended v ON (((v.id = z.id) AND ((v.ibid)::text = (z.ibid)::text))))
          WHERE (((x.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)) AND (NOT (((z.build_duration || ' seconds'::text))::interval > '12:00:00'::interval)))
        ), aa AS (
         SELECT ibid.week
           FROM ibid
          GROUP BY ibid.week
        ), a AS (
         SELECT ibid.week,
            ibid.fault_category,
            ibid.build_duration,
            ibid.comp_count,
            ibid.build_class,
            ibid.result
           FROM ibid
        ), b AS (
         SELECT a.week,
            a.fault_category,
            a.build_duration,
            a.comp_count,
            a.build_class,
            a.result
           FROM a
          WHERE ((a.build_class)::text = 'Developer'::text)
        ), c AS (
         SELECT a.week,
            a.fault_category,
            a.build_duration,
            a.comp_count,
            a.build_class,
            a.result
           FROM a
          WHERE ((a.build_class)::text = 'Jenkins'::text)
        ), d AS (
         SELECT a.week,
            a.fault_category,
            a.build_duration,
            a.comp_count,
            a.build_class,
            a.result
           FROM a
          WHERE ((a.build_class)::text = 'Rel Eng'::text)
        ), e AS (
         SELECT a.week,
            a.fault_category,
            a.build_duration,
            a.comp_count,
            a.build_class,
            a.result
           FROM a
          WHERE (((a.result)::text = 'pass'::text) AND (a.comp_count > 40) AND (a.build_duration > 3600))
        ), f AS (
         SELECT e.week,
            e.fault_category,
            e.build_duration,
            e.comp_count,
            e.build_class,
            e.result
           FROM e
          WHERE ((e.build_class)::text = 'Developer'::text)
        ), g AS (
         SELECT e.week,
            e.fault_category,
            e.build_duration,
            e.comp_count,
            e.build_class,
            e.result
           FROM e
          WHERE ((e.build_class)::text = 'Jenkins'::text)
        ), h AS (
         SELECT e.week,
            e.fault_category,
            e.build_duration,
            e.comp_count,
            e.build_class,
            e.result
           FROM e
          WHERE ((e.build_class)::text = 'Rel Eng'::text)
        ), a1 AS (
         SELECT a.week,
            count(*) AS "All: total"
           FROM a
          GROUP BY a.week
        ), a4 AS (
         SELECT a.week,
            count(*) AS "All: total full"
           FROM a
          WHERE ((a.comp_count > 40) AND (a.build_duration > 7200))
          GROUP BY a.week
        ), a2 AS (
         SELECT a.week,
            count(*) AS "All: Pass"
           FROM a
          WHERE ((a.fault_category)::text = 'Pass'::text)
          GROUP BY a.week
        ), a3 AS (
         SELECT e.week,
            ((max(e.build_duration) || ' seconds'::text))::interval AS "All: max duration",
            ((round(avg(e.build_duration), 0) || ' seconds'::text))::interval AS "All: avg duration",
            public.quantile(e.comp_count, (0.5)::double precision) AS "All: median comp count",
            ((public.quantile(e.build_duration, (0.5)::double precision) || ' seconds'::text))::interval AS "All: median build time",
            ((public.quantile((e.build_duration / e.comp_count), (0.5)::double precision) || ' seconds'::text))::interval AS "All: normalized median time"
           FROM e
          GROUP BY e.week
        ), b1 AS (
         SELECT b.week,
            count(*) AS "DV: total"
           FROM b
          GROUP BY b.week
        ), b4 AS (
         SELECT b.week,
            count(*) AS "DV: total full"
           FROM b
          WHERE ((b.comp_count > 40) AND (b.build_duration > 7200))
          GROUP BY b.week
        ), b2 AS (
         SELECT b.week,
            count(*) AS "DV: Pass"
           FROM b
          WHERE ((b.fault_category)::text = 'Pass'::text)
          GROUP BY b.week
        ), b0 AS (
         SELECT b.week,
            count(*) AS "DV: Developer Error"
           FROM b
          WHERE ((b.fault_category)::text = 'Developer Error'::text)
          GROUP BY b.week
        ), b3 AS (
         SELECT f.week,
            ((max(f.build_duration) || ' seconds'::text))::interval AS "DV: max duration",
            ((round(avg(f.build_duration), 0) || ' seconds'::text))::interval AS "DV: avg duration",
            public.quantile(f.comp_count, (0.5)::double precision) AS "DV: median comp count",
            ((public.quantile(f.build_duration, (0.5)::double precision) || ' seconds'::text))::interval AS "DV: median build time",
            ((public.quantile((f.build_duration / f.comp_count), (0.5)::double precision) || ' seconds'::text))::interval AS "DV: normalized median time"
           FROM f
          GROUP BY f.week
        ), c1 AS (
         SELECT c.week,
            count(*) AS "CI: total"
           FROM c
          GROUP BY c.week
        ), c4 AS (
         SELECT c.week,
            count(*) AS "CI: total full"
           FROM c
          WHERE ((c.comp_count > 40) AND (c.build_duration > 7200))
          GROUP BY c.week
        ), c2 AS (
         SELECT c.week,
            count(*) AS "CI: Pass"
           FROM c
          WHERE ((c.fault_category)::text = 'Pass'::text)
          GROUP BY c.week
        ), c3 AS (
         SELECT g.week,
            ((max(g.build_duration) || ' seconds'::text))::interval AS "CI: max duration",
            ((round(avg(g.build_duration), 0) || ' seconds'::text))::interval AS "CI: avg duration",
            public.quantile(g.comp_count, (0.5)::double precision) AS "CI: median comp count",
            ((public.quantile(g.build_duration, (0.5)::double precision) || ' seconds'::text))::interval AS "CI: median build time",
            ((public.quantile((g.build_duration / g.comp_count), (0.5)::double precision) || ' seconds'::text))::interval AS "CI: normalized median time"
           FROM g
          GROUP BY g.week
        ), d1 AS (
         SELECT d.week,
            count(*) AS "RE: total"
           FROM d
          GROUP BY d.week
        ), d4 AS (
         SELECT d.week,
            count(*) AS "RE: total full"
           FROM d
          WHERE ((d.comp_count > 40) AND (d.build_duration > 7200))
          GROUP BY d.week
        ), d2 AS (
         SELECT d.week,
            count(*) AS "RE: Pass"
           FROM d
          WHERE ((d.fault_category)::text = 'Pass'::text)
          GROUP BY d.week
        ), d3 AS (
         SELECT h.week,
            ((max(h.build_duration) || ' seconds'::text))::interval AS "RE: max duration",
            ((round(avg(h.build_duration), 0) || ' seconds'::text))::interval AS "RE: avg duration",
            public.quantile(h.comp_count, (0.5)::double precision) AS "RE: median comp count",
            ((public.quantile(h.build_duration, (0.5)::double precision) || ' seconds'::text))::interval AS "RE: median build time",
            ((public.quantile((h.build_duration / h.comp_count), (0.5)::double precision) || ' seconds'::text))::interval AS "RE: normalized median time"
           FROM h
          GROUP BY h.week
        ), zz AS (
         SELECT aa.week,
            a1."All: total",
            a4."All: total full",
            a3."All: median build time",
            a3."All: avg duration",
            a3."All: max duration",
            a3."All: normalized median time",
            a3."All: median comp count",
            round((((((a1."All: total" - a2."All: Pass") - b0."DV: Developer Error") * 100) / a1."All: total"))::numeric, 0) AS "All: Build Issues",
            b1."DV: total",
            b4."DV: total full",
            b3."DV: median build time",
            b3."DV: avg duration",
            b3."DV: max duration",
            b3."DV: normalized median time",
            b3."DV: median comp count",
            round((((((b1."DV: total" - b2."DV: Pass") - b0."DV: Developer Error") * 100) / b1."DV: total"))::numeric, 0) AS "DV: Build Issues",
            c1."CI: total",
            c4."CI: total full",
            c3."CI: median build time",
            c3."CI: avg duration",
            c3."CI: max duration",
            c3."CI: normalized median time",
            c3."CI: median comp count",
            round(((((c1."CI: total" - c2."CI: Pass") * 100) / c1."CI: total"))::numeric, 0) AS "CI: Build Issues",
            d1."RE: total",
            d4."RE: total full",
            d3."RE: median build time",
            d3."RE: avg duration",
            d3."RE: max duration",
            d3."RE: normalized median time",
            d3."RE: median comp count",
            round(((((d1."RE: total" - d2."RE: Pass") * 100) / d1."RE: total"))::numeric, 0) AS "RE: Build Issues"
           FROM (((((((((((((((((aa
             LEFT JOIN a1 USING (week))
             LEFT JOIN a2 USING (week))
             LEFT JOIN a3 USING (week))
             LEFT JOIN a4 USING (week))
             LEFT JOIN b0 USING (week))
             LEFT JOIN b1 USING (week))
             LEFT JOIN b2 USING (week))
             LEFT JOIN b3 USING (week))
             LEFT JOIN b4 USING (week))
             LEFT JOIN c1 USING (week))
             LEFT JOIN c2 USING (week))
             LEFT JOIN c3 USING (week))
             LEFT JOIN c4 USING (week))
             LEFT JOIN d1 USING (week))
             LEFT JOIN d2 USING (week))
             LEFT JOIN d3 USING (week))
             LEFT JOIN d4 USING (week))
        )
 SELECT zz.week,
    zz."All: total",
    zz."All: total full",
    zz."All: median build time",
    zz."All: avg duration",
    zz."All: max duration",
    zz."All: normalized median time",
    zz."All: median comp count",
    zz."All: Build Issues",
    zz."DV: total",
    zz."DV: total full",
    zz."DV: median build time",
    zz."DV: avg duration",
    zz."DV: max duration",
    zz."DV: normalized median time",
    zz."DV: median comp count",
    zz."DV: Build Issues",
    zz."CI: total",
    zz."CI: total full",
    zz."CI: median build time",
    zz."CI: avg duration",
    zz."CI: max duration",
    zz."CI: normalized median time",
    zz."CI: median comp count",
    zz."CI: Build Issues",
    zz."RE: total",
    zz."RE: total full",
    zz."RE: median build time",
    zz."RE: avg duration",
    zz."RE: max duration",
    zz."RE: normalized median time",
    zz."RE: median comp count",
    zz."RE: Build Issues"
   FROM zz
  ORDER BY zz.week;


ALTER TABLE "Indicators Summary" OWNER TO postgres;

--
-- Name: Last Weeks biggest changes (CI); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Last Weeks biggest changes (CI)" AS
 SELECT weekly_biggest_changes.component,
    weekly_biggest_changes.previous_week,
    weekly_biggest_changes.previous_duration,
    weekly_biggest_changes.week,
    weekly_biggest_changes.duration,
    weekly_biggest_changes.delta
   FROM weekly_biggest_changes('Jenkins'::text) weekly_biggest_changes(component, previous_week, previous_duration, week, duration, delta)
  WHERE (date((public.startofweek((('now'::text)::date)::timestamp with time zone) - '7 days'::interval)) = (weekly_biggest_changes.week)::date);


ALTER TABLE "Last Weeks biggest changes (CI)" OWNER TO postgres;

--
-- Name: VIEW "Last Weeks biggest changes (CI)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Last Weeks biggest changes (CI)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Last Weeks biggest changes (DE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Last Weeks biggest changes (DE)" AS
 SELECT weekly_biggest_changes.component,
    weekly_biggest_changes.previous_week,
    weekly_biggest_changes.previous_duration,
    weekly_biggest_changes.week,
    weekly_biggest_changes.duration,
    weekly_biggest_changes.delta
   FROM weekly_biggest_changes('Developer'::text) weekly_biggest_changes(component, previous_week, previous_duration, week, duration, delta)
  WHERE (date((public.startofweek((('now'::text)::date)::timestamp with time zone) - '7 days'::interval)) = (weekly_biggest_changes.week)::date);


ALTER TABLE "Last Weeks biggest changes (DE)" OWNER TO postgres;

--
-- Name: VIEW "Last Weeks biggest changes (DE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Last Weeks biggest changes (DE)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Last Weeks biggest changes (RE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Last Weeks biggest changes (RE)" AS
 SELECT weekly_biggest_changes.component,
    weekly_biggest_changes.previous_week,
    weekly_biggest_changes.previous_duration,
    weekly_biggest_changes.week,
    weekly_biggest_changes.duration,
    weekly_biggest_changes.delta
   FROM weekly_biggest_changes('Rel Eng'::text) weekly_biggest_changes(component, previous_week, previous_duration, week, duration, delta)
  WHERE (date((public.startofweek((('now'::text)::date)::timestamp with time zone) - '7 days'::interval)) = (weekly_biggest_changes.week)::date);


ALTER TABLE "Last Weeks biggest changes (RE)" OWNER TO postgres;

--
-- Name: VIEW "Last Weeks biggest changes (RE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Last Weeks biggest changes (RE)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Last weeks faults; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Last weeks faults" AS
 WITH ibid AS (
         SELECT x.build_class,
                CASE
                    WHEN (strpos((z.fault_class)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE v.fault_category
                END AS fault_category,
            public.endofweek(y.tm) AS week
           FROM (((ibidresults z
             LEFT JOIN baseresults y USING (id))
             LEFT JOIN etlresults x USING (id))
             LEFT JOIN fault_class v ON (((v.fault_class)::text = (z.fault_class)::text)))
          WHERE (public.endofweek(y.tm) < public.startofweek((('now'::text)::date)::timestamp with time zone))
        ), a AS (
         SELECT ibid.week,
            ibid.fault_category,
            count(*) AS faults
           FROM ibid
          WHERE (ibid.fault_category IS NOT NULL)
          GROUP BY ibid.week, ibid.fault_category
        ), b AS (
         SELECT a.fault_category AS "Category",
            a.faults
           FROM a
          WHERE (a.week IN ( SELECT max(a_1.week) AS max
                   FROM a a_1))
        )
 SELECT b."Category",
    b.faults
   FROM b;


ALTER TABLE "Last weeks faults" OWNER TO postgres;

--
-- Name: VIEW "Last weeks faults"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Last weeks faults" IS 'Data to produce graph of ''Build Reliability over last 52 weeks''';


--
-- Name: build-summary2; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "build-summary2" AS
 WITH aa AS (
         SELECT x.id,
            x.comment
           FROM ( VALUES ('9A'::text,'all builds since 6/3/2014'::text), ('9B'::text,'prev:last %ge change in builds'::text), ('9C'::text,'all CEC builds since 6/3/2014'::text), ('9D'::text,'all non-CEC builds since 6/3/2014'::text), ('9E'::text,'builds during last week'::text), ('9F'::text,'CEC builds during last week'::text), ('9G'::text,'non-CEC builds during last week'::text), ('9H'::text,'builds during previous week'::text), ('9I'::text,'CEC builds during previous week'::text), ('9J'::text,'non-CEC builds during previous week'::text), ('9K'::text,'full builds during last week'::text), ('9L'::text,'full builds during previous week'::text), ('9M'::text,'failed builds during last week'::text), ('9N'::text,'failed builds during previous week'::text), ('9O'::text,'all "bld_alls" invocations since 6/3/2014'::text), ('9P'::text,'bld_all invocations during last week'::text), ('9Q'::text,'bld_all invocationsduring previous week'::text), ('9R'::text,'prev:last %ge change in build_all'::text), ('9S'::text,'total number of users since 6/3/2014'::text), ('9T'::text,'users running builds last week'::text), ('9U'::text,'build_all invoked as root last week'::text), ('9V'::text,'users running builds as root last week'::text)) x(id, comment)
        ), weeks AS (
         SELECT weeks.id,
            weeks.name,
            weeks.week
           FROM ( VALUES (1,'lastweek'::text,public.endofweek((('now'::text)::date - '7 days'::interval))), (2,'previousweek'::text,public.endofweek((('now'::text)::date - '14 days'::interval)))) weeks(id, name, week)
        ), base AS (
         SELECT z."user",
            z.acuser,
            y.week,
            y.build_class
           FROM (baseresults z
             LEFT JOIN etlresults y ON ((y.id = z.id)))
        ), blastwk AS (
         SELECT base."user",
            base.acuser,
            base.week,
            base.build_class
           FROM base
          WHERE ((base.week)::date = public.endofweek((('now'::text)::date - '7 days'::interval)))
        ), bprevwk AS (
         SELECT base."user",
            base.acuser,
            base.week,
            base.build_class
           FROM base
          WHERE ((base.week)::date = public.endofweek((('now'::text)::date - '14 days'::interval)))
        ), ibase AS (
         SELECT y.week,
            y.build_class,
            z."user",
            z.acuser,
            x.comp_count,
            x.build_duration,
            w.fault_category,
            v.cloud
           FROM ((((ibidresults x
             LEFT JOIN baseresults z USING (id))
             LEFT JOIN etlresults y ON (((y.id = x.id) AND (NOT ((x.prepare_count >= 0) AND (x.build2_count = 0) AND (x.package_count = 0))))))
             LEFT JOIN fault_class w ON (((w.fault_class)::text = (x.fault_class)::text)))
             LEFT JOIN ibidextended v ON (((v.id = x.id) AND ((v.ibid)::text = (x.ibid)::text))))
        ), ilastwk AS (
         SELECT ibase.week,
            ibase.build_class,
            ibase."user",
            ibase.acuser,
            ibase.comp_count,
            ibase.build_duration,
            ibase.fault_category,
            ibase.cloud
           FROM ibase
          WHERE (date(ibase.week) IN ( SELECT weeks.week
                   FROM weeks
                  WHERE (weeks.id = 1)))
        ), iprevwk AS (
         SELECT ibase.week,
            ibase.build_class,
            ibase."user",
            ibase.acuser,
            ibase.comp_count,
            ibase.build_duration,
            ibase.fault_category,
            ibase.cloud
           FROM ibase
          WHERE (date(ibase.week) IN ( SELECT weeks.week
                   FROM weeks
                  WHERE (weeks.id = 2)))
        ), b00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM blastwk
        ), b01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Developer'::text)
        ), b02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Jenkins'::text)
        ), b03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Rel Eng'::text)
        ), c00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM bprevwk
        ), c01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Developer'::text)
        ), c02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Jenkins'::text)
        ), c03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Rel Eng'::text)
        ), g00 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
        ), g11 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Developer'::text)
        ), g22 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Jenkins'::text)
        ), g33 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Rel Eng'::text)
        ), h00 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
        ), h11 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Developer'::text)
        ), h22 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Jenkins'::text)
        ), h33 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Rel Eng'::text)
        ), i00 AS (
         SELECT ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.fault_category,
            ilastwk.cloud
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL))
        ), i11 AS (
         SELECT ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.fault_category,
            ilastwk.cloud
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL) AND ((ilastwk.build_class)::text = 'Developer'::text))
        ), i22 AS (
         SELECT ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.fault_category,
            ilastwk.cloud
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL) AND ((ilastwk.build_class)::text = 'Jenkins'::text))
        ), i33 AS (
         SELECT ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.fault_category,
            ilastwk.cloud
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL) AND ((ilastwk.build_class)::text = 'Rel Eng'::text))
        ), j00 AS (
         SELECT DISTINCT i00.acuser
           FROM i00
        ), j11 AS (
         SELECT DISTINCT i11.acuser
           FROM i11
        ), j22 AS (
         SELECT DISTINCT i22.acuser
           FROM i22
        ), j33 AS (
         SELECT DISTINCT i33.acuser
           FROM i33
        ), k00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ibase
        ), k01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Developer'::text)
        ), k02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Jenkins'::text)
        ), k03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Rel Eng'::text)
        ), l00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ibase
          WHERE ((ibase.cloud)::text ~* 'CEC'::text)
        ), l01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Developer'::text) AND ((ibase.cloud)::text ~* 'CEC'::text))
        ), l02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Jenkins'::text) AND ((ibase.cloud)::text ~* 'CEC'::text))
        ), l03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Rel Eng'::text) AND ((ibase.cloud)::text ~* 'CEC'::text))
        ), m00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ibase
          WHERE (((ibase.cloud)::text !~* 'CEC'::text) OR (ibase.cloud IS NULL))
        ), m01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Developer'::text) AND (((ibase.cloud)::text !~* 'CEC'::text) OR (ibase.cloud IS NULL)))
        ), m02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Jenkins'::text) AND (((ibase.cloud)::text !~* 'CEC'::text) OR (ibase.cloud IS NULL)))
        ), m03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Rel Eng'::text) AND (((ibase.cloud)::text !~* 'CEC'::text) OR (ibase.cloud IS NULL)))
        ), n00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ilastwk
        ), n01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Developer'::text)
        ), n02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Jenkins'::text)
        ), n03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Rel Eng'::text)
        ), o00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ilastwk
          WHERE ((ilastwk.cloud)::text ~* 'CEC'::text)
        ), o01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Developer'::text) AND ((ilastwk.cloud)::text ~* 'CEC'::text))
        ), o02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Jenkins'::text) AND ((ilastwk.cloud)::text ~* 'CEC'::text))
        ), o03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Rel Eng'::text) AND ((ilastwk.cloud)::text ~* 'CEC'::text))
        ), p00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ilastwk
          WHERE (((ilastwk.cloud)::text !~* 'CEC'::text) OR (ilastwk.cloud IS NULL))
        ), p01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Developer'::text) AND (((ilastwk.cloud)::text !~* 'CEC'::text) OR (ilastwk.cloud IS NULL)))
        ), p02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Jenkins'::text) AND (((ilastwk.cloud)::text !~* 'CEC'::text) OR (ilastwk.cloud IS NULL)))
        ), p03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Rel Eng'::text) AND (((ilastwk.cloud)::text !~* 'CEC'::text) OR (ilastwk.cloud IS NULL)))
        ), q00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM iprevwk
        ), q01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM iprevwk
          WHERE ((iprevwk.build_class)::text = 'Developer'::text)
        ), q02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM iprevwk
          WHERE ((iprevwk.build_class)::text = 'Jenkins'::text)
        ), q03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM iprevwk
          WHERE ((iprevwk.build_class)::text = 'Rel Eng'::text)
        ), r00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM iprevwk
          WHERE ((iprevwk.cloud)::text ~* 'CEC'::text)
        ), r01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Developer'::text) AND ((iprevwk.cloud)::text ~* 'CEC'::text))
        ), r02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Jenkins'::text) AND ((iprevwk.cloud)::text ~* 'CEC'::text))
        ), r03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Rel Eng'::text) AND ((iprevwk.cloud)::text ~* 'CEC'::text))
        ), s00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM iprevwk
          WHERE (((iprevwk.cloud)::text !~* 'CEC'::text) OR (iprevwk.cloud IS NULL))
        ), s01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Developer'::text) AND (((iprevwk.cloud)::text !~* 'CEC'::text) OR (iprevwk.cloud IS NULL)))
        ), s02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Jenkins'::text) AND (((iprevwk.cloud)::text !~* 'CEC'::text) OR (iprevwk.cloud IS NULL)))
        ), s03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Rel Eng'::text) AND (((iprevwk.cloud)::text !~* 'CEC'::text) OR (iprevwk.cloud IS NULL)))
        ), a1 AS (
         SELECT k00.cnt AS "combined totals",
            '9A'::text AS id
           FROM k00
        ), a2 AS (
         SELECT k01.cnt AS "Developer totals",
            '9A'::text AS id
           FROM k01
        ), a3 AS (
         SELECT k02.cnt AS "Jenkins totals",
            '9A'::text AS id
           FROM k02
        ), a4 AS (
         SELECT k03.cnt AS "Rel Eng totals",
            '9A'::text AS id
           FROM k03
        ), a0 AS (
         SELECT a1.id,
            a1."combined totals",
            a2."Developer totals",
            a3."Jenkins totals",
            a4."Rel Eng totals"
           FROM (((a1
             LEFT JOIN a2 USING (id))
             LEFT JOIN a3 USING (id))
             LEFT JOIN a4 USING (id))
        ), d1 AS (
         SELECT
                CASE
                    WHEN (q00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n00.cnt)::numeric - (q00.cnt)::numeric) * (100)::numeric) / (q00.cnt)::numeric), 2)
                END AS "combined totals",
            '9B'::text AS id
           FROM (n00
             LEFT JOIN q00 USING (id))
        ), d2 AS (
         SELECT
                CASE
                    WHEN (q01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n01.cnt)::numeric - (q01.cnt)::numeric) * (100)::numeric) / (q01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9B'::text AS id
           FROM (n01
             LEFT JOIN q01 USING (id))
        ), d3 AS (
         SELECT
                CASE
                    WHEN (q02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n02.cnt)::numeric - (q02.cnt)::numeric) * (100)::numeric) / (q02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9B'::text AS id
           FROM (n02
             LEFT JOIN q02 USING (id))
        ), d4 AS (
         SELECT
                CASE
                    WHEN (q03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n03.cnt)::numeric - (q03.cnt)::numeric) * (100)::numeric) / (q03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9B'::text AS id
           FROM (n03
             LEFT JOIN q03 USING (id))
        ), d0 AS (
         SELECT d1.id,
            d1."combined totals",
            d2."Developer totals",
            d3."Jenkins totals",
            d4."Rel Eng totals"
           FROM (((d1
             LEFT JOIN d2 USING (id))
             LEFT JOIN d3 USING (id))
             LEFT JOIN d4 USING (id))
        ), q1 AS (
         SELECT
                CASE
                    WHEN (k00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k00.cnt)::numeric - (l00.cnt)::numeric) * (100)::numeric) / (k00.cnt)::numeric), 2)
                END AS "combined totals",
            '9C'::text AS id
           FROM (l00
             LEFT JOIN k00 USING (id))
        ), q2 AS (
         SELECT
                CASE
                    WHEN (k01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k01.cnt)::numeric - (l01.cnt)::numeric) * (100)::numeric) / (k01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9C'::text AS id
           FROM (l01
             LEFT JOIN k01 USING (id))
        ), q3 AS (
         SELECT
                CASE
                    WHEN (k02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k02.cnt)::numeric - (l02.cnt)::numeric) * (100)::numeric) / (k02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9C'::text AS id
           FROM (l02
             LEFT JOIN k02 USING (id))
        ), q4 AS (
         SELECT
                CASE
                    WHEN (k03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k03.cnt)::numeric - (l03.cnt)::numeric) * (100)::numeric) / (k03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9C'::text AS id
           FROM (l03
             LEFT JOIN k03 USING (id))
        ), q0 AS (
         SELECT q1.id,
            q1."combined totals",
            q2."Developer totals",
            q3."Jenkins totals",
            q4."Rel Eng totals"
           FROM (((q1
             LEFT JOIN q2 USING (id))
             LEFT JOIN q3 USING (id))
             LEFT JOIN q4 USING (id))
        ), t1 AS (
         SELECT
                CASE
                    WHEN (k00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k00.cnt)::numeric - (m00.cnt)::numeric) * (100)::numeric) / (k00.cnt)::numeric), 2)
                END AS "combined totals",
            '9D'::text AS id
           FROM (m00
             LEFT JOIN k00 USING (id))
        ), t2 AS (
         SELECT
                CASE
                    WHEN (k01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k01.cnt)::numeric - (m01.cnt)::numeric) * (100)::numeric) / (k01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9D'::text AS id
           FROM (m01
             LEFT JOIN k01 USING (id))
        ), t3 AS (
         SELECT
                CASE
                    WHEN (k02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k02.cnt)::numeric - (m02.cnt)::numeric) * (100)::numeric) / (k02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9D'::text AS id
           FROM (m02
             LEFT JOIN k02 USING (id))
        ), t4 AS (
         SELECT
                CASE
                    WHEN (k03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k03.cnt)::numeric - (m03.cnt)::numeric) * (100)::numeric) / (k03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9D'::text AS id
           FROM (m03
             LEFT JOIN k03 USING (id))
        ), t0 AS (
         SELECT t1.id,
            t1."combined totals",
            t2."Developer totals",
            t3."Jenkins totals",
            t4."Rel Eng totals"
           FROM (((t1
             LEFT JOIN t2 USING (id))
             LEFT JOIN t3 USING (id))
             LEFT JOIN t4 USING (id))
        ), b1 AS (
         SELECT n00.cnt AS "combined totals",
            '9E'::text AS id
           FROM n00
        ), b2 AS (
         SELECT n01.cnt AS "Developer totals",
            '9E'::text AS id
           FROM n01
        ), b3 AS (
         SELECT n02.cnt AS "Jenkins totals",
            '9E'::text AS id
           FROM n02
        ), b4 AS (
         SELECT n03.cnt AS "Rel Eng totals",
            '9E'::text AS id
           FROM n03
        ), b0 AS (
         SELECT b1.id,
            b1."combined totals",
            b2."Developer totals",
            b3."Jenkins totals",
            b4."Rel Eng totals"
           FROM (((b1
             LEFT JOIN b2 USING (id))
             LEFT JOIN b3 USING (id))
             LEFT JOIN b4 USING (id))
        ), r1 AS (
         SELECT
                CASE
                    WHEN (n00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n00.cnt)::numeric - (o00.cnt)::numeric) * (100)::numeric) / (n00.cnt)::numeric), 2)
                END AS "combined totals",
            '9F'::text AS id
           FROM (o00
             LEFT JOIN n00 USING (id))
        ), r2 AS (
         SELECT
                CASE
                    WHEN (n01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n01.cnt)::numeric - (o01.cnt)::numeric) * (100)::numeric) / (n01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9F'::text AS id
           FROM (o01
             LEFT JOIN n01 USING (id))
        ), r3 AS (
         SELECT
                CASE
                    WHEN (n02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n02.cnt)::numeric - (o02.cnt)::numeric) * (100)::numeric) / (n02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9F'::text AS id
           FROM (o02
             LEFT JOIN n02 USING (id))
        ), r4 AS (
         SELECT
                CASE
                    WHEN (n03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n03.cnt)::numeric - (o03.cnt)::numeric) * (100)::numeric) / (n03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9F'::text AS id
           FROM (o03
             LEFT JOIN n03 USING (id))
        ), r0 AS (
         SELECT r1.id,
            r1."combined totals",
            r2."Developer totals",
            r3."Jenkins totals",
            r4."Rel Eng totals"
           FROM (((r1
             LEFT JOIN r2 USING (id))
             LEFT JOIN r3 USING (id))
             LEFT JOIN r4 USING (id))
        ), u1 AS (
         SELECT
                CASE
                    WHEN (n00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n00.cnt)::numeric - (p00.cnt)::numeric) * (100)::numeric) / (n00.cnt)::numeric), 2)
                END AS "combined totals",
            '9G'::text AS id
           FROM (p00
             LEFT JOIN n00 USING (id))
        ), u2 AS (
         SELECT
                CASE
                    WHEN (n01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n01.cnt)::numeric - (p01.cnt)::numeric) * (100)::numeric) / (n01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9G'::text AS id
           FROM (p01
             LEFT JOIN n01 USING (id))
        ), u3 AS (
         SELECT
                CASE
                    WHEN (n02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n02.cnt)::numeric - (p02.cnt)::numeric) * (100)::numeric) / (n02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9G'::text AS id
           FROM (p02
             LEFT JOIN n02 USING (id))
        ), u4 AS (
         SELECT
                CASE
                    WHEN (n03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n03.cnt)::numeric - (p03.cnt)::numeric) * (100)::numeric) / (n03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9G'::text AS id
           FROM (p03
             LEFT JOIN n03 USING (id))
        ), u0 AS (
         SELECT u1.id,
            u1."combined totals",
            u2."Developer totals",
            u3."Jenkins totals",
            u4."Rel Eng totals"
           FROM (((u1
             LEFT JOIN u2 USING (id))
             LEFT JOIN u3 USING (id))
             LEFT JOIN u4 USING (id))
        ), c1 AS (
         SELECT q00.cnt AS "combined totals",
            '9H'::text AS id
           FROM q00
        ), c2 AS (
         SELECT q01.cnt AS "Developer totals",
            '9H'::text AS id
           FROM q01
        ), c3 AS (
         SELECT q02.cnt AS "Jenkins totals",
            '9H'::text AS id
           FROM q02
        ), c4 AS (
         SELECT q03.cnt AS "Rel Eng totals",
            '9H'::text AS id
           FROM q03
        ), c0 AS (
         SELECT c1.id,
            c1."combined totals",
            c2."Developer totals",
            c3."Jenkins totals",
            c4."Rel Eng totals"
           FROM (((c1
             LEFT JOIN c2 USING (id))
             LEFT JOIN c3 USING (id))
             LEFT JOIN c4 USING (id))
        ), s1 AS (
         SELECT
                CASE
                    WHEN (q00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q00.cnt)::numeric - (r00.cnt)::numeric) * (100)::numeric) / (q00.cnt)::numeric), 2)
                END AS "combined totals",
            '9I'::text AS id
           FROM (r00
             LEFT JOIN q00 USING (id))
        ), s2 AS (
         SELECT
                CASE
                    WHEN (q01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q01.cnt)::numeric - (r01.cnt)::numeric) * (100)::numeric) / (q01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9I'::text AS id
           FROM (r01
             LEFT JOIN q01 USING (id))
        ), s3 AS (
         SELECT
                CASE
                    WHEN (q02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q02.cnt)::numeric - (r02.cnt)::numeric) * (100)::numeric) / (q02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9I'::text AS id
           FROM (r02
             LEFT JOIN q02 USING (id))
        ), s4 AS (
         SELECT
                CASE
                    WHEN (q03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q03.cnt)::numeric - (r03.cnt)::numeric) * (100)::numeric) / (q03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9I'::text AS id
           FROM (r03
             LEFT JOIN q03 USING (id))
        ), s0 AS (
         SELECT s1.id,
            s1."combined totals",
            s2."Developer totals",
            s3."Jenkins totals",
            s4."Rel Eng totals"
           FROM (((s1
             LEFT JOIN s2 USING (id))
             LEFT JOIN s3 USING (id))
             LEFT JOIN s4 USING (id))
        ), v1 AS (
         SELECT
                CASE
                    WHEN (q00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q00.cnt)::numeric - (s00.cnt)::numeric) * (100)::numeric) / (q00.cnt)::numeric), 2)
                END AS "combined totals",
            '9J'::text AS id
           FROM (s00
             LEFT JOIN q00 USING (id))
        ), v2 AS (
         SELECT
                CASE
                    WHEN (q01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q01.cnt)::numeric - (s01.cnt)::numeric) * (100)::numeric) / (q01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9J'::text AS id
           FROM (s01
             LEFT JOIN q01 USING (id))
        ), v3 AS (
         SELECT
                CASE
                    WHEN (q02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q02.cnt)::numeric - (s02.cnt)::numeric) * (100)::numeric) / (q02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9J'::text AS id
           FROM (s02
             LEFT JOIN q02 USING (id))
        ), v4 AS (
         SELECT
                CASE
                    WHEN (q03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q03.cnt)::numeric - (s03.cnt)::numeric) * (100)::numeric) / (q03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9J'::text AS id
           FROM (s03
             LEFT JOIN q03 USING (id))
        ), v0 AS (
         SELECT v1.id,
            v1."combined totals",
            v2."Developer totals",
            v3."Jenkins totals",
            v4."Rel Eng totals"
           FROM (((v1
             LEFT JOIN v2 USING (id))
             LEFT JOIN v3 USING (id))
             LEFT JOIN v4 USING (id))
        ), e1 AS (
         SELECT count(*) AS "combined totals",
            '9K'::text AS id
           FROM ilastwk
          WHERE ((ilastwk.build_duration > 7200) AND (ilastwk.comp_count > 40))
        ), e2 AS (
         SELECT count(*) AS "Developer totals",
            '9K'::text AS id
           FROM ilastwk
          WHERE ((ilastwk.build_duration > 7200) AND (ilastwk.comp_count > 40) AND ((ilastwk.build_class)::text = 'Developer'::text))
        ), e3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9K'::text AS id
           FROM ilastwk
          WHERE ((ilastwk.build_duration > 7200) AND (ilastwk.comp_count > 40) AND ((ilastwk.build_class)::text = 'Jenkins'::text))
        ), e4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9K'::text AS id
           FROM ilastwk
          WHERE ((ilastwk.build_duration > 7200) AND (ilastwk.comp_count > 40) AND ((ilastwk.build_class)::text = 'Rel Eng'::text))
        ), e0 AS (
         SELECT e1.id,
            e1."combined totals",
            e2."Developer totals",
            e3."Jenkins totals",
            e4."Rel Eng totals"
           FROM (((e1
             LEFT JOIN e2 USING (id))
             LEFT JOIN e3 USING (id))
             LEFT JOIN e4 USING (id))
        ), f1 AS (
         SELECT count(*) AS "combined totals",
            '9L'::text AS id
           FROM iprevwk
          WHERE ((iprevwk.build_duration > 7200) AND (iprevwk.comp_count > 40))
        ), f2 AS (
         SELECT count(*) AS "Developer totals",
            '9L'::text AS id
           FROM iprevwk
          WHERE ((iprevwk.build_duration > 7200) AND (iprevwk.comp_count > 40) AND ((iprevwk.build_class)::text = 'Developer'::text))
        ), f3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9L'::text AS id
           FROM iprevwk
          WHERE ((iprevwk.build_duration > 7200) AND (iprevwk.comp_count > 40) AND ((iprevwk.build_class)::text = 'Jenkins'::text))
        ), f4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9L'::text AS id
           FROM iprevwk
          WHERE ((iprevwk.build_duration > 7200) AND (iprevwk.comp_count > 40) AND ((iprevwk.build_class)::text = 'Rel Eng'::text))
        ), f0 AS (
         SELECT f1.id,
            f1."combined totals",
            f2."Developer totals",
            f3."Jenkins totals",
            f4."Rel Eng totals"
           FROM (((f1
             LEFT JOIN f2 USING (id))
             LEFT JOIN f3 USING (id))
             LEFT JOIN f4 USING (id))
        ), g1 AS (
         SELECT count(*) AS "combined totals",
            '9M'::text AS id
           FROM ilastwk
          WHERE ((ilastwk.fault_category)::text !~* '((Pass)|(Developer Error))'::text)
        ), g2 AS (
         SELECT count(*) AS "Developer totals",
            '9M'::text AS id
           FROM ilastwk
          WHERE (((ilastwk.fault_category)::text !~* '((Pass)|(Developer Error))'::text) AND ((ilastwk.build_class)::text = 'Developer'::text))
        ), g3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9M'::text AS id
           FROM ilastwk
          WHERE (((ilastwk.fault_category)::text !~* 'Pass'::text) AND ((ilastwk.build_class)::text = 'Jenkins'::text))
        ), g4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9M'::text AS id
           FROM ilastwk
          WHERE (((ilastwk.fault_category)::text !~* 'Pass'::text) AND ((ilastwk.build_class)::text = 'Rel Eng'::text))
        ), g0 AS (
         SELECT g1.id,
            g1."combined totals",
            g2."Developer totals",
            g3."Jenkins totals",
            g4."Rel Eng totals"
           FROM (((g1
             LEFT JOIN g2 USING (id))
             LEFT JOIN g3 USING (id))
             LEFT JOIN g4 USING (id))
        ), h1 AS (
         SELECT count(*) AS "combined totals",
            '9N'::text AS id
           FROM iprevwk
          WHERE ((iprevwk.fault_category)::text !~* '((Pass)|(Developer Error))'::text)
        ), h2 AS (
         SELECT count(*) AS "Developer totals",
            '9N'::text AS id
           FROM iprevwk
          WHERE (((iprevwk.fault_category)::text !~* '((Pass)|(Developer Error))'::text) AND ((iprevwk.build_class)::text = 'Developer'::text))
        ), h3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9N'::text AS id
           FROM iprevwk
          WHERE (((iprevwk.fault_category)::text !~* 'Pass'::text) AND ((iprevwk.build_class)::text = 'Jenkins'::text))
        ), h4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9N'::text AS id
           FROM iprevwk
          WHERE (((iprevwk.fault_category)::text !~* 'Pass'::text) AND ((iprevwk.build_class)::text = 'Rel Eng'::text))
        ), h0 AS (
         SELECT h1.id,
            h1."combined totals",
            h2."Developer totals",
            h3."Jenkins totals",
            h4."Rel Eng totals"
           FROM (((h1
             LEFT JOIN h2 USING (id))
             LEFT JOIN h3 USING (id))
             LEFT JOIN h4 USING (id))
        ), i1 AS (
         SELECT count(*) AS "combined totals",
            '9O'::text AS id
           FROM base
        ), i2 AS (
         SELECT count(*) AS "Developer totals",
            '9O'::text AS id
           FROM base
          WHERE ((base.build_class)::text = 'Developer'::text)
        ), i3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9O'::text AS id
           FROM base
          WHERE ((base.build_class)::text = 'Jenkins'::text)
        ), i4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9O'::text AS id
           FROM base
          WHERE ((base.build_class)::text = 'Rel Eng'::text)
        ), i0 AS (
         SELECT i1.id,
            i1."combined totals",
            i2."Developer totals",
            i3."Jenkins totals",
            i4."Rel Eng totals"
           FROM (((i1
             LEFT JOIN i2 USING (id))
             LEFT JOIN i3 USING (id))
             LEFT JOIN i4 USING (id))
        ), j1 AS (
         SELECT count(*) AS "combined totals",
            '9P'::text AS id
           FROM blastwk
        ), j2 AS (
         SELECT count(*) AS "Developer totals",
            '9P'::text AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Developer'::text)
        ), j3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9P'::text AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Jenkins'::text)
        ), j4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9P'::text AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Rel Eng'::text)
        ), j0 AS (
         SELECT j1.id,
            j1."combined totals",
            j2."Developer totals",
            j3."Jenkins totals",
            j4."Rel Eng totals"
           FROM (((j1
             LEFT JOIN j2 USING (id))
             LEFT JOIN j3 USING (id))
             LEFT JOIN j4 USING (id))
        ), k1 AS (
         SELECT count(*) AS "combined totals",
            '9Q'::text AS id
           FROM bprevwk
        ), k2 AS (
         SELECT count(*) AS "Developer totals",
            '9Q'::text AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Developer'::text)
        ), k3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9Q'::text AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Jenkins'::text)
        ), k4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9Q'::text AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Rel Eng'::text)
        ), k0 AS (
         SELECT k1.id,
            k1."combined totals",
            k2."Developer totals",
            k3."Jenkins totals",
            k4."Rel Eng totals"
           FROM (((k1
             LEFT JOIN k2 USING (id))
             LEFT JOIN k3 USING (id))
             LEFT JOIN k4 USING (id))
        ), l1 AS (
         SELECT
                CASE
                    WHEN (c00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b00.cnt)::numeric - (c00.cnt)::numeric) * (100)::numeric) / (c00.cnt)::numeric), 2)
                END AS "combined totals",
            '9R'::text AS id
           FROM (b00
             LEFT JOIN c00 USING (id))
        ), l2 AS (
         SELECT
                CASE
                    WHEN (c01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b01.cnt)::numeric - (c01.cnt)::numeric) * (100)::numeric) / (c01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9R'::text AS id
           FROM (b01
             LEFT JOIN c01 USING (id))
        ), l3 AS (
         SELECT
                CASE
                    WHEN (c02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b02.cnt)::numeric - (c02.cnt)::numeric) * (100)::numeric) / (c02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9R'::text AS id
           FROM (b02
             LEFT JOIN c02 USING (id))
        ), l4 AS (
         SELECT
                CASE
                    WHEN (c03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b03.cnt)::numeric - (c03.cnt)::numeric) * (100)::numeric) / (c03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9R'::text AS id
           FROM (b03
             LEFT JOIN c03 USING (id))
        ), l0 AS (
         SELECT l1.id,
            l1."combined totals",
            l2."Developer totals",
            l3."Jenkins totals",
            l4."Rel Eng totals"
           FROM (((l1
             LEFT JOIN l2 USING (id))
             LEFT JOIN l3 USING (id))
             LEFT JOIN l4 USING (id))
        ), m1 AS (
         SELECT count(g00.acuser) AS "combined totals",
            '9S'::text AS id
           FROM g00
        ), m2 AS (
         SELECT count(g11.acuser) AS "Developer totals",
            '9S'::text AS id
           FROM g11
        ), m3 AS (
         SELECT count(g22.acuser) AS "Jenkins totals",
            '9S'::text AS id
           FROM g22
        ), m4 AS (
         SELECT count(g33.acuser) AS "Rel Eng totals",
            '9S'::text AS id
           FROM g33
        ), m0 AS (
         SELECT m1.id,
            m1."combined totals",
            m2."Developer totals",
            m3."Jenkins totals",
            m4."Rel Eng totals"
           FROM (((m1
             LEFT JOIN m2 USING (id))
             LEFT JOIN m3 USING (id))
             LEFT JOIN m4 USING (id))
        ), n1 AS (
         SELECT count(h00.acuser) AS "combined totals",
            '9T'::text AS id
           FROM h00
        ), n2 AS (
         SELECT count(h11.acuser) AS "Developer totals",
            '9T'::text AS id
           FROM h11
        ), n3 AS (
         SELECT count(h22.acuser) AS "Jenkins totals",
            '9T'::text AS id
           FROM h22
        ), n4 AS (
         SELECT count(h33.acuser) AS "Rel Eng totals",
            '9T'::text AS id
           FROM h33
        ), n0 AS (
         SELECT n1.id,
            n1."combined totals",
            n2."Developer totals",
            n3."Jenkins totals",
            n4."Rel Eng totals"
           FROM (((n1
             LEFT JOIN n2 USING (id))
             LEFT JOIN n3 USING (id))
             LEFT JOIN n4 USING (id))
        ), o1 AS (
         SELECT count(*) AS "combined totals",
            '9U'::text AS id
           FROM i00
        ), o2 AS (
         SELECT count(*) AS "Developer totals",
            '9U'::text AS id
           FROM i00
          WHERE ((i00.build_class)::text = 'Developer'::text)
        ), o3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9U'::text AS id
           FROM i00
          WHERE ((i00.build_class)::text = 'Jenkins'::text)
        ), o4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9U'::text AS id
           FROM i00
          WHERE ((i00.build_class)::text = 'Rel Eng'::text)
        ), o0 AS (
         SELECT o1.id,
            o1."combined totals",
            o2."Developer totals",
            o3."Jenkins totals",
            o4."Rel Eng totals"
           FROM (((o1
             LEFT JOIN o2 USING (id))
             LEFT JOIN o3 USING (id))
             LEFT JOIN o4 USING (id))
        ), p1 AS (
         SELECT count(j00.acuser) AS "combined totals",
            '9V'::text AS id
           FROM j00
        ), p2 AS (
         SELECT count(j11.acuser) AS "Developer totals",
            '9V'::text AS id
           FROM j11
        ), p3 AS (
         SELECT count(j22.acuser) AS "Jenkins totals",
            '9V'::text AS id
           FROM j22
        ), p4 AS (
         SELECT count(j33.acuser) AS "Rel Eng totals",
            '9V'::text AS id
           FROM j33
        ), p0 AS (
         SELECT p1.id,
            p1."combined totals",
            p2."Developer totals",
            p3."Jenkins totals",
            p4."Rel Eng totals"
           FROM (((p1
             LEFT JOIN p2 USING (id))
             LEFT JOIN p3 USING (id))
             LEFT JOIN p4 USING (id))
        ), zz AS (
         SELECT a0.id,
            a0."combined totals",
            a0."Developer totals",
            a0."Jenkins totals",
            a0."Rel Eng totals"
           FROM a0
        UNION
         SELECT b0.id,
            b0."combined totals",
            b0."Developer totals",
            b0."Jenkins totals",
            b0."Rel Eng totals"
           FROM b0
        UNION
         SELECT c0.id,
            c0."combined totals",
            c0."Developer totals",
            c0."Jenkins totals",
            c0."Rel Eng totals"
           FROM c0
        UNION
         SELECT d0.id,
            d0."combined totals",
            d0."Developer totals",
            d0."Jenkins totals",
            d0."Rel Eng totals"
           FROM d0
        UNION
         SELECT e0.id,
            e0."combined totals",
            e0."Developer totals",
            e0."Jenkins totals",
            e0."Rel Eng totals"
           FROM e0
        UNION
         SELECT f0.id,
            f0."combined totals",
            f0."Developer totals",
            f0."Jenkins totals",
            f0."Rel Eng totals"
           FROM f0
        UNION
         SELECT g0.id,
            g0."combined totals",
            g0."Developer totals",
            g0."Jenkins totals",
            g0."Rel Eng totals"
           FROM g0
        UNION
         SELECT h0.id,
            h0."combined totals",
            h0."Developer totals",
            h0."Jenkins totals",
            h0."Rel Eng totals"
           FROM h0
        UNION
         SELECT i0.id,
            i0."combined totals",
            i0."Developer totals",
            i0."Jenkins totals",
            i0."Rel Eng totals"
           FROM i0
        UNION
         SELECT j0.id,
            j0."combined totals",
            j0."Developer totals",
            j0."Jenkins totals",
            j0."Rel Eng totals"
           FROM j0
        UNION
         SELECT k0.id,
            k0."combined totals",
            k0."Developer totals",
            k0."Jenkins totals",
            k0."Rel Eng totals"
           FROM k0
        UNION
         SELECT l0.id,
            l0."combined totals",
            l0."Developer totals",
            l0."Jenkins totals",
            l0."Rel Eng totals"
           FROM l0
        UNION
         SELECT m0.id,
            m0."combined totals",
            m0."Developer totals",
            m0."Jenkins totals",
            m0."Rel Eng totals"
           FROM m0
        UNION
         SELECT n0.id,
            n0."combined totals",
            n0."Developer totals",
            n0."Jenkins totals",
            n0."Rel Eng totals"
           FROM n0
        UNION
         SELECT o0.id,
            o0."combined totals",
            o0."Developer totals",
            o0."Jenkins totals",
            o0."Rel Eng totals"
           FROM o0
        UNION
         SELECT p0.id,
            p0."combined totals",
            p0."Developer totals",
            p0."Jenkins totals",
            p0."Rel Eng totals"
           FROM p0
        UNION
         SELECT q0.id,
            q0."combined totals",
            q0."Developer totals",
            q0."Jenkins totals",
            q0."Rel Eng totals"
           FROM q0
        UNION
         SELECT r0.id,
            r0."combined totals",
            r0."Developer totals",
            r0."Jenkins totals",
            r0."Rel Eng totals"
           FROM r0
        UNION
         SELECT s0.id,
            s0."combined totals",
            s0."Developer totals",
            s0."Jenkins totals",
            s0."Rel Eng totals"
           FROM s0
        UNION
         SELECT t0.id,
            t0."combined totals",
            t0."Developer totals",
            t0."Jenkins totals",
            t0."Rel Eng totals"
           FROM t0
        UNION
         SELECT u0.id,
            u0."combined totals",
            u0."Developer totals",
            u0."Jenkins totals",
            u0."Rel Eng totals"
           FROM u0
        UNION
         SELECT v0.id,
            v0."combined totals",
            v0."Developer totals",
            v0."Jenkins totals",
            v0."Rel Eng totals"
           FROM v0
        ), data AS (
         SELECT zz.id,
            aa.comment,
            zz."combined totals",
            zz."Developer totals",
            zz."Jenkins totals",
            zz."Rel Eng totals"
           FROM (zz
             LEFT JOIN aa USING (id))
          ORDER BY zz.id
        )
 SELECT data.id,
    data.comment,
    data."combined totals",
    data."Developer totals",
    data."Jenkins totals",
    data."Rel Eng totals"
   FROM data;


ALTER TABLE "build-summary2" OWNER TO postgres;

--
-- Name: LiveWire-summary; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "LiveWire-summary" AS
 WITH weeks AS (
         SELECT weeks.id,
            weeks.name,
            weeks.week
           FROM ( VALUES (1,'lastweek'::text,public.endofweek((('now'::text)::date - '7 days'::interval))), (2,'previousweek'::text,public.endofweek((('now'::text)::date - '14 days'::interval)))) weeks(id, name, week)
        ), a AS (
         SELECT "build-summary2".id,
            "build-summary2".comment,
            "build-summary2"."combined totals",
            "build-summary2"."Developer totals",
            "build-summary2"."Jenkins totals",
            "build-summary2"."Rel Eng totals"
           FROM "build-summary2"
        ), b AS (
         SELECT
                CASE
                    WHEN (( SELECT (a."combined totals")::integer AS "combined totals"
                       FROM a
                      WHERE (a.id = '9B'::text)) > 0) THEN 'up '::text
                    ELSE 'down '::text
                END AS ibid_direction,
                CASE
                    WHEN (( SELECT (a."combined totals")::integer AS "combined totals"
                       FROM a
                      WHERE (a.id = '9E'::text)) > ( SELECT (a."combined totals")::integer AS "combined totals"
                       FROM a
                      WHERE (a.id = '9F'::text))) THEN 'up '::text
                    ELSE 'down '::text
                END AS full_direction,
                CASE
                    WHEN (( SELECT (a."combined totals")::integer AS "combined totals"
                       FROM a
                      WHERE (a.id = '9R'::text)) > 0) THEN 'up '::text
                    ELSE 'down '::text
                END AS ball_direction
        ), l1 AS (
         SELECT 1 AS linenum,
            (((('**Various build metrics and charts for the week: '::text || public.startofweek((weeks.week)::timestamp with time zone)) || ' - '::text) || weeks.week) || '**'::text) AS line
           FROM weeks
          WHERE (weeks.id = 1)
        ), l2 AS (
         SELECT 2 AS linenum,
            ((((('  -  '::text || ( SELECT a."combined totals"
                   FROM a
                  WHERE (a.id = '9E'::text))) || ' builds were recorded, which is '::text) || ( SELECT b.ibid_direction
                   FROM b)) || abs(( SELECT a."combined totals"
                   FROM a
                  WHERE (a.id = '9B'::text)))) || '% previous week'::text) AS line
        ), l3 AS (
         SELECT 3 AS linenum,
            (((('  -  '::text || ( SELECT a."combined totals"
                   FROM a
                  WHERE (a.id = '9K'::text))) || ' FULL builds were recorded, which is '::text) || ( SELECT b.full_direction
                   FROM b)) || 'from previous week'::text) AS line
        ), l4 AS (
         SELECT 4 AS linenum,
            (((('  -  '::text || ( SELECT a."combined totals"
                   FROM a
                  WHERE (a.id = '9P'::text))) || ' invocations of build_all were recorded, which is '::text) || ( SELECT b.ball_direction
                   FROM b)) || 'from previous week'::text) AS line
        ), l5 AS (
         SELECT 5 AS linenum,
            (((('  -  There were '::text || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9E'::text))) || ' developer builds, performed by '::text) || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9T'::text))) || ' unique users'::text) AS line
        ), l6 AS (
         SELECT 6 AS linenum,
            (((('  -  There were '::text || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9U'::text))) || ' developer builds as "root", performed by '::text) || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9V'::text))) || ' unique users'::text) AS line
        ), l7 AS (
         SELECT 7 AS linenum,
            (((('  -  Since 2014-03-06, there have been '::text || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9A'::text))) || ' developer builds, performed by '::text) || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9S'::text))) || ' unique users'::text) AS line
        ), lines AS (
         SELECT l1.linenum,
            l1.line
           FROM l1
        UNION
         SELECT l2.linenum,
            l2.line
           FROM l2
        UNION
         SELECT l3.linenum,
            l3.line
           FROM l3
        UNION
         SELECT l4.linenum,
            l4.line
           FROM l4
        UNION
         SELECT l5.linenum,
            l5.line
           FROM l5
        UNION
         SELECT l6.linenum,
            l6.line
           FROM l6
        UNION
         SELECT l7.linenum,
            l7.line
           FROM l7
        )
 SELECT lines.line
   FROM lines
  ORDER BY lines.linenum;


ALTER TABLE "LiveWire-summary" OWNER TO postgres;

--
-- Name: PIE_builds; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "PIE_builds" AS
 WITH a AS (
         SELECT z.ibid
           FROM ((ibidresults z
             LEFT JOIN baseresults y USING (id))
             LEFT JOIN etlresults x USING (id))
          WHERE (((z.ibid)::text ~* '-ci-server-23-'::text) AND (z.start_tm > '2016-06-01 00:00:00'::timestamp without time zone))
        ), b AS (
         SELECT baseresults.id,
            baseresults.tm,
            etlresults.ibid_calc AS ibid
           FROM (baseresults
             LEFT JOIN etlresults USING (id))
          WHERE ((etlresults.ibid_calc)::text IN ( SELECT a.ibid
                   FROM a))
        ), c AS (
         SELECT z.id,
            z.component,
            ((z.duration || 'seconds'::text))::interval AS duration,
            z.phase
           FROM componentsbyoccurrence z
          WHERE (z.id IN ( SELECT b.id
                   FROM b))
          ORDER BY z.id DESC
        ), d AS (
         SELECT c.id,
            c.component,
            c.duration AS prep_duration
           FROM c
          WHERE ((c.phase)::text = 'prepare'::text)
        ), e AS (
         SELECT c.id,
            c.component,
            c.duration AS build_duration
           FROM c
          WHERE ((c.phase)::text = 'build'::text)
        ), f AS (
         SELECT c.id,
            c.component,
            c.duration AS pack_duration
           FROM c
          WHERE ((c.phase)::text = 'package'::text)
        ), g AS (
         SELECT d.id,
            d.component,
            d.prep_duration,
            e.build_duration,
            f.pack_duration
           FROM ((d
             LEFT JOIN e USING (id, component))
             LEFT JOIN f USING (id, component))
          ORDER BY d.id
        ), h AS (
         SELECT g.id,
            g.component,
            g.prep_duration,
            g.build_duration,
            g.pack_duration,
            b.tm,
            b.ibid
           FROM (g
             LEFT JOIN b USING (id))
          ORDER BY b.ibid, g.id
        )
 SELECT h.id,
    h.component,
    h.tm AS tm_start,
    (((h.tm + h.prep_duration) + h.build_duration) + h.pack_duration) AS tm_end,
    ((h.prep_duration + h.build_duration) + h.pack_duration) AS duration,
    h.prep_duration,
    h.build_duration,
    h.pack_duration,
    h.ibid
   FROM h;


ALTER TABLE "PIE_builds" OWNER TO postgres;

--
-- Name: Reliability; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Reliability" AS
 WITH ibid AS (
         SELECT x.build_class,
                CASE
                    WHEN (strpos((z.fault_class)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE w.fault_category
                END AS fault_category,
            (x.week)::date AS week
           FROM (((ibidresults z
             LEFT JOIN etlresults x ON ((x.id = z.id)))
             LEFT JOIN fault_class w USING (fault_class))
             LEFT JOIN ibidextended v ON (((v.id = z.id) AND ((v.ibid)::text = (z.ibid)::text))))
          WHERE ((x.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone))
        ), a AS (
         SELECT ibid.week,
            ibid.fault_category,
            ibid.build_class
           FROM ibid
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), b AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Developer'::text)
        ), bb AS (
         SELECT b.week,
            count(*) AS "DV: All"
           FROM b
          GROUP BY b.week
        ), h AS (
         SELECT b.week,
            count(*) AS "DV: Pass"
           FROM b
          WHERE ((b.fault_category)::text = 'Pass'::text)
          GROUP BY b.week
        ), i AS (
         SELECT b.week,
            count(*) AS "DV: Developer Error"
           FROM b
          WHERE ((b.fault_category)::text = 'Developer Error'::text)
          GROUP BY b.week
        ), c AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Jenkins'::text)
        ), cc AS (
         SELECT c.week,
            count(*) AS "CI: All"
           FROM c
          GROUP BY c.week
        ), o AS (
         SELECT c.week,
            count(*) AS "CI: Pass"
           FROM c
          WHERE ((c.fault_category)::text = 'Pass'::text)
          GROUP BY c.week
        ), d AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Rel Eng'::text)
        ), dd AS (
         SELECT d.week,
            count(*) AS "RE: All"
           FROM d
          GROUP BY d.week
        ), v AS (
         SELECT d.week,
            count(*) AS "RE: Pass"
           FROM d
          WHERE ((d.fault_category)::text = 'Pass'::text)
          GROUP BY d.week
        ), ee AS (
         SELECT aa.week,
            h."DV: Pass",
            i."DV: Developer Error",
            bb."DV: All",
            o."CI: Pass",
            cc."CI: All",
            v."RE: Pass",
            dd."RE: All"
           FROM (((((((aa
             LEFT JOIN h USING (week))
             LEFT JOIN i USING (week))
             LEFT JOIN bb USING (week))
             LEFT JOIN o USING (week))
             LEFT JOIN cc USING (week))
             LEFT JOIN v USING (week))
             LEFT JOIN dd USING (week))
        )
 SELECT ee.week,
    round(((((ee."DV: Pass" + ee."DV: Developer Error") * 100) / ee."DV: All"))::numeric, 2) AS "DV: Reliability",
    round((((ee."CI: Pass" * 100) / ee."CI: All"))::numeric, 2) AS "CI: Reliability",
    round((((ee."RE: Pass" * 100) / ee."RE: All"))::numeric, 2) AS "RE: Reliability"
   FROM ee
  ORDER BY ee.week;


ALTER TABLE "Reliability" OWNER TO postgres;

--
-- Name: VIEW "Reliability"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Reliability" IS 'Data to produce graph of ''Build Reliability over last 52 weeks''';


--
-- Name: Reliability: CI; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Reliability: CI" AS
 WITH ibid AS (
         SELECT x.build_class,
                CASE
                    WHEN (strpos((z.fault_class)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE w.fault_category
                END AS fault_category,
            (x.week)::date AS week
           FROM ((ibidresults z
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN fault_class w ON (((z.fault_class)::text = (w.fault_class)::text)))
        ), a AS (
         SELECT ibid.week,
            ibid.fault_category,
            ibid.build_class
           FROM ibid
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), c AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Jenkins'::text)
        ), cc AS (
         SELECT c.week,
            count(*) AS "CI: All"
           FROM c
          GROUP BY c.week
        ), o AS (
         SELECT c.week,
            count(*) AS "CI: Pass"
           FROM c
          WHERE ((c.fault_category)::text = 'Pass'::text)
          GROUP BY c.week
        ), ee AS (
         SELECT aa.week,
            o."CI: Pass",
            cc."CI: All"
           FROM ((aa
             LEFT JOIN o USING (week))
             LEFT JOIN cc USING (week))
        )
 SELECT ee.week,
    round((((ee."CI: Pass" * 100) / ee."CI: All"))::numeric, 2) AS "CI: Reliability"
   FROM ee
  ORDER BY ee.week;


ALTER TABLE "Reliability: CI" OWNER TO postgres;

--
-- Name: VIEW "Reliability: CI"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Reliability: CI" IS 'Data to produce graph of ''Jenkins Build Reliability over last 52 weeks''';


--
-- Name: Reliability: DE; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Reliability: DE" AS
 WITH ibid AS (
         SELECT x.build_class,
                CASE
                    WHEN (strpos((z.fault_class)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE w.fault_category
                END AS fault_category,
            (x.week)::date AS week
           FROM ((ibidresults z
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN fault_class w ON (((z.fault_class)::text = (w.fault_class)::text)))
        ), a AS (
         SELECT ibid.week,
            ibid.fault_category,
            ibid.build_class
           FROM ibid
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), b AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Developer'::text)
        ), bb AS (
         SELECT b.week,
            count(*) AS "DV: All"
           FROM b
          GROUP BY b.week
        ), h AS (
         SELECT b.week,
            count(*) AS "DV: Pass"
           FROM b
          WHERE ((b.fault_category)::text = 'Pass'::text)
          GROUP BY b.week
        ), i AS (
         SELECT b.week,
            count(*) AS "DV: Developer Error"
           FROM b
          WHERE ((b.fault_category)::text = 'Developer Error'::text)
          GROUP BY b.week
        ), ee AS (
         SELECT aa.week,
            h."DV: Pass",
            i."DV: Developer Error",
            bb."DV: All"
           FROM (((aa
             LEFT JOIN h USING (week))
             LEFT JOIN i USING (week))
             LEFT JOIN bb USING (week))
        )
 SELECT ee.week,
    round(((((ee."DV: Pass" + ee."DV: Developer Error") * 100) / ee."DV: All"))::numeric, 2) AS "DV: Reliability"
   FROM ee
  ORDER BY ee.week;


ALTER TABLE "Reliability: DE" OWNER TO postgres;

--
-- Name: VIEW "Reliability: DE"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Reliability: DE" IS 'Data to produce graph of ''Developer Build Reliability over last 52 weeks''';


--
-- Name: Reliability: RE; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Reliability: RE" AS
 WITH ibid AS (
         SELECT x.build_class,
                CASE
                    WHEN (strpos((z.fault_class)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE w.fault_category
                END AS fault_category,
            (x.week)::date AS week
           FROM ((ibidresults z
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN fault_class w ON (((z.fault_class)::text = (w.fault_class)::text)))
        ), a AS (
         SELECT ibid.week,
            ibid.fault_category,
            ibid.build_class
           FROM ibid
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), d AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Rel Eng'::text)
        ), dd AS (
         SELECT d.week,
            count(*) AS "RE: All"
           FROM d
          GROUP BY d.week
        ), v AS (
         SELECT d.week,
            count(*) AS "RE: Pass"
           FROM d
          WHERE ((d.fault_category)::text = 'Pass'::text)
          GROUP BY d.week
        ), ee AS (
         SELECT aa.week,
            v."RE: Pass",
            dd."RE: All"
           FROM ((aa
             LEFT JOIN v USING (week))
             LEFT JOIN dd USING (week))
        )
 SELECT ee.week,
    round((((ee."RE: Pass" * 100) / ee."RE: All"))::numeric, 2) AS "RE: Reliability"
   FROM ee
  ORDER BY ee.week;


ALTER TABLE "Reliability: RE" OWNER TO postgres;

--
-- Name: VIEW "Reliability: RE"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Reliability: RE" IS 'Data to produce graph of ''Rel Eng Build Reliability over last 52 weeks''';


--
-- Name: Savings; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Savings" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir
           FROM baseresults
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), base2 AS (
         SELECT base.id,
            base.tm,
            z.build_class
           FROM base,
            etlresults z
          WHERE ((z.id = base.id) AND ((z.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)))
        ), rslts AS (
         SELECT base2.build_class,
            z.component,
            z.duration,
            y.component_class,
            y.last_improvement,
            base2.tm
           FROM ((base2
             LEFT JOIN componentsbyoccurrence z ON ((base2.id = z.id)))
             LEFT JOIN componentmeta y ON (((y.component)::text = (z.component)::text)))
        ), prerslts AS (
         SELECT rslts.component,
            rslts.build_class,
            count(rslts.tm) AS num,
            sum(rslts.duration) AS total,
            avg(rslts.duration) AS avg,
            rslts.component_class
           FROM rslts
          WHERE (rslts.tm <= rslts.last_improvement)
          GROUP BY rslts.component, rslts.build_class, rslts.component_class
        ), pstrslts AS (
         SELECT rslts.component,
            rslts.build_class,
            avg(rslts.duration) AS avg,
            count(rslts.tm) AS num,
            sum(rslts.duration) AS total,
            rslts.component_class
           FROM rslts
          WHERE (rslts.tm > rslts.last_improvement)
          GROUP BY rslts.component, rslts.build_class, rslts.component_class
        ), all_rslts AS (
         SELECT prerslts.component,
            prerslts.build_class,
            prerslts.num,
            prerslts.total,
            prerslts.avg,
            prerslts.component_class,
            pstrslts.avg,
            pstrslts.num,
            pstrslts.total,
            (((prerslts.avg - pstrslts.avg) * (pstrslts.num)::numeric) / (3600)::numeric) AS savings
           FROM prerslts,
            pstrslts
          WHERE (((prerslts.component)::text = (pstrslts.component)::text) AND ((prerslts.build_class)::text = (pstrslts.build_class)::text))
        ), results AS (
         SELECT all_rslts.build_class,
            trunc(sum(all_rslts.savings)) AS savings,
            all_rslts.component_class
           FROM all_rslts all_rslts(component, build_class, num, total, avg, component_class, avg_1, num_1, total_1, savings)
          WHERE ((all_rslts.component_class)::text <> 'meta'::text)
          GROUP BY all_rslts.component_class, all_rslts.build_class
        ), packages AS (
         SELECT results.build_class,
            results.savings AS packaging
           FROM results
          WHERE ((results.component_class)::text = 'packaging'::text)
        ), pkg_tot AS (
         SELECT 'total'::character varying AS build_class,
            sum(packages.packaging) AS packaging
           FROM packages
          WHERE (packages.packaging > (0)::numeric)
        ), pkg_all AS (
         SELECT packages.build_class,
            packages.packaging
           FROM packages
        UNION
         SELECT pkg_tot.build_class,
            pkg_tot.packaging
           FROM pkg_tot
        ), sources AS (
         SELECT results.build_class,
            results.savings AS source
           FROM results
          WHERE ((results.component_class)::text = 'source'::text)
        ), srs_tot AS (
         SELECT 'total'::character varying AS build_class,
            sum(sources.source) AS source
           FROM sources
        ), srs_all AS (
         SELECT sources.build_class,
            sources.source
           FROM sources
        UNION
         SELECT srs_tot.build_class,
            srs_tot.source
           FROM srs_tot
        ), savings AS (
         SELECT pkg_all.build_class,
            srs_all.source,
            pkg_all.packaging
           FROM (pkg_all
             LEFT JOIN srs_all ON (((srs_all.build_class)::text = (pkg_all.build_class)::text)))
        )
 SELECT savings.build_class,
    savings.source,
    savings.packaging
   FROM savings
  ORDER BY savings.build_class;


ALTER TABLE "Savings" OWNER TO postgres;

--
-- Name: Week over Week delta - components_bld (CI); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Week over Week delta - components_bld (CI)" AS
 WITH a AS (
         SELECT average_components_bld.week,
            average_components_bld.bamxml,
            average_components_bld.blockshim_ng,
            average_components_bld.c4core,
            average_components_bld.c4csx,
            average_components_bld.cemgui,
            average_components_bld.clariion,
            average_components_bld.cp,
            average_components_bld.cta,
            average_components_bld.cumulus,
            average_components_bld.gms,
            average_components_bld.healthchecks,
            average_components_bld.infrastructureproviders,
            average_components_bld.jmi,
            average_components_bld.kernel,
            average_components_bld.libpsm,
            average_components_bld.mf,
            average_components_bld.mf_common,
            average_components_bld.nxgui,
            average_components_bld.observability,
            average_components_bld.papi,
            average_components_bld.restcommon,
            average_components_bld.sade,
            average_components_bld.safe,
            average_components_bld.security,
            average_components_bld.serviceability,
            average_components_bld.tbn,
            average_components_bld.tomcatcommon,
            average_components_bld.udoctor,
            average_components_bld.uemcli,
            average_components_bld.unirest,
            average_components_bld.univasa,
            average_components_bld.vmwaresdkclient,
            average_components_bld.vvnxdeploydual,
            average_components_pkg.bootflash,
            average_components_pkg.econtrolstation,
            average_components_pkg.image,
            average_components_pkg.languages,
            average_components_pkg.rpms,
            average_components_pkg.rpmsinfq,
            average_components_pkg.systemtap,
            average_components_pkg.vtune
           FROM (average_components_bld('Jenkins'::text) average_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual)
             LEFT JOIN average_components_pkg('Jenkins'::text) average_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune) USING (week))
        ), b AS (
         SELECT a.week,
            (date_part('epoch'::text, (a.bamxml - lag(a.bamxml) OVER week_window)) / date_part('epoch'::text, a.bamxml)) AS bamxml,
            (date_part('epoch'::text, (a.blockshim_ng - lag(a.blockshim_ng) OVER week_window)) / date_part('epoch'::text, a.blockshim_ng)) AS blockshim_ng,
            (date_part('epoch'::text, (a.bootflash - lag(a.bootflash) OVER week_window)) / date_part('epoch'::text, a.bootflash)) AS bootflash,
            (date_part('epoch'::text, (a.c4core - lag(a.c4core) OVER week_window)) / date_part('epoch'::text, a.c4core)) AS c4core,
            (date_part('epoch'::text, (a.c4csx - lag(a.c4csx) OVER week_window)) / date_part('epoch'::text, a.c4csx)) AS c4csx,
            (date_part('epoch'::text, (a.cemgui - lag(a.cemgui) OVER week_window)) / date_part('epoch'::text, a.cemgui)) AS cemgui,
            (date_part('epoch'::text, (a.clariion - lag(a.clariion) OVER week_window)) / date_part('epoch'::text, a.clariion)) AS clariion,
            (date_part('epoch'::text, (a.cp - lag(a.cp) OVER week_window)) / date_part('epoch'::text, a.cp)) AS cp,
            (date_part('epoch'::text, (a.cta - lag(a.cta) OVER week_window)) / date_part('epoch'::text, a.cta)) AS cta,
            (date_part('epoch'::text, (a.cumulus - lag(a.cumulus) OVER week_window)) / date_part('epoch'::text, a.cumulus)) AS cumulus,
            (date_part('epoch'::text, (a.econtrolstation - lag(a.econtrolstation) OVER week_window)) / date_part('epoch'::text, a.econtrolstation)) AS econtrolstation,
            (date_part('epoch'::text, (a.gms - lag(a.gms) OVER week_window)) / date_part('epoch'::text, a.gms)) AS gms,
            (date_part('epoch'::text, (a.healthchecks - lag(a.healthchecks) OVER week_window)) / date_part('epoch'::text, a.healthchecks)) AS healthchecks,
            (date_part('epoch'::text, (a.image - lag(a.image) OVER week_window)) / date_part('epoch'::text, a.image)) AS image,
            (date_part('epoch'::text, (a.infrastructureproviders - lag(a.infrastructureproviders) OVER week_window)) / date_part('epoch'::text, a.infrastructureproviders)) AS infrastructureproviders,
            (date_part('epoch'::text, (a.jmi - lag(a.jmi) OVER week_window)) / date_part('epoch'::text, a.jmi)) AS jmi,
            (date_part('epoch'::text, (a.kernel - lag(a.kernel) OVER week_window)) / date_part('epoch'::text, a.kernel)) AS kernel,
            (date_part('epoch'::text, (a.languages - lag(a.languages) OVER week_window)) / date_part('epoch'::text, a.languages)) AS languages,
            (date_part('epoch'::text, (a.libpsm - lag(a.libpsm) OVER week_window)) / date_part('epoch'::text, a.libpsm)) AS libpsm,
            (date_part('epoch'::text, (a.mf - lag(a.mf) OVER week_window)) / date_part('epoch'::text, a.mf)) AS mf,
            (date_part('epoch'::text, (a.mf_common - lag(a.mf_common) OVER week_window)) / date_part('epoch'::text, a.mf_common)) AS mf_common,
            (date_part('epoch'::text, (a.nxgui - lag(a.nxgui) OVER week_window)) / date_part('epoch'::text, a.nxgui)) AS nxgui,
            (date_part('epoch'::text, (a.observability - lag(a.observability) OVER week_window)) / date_part('epoch'::text, a.observability)) AS observability,
            (date_part('epoch'::text, (a.papi - lag(a.papi) OVER week_window)) / date_part('epoch'::text, a.papi)) AS papi,
            (date_part('epoch'::text, (a.restcommon - lag(a.restcommon) OVER week_window)) / date_part('epoch'::text, a.restcommon)) AS restcommon,
            (date_part('epoch'::text, (a.rpms - lag(a.rpms) OVER week_window)) / date_part('epoch'::text, a.rpms)) AS rpms,
            (date_part('epoch'::text, (a.rpmsinfq - lag(a.rpmsinfq) OVER week_window)) / date_part('epoch'::text, a.rpmsinfq)) AS rpmsinfq,
            (date_part('epoch'::text, (a.sade - lag(a.sade) OVER week_window)) / date_part('epoch'::text, a.sade)) AS sade,
            (date_part('epoch'::text, (a.safe - lag(a.safe) OVER week_window)) / date_part('epoch'::text, a.safe)) AS safe,
            (date_part('epoch'::text, (a.security - lag(a.security) OVER week_window)) / date_part('epoch'::text, a.security)) AS security,
            (date_part('epoch'::text, (a.serviceability - lag(a.serviceability) OVER week_window)) / date_part('epoch'::text, a.serviceability)) AS serviceability,
            (date_part('epoch'::text, (a.systemtap - lag(a.systemtap) OVER week_window)) / date_part('epoch'::text, a.systemtap)) AS systemtap,
            (date_part('epoch'::text, (a.tbn - lag(a.tbn) OVER week_window)) / date_part('epoch'::text, a.tbn)) AS tbn,
            (date_part('epoch'::text, (a.tomcatcommon - lag(a.tomcatcommon) OVER week_window)) / date_part('epoch'::text, a.tomcatcommon)) AS tomcatcommon,
            (date_part('epoch'::text, (a.udoctor - lag(a.udoctor) OVER week_window)) / date_part('epoch'::text, a.udoctor)) AS udoctor,
            (date_part('epoch'::text, (a.uemcli - lag(a.uemcli) OVER week_window)) / date_part('epoch'::text, a.uemcli)) AS uemcli,
            (date_part('epoch'::text, (a.unirest - lag(a.unirest) OVER week_window)) / date_part('epoch'::text, a.unirest)) AS unirest,
            (date_part('epoch'::text, (a.univasa - lag(a.univasa) OVER week_window)) / date_part('epoch'::text, a.univasa)) AS univasa,
            (date_part('epoch'::text, (a.vmwaresdkclient - lag(a.vmwaresdkclient) OVER week_window)) / date_part('epoch'::text, a.vmwaresdkclient)) AS vmwaresdkclient,
            (date_part('epoch'::text, (a.vtune - lag(a.vtune) OVER week_window)) / date_part('epoch'::text, a.vtune)) AS vtune,
            (date_part('epoch'::text, (a.vvnxdeploydual - lag(a.vvnxdeploydual) OVER week_window)) / date_part('epoch'::text, a.vvnxdeploydual)) AS vvnxdeploydual
           FROM a
          WINDOW week_window AS (ORDER BY a.week)
          ORDER BY a.week
        )
 SELECT b.week,
    b.bamxml,
    b.blockshim_ng,
    b.bootflash,
    b.c4core,
    b.c4csx,
    b.cemgui,
    b.clariion,
    b.cp,
    b.cta,
    b.cumulus,
    b.econtrolstation,
    b.gms,
    b.healthchecks,
    b.image,
    b.infrastructureproviders,
    b.jmi,
    b.kernel,
    b.languages,
    b.libpsm,
    b.mf,
    b.mf_common,
    b.nxgui,
    b.observability,
    b.papi,
    b.restcommon,
    b.rpms,
    b.rpmsinfq,
    b.sade,
    b.safe,
    b.security,
    b.serviceability,
    b.systemtap,
    b.tbn,
    b.tomcatcommon,
    b.udoctor,
    b.uemcli,
    b.unirest,
    b.univasa,
    b.vmwaresdkclient,
    b.vtune,
    b.vvnxdeploydual
   FROM b;


ALTER TABLE "Week over Week delta - components_bld (CI)" OWNER TO postgres;

--
-- Name: VIEW "Week over Week delta - components_bld (CI)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Week over Week delta - components_bld (CI)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Week over Week delta - components_bld (DE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Week over Week delta - components_bld (DE)" AS
 WITH a AS (
         SELECT average_components_bld.week,
            average_components_bld.bamxml,
            average_components_bld.blockshim_ng,
            average_components_bld.c4core,
            average_components_bld.c4csx,
            average_components_bld.cemgui,
            average_components_bld.clariion,
            average_components_bld.cp,
            average_components_bld.cta,
            average_components_bld.cumulus,
            average_components_bld.gms,
            average_components_bld.healthchecks,
            average_components_bld.infrastructureproviders,
            average_components_bld.jmi,
            average_components_bld.kernel,
            average_components_bld.libpsm,
            average_components_bld.mf,
            average_components_bld.mf_common,
            average_components_bld.nxgui,
            average_components_bld.observability,
            average_components_bld.papi,
            average_components_bld.restcommon,
            average_components_bld.sade,
            average_components_bld.safe,
            average_components_bld.security,
            average_components_bld.serviceability,
            average_components_bld.tbn,
            average_components_bld.tomcatcommon,
            average_components_bld.udoctor,
            average_components_bld.uemcli,
            average_components_bld.unirest,
            average_components_bld.univasa,
            average_components_bld.vmwaresdkclient,
            average_components_bld.vvnxdeploydual,
            average_components_pkg.bootflash,
            average_components_pkg.econtrolstation,
            average_components_pkg.image,
            average_components_pkg.languages,
            average_components_pkg.rpms,
            average_components_pkg.rpmsinfq,
            average_components_pkg.systemtap,
            average_components_pkg.vtune
           FROM (average_components_bld('Developer'::text) average_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual)
             LEFT JOIN average_components_pkg('Developer'::text) average_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune) USING (week))
        ), b AS (
         SELECT a.week,
            (date_part('epoch'::text, (a.bamxml - lag(a.bamxml) OVER week_window)) / date_part('epoch'::text, a.bamxml)) AS bamxml,
            (date_part('epoch'::text, (a.blockshim_ng - lag(a.blockshim_ng) OVER week_window)) / date_part('epoch'::text, a.blockshim_ng)) AS blockshim_ng,
            (date_part('epoch'::text, (a.bootflash - lag(a.bootflash) OVER week_window)) / date_part('epoch'::text, a.bootflash)) AS bootflash,
            (date_part('epoch'::text, (a.c4core - lag(a.c4core) OVER week_window)) / date_part('epoch'::text, a.c4core)) AS c4core,
            (date_part('epoch'::text, (a.c4csx - lag(a.c4csx) OVER week_window)) / date_part('epoch'::text, a.c4csx)) AS c4csx,
            (date_part('epoch'::text, (a.cemgui - lag(a.cemgui) OVER week_window)) / date_part('epoch'::text, a.cemgui)) AS cemgui,
            (date_part('epoch'::text, (a.clariion - lag(a.clariion) OVER week_window)) / date_part('epoch'::text, a.clariion)) AS clariion,
            (date_part('epoch'::text, (a.cp - lag(a.cp) OVER week_window)) / date_part('epoch'::text, a.cp)) AS cp,
            (date_part('epoch'::text, (a.cta - lag(a.cta) OVER week_window)) / date_part('epoch'::text, a.cta)) AS cta,
            (date_part('epoch'::text, (a.cumulus - lag(a.cumulus) OVER week_window)) / date_part('epoch'::text, a.cumulus)) AS cumulus,
            (date_part('epoch'::text, (a.econtrolstation - lag(a.econtrolstation) OVER week_window)) / date_part('epoch'::text, a.econtrolstation)) AS econtrolstation,
            (date_part('epoch'::text, (a.gms - lag(a.gms) OVER week_window)) / date_part('epoch'::text, a.gms)) AS gms,
            (date_part('epoch'::text, (a.healthchecks - lag(a.healthchecks) OVER week_window)) / date_part('epoch'::text, a.healthchecks)) AS healthchecks,
            (date_part('epoch'::text, (a.image - lag(a.image) OVER week_window)) / date_part('epoch'::text, a.image)) AS image,
            (date_part('epoch'::text, (a.infrastructureproviders - lag(a.infrastructureproviders) OVER week_window)) / date_part('epoch'::text, a.infrastructureproviders)) AS infrastructureproviders,
            (date_part('epoch'::text, (a.jmi - lag(a.jmi) OVER week_window)) / date_part('epoch'::text, a.jmi)) AS jmi,
            (date_part('epoch'::text, (a.kernel - lag(a.kernel) OVER week_window)) / date_part('epoch'::text, a.kernel)) AS kernel,
            (date_part('epoch'::text, (a.languages - lag(a.languages) OVER week_window)) / date_part('epoch'::text, a.languages)) AS languages,
            (date_part('epoch'::text, (a.libpsm - lag(a.libpsm) OVER week_window)) / date_part('epoch'::text, a.libpsm)) AS libpsm,
            (date_part('epoch'::text, (a.mf - lag(a.mf) OVER week_window)) / date_part('epoch'::text, a.mf)) AS mf,
            (date_part('epoch'::text, (a.mf_common - lag(a.mf_common) OVER week_window)) / date_part('epoch'::text, a.mf_common)) AS mf_common,
            (date_part('epoch'::text, (a.nxgui - lag(a.nxgui) OVER week_window)) / date_part('epoch'::text, a.nxgui)) AS nxgui,
            (date_part('epoch'::text, (a.observability - lag(a.observability) OVER week_window)) / date_part('epoch'::text, a.observability)) AS observability,
            (date_part('epoch'::text, (a.papi - lag(a.papi) OVER week_window)) / date_part('epoch'::text, a.papi)) AS papi,
            (date_part('epoch'::text, (a.restcommon - lag(a.restcommon) OVER week_window)) / date_part('epoch'::text, a.restcommon)) AS restcommon,
            (date_part('epoch'::text, (a.rpms - lag(a.rpms) OVER week_window)) / date_part('epoch'::text, a.rpms)) AS rpms,
            (date_part('epoch'::text, (a.rpmsinfq - lag(a.rpmsinfq) OVER week_window)) / date_part('epoch'::text, a.rpmsinfq)) AS rpmsinfq,
            (date_part('epoch'::text, (a.sade - lag(a.sade) OVER week_window)) / date_part('epoch'::text, a.sade)) AS sade,
            (date_part('epoch'::text, (a.safe - lag(a.safe) OVER week_window)) / date_part('epoch'::text, a.safe)) AS safe,
            (date_part('epoch'::text, (a.security - lag(a.security) OVER week_window)) / date_part('epoch'::text, a.security)) AS security,
            (date_part('epoch'::text, (a.serviceability - lag(a.serviceability) OVER week_window)) / date_part('epoch'::text, a.serviceability)) AS serviceability,
            (date_part('epoch'::text, (a.systemtap - lag(a.systemtap) OVER week_window)) / date_part('epoch'::text, a.systemtap)) AS systemtap,
            (date_part('epoch'::text, (a.tbn - lag(a.tbn) OVER week_window)) / date_part('epoch'::text, a.tbn)) AS tbn,
            (date_part('epoch'::text, (a.tomcatcommon - lag(a.tomcatcommon) OVER week_window)) / date_part('epoch'::text, a.tomcatcommon)) AS tomcatcommon,
            (date_part('epoch'::text, (a.udoctor - lag(a.udoctor) OVER week_window)) / date_part('epoch'::text, a.udoctor)) AS udoctor,
            (date_part('epoch'::text, (a.uemcli - lag(a.uemcli) OVER week_window)) / date_part('epoch'::text, a.uemcli)) AS uemcli,
            (date_part('epoch'::text, (a.unirest - lag(a.unirest) OVER week_window)) / date_part('epoch'::text, a.unirest)) AS unirest,
            (date_part('epoch'::text, (a.univasa - lag(a.univasa) OVER week_window)) / date_part('epoch'::text, a.univasa)) AS univasa,
            (date_part('epoch'::text, (a.vmwaresdkclient - lag(a.vmwaresdkclient) OVER week_window)) / date_part('epoch'::text, a.vmwaresdkclient)) AS vmwaresdkclient,
            (date_part('epoch'::text, (a.vtune - lag(a.vtune) OVER week_window)) / date_part('epoch'::text, a.vtune)) AS vtune,
            (date_part('epoch'::text, (a.vvnxdeploydual - lag(a.vvnxdeploydual) OVER week_window)) / date_part('epoch'::text, a.vvnxdeploydual)) AS vvnxdeploydual
           FROM a
          WINDOW week_window AS (ORDER BY a.week)
          ORDER BY a.week
        )
 SELECT b.week,
    b.bamxml,
    b.blockshim_ng,
    b.bootflash,
    b.c4core,
    b.c4csx,
    b.cemgui,
    b.clariion,
    b.cp,
    b.cta,
    b.cumulus,
    b.econtrolstation,
    b.gms,
    b.healthchecks,
    b.image,
    b.infrastructureproviders,
    b.jmi,
    b.kernel,
    b.languages,
    b.libpsm,
    b.mf,
    b.mf_common,
    b.nxgui,
    b.observability,
    b.papi,
    b.restcommon,
    b.rpms,
    b.rpmsinfq,
    b.sade,
    b.safe,
    b.security,
    b.serviceability,
    b.systemtap,
    b.tbn,
    b.tomcatcommon,
    b.udoctor,
    b.uemcli,
    b.unirest,
    b.univasa,
    b.vmwaresdkclient,
    b.vtune,
    b.vvnxdeploydual
   FROM b;


ALTER TABLE "Week over Week delta - components_bld (DE)" OWNER TO postgres;

--
-- Name: VIEW "Week over Week delta - components_bld (DE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Week over Week delta - components_bld (DE)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Week over Week delta - components_bld (RE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Week over Week delta - components_bld (RE)" AS
 WITH a AS (
         SELECT average_components_bld.week,
            average_components_bld.bamxml,
            average_components_bld.blockshim_ng,
            average_components_bld.c4core,
            average_components_bld.c4csx,
            average_components_bld.cemgui,
            average_components_bld.clariion,
            average_components_bld.cp,
            average_components_bld.cta,
            average_components_bld.cumulus,
            average_components_bld.gms,
            average_components_bld.healthchecks,
            average_components_bld.infrastructureproviders,
            average_components_bld.jmi,
            average_components_bld.kernel,
            average_components_bld.libpsm,
            average_components_bld.mf,
            average_components_bld.mf_common,
            average_components_bld.nxgui,
            average_components_bld.observability,
            average_components_bld.papi,
            average_components_bld.restcommon,
            average_components_bld.sade,
            average_components_bld.safe,
            average_components_bld.security,
            average_components_bld.serviceability,
            average_components_bld.tbn,
            average_components_bld.tomcatcommon,
            average_components_bld.udoctor,
            average_components_bld.uemcli,
            average_components_bld.unirest,
            average_components_bld.univasa,
            average_components_bld.vmwaresdkclient,
            average_components_bld.vvnxdeploydual,
            average_components_pkg.bootflash,
            average_components_pkg.econtrolstation,
            average_components_pkg.image,
            average_components_pkg.languages,
            average_components_pkg.rpms,
            average_components_pkg.rpmsinfq,
            average_components_pkg.systemtap,
            average_components_pkg.vtune
           FROM (average_components_bld('Rel Eng'::text) average_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual)
             LEFT JOIN average_components_pkg('Rel Eng'::text) average_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune) USING (week))
        ), b AS (
         SELECT a.week,
            (date_part('epoch'::text, (a.bamxml - lag(a.bamxml) OVER week_window)) / date_part('epoch'::text, a.bamxml)) AS bamxml,
            (date_part('epoch'::text, (a.blockshim_ng - lag(a.blockshim_ng) OVER week_window)) / date_part('epoch'::text, a.blockshim_ng)) AS blockshim_ng,
            (date_part('epoch'::text, (a.bootflash - lag(a.bootflash) OVER week_window)) / date_part('epoch'::text, a.bootflash)) AS bootflash,
            (date_part('epoch'::text, (a.c4core - lag(a.c4core) OVER week_window)) / date_part('epoch'::text, a.c4core)) AS c4core,
            (date_part('epoch'::text, (a.c4csx - lag(a.c4csx) OVER week_window)) / date_part('epoch'::text, a.c4csx)) AS c4csx,
            (date_part('epoch'::text, (a.cemgui - lag(a.cemgui) OVER week_window)) / date_part('epoch'::text, a.cemgui)) AS cemgui,
            (date_part('epoch'::text, (a.clariion - lag(a.clariion) OVER week_window)) / date_part('epoch'::text, a.clariion)) AS clariion,
            (date_part('epoch'::text, (a.cp - lag(a.cp) OVER week_window)) / date_part('epoch'::text, a.cp)) AS cp,
            (date_part('epoch'::text, (a.cta - lag(a.cta) OVER week_window)) / date_part('epoch'::text, a.cta)) AS cta,
            (date_part('epoch'::text, (a.cumulus - lag(a.cumulus) OVER week_window)) / date_part('epoch'::text, a.cumulus)) AS cumulus,
            (date_part('epoch'::text, (a.econtrolstation - lag(a.econtrolstation) OVER week_window)) / date_part('epoch'::text, a.econtrolstation)) AS econtrolstation,
            (date_part('epoch'::text, (a.gms - lag(a.gms) OVER week_window)) / date_part('epoch'::text, a.gms)) AS gms,
            (date_part('epoch'::text, (a.healthchecks - lag(a.healthchecks) OVER week_window)) / date_part('epoch'::text, a.healthchecks)) AS healthchecks,
            (date_part('epoch'::text, (a.image - lag(a.image) OVER week_window)) / date_part('epoch'::text, a.image)) AS image,
            (date_part('epoch'::text, (a.infrastructureproviders - lag(a.infrastructureproviders) OVER week_window)) / date_part('epoch'::text, a.infrastructureproviders)) AS infrastructureproviders,
            (date_part('epoch'::text, (a.jmi - lag(a.jmi) OVER week_window)) / date_part('epoch'::text, a.jmi)) AS jmi,
            (date_part('epoch'::text, (a.kernel - lag(a.kernel) OVER week_window)) / date_part('epoch'::text, a.kernel)) AS kernel,
            (date_part('epoch'::text, (a.languages - lag(a.languages) OVER week_window)) / date_part('epoch'::text, a.languages)) AS languages,
            (date_part('epoch'::text, (a.libpsm - lag(a.libpsm) OVER week_window)) / date_part('epoch'::text, a.libpsm)) AS libpsm,
            (date_part('epoch'::text, (a.mf - lag(a.mf) OVER week_window)) / date_part('epoch'::text, a.mf)) AS mf,
            (date_part('epoch'::text, (a.mf_common - lag(a.mf_common) OVER week_window)) / date_part('epoch'::text, a.mf_common)) AS mf_common,
            (date_part('epoch'::text, (a.nxgui - lag(a.nxgui) OVER week_window)) / date_part('epoch'::text, a.nxgui)) AS nxgui,
            (date_part('epoch'::text, (a.observability - lag(a.observability) OVER week_window)) / date_part('epoch'::text, a.observability)) AS observability,
            (date_part('epoch'::text, (a.papi - lag(a.papi) OVER week_window)) / date_part('epoch'::text, a.papi)) AS papi,
            (date_part('epoch'::text, (a.restcommon - lag(a.restcommon) OVER week_window)) / date_part('epoch'::text, a.restcommon)) AS restcommon,
            (date_part('epoch'::text, (a.rpms - lag(a.rpms) OVER week_window)) / date_part('epoch'::text, a.rpms)) AS rpms,
            (date_part('epoch'::text, (a.rpmsinfq - lag(a.rpmsinfq) OVER week_window)) / date_part('epoch'::text, a.rpmsinfq)) AS rpmsinfq,
            (date_part('epoch'::text, (a.sade - lag(a.sade) OVER week_window)) / date_part('epoch'::text, a.sade)) AS sade,
            (date_part('epoch'::text, (a.safe - lag(a.safe) OVER week_window)) / date_part('epoch'::text, a.safe)) AS safe,
            (date_part('epoch'::text, (a.security - lag(a.security) OVER week_window)) / date_part('epoch'::text, a.security)) AS security,
            (date_part('epoch'::text, (a.serviceability - lag(a.serviceability) OVER week_window)) / date_part('epoch'::text, a.serviceability)) AS serviceability,
            (date_part('epoch'::text, (a.systemtap - lag(a.systemtap) OVER week_window)) / date_part('epoch'::text, a.systemtap)) AS systemtap,
            (date_part('epoch'::text, (a.tbn - lag(a.tbn) OVER week_window)) / date_part('epoch'::text, a.tbn)) AS tbn,
            (date_part('epoch'::text, (a.tomcatcommon - lag(a.tomcatcommon) OVER week_window)) / date_part('epoch'::text, a.tomcatcommon)) AS tomcatcommon,
            (date_part('epoch'::text, (a.udoctor - lag(a.udoctor) OVER week_window)) / date_part('epoch'::text, a.udoctor)) AS udoctor,
            (date_part('epoch'::text, (a.uemcli - lag(a.uemcli) OVER week_window)) / date_part('epoch'::text, a.uemcli)) AS uemcli,
            (date_part('epoch'::text, (a.unirest - lag(a.unirest) OVER week_window)) / date_part('epoch'::text, a.unirest)) AS unirest,
            (date_part('epoch'::text, (a.univasa - lag(a.univasa) OVER week_window)) / date_part('epoch'::text, a.univasa)) AS univasa,
            (date_part('epoch'::text, (a.vmwaresdkclient - lag(a.vmwaresdkclient) OVER week_window)) / date_part('epoch'::text, a.vmwaresdkclient)) AS vmwaresdkclient,
            (date_part('epoch'::text, (a.vtune - lag(a.vtune) OVER week_window)) / date_part('epoch'::text, a.vtune)) AS vtune,
            (date_part('epoch'::text, (a.vvnxdeploydual - lag(a.vvnxdeploydual) OVER week_window)) / date_part('epoch'::text, a.vvnxdeploydual)) AS vvnxdeploydual
           FROM a
          WINDOW week_window AS (ORDER BY a.week)
          ORDER BY a.week
        )
 SELECT b.week,
    b.bamxml,
    b.blockshim_ng,
    b.bootflash,
    b.c4core,
    b.c4csx,
    b.cemgui,
    b.clariion,
    b.cp,
    b.cta,
    b.cumulus,
    b.econtrolstation,
    b.gms,
    b.healthchecks,
    b.image,
    b.infrastructureproviders,
    b.jmi,
    b.kernel,
    b.languages,
    b.libpsm,
    b.mf,
    b.mf_common,
    b.nxgui,
    b.observability,
    b.papi,
    b.restcommon,
    b.rpms,
    b.rpmsinfq,
    b.sade,
    b.safe,
    b.security,
    b.serviceability,
    b.systemtap,
    b.tbn,
    b.tomcatcommon,
    b.udoctor,
    b.uemcli,
    b.unirest,
    b.univasa,
    b.vmwaresdkclient,
    b.vtune,
    b.vvnxdeploydual
   FROM b;


ALTER TABLE "Week over Week delta - components_bld (RE)" OWNER TO postgres;

--
-- Name: VIEW "Week over Week delta - components_bld (RE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Week over Week delta - components_bld (RE)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Weekly Build Counts by Director (xtab); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly Build Counts by Director (xtab)" AS
 SELECT crosstab."Week ending",
    crosstab."Corniquet, Frederic",
    crosstab."Didier, John",
    crosstab."Flannery, Julie",
    crosstab."He, Zine",
    crosstab."Medhi, Gunajit",
    crosstab."Myers, Brandon",
    crosstab."Yang, Rong",
    crosstab."Zhang, Yiyang",
    crosstab."Other"
   FROM public.crosstab('
select "Week ending"
     , director
     , "number of builds"
  from buildlog."Weekly Build Stats by Director"
 order by "Week ending"
 '::text, '
select * from (values
        (''Corniquet, Frederic'')
      , (''Didier, John'')
      , (''Flannery, Julie'')
      , (''He, Zine'')
      , (''Medhi, Gunajit'')
      , (''Myers, Brandon'')
      , (''Yang, Rong'')
      , (''Zhang, Yiyang'')
      , (''Other'')
     ) x(director)
 '::text) crosstab("Week ending" date, "Corniquet, Frederic" bigint, "Didier, John" bigint, "Flannery, Julie" bigint, "He, Zine" bigint, "Medhi, Gunajit" bigint, "Myers, Brandon" bigint, "Yang, Rong" bigint, "Zhang, Yiyang" bigint, "Other" bigint);


ALTER TABLE "Weekly Build Counts by Director (xtab)" OWNER TO postgres;

--
-- Name: Weekly statistics values; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly statistics values" AS
 WITH a AS (
         SELECT DISTINCT public.endofweek(ibidresults.start_tm) AS week
           FROM ibidresults
          WHERE (public.endofweek(ibidresults.start_tm) < public.startofweek((('now'::text)::date)::timestamp with time zone))
          ORDER BY (public.endofweek(ibidresults.start_tm)) DESC
         LIMIT 27
        ), b AS (
         SELECT public.endofweek(z.start_tm) AS week,
            x.fault_class,
            w.build_class,
            y.location,
            y.director_ntlogin,
            y.site,
            y.cloud,
            ((z.prepare_duration + z.build2_duration) + z.package_duration) AS total_components_duration,
            z.build_duration,
            z.comp_count AS components_count
           FROM (((ibidresults z
             LEFT JOIN ibidextended y USING (id, ibid))
             LEFT JOIN baseresults x USING (id))
             LEFT JOIN etlresults w USING (id))
          WHERE (public.endofweek(z.start_tm) IN ( SELECT a.week
                   FROM a))
        )
 SELECT b.week,
    b.fault_class,
    b.build_class,
    b.location,
    b.director_ntlogin,
    b.site,
    b.cloud,
    b.total_components_duration,
    b.build_duration,
    b.components_count
   FROM b;


ALTER TABLE "Weekly statistics values" OWNER TO postgres;

SET search_path = empdata, pg_catalog;

--
-- Name: ix_badgeid_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_badgeid_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_badgeid_id OWNER TO postgres;

--
-- Name: ix_badgeid; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_badgeid (
    id bigint DEFAULT nextval('ix_badgeid_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_badgeid OWNER TO postgres;

--
-- Name: ix_citys_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_citys_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_citys_id OWNER TO postgres;

--
-- Name: ix_citys; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_citys (
    id bigint DEFAULT nextval('ix_citys_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_citys OWNER TO postgres;

--
-- Name: ix_countrys_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_countrys_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_countrys_id OWNER TO postgres;

--
-- Name: ix_countrys; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_countrys (
    id bigint DEFAULT nextval('ix_countrys_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_countrys OWNER TO postgres;

--
-- Name: ix_distinguishedname_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_distinguishedname_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_distinguishedname_id OWNER TO postgres;

--
-- Name: ix_distinguishedname; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_distinguishedname (
    id bigint DEFAULT nextval('ix_distinguishedname_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_distinguishedname OWNER TO postgres;

--
-- Name: ix_email_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_email_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_email_id OWNER TO postgres;

--
-- Name: ix_email; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_email (
    id bigint DEFAULT nextval('ix_email_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_email OWNER TO postgres;

--
-- Name: ix_fullname_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_fullname_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_fullname_id OWNER TO postgres;

--
-- Name: ix_fullname; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_fullname (
    id bigint DEFAULT nextval('ix_fullname_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_fullname OWNER TO postgres;

--
-- Name: ix_givenname_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_givenname_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_givenname_id OWNER TO postgres;

--
-- Name: ix_givenname; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_givenname (
    id bigint DEFAULT nextval('ix_givenname_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_givenname OWNER TO postgres;

--
-- Name: ix_ntlogin_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_ntlogin_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_ntlogin_id OWNER TO postgres;

--
-- Name: ix_ntlogin; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_ntlogin (
    id bigint DEFAULT nextval('ix_ntlogin_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_ntlogin OWNER TO postgres;

--
-- Name: ix_phone_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_phone_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_phone_id OWNER TO postgres;

--
-- Name: ix_phone; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_phone (
    id bigint DEFAULT nextval('ix_phone_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_phone OWNER TO postgres;

--
-- Name: ix_scans_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_scans_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_scans_id OWNER TO postgres;

--
-- Name: ix_scans; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_scans (
    id bigint DEFAULT nextval('ix_scans_id'::regclass) NOT NULL,
    scan_time timestamp with time zone NOT NULL
);


ALTER TABLE ix_scans OWNER TO postgres;

--
-- Name: ix_surname_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_surname_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_surname_id OWNER TO postgres;

--
-- Name: ix_surname; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_surname (
    id bigint DEFAULT nextval('ix_surname_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_surname OWNER TO postgres;

--
-- Name: tbl_employees_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE tbl_employees_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tbl_employees_id OWNER TO postgres;

--
-- Name: tbl_employees; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE tbl_employees (
    id bigint DEFAULT nextval('tbl_employees_id'::regclass) NOT NULL,
    ix_badgeid_id bigint,
    ix_ntlogin_id bigint,
    ix_email_id bigint,
    ix_fullname_id bigint,
    ix_surname_id bigint,
    ix_givenname_id bigint,
    ix_distinguishedname_id bigint
);


ALTER TABLE tbl_employees OWNER TO postgres;

--
-- Name: tbl_employees_info; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE tbl_employees_info (
    tbl_employees_id bigint NOT NULL,
    ix_scans_id bigint,
    ix_manager_id bigint,
    ix_citys_id bigint,
    ix_countrys_id bigint,
    ix_departments_id bigint,
    ix_employeetypes_id bigint,
    ix_officenames_id bigint,
    ix_primarygroupids_id bigint,
    ix_samaccounttypes_id bigint,
    ix_states_id bigint,
    ix_useraccountcontrols_id bigint,
    ix_zipcodes_id bigint,
    ix_phone_telephonenumber_id bigint,
    ix_phone_ipphone_id bigint,
    ix_phone_othertelephone_id bigint,
    ix_description_id bigint,
    ix_email_userprincipalname_id bigint,
    ix_title_id bigint,
    ix_displayname_id bigint,
    ix_lastscan_id bigint
);


ALTER TABLE tbl_employees_info OWNER TO postgres;

--
-- Name: employee_data; Type: VIEW; Schema: empdata; Owner: postgres
--

CREATE VIEW employee_data AS
 WITH a AS (
         SELECT ix_scans.id,
            max(ix_scans.scan_time) AS max
           FROM ix_scans
          GROUP BY ix_scans.id
        ), b AS (
         SELECT z.tbl_employees_id,
            max(y.scan_time) AS scan_time
           FROM (tbl_employees_info z
             LEFT JOIN ix_scans y ON ((y.id = z.ix_scans_id)))
          GROUP BY z.tbl_employees_id
        ), c AS (
         SELECT b.tbl_employees_id,
            b.scan_time,
            z.id AS ix_scans_id
           FROM (b
             LEFT JOIN ix_scans z USING (scan_time))
        ), d AS (
         SELECT c.tbl_employees_id,
            z.ix_manager_id,
            y.name AS phone,
            x.name AS city,
            w.name AS country
           FROM ((((c
             LEFT JOIN tbl_employees_info z USING (tbl_employees_id, ix_scans_id))
             LEFT JOIN ix_phone y ON ((y.id = z.ix_phone_telephonenumber_id)))
             LEFT JOIN ix_citys x ON ((x.id = z.ix_citys_id)))
             LEFT JOIN ix_countrys w ON ((w.id = z.ix_countrys_id)))
        ), e AS (
         SELECT d.tbl_employees_id,
            d.ix_manager_id,
            y.name AS badgeid,
            x.name AS ntlogin,
            w.name AS email,
            v.name,
            u.name AS surname,
            t.name AS givenname,
            d.phone,
            d.city,
            d.country,
            s.name AS distinguishedname
           FROM ((((((((d
             LEFT JOIN tbl_employees z ON ((z.id = d.tbl_employees_id)))
             LEFT JOIN ix_badgeid y ON ((y.id = z.ix_badgeid_id)))
             LEFT JOIN ix_ntlogin x ON ((x.id = z.ix_ntlogin_id)))
             LEFT JOIN ix_email w ON ((w.id = z.ix_email_id)))
             LEFT JOIN ix_fullname v ON ((v.id = z.ix_fullname_id)))
             LEFT JOIN ix_surname u ON ((u.id = z.ix_surname_id)))
             LEFT JOIN ix_givenname t ON ((t.id = z.ix_givenname_id)))
             LEFT JOIN ix_distinguishedname s ON ((s.id = z.ix_distinguishedname_id)))
          WHERE ((s.name)::text !~* 'OU=Terminations'::text)
        ), f AS (
         SELECT e.tbl_employees_id,
            e.badgeid,
            e.ntlogin,
            e.email,
            e.name,
            e.surname,
            e.givenname,
            e.phone,
            e.city,
            e.country,
            mgr.name AS mgr_name,
            mgr.badgeid AS mgr_badgeid,
            mgr.ntlogin AS mgr_ntlogin,
            mgr.email AS mgr_email,
            mgr.phone AS mgr_phone,
            e.distinguishedname
           FROM (e
             LEFT JOIN e mgr ON ((mgr.tbl_employees_id = e.ix_manager_id)))
        )
 SELECT f.tbl_employees_id,
    f.badgeid,
    f.ntlogin,
    f.email,
    f.name,
    f.surname,
    f.givenname,
    f.phone,
    f.city,
    f.country,
    f.mgr_name,
    f.mgr_badgeid,
    f.mgr_ntlogin,
    f.mgr_email,
    f.mgr_phone,
    f.distinguishedname
   FROM f;


ALTER TABLE employee_data OWNER TO postgres;

SET search_path = buildlog, pg_catalog;

--
-- Name: Weekly Build Stats by Director; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly Build Stats by Director" AS
 WITH a AS (
         SELECT z.week,
                CASE
                    WHEN (((y.mgr_ntlogin)::text = 'papadg'::text) OR ((z.director_ntlogin)::text = 'medhig1'::text)) THEN y.name
                    ELSE 'Other'::character varying
                END AS director,
            z.build_duration
           FROM ("Weekly statistics values" z
             LEFT JOIN empdata.employee_data y ON (((y.ntlogin)::text = (z.director_ntlogin)::text)))
          WHERE (((z.build_class)::text = 'Developer'::text) AND (z.week > public.endofweek((('now'::text)::date - '196 days'::interval))) AND (z.week < public.startofweek((('now'::text)::date)::timestamp with time zone)))
        ), b AS (
         SELECT a.week,
            a.director,
            weekly_stats(array_agg(a.build_duration)) AS data
           FROM a
          GROUP BY a.week, a.director
        ), c AS (
         SELECT b.week AS "Week ending",
            b.director,
            (b.data)."number of builds" AS "number of builds",
            (b.data)."median time" AS "median time",
            (b.data)."minimum time" AS "minimum time",
            (b.data)."maximum time" AS "maximum time",
            (b.data)."average time" AS "average time",
            (b.data)."stddev time" AS "stddev time"
           FROM b
          ORDER BY b.week DESC, b.director DESC
        )
 SELECT c."Week ending",
    c.director,
    c."number of builds",
    c."median time",
    c."minimum time",
    c."maximum time",
    c."average time",
    c."stddev time"
   FROM c;


ALTER TABLE "Weekly Build Stats by Director" OWNER TO postgres;

--
-- Name: Weekly Build Times by Director (xtab); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly Build Times by Director (xtab)" AS
 SELECT crosstab."Week ending",
    crosstab."Corniquet, Frederic",
    crosstab."Didier, John",
    crosstab."Flannery, Julie",
    crosstab."He, Zine",
    crosstab."Medhi, Gunajit",
    crosstab."Myers, Brandon",
    crosstab."Yang, Rong",
    crosstab."Zhang, Yiyang",
    crosstab."Other"
   FROM public.crosstab('
select "Week ending"
     , director
     , "median time"
  from buildlog."Weekly Build Stats by Director"
 order by "Week ending"
 '::text, '
select * from (values
        (''Corniquet, Frederic'')
      , (''Didier, John'')
      , (''Flannery, Julie'')
      , (''He, Zine'')
      , (''Medhi, Gunajit'')
      , (''Myers, Brandon'')
      , (''Yang, Rong'')
      , (''Zhang, Yiyang'')
      , (''Other'')
     ) x(director)
 '::text) crosstab("Week ending" date, "Corniquet, Frederic" bigint, "Didier, John" bigint, "Flannery, Julie" bigint, "He, Zine" bigint, "Medhi, Gunajit" bigint, "Myers, Brandon" bigint, "Yang, Rong" bigint, "Zhang, Yiyang" bigint, "Other" bigint);


ALTER TABLE "Weekly Build Times by Director (xtab)" OWNER TO postgres;

--
-- Name: Weekly averages - Builds; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - Builds" AS
 WITH a AS (
         SELECT (metrics.week)::date AS week,
            metrics.build_duration,
            metrics.result
           FROM metrics
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), b AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS pass
           FROM a
          WHERE ((a.result)::text = 'pass'::text)
          GROUP BY a.week
        ), c AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS fail
           FROM a
          WHERE ((a.result)::text = 'fail'::text)
          GROUP BY a.week
        ), d AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS overall
           FROM a
          GROUP BY a.week
        ), e AS (
         SELECT aa.week,
            b.pass,
            c.fail,
            d.overall
           FROM (((aa
             LEFT JOIN b USING (week))
             LEFT JOIN c USING (week))
             LEFT JOIN d USING (week))
        )
 SELECT e.week,
    e.pass,
    e.fail,
    e.overall
   FROM e
  ORDER BY e.week;


ALTER TABLE "Weekly averages - Builds" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - Builds"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - Builds" IS 'Data to produce graph of ''Average "Build+Packaging" Duration for Developers''';


--
-- Name: Weekly averages - Full Build Times; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - Full Build Times" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir,
            etlresults.build_class,
            etlresults.result,
            etlresults.ntid,
            etlresults.build_duration,
            etlresults.comp_count,
            etlresults.arg_count,
            etlresults.hour,
            etlresults.date,
            etlresults.week,
            etlresults.prepare_duration,
            etlresults.prepare_count,
            etlresults.build2_duration,
            etlresults.build2_count,
            etlresults.package_duration,
            etlresults.package_count,
            etlresults.ibid_calc,
            etlresults.m_id,
            etlresults.mask
           FROM (baseresults
             LEFT JOIN etlresults USING (id))
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), i0 AS (
         SELECT z.ibid_calc AS ibid,
            z.id,
            z.component,
            v.phase,
            v.duration,
            u.packaging,
            u.last_improvement,
            u.component_class,
            u.build_type,
            u.mask,
            u."kittyhawk-all"
           FROM ((base z
             LEFT JOIN componentsbyoccurrence v ON ((v.id = z.id)))
             LEFT JOIN componentmeta u ON (((u.component)::text = (v.component)::text)))
          WHERE ((z.fault_class)::text = 'PASS'::text)
        ), i1 AS (
         SELECT i0.id,
            i0.ibid,
            i0.component,
            i0.duration,
            i0.mask
           FROM i0
          WHERE (i0.phase IS NULL)
        ), j1 AS (
         SELECT i0.ibid,
            sum(i0.duration) AS duration,
            bit_or(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          GROUP BY i0.ibid
        ), i2 AS (
         SELECT i0.id,
            i0.ibid,
            i0.component,
            sum(i0.duration) AS duration,
            bit_and(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          WHERE ((((i0.phase)::text = 'build'::text) OR ((i0.phase)::text = 'package'::text)) AND (i0."kittyhawk-all" = true) AND ((i0.component_class)::text <> 'meta'::text))
          GROUP BY i0.id, i0.ibid, i0.component
        ), i2a AS (
         SELECT i2.id,
            i2.ibid,
            i2.component,
            i2.duration,
            i2.mask,
            i2.cnt
           FROM i2
          WHERE ((i2.cnt > 1) AND (i2.mask > 0))
        ), j2 AS (
         SELECT i2a.ibid,
            sum(i2a.duration) AS duration,
            bit_or(i2a.mask) AS mask,
            (count(*) / 2) AS cnt
           FROM i2a
          GROUP BY i2a.ibid
        ), k1 AS (
         SELECT j1.ibid,
            j1.duration,
            j1.mask,
            j1.cnt
           FROM j1
        UNION
         SELECT j2.ibid,
            j2.duration,
            j2.mask,
            j2.cnt
           FROM j2
        ), ibid AS (
         SELECT p.duration,
            y.host_class,
            x.build_class,
            x.week
           FROM ((((((k1 p
             LEFT JOIN ibidresults z ON (((z.ibid)::text = (p.ibid)::text)))
             LEFT JOIN base ON ((z.id = base.id)))
             LEFT JOIN hosts y ON (((base.host)::text = (y.host)::text)))
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN fault_class w ON (((z.fault_class)::text = (w.fault_class)::text)))
             LEFT JOIN ibidextended v ON (((v.id = z.id) AND ((v.ibid)::text = (z.ibid)::text))))
          WHERE (((x.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)) AND ((z.fault_class)::text = 'PASS'::text) AND ((p.mask & '8821886970380'::bigint) = '8821886970380'::bigint))
        ), re AS (
         SELECT ((round(avg(ibid.duration), 0) || ' seconds'::text))::interval AS "RE builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Rel Eng'::text)
          GROUP BY ibid.week
        ), ci AS (
         SELECT ((round(avg(ibid.duration), 0) || ' seconds'::text))::interval AS "CI builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Jenkins'::text)
          GROUP BY ibid.week
        ), dev AS (
         SELECT ((round(avg(ibid.duration), 0) || ' seconds'::text))::interval AS "Developer builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Developer'::text)
          GROUP BY ibid.week
        ), ave AS (
         SELECT ((round(avg(ibid.duration), 0) || ' seconds'::text))::interval AS "Average build duration",
            ibid.week
           FROM ibid
          GROUP BY ibid.week
        ), rslts AS (
         SELECT date(ave.week) AS "Week ending",
            ave."Average build duration",
            re."RE builds",
            ci."CI builds",
            dev."Developer builds"
           FROM (((ave
             LEFT JOIN re USING (week))
             LEFT JOIN ci USING (week))
             LEFT JOIN dev USING (week))
        )
 SELECT rslts."Week ending",
    rslts."Average build duration",
    rslts."RE builds",
    rslts."CI builds",
    rslts."Developer builds"
   FROM rslts
  ORDER BY rslts."Week ending";


ALTER TABLE "Weekly averages - Full Build Times" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - Full Build Times"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - Full Build Times" IS 'Data to produce graph of ''Average "Clean Build+Packaging" Duration for Developers''';


--
-- Name: Weekly averages - Full Build Times (CEC); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - Full Build Times (CEC)" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir,
            etlresults.build_class,
            etlresults.result,
            etlresults.ntid,
            etlresults.build_duration,
            etlresults.comp_count,
            etlresults.arg_count,
            etlresults.hour,
            etlresults.date,
            etlresults.week,
            etlresults.prepare_duration,
            etlresults.prepare_count,
            etlresults.build2_duration,
            etlresults.build2_count,
            etlresults.package_duration,
            etlresults.package_count,
            etlresults.ibid_calc,
            etlresults.m_id,
            etlresults.mask
           FROM (baseresults
             LEFT JOIN etlresults USING (id))
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), i0 AS (
         SELECT z.ibid_calc AS ibid,
            z.id,
            z.component,
            v.phase,
            v.duration,
            u.packaging,
            u.last_improvement,
            u.component_class,
            u.build_type,
            u.mask,
            u."kittyhawk-all"
           FROM ((base z
             LEFT JOIN componentsbyoccurrence v ON ((v.id = z.id)))
             LEFT JOIN componentmeta u ON (((u.component)::text = (v.component)::text)))
          WHERE ((z.fault_class)::text = 'PASS'::text)
        ), i1 AS (
         SELECT i0.id,
            i0.ibid,
            i0.component,
            i0.duration,
            i0.mask
           FROM i0
          WHERE (i0.phase IS NULL)
        ), j1 AS (
         SELECT i0.ibid,
            sum(i0.duration) AS duration,
            bit_or(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          GROUP BY i0.ibid
        ), i2 AS (
         SELECT i0.id,
            i0.ibid,
            i0.component,
            sum(i0.duration) AS duration,
            bit_and(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          WHERE ((((i0.phase)::text = 'build'::text) OR ((i0.phase)::text = 'package'::text)) AND (i0."kittyhawk-all" = true) AND ((i0.component_class)::text <> 'meta'::text))
          GROUP BY i0.id, i0.ibid, i0.component
        ), i2a AS (
         SELECT i2.id,
            i2.ibid,
            i2.component,
            i2.duration,
            i2.mask,
            i2.cnt
           FROM i2
          WHERE ((i2.cnt > 1) AND (i2.mask > 0))
        ), j2 AS (
         SELECT i2a.ibid,
            sum(i2a.duration) AS duration,
            bit_or(i2a.mask) AS mask,
            (count(*) / 2) AS cnt
           FROM i2a
          GROUP BY i2a.ibid
        ), k1 AS (
         SELECT j1.ibid,
            j1.duration,
            j1.mask,
            j1.cnt
           FROM j1
        UNION
         SELECT j2.ibid,
            j2.duration,
            j2.mask,
            j2.cnt
           FROM j2
        ), ibid AS (
         SELECT p.duration,
            y.host_class,
            x.build_class,
            x.week
           FROM ((((((k1 p
             LEFT JOIN ibidresults z ON (((z.ibid)::text = (p.ibid)::text)))
             LEFT JOIN base ON ((z.id = base.id)))
             LEFT JOIN hosts y ON (((base.host)::text = (y.host)::text)))
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN fault_class w ON (((z.fault_class)::text = (w.fault_class)::text)))
             LEFT JOIN ibidextended v ON (((v.id = z.id) AND ((v.ibid)::text = (z.ibid)::text))))
          WHERE (((x.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)) AND ((z.fault_class)::text = 'PASS'::text) AND ((p.mask & '8821886970380'::bigint) = '8821886970380'::bigint) AND ((v.cloud)::text ~* 'CEC'::text))
        ), re AS (
         SELECT ((round(avg(ibid.duration), 0) || ' seconds'::text))::interval AS "RE builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Rel Eng'::text)
          GROUP BY ibid.week
        ), ci AS (
         SELECT ((round(avg(ibid.duration), 0) || ' seconds'::text))::interval AS "CI builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Jenkins'::text)
          GROUP BY ibid.week
        ), dev AS (
         SELECT ((round(avg(ibid.duration), 0) || ' seconds'::text))::interval AS "Developer builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Developer'::text)
          GROUP BY ibid.week
        ), ave AS (
         SELECT ((round(avg(ibid.duration), 0) || ' seconds'::text))::interval AS "Average build duration",
            ibid.week
           FROM ibid
          GROUP BY ibid.week
        ), rslts AS (
         SELECT date(ave.week) AS "Week ending",
            ave."Average build duration",
            re."RE builds",
            ci."CI builds",
            dev."Developer builds"
           FROM (((ave
             LEFT JOIN re USING (week))
             LEFT JOIN ci USING (week))
             LEFT JOIN dev USING (week))
        )
 SELECT rslts."Week ending",
    rslts."Average build duration",
    rslts."RE builds",
    rslts."CI builds",
    rslts."Developer builds"
   FROM rslts
  ORDER BY rslts."Week ending";


ALTER TABLE "Weekly averages - Full Build Times (CEC)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - Full Build Times (CEC)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - Full Build Times (CEC)" IS 'Data to produce graph of ''Average "Clean Build+Packaging" Duration for Developers''';


--
-- Name: Weekly averages - Full Build Times.1; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - Full Build Times.1" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir,
            etlresults.build_class,
            etlresults.result,
            etlresults.ntid,
            etlresults.build_duration,
            etlresults.comp_count,
            etlresults.arg_count,
            etlresults.hour,
            etlresults.date,
            etlresults.week,
            etlresults.prepare_duration,
            etlresults.prepare_count,
            etlresults.build2_duration,
            etlresults.build2_count,
            etlresults.package_duration,
            etlresults.package_count,
            etlresults.ibid_calc,
            etlresults.m_id,
            etlresults.mask
           FROM (baseresults
             LEFT JOIN etlresults USING (id))
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), i0 AS (
         SELECT z.ibid_calc AS ibid,
            z.id,
            z.component,
            v.phase,
            v.duration,
            u.packaging,
            u.last_improvement,
            u.component_class,
            u.build_type,
            u.mask,
            u."kittyhawk-all"
           FROM ((base z
             LEFT JOIN componentsbyoccurrence v ON ((v.id = z.id)))
             LEFT JOIN componentmeta u ON (((u.component)::text = (v.component)::text)))
          WHERE ((z.fault_class)::text = 'PASS'::text)
        ), i1 AS (
         SELECT i0.id,
            i0.component,
            i0.duration
           FROM i0
          WHERE (i0.phase IS NULL)
        ), i2 AS (
         SELECT i0.id,
            i0.component,
            sum(i0.duration) AS duration,
            bit_and(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          WHERE ((((i0.phase)::text = 'build'::text) OR ((i0.phase)::text = 'package'::text)) AND (i0."kittyhawk-all" = true) AND ((i0.component_class)::text <> 'meta'::text))
          GROUP BY i0.id, i0.component
        ), j2 AS (
         SELECT i2.id,
            i2.component,
            i2.duration,
            i2.mask
           FROM i2
          WHERE ((mod(i2.cnt, (2)::bigint) = 0) AND (i2.mask > 0) AND (i2.cnt > 0))
        ), k1 AS (
         SELECT i1.id,
            i1.component,
            i1.duration
           FROM i1
        UNION
         SELECT j2.id,
            j2.component,
            j2.duration
           FROM j2
        ), bld AS (
         SELECT x.week,
            x.build_class,
            p.duration
           FROM ((k1 p
             LEFT JOIN base z ON ((z.id = p.id)))
             LEFT JOIN etlresults x ON ((x.id = p.id)))
          WHERE (((x.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)) AND ((z.fault_class)::text = 'PASS'::text))
        ), re AS (
         SELECT ((round(avg(bld.duration), 0) || ' seconds'::text))::interval AS "RE builds",
            bld.week
           FROM bld
          WHERE ((bld.build_class)::text = 'Rel Eng'::text)
          GROUP BY bld.week
        ), ci AS (
         SELECT ((round(avg(bld.duration), 0) || ' seconds'::text))::interval AS "CI builds",
            bld.week
           FROM bld
          WHERE ((bld.build_class)::text = 'Jenkins'::text)
          GROUP BY bld.week
        ), dev AS (
         SELECT ((round(avg(bld.duration), 0) || ' seconds'::text))::interval AS "Developer builds",
            bld.week
           FROM bld
          WHERE ((bld.build_class)::text = 'Developer'::text)
          GROUP BY bld.week
        ), ave AS (
         SELECT ((round(avg(bld.duration), 0) || ' seconds'::text))::interval AS "Average build duration",
            bld.week
           FROM bld
          GROUP BY bld.week
        ), rslts AS (
         SELECT date(ave.week) AS "Week ending",
            ave."Average build duration",
            re."RE builds",
            ci."CI builds",
            dev."Developer builds"
           FROM (((ave
             LEFT JOIN re USING (week))
             LEFT JOIN ci USING (week))
             LEFT JOIN dev USING (week))
        )
 SELECT rslts."Week ending",
    rslts."Average build duration",
    rslts."RE builds",
    rslts."CI builds",
    rslts."Developer builds"
   FROM rslts
  ORDER BY rslts."Week ending";


ALTER TABLE "Weekly averages - Full Build Times.1" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - Full Build Times.1"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - Full Build Times.1" IS 'Data to produce graph of ''Average "Clean Build+Packaging" Duration for Developers''';


--
-- Name: Weekly averages - Full Build Times.2; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - Full Build Times.2" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir,
            etlresults.build_class,
            etlresults.result,
            etlresults.ntid,
            etlresults.build_duration,
            etlresults.comp_count,
            etlresults.arg_count,
            etlresults.hour,
            etlresults.date,
            etlresults.week,
            etlresults.prepare_duration,
            etlresults.prepare_count,
            etlresults.build2_duration,
            etlresults.build2_count,
            etlresults.package_duration,
            etlresults.package_count,
            etlresults.ibid_calc,
            etlresults.m_id,
            etlresults.mask
           FROM (baseresults
             LEFT JOIN etlresults USING (id))
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), i0 AS (
         SELECT z.ibid_calc AS ibid,
            z.id,
            z.component,
            v.phase,
            v.duration,
            u.packaging,
            u.last_improvement,
            u.component_class,
            u.build_type,
            u.mask,
            u."kittyhawk-all"
           FROM ((base z
             LEFT JOIN componentsbyoccurrence v ON ((v.id = z.id)))
             LEFT JOIN componentmeta u ON (((u.component)::text = (v.component)::text)))
          WHERE ((z.fault_class)::text = 'PASS'::text)
        ), i1 AS (
         SELECT i0.id,
            i0.ibid,
            i0.component,
            i0.duration
           FROM i0
          WHERE (i0.phase IS NULL)
        ), i2 AS (
         SELECT i0.id,
            i0.ibid,
            i0.component,
            sum(i0.duration) AS duration,
            bit_and(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          WHERE ((((i0.phase)::text = 'build'::text) OR ((i0.phase)::text = 'package'::text)) AND (i0."kittyhawk-all" = true) AND ((i0.component_class)::text <> 'meta'::text))
          GROUP BY i0.id, i0.ibid, i0.component
        ), j2 AS (
         SELECT i2.id,
            i2.ibid,
            i2.component,
            i2.duration,
            i2.mask
           FROM i2
          WHERE ((mod(i2.cnt, (2)::bigint) = 0) AND (i2.mask > 0) AND (i2.cnt > 0))
        ), k1 AS (
         SELECT i1.id,
            i1.ibid,
            i1.component,
            i1.duration
           FROM i1
        UNION
         SELECT j2.id,
            j2.ibid,
            j2.component,
            j2.duration
           FROM j2
        ), bld AS (
         SELECT x.week,
            x.build_class,
            y.build_duration
           FROM (((k1 p
             LEFT JOIN base z ON ((z.id = p.id)))
             LEFT JOIN ibidresults y ON (((y.ibid)::text = (p.ibid)::text)))
             LEFT JOIN etlresults x ON ((x.id = y.id)))
          WHERE (((x.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)) AND ((y.fault_class)::text = 'PASS'::text))
        ), re AS (
         SELECT ((round(avg(bld.build_duration), 0) || ' seconds'::text))::interval AS "RE builds",
            bld.week
           FROM bld
          WHERE ((bld.build_class)::text = 'Rel Eng'::text)
          GROUP BY bld.week
        ), ci AS (
         SELECT ((round(avg(bld.build_duration), 0) || ' seconds'::text))::interval AS "CI builds",
            bld.week
           FROM bld
          WHERE ((bld.build_class)::text = 'Jenkins'::text)
          GROUP BY bld.week
        ), dev AS (
         SELECT ((round(avg(bld.build_duration), 0) || ' seconds'::text))::interval AS "Developer builds",
            bld.week
           FROM bld
          WHERE ((bld.build_class)::text = 'Developer'::text)
          GROUP BY bld.week
        ), ave AS (
         SELECT ((round(avg(bld.build_duration), 0) || ' seconds'::text))::interval AS "Average build duration",
            bld.week
           FROM bld
          GROUP BY bld.week
        ), rslts AS (
         SELECT date(ave.week) AS "Week ending",
            ave."Average build duration",
            re."RE builds",
            ci."CI builds",
            dev."Developer builds"
           FROM (((ave
             LEFT JOIN re USING (week))
             LEFT JOIN ci USING (week))
             LEFT JOIN dev USING (week))
        )
 SELECT rslts."Week ending",
    rslts."Average build duration",
    rslts."RE builds",
    rslts."CI builds",
    rslts."Developer builds"
   FROM rslts
  ORDER BY rslts."Week ending";


ALTER TABLE "Weekly averages - Full Build Times.2" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - Full Build Times.2"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - Full Build Times.2" IS 'Data to produce graph of ''Average "Clean Build+Packaging" Duration for Developers''';


--
-- Name: Weekly averages - Full Build Times.3; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - Full Build Times.3" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir,
            etlresults.build_class,
            etlresults.result,
            etlresults.ntid,
            etlresults.build_duration,
            etlresults.comp_count,
            etlresults.arg_count,
            etlresults.hour,
            etlresults.date,
            etlresults.week,
            etlresults.prepare_duration,
            etlresults.prepare_count,
            etlresults.build2_duration,
            etlresults.build2_count,
            etlresults.package_duration,
            etlresults.package_count,
            etlresults.ibid_calc,
            etlresults.m_id,
            etlresults.mask
           FROM (baseresults
             LEFT JOIN etlresults USING (id))
          WHERE ((NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults))) AND (etlresults.build_duration IS NOT NULL))
        ), i0 AS (
         SELECT z.ibid_calc AS ibid,
            z.id,
            z.component,
            v.phase,
            v.duration,
            u.packaging,
            u.last_improvement,
            u.component_class,
            u.build_type,
            u.mask,
            u."kittyhawk-all",
            z.week
           FROM ((base z
             LEFT JOIN componentsbyoccurrence v ON ((v.id = z.id)))
             LEFT JOIN componentmeta u ON (((u.component)::text = (v.component)::text)))
        ), i1 AS (
         SELECT i0.id,
            i0.ibid,
            i0.week,
            i0.component,
            i0.duration,
            '8821886970380'::bigint AS mask,
            0 AS cnt
           FROM i0
          WHERE (i0.phase IS NULL)
        ), i2 AS (
         SELECT i0.id,
            i0.ibid,
            i0.week,
            i0.component,
            sum(i0.duration) AS duration,
            bit_and(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          WHERE ((((i0.phase)::text = 'build'::text) OR ((i0.phase)::text = 'package'::text)) AND (i0."kittyhawk-all" = true) AND ((i0.component_class)::text <> 'meta'::text))
          GROUP BY i0.id, i0.ibid, i0.week, i0.component
        ), j2 AS (
         SELECT i2.id,
            i2.ibid,
            i2.week,
            i2.component,
            i2.duration,
            i2.mask,
            (i2.cnt / 2) AS cnt
           FROM i2
          WHERE ((mod(i2.cnt, (2)::bigint) = 0) AND (i2.mask > 0) AND (i2.cnt > 0))
        ), k1 AS (
         SELECT i1.id,
            i1.ibid,
            i1.week,
            i1.component,
            i1.duration,
            i1.mask,
            i1.cnt
           FROM i1
        UNION
         SELECT j2.id,
            j2.ibid,
            j2.week,
            j2.component,
            j2.duration,
            j2.mask,
            j2.cnt
           FROM j2
        ), bld AS (
         SELECT x.week,
            x.build_class,
            ((y.build_duration || ' seconds'::text))::interval AS duration
           FROM (((k1 p
             LEFT JOIN base z ON ((z.id = p.id)))
             LEFT JOIN ibidresults y ON (((y.ibid)::text = (p.ibid)::text)))
             LEFT JOIN etlresults x ON ((x.id = y.id)))
          WHERE (((y.fault_class)::text = 'PASS'::text) AND (y.build_duration IS NOT NULL) AND (y.build_duration < 34500) AND ((p.mask & '8821886970380'::bigint) = '8821886970380'::bigint))
        ), ibid AS (
         SELECT z.ibid,
            x.build_class,
                CASE
                    WHEN (strpos((z.fault_class)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE w.fault_category
                END AS fault_category,
            ((x.build_duration || ' seconds'::text))::interval AS build_duration,
            x.week
           FROM ((ibidresults z
             LEFT JOIN etlresults x USING (id))
             LEFT JOIN fault_class w ON (((z.fault_class)::text = (w.fault_class)::text)))
          WHERE (NOT ((z.prepare_count >= 0) AND (z.build2_count = 0) AND (z.package_count = 0)))
        ), ibid2 AS (
         SELECT xx.ibid,
            xx.build_class,
            xx.fault_category,
            xx.build_duration,
            xx.week
           FROM ((((ibid xx
             LEFT JOIN ibidresults z ON (((z.ibid)::text = (xx.ibid)::text)))
             LEFT JOIN baseresults y USING (id))
             LEFT JOIN etlresults x USING (id))
             LEFT JOIN hosts v ON (((v.host)::text = (y.host)::text)))
          WHERE (x.build_duration IS NOT NULL)
        ), dv AS (
         SELECT ibid.ibid,
            ibid.build_class,
            ibid.fault_category,
            ibid.build_duration,
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Developer'::text)
        ), dv0 AS (
         SELECT ibid2.ibid,
            ibid2.build_class,
            ibid2.fault_category,
            ibid2.build_duration,
            ibid2.week
           FROM ibid2
          WHERE ((ibid2.build_class)::text = 'Developer'::text)
        ), dv1 AS (
         SELECT '1.Average Build Duration'::text AS id,
            dv0.week,
            date_part('epoch'::text, avg(dv0.build_duration)) AS "Dev"
           FROM dv0
          GROUP BY dv0.week
        UNION
         SELECT '2.Full Build Duration'::text AS id,
            bld.week,
            date_part('epoch'::text, avg(bld.duration)) AS "Dev"
           FROM bld
          WHERE ((bld.build_class)::text = 'Developer'::text)
          GROUP BY bld.week
        UNION
         SELECT '3.Pass__'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Pass'::text)
          GROUP BY dv.week
        UNION
         SELECT '4.Accurev/CMTools'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY dv.week
        UNION
         SELECT '5.Build Avoidance'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY dv.week
        UNION
         SELECT '6.Developer Environment'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Developer Environment'::text)
          GROUP BY dv.week
        UNION
         SELECT '7.NON-developer error'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text IN ( SELECT x.fault_category
                   FROM ( VALUES ('MULTIPLE FAULTS'::text), ('Developer Environment'::text), ('Build Avoidance'::text), ('Accurev/CMTools'::text)) x(fault_category)))
          GROUP BY dv.week
        UNION
         SELECT '8.Developer Error__'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Developer Error'::text)
          GROUP BY dv.week
        UNION
         SELECT '9.Unknown'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Under Investigation'::text)
          GROUP BY dv.week
        UNION
         SELECT 'A.Total builds'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          GROUP BY dv.week
        ), ci AS (
         SELECT ibid.ibid,
            ibid.build_class,
            ibid.fault_category,
            ibid.build_duration,
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Jenkins'::text)
        ), ci0 AS (
         SELECT ibid2.ibid,
            ibid2.build_class,
            ibid2.fault_category,
            ibid2.build_duration,
            ibid2.week
           FROM ibid2
          WHERE ((ibid2.build_class)::text = 'Jenkins'::text)
        ), ci1 AS (
         SELECT '1.Average Build Duration'::text AS id,
            ci0.week,
            date_part('epoch'::text, avg(ci0.build_duration)) AS "CI"
           FROM ci0
          GROUP BY ci0.week
        UNION
         SELECT '2.Full Build Duration'::text AS id,
            bld.week,
            date_part('epoch'::text, avg(bld.duration)) AS "CI"
           FROM bld
          WHERE ((bld.build_class)::text = 'Jenkins'::text)
          GROUP BY bld.week
        UNION
         SELECT '3.Pass__'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Pass'::text)
          GROUP BY ci.week
        UNION
         SELECT '4.Accurev/CMTools'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY ci.week
        UNION
         SELECT '5.Build Avoidance'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY ci.week
        UNION
         SELECT '6.Developer Environment'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Developer Environment'::text)
          GROUP BY ci.week
        UNION
         SELECT '7.NON-developer error'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text IN ( SELECT x.fault_category
                   FROM ( VALUES ('MULTIPLE FAULTS'::text), ('Developer Environment'::text), ('Build Avoidance'::text), ('Accurev/CMTools'::text)) x(fault_category)))
          GROUP BY ci.week
        UNION
         SELECT '8.Developer Error__'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Developer Error'::text)
          GROUP BY ci.week
        UNION
         SELECT '9.Unknown'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Under Investigation'::text)
          GROUP BY ci.week
        UNION
         SELECT 'A.Total builds'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          GROUP BY ci.week
        ), re AS (
         SELECT ibid.ibid,
            ibid.build_class,
            ibid.fault_category,
            ibid.build_duration,
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Rel Eng'::text)
        ), re0 AS (
         SELECT ibid2.ibid,
            ibid2.build_class,
            ibid2.fault_category,
            ibid2.build_duration,
            ibid2.week
           FROM ibid2
          WHERE ((ibid2.build_class)::text = 'Rel Eng'::text)
        ), re1 AS (
         SELECT '1.Average Build Duration'::text AS id,
            re0.week,
            date_part('epoch'::text, avg(re0.build_duration)) AS "RE"
           FROM re0
          GROUP BY re0.week
        UNION
         SELECT '2.Full Build Duration'::text AS id,
            bld.week,
            date_part('epoch'::text, avg(bld.duration)) AS "RE"
           FROM bld
          WHERE ((bld.build_class)::text = 'Rel Eng'::text)
          GROUP BY bld.week
        UNION
         SELECT '3.Pass__'::text AS id,
            re.week,
            count(*) AS "CI"
           FROM re
          WHERE ((re.fault_category)::text = 'Pass'::text)
          GROUP BY re.week
        UNION
         SELECT '4.Accurev/CMTools'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY re.week
        UNION
         SELECT '5.Build Avoidance'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY re.week
        UNION
         SELECT '6.Developer Environment'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text = 'Developer Environment'::text)
          GROUP BY re.week
        UNION
         SELECT '7.NON-developer error'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text IN ( SELECT x.fault_category
                   FROM ( VALUES ('MULTIPLE FAULTS'::text), ('Developer Environment'::text), ('Build Avoidance'::text), ('Accurev/CMTools'::text)) x(fault_category)))
          GROUP BY re.week
        UNION
         SELECT '8.Developer Error__'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text = 'Developer Error'::text)
          GROUP BY re.week
        UNION
         SELECT '9.Unknown'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text = 'Under Investigation'::text)
          GROUP BY re.week
        UNION
         SELECT 'A.Total builds'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          GROUP BY re.week
        ), ax1 AS (
         SELECT '1.Average Build Duration'::text AS id,
            ibid2.week,
            date_part('epoch'::text, avg(ibid2.build_duration)) AS "All"
           FROM ibid2
          GROUP BY ibid2.week
        UNION
         SELECT '2.Full Build Duration'::text AS id,
            bld.week,
            date_part('epoch'::text, avg(bld.duration)) AS "All"
           FROM bld
          GROUP BY bld.week
        UNION
         SELECT '3.Pass__'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Pass'::text)
          GROUP BY ibid.week
        UNION
         SELECT '4.Accurev/CMTools'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY ibid.week
        UNION
         SELECT '5.Build Avoidance'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY ibid.week
        UNION
         SELECT '6.Developer Environment'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Developer Environment'::text)
          GROUP BY ibid.week
        UNION
         SELECT '7.NON-developer error'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text IN ( SELECT x.fault_category
                   FROM ( VALUES ('MULTIPLE FAULTS'::text), ('Developer Environment'::text), ('Build Avoidance'::text), ('Accurev/CMTools'::text)) x(fault_category)))
          GROUP BY ibid.week
        UNION
         SELECT '8.Developer Error__'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Developer Error'::text)
          GROUP BY ibid.week
        UNION
         SELECT '9.Unknown'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Under Investigation'::text)
          GROUP BY ibid.week
        UNION
         SELECT 'A.Total builds'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          GROUP BY ibid.week
        ), smry AS (
         SELECT dv1.week,
            substr(dv1.id, 3) AS "desc",
            dv1."Dev",
            ci1."CI",
            re1."RE",
            ax1."All"
           FROM (((dv1
             LEFT JOIN ci1 ON (((ci1.week = dv1.week) AND (ci1.id = dv1.id))))
             LEFT JOIN re1 ON (((re1.week = dv1.week) AND (re1.id = dv1.id))))
             LEFT JOIN ax1 ON (((ax1.week = dv1.week) AND (ax1.id = dv1.id))))
          ORDER BY dv1.week, dv1.id
        )
 SELECT smry.week,
    smry."desc",
    smry."Dev",
    smry."CI",
    smry."RE",
    smry."All"
   FROM smry;


ALTER TABLE "Weekly averages - Full Build Times.3" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - Full Build Times.3"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - Full Build Times.3" IS 'Data to produce graph of ''Average "Clean Build+Packaging" Duration for Developers''';


--
-- Name: Weekly averages - Host Types; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - Host Types" AS
 WITH a AS (
         SELECT (metrics.week)::date AS week,
            metrics.build_duration,
            metrics.host_category
           FROM metrics
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), c AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS "Durham CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Durham CEC'::text)
          GROUP BY a.week
        ), d AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS "Durham EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Durham EOS2'::text)
          GROUP BY a.week
        ), e AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS "Hopkinton CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton CEC'::text)
          GROUP BY a.week
        ), f AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS "Hopkinton EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton EOS2'::text)
          GROUP BY a.week
        ), g AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS "New Jersey"
           FROM a
          WHERE ((a.host_category)::text = 'New Jersey'::text)
          GROUP BY a.week
        ), h AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS "Paris"
           FROM a
          WHERE ((a.host_category)::text = 'RTP'::text)
          GROUP BY a.week
        ), i AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS "RTP"
           FROM a
          WHERE ((a.host_category)::text = 'Mysterious c4dev'::text)
          GROUP BY a.week
        ), j AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS "Shanghai"
           FROM a
          WHERE ((a.host_category)::text = 'Shanghai'::text)
          GROUP BY a.week
        ), k AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS "St Petersburg"
           FROM a
          WHERE ((a.host_category)::text = 'St Petersburg'::text)
          GROUP BY a.week
        ), l AS (
         SELECT a.week,
            ((round(avg(a.build_duration), 0) || ' seconds'::text))::interval AS "Other"
           FROM a
          WHERE ((a.host_category)::text = 'Other'::text)
          GROUP BY a.week
        ), bb AS (
         SELECT aa.week,
            c."Durham CEC",
            d."Durham EOS2",
            e."Hopkinton CEC",
            f."Hopkinton EOS2",
            g."New Jersey",
            h."Paris",
            i."RTP",
            j."Shanghai",
            k."St Petersburg",
            l."Other"
           FROM ((((((((((aa
             LEFT JOIN c USING (week))
             LEFT JOIN d USING (week))
             LEFT JOIN e USING (week))
             LEFT JOIN f USING (week))
             LEFT JOIN g USING (week))
             LEFT JOIN h USING (week))
             LEFT JOIN i USING (week))
             LEFT JOIN j USING (week))
             LEFT JOIN k USING (week))
             LEFT JOIN l USING (week))
        )
 SELECT bb.week,
    bb."Durham CEC",
    bb."Durham EOS2",
    bb."Hopkinton CEC",
    bb."Hopkinton EOS2",
    bb."New Jersey",
    bb."Paris",
    bb."RTP",
    bb."Shanghai",
    bb."St Petersburg",
    bb."Other"
   FROM bb
  ORDER BY bb.week;


ALTER TABLE "Weekly averages - Host Types" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - Host Types"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - Host Types" IS 'Data to produce graph of ''Weekly Build-Counts for each Host Type''';


--
-- Name: Weekly averages - build_all; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - build_all" AS
 WITH base AS (
         SELECT z.id,
            z.tm,
            z.fault_class,
            z.ibid,
            z."user",
            z.acuser,
            z.host,
            z.hostname,
            z.ipaddr,
            z.status,
            z.stream,
            z.fault_component,
            z.fault_msg,
            z.fault_detail,
            z.init_val,
            z.pwd,
            z.basis,
            z.env_type,
            z.native_env,
            z.run_env,
            z.workspace,
            z.logerr,
            z.logout,
            z.log_subdir,
            z.component,
            z.component_outdir,
            y.build_class,
            y.result,
            y.ntid,
            y.build_duration,
            y.comp_count,
            y.arg_count,
            y.hour,
            y.date,
            y.week,
            y.prepare_duration,
            y.prepare_count,
            y.build2_duration,
            y.build2_count,
            y.package_duration,
            y.package_count,
            y.ibid_calc,
            y.m_id,
            y.mask
           FROM (baseresults z
             LEFT JOIN etlresults y USING (id))
          WHERE (((z.fault_class)::text = 'PASS'::text) AND (NOT (z.id IN ( SELECT suspectresults.id
                   FROM suspectresults))))
        ), re AS (
         SELECT (base.week)::date AS week,
            ((round(avg(base.build_duration), 0) || ' seconds'::text))::interval AS re_build_duration,
            ((round(avg(base.prepare_duration), 0) || ' seconds'::text))::interval AS re_prepare_duration,
            ((round(avg(base.build2_duration), 0) || ' seconds'::text))::interval AS re_build2_duration,
            ((round(avg(base.package_duration), 0) || ' seconds'::text))::interval AS re_package_duration,
            sum(base.comp_count) AS re_comp_count,
            sum(base.prepare_count) AS re_prepare_count,
            sum(base.build2_count) AS re_build2_count,
            sum(base.package_count) AS re_package_count
           FROM base
          WHERE ((base.build_class)::text = 'Rel Eng'::text)
          GROUP BY base.week
        ), ci AS (
         SELECT (base.week)::date AS week,
            ((round(avg(base.build_duration), 0) || ' seconds'::text))::interval AS ci_build_duration,
            ((round(avg(base.prepare_duration), 0) || ' seconds'::text))::interval AS ci_prepare_duration,
            ((round(avg(base.build2_duration), 0) || ' seconds'::text))::interval AS ci_build2_duration,
            ((round(avg(base.package_duration), 0) || ' seconds'::text))::interval AS ci_package_duration,
            sum(base.comp_count) AS ci_comp_count,
            sum(base.prepare_count) AS ci_prepare_count,
            sum(base.build2_count) AS ci_build2_count,
            sum(base.package_count) AS ci_package_count
           FROM base
          WHERE ((base.build_class)::text = 'Jenkins'::text)
          GROUP BY base.week
        ), dev AS (
         SELECT (base.week)::date AS week,
            ((round(avg(base.build_duration), 0) || ' seconds'::text))::interval AS dv_build_duration,
            ((round(avg(base.prepare_duration), 0) || ' seconds'::text))::interval AS dv_prepare_duration,
            ((round(avg(base.build2_duration), 0) || ' seconds'::text))::interval AS dv_build2_duration,
            ((round(avg(base.package_duration), 0) || ' seconds'::text))::interval AS dv_package_duration,
            sum(base.comp_count) AS dv_comp_count,
            sum(base.prepare_count) AS dv_prepare_count,
            sum(base.build2_count) AS dv_build2_count,
            sum(base.package_count) AS dv_package_count
           FROM base
          WHERE ((base.build_class)::text = 'Developer'::text)
          GROUP BY base.week
        ), ave AS (
         SELECT (base.week)::date AS week,
            ((round(avg(base.build_duration), 0) || ' seconds'::text))::interval AS av_build_duration,
            ((round(avg(base.prepare_duration), 0) || ' seconds'::text))::interval AS av_prepare_duration,
            ((round(avg(base.build2_duration), 0) || ' seconds'::text))::interval AS av_build2_duration,
            ((round(avg(base.package_duration), 0) || ' seconds'::text))::interval AS av_package_duration,
            sum(base.comp_count) AS av_comp_count,
            sum(base.prepare_count) AS av_prepare_count,
            sum(base.build2_count) AS av_build2_count,
            sum(base.package_count) AS av_package_count
           FROM base
          GROUP BY base.week
        ), rslts AS (
         SELECT ave.week,
            ave.av_build_duration,
            ave.av_prepare_duration,
            ave.av_build2_duration,
            ave.av_package_duration,
            ci.ci_build_duration,
            ci.ci_prepare_duration,
            ci.ci_build2_duration,
            ci.ci_package_duration,
            dev.dv_build_duration,
            dev.dv_prepare_duration,
            dev.dv_build2_duration,
            dev.dv_package_duration,
            re.re_build_duration,
            re.re_prepare_duration,
            re.re_build2_duration,
            re.re_package_duration,
            ave.av_comp_count,
            ave.av_prepare_count,
            ave.av_build2_count,
            ave.av_package_count,
            ci.ci_comp_count,
            ci.ci_prepare_count,
            ci.ci_build2_count,
            ci.ci_package_count,
            dev.dv_comp_count,
            dev.dv_prepare_count,
            dev.dv_build2_count,
            dev.dv_package_count,
            re.re_comp_count,
            re.re_prepare_count,
            re.re_build2_count,
            re.re_package_count
           FROM (((ave
             LEFT JOIN re USING (week))
             LEFT JOIN ci USING (week))
             LEFT JOIN dev USING (week))
        )
 SELECT rslts.week,
    rslts.av_build_duration,
    rslts.av_prepare_duration,
    rslts.av_build2_duration,
    rslts.av_package_duration,
    rslts.ci_build_duration,
    rslts.ci_prepare_duration,
    rslts.ci_build2_duration,
    rslts.ci_package_duration,
    rslts.dv_build_duration,
    rslts.dv_prepare_duration,
    rslts.dv_build2_duration,
    rslts.dv_package_duration,
    rslts.re_build_duration,
    rslts.re_prepare_duration,
    rslts.re_build2_duration,
    rslts.re_package_duration,
    rslts.av_comp_count,
    rslts.av_prepare_count,
    rslts.av_build2_count,
    rslts.av_package_count,
    rslts.ci_comp_count,
    rslts.ci_prepare_count,
    rslts.ci_build2_count,
    rslts.ci_package_count,
    rslts.dv_comp_count,
    rslts.dv_prepare_count,
    rslts.dv_build2_count,
    rslts.dv_package_count,
    rslts.re_comp_count,
    rslts.re_prepare_count,
    rslts.re_build2_count,
    rslts.re_package_count
   FROM rslts
  ORDER BY rslts.week;


ALTER TABLE "Weekly averages - build_all" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - build_all"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - build_all" IS 'Data to produce graph of ''Weekly averages - build_all''';


--
-- Name: Weekly averages - components; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - components" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir
           FROM baseresults
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), bcmpts AS (
         SELECT z.id,
            z.component,
            sum(z.duration) AS duration,
            every(((z.phase)::text = 'prepare'::text)) AS prepare,
            y.component_class AS packaging
           FROM (componentsbyoccurrence z
             LEFT JOIN componentmeta y ON (((y.component)::text = (z.component)::text)))
          WHERE ((y.component_class)::text <> 'meta'::text)
          GROUP BY z.id, z.component, y.component_class
        ), cmpts AS (
         SELECT bcmpts.id,
            bcmpts.component,
            bcmpts.duration,
            bcmpts.packaging
           FROM bcmpts
          WHERE ((bcmpts.prepare = false) OR (bcmpts.prepare IS NULL))
        ), a AS (
         SELECT (y.week)::date AS week,
                CASE
                    WHEN (((cmpts.component)::text = 'bseye'::text) OR ((cmpts.component)::text = 'bullseye'::text)) THEN 'bseyecov'::character varying
                    ELSE cmpts.component
                END AS component,
            y.result,
            cmpts.duration,
            y.build_class,
            base.fault_component
           FROM ((((base
             LEFT JOIN etlresults y ON ((base.id = y.id)))
             LEFT JOIN hosts x ON (((base.host)::text = (x.host)::text)))
             LEFT JOIN fault_class w ON (((base.fault_class)::text = (w.fault_class)::text)))
             LEFT JOIN cmpts ON ((base.id = cmpts.id)))
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), ap AS (
         SELECT a.week,
            a.component,
            a.duration
           FROM a
          WHERE (((a.result)::text = 'pass'::text) OR ((a.component)::text <> (a.fault_component)::text))
        ), p02 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS bamxml
           FROM ap
          WHERE ((ap.component)::text = 'bamxml'::text)
          GROUP BY ap.week
        ), p03 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS blockshim_ng
           FROM ap
          WHERE ((ap.component)::text = 'blockshim_ng'::text)
          GROUP BY ap.week
        ), p04 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS bootflash
           FROM ap
          WHERE ((ap.component)::text = 'bootflash'::text)
          GROUP BY ap.week
        ), p06 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS bseyecov
           FROM ap
          WHERE ((ap.component)::text = 'bseyecov'::text)
          GROUP BY ap.week
        ), p07 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS build
           FROM ap
          WHERE ((ap.component)::text = 'build'::text)
          GROUP BY ap.week
        ), p09 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS c4core
           FROM ap
          WHERE ((ap.component)::text = 'c4core'::text)
          GROUP BY ap.week
        ), p10 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS c4csx
           FROM ap
          WHERE ((ap.component)::text = 'c4csx'::text)
          GROUP BY ap.week
        ), p11 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS cemgui
           FROM ap
          WHERE ((ap.component)::text = 'cemgui'::text)
          GROUP BY ap.week
        ), p12 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS clariion
           FROM ap
          WHERE ((ap.component)::text = 'clariion'::text)
          GROUP BY ap.week
        ), p13 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS cloudarray
           FROM ap
          WHERE ((ap.component)::text = 'cloudarray'::text)
          GROUP BY ap.week
        ), p14 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS cp
           FROM ap
          WHERE ((ap.component)::text = 'cp'::text)
          GROUP BY ap.week
        ), p15 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS cstarball
           FROM ap
          WHERE ((ap.component)::text = 'cstarball'::text)
          GROUP BY ap.week
        ), p16 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS cta
           FROM ap
          WHERE ((ap.component)::text = 'cta'::text)
          GROUP BY ap.week
        ), p17 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS cumulus
           FROM ap
          WHERE ((ap.component)::text = 'cumulus'::text)
          GROUP BY ap.week
        ), p18 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS driver
           FROM ap
          WHERE ((ap.component)::text = 'driver'::text)
          GROUP BY ap.week
        ), p19 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS econtrolstation
           FROM ap
          WHERE ((ap.component)::text = 'econtrolstation'::text)
          GROUP BY ap.week
        ), p20 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS gms
           FROM ap
          WHERE ((ap.component)::text = 'gms'::text)
          GROUP BY ap.week
        ), p21 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS healthchecks
           FROM ap
          WHERE ((ap.component)::text = 'healthchecks'::text)
          GROUP BY ap.week
        ), p22 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS image
           FROM ap
          WHERE ((ap.component)::text = 'image'::text)
          GROUP BY ap.week
        ), p23 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS imager
           FROM ap
          WHERE ((ap.component)::text = 'imager'::text)
          GROUP BY ap.week
        ), p24 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS infrastructureproviders
           FROM ap
          WHERE ((ap.component)::text = 'infrastructureproviders'::text)
          GROUP BY ap.week
        ), p25 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS ipreflect
           FROM ap
          WHERE ((ap.component)::text = 'ipreflect'::text)
          GROUP BY ap.week
        ), p26 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS javacli
           FROM ap
          WHERE ((ap.component)::text = 'javacli'::text)
          GROUP BY ap.week
        ), p27 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS jiff
           FROM ap
          WHERE ((ap.component)::text = 'jiff'::text)
          GROUP BY ap.week
        ), p28 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS jiffcommon
           FROM ap
          WHERE ((ap.component)::text = 'jiffcommon'::text)
          GROUP BY ap.week
        ), p29 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS jmi
           FROM ap
          WHERE ((ap.component)::text = 'jmi'::text)
          GROUP BY ap.week
        ), p30 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS kernel
           FROM ap
          WHERE ((ap.component)::text = 'kernel'::text)
          GROUP BY ap.week
        ), p31 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS languages
           FROM ap
          WHERE ((ap.component)::text = 'languages'::text)
          GROUP BY ap.week
        ), p32 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS libpsm
           FROM ap
          WHERE ((ap.component)::text = 'libpsm'::text)
          GROUP BY ap.week
        ), p33 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS mf
           FROM ap
          WHERE ((ap.component)::text = 'mf'::text)
          GROUP BY ap.week
        ), p34 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS mf_common
           FROM ap
          WHERE ((ap.component)::text = 'mf_common'::text)
          GROUP BY ap.week
        ), p35 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS nxgui
           FROM ap
          WHERE ((ap.component)::text = 'nxgui'::text)
          GROUP BY ap.week
        ), p36 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS observability
           FROM ap
          WHERE ((ap.component)::text = 'observability'::text)
          GROUP BY ap.week
        ), p37 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS ofed
           FROM ap
          WHERE ((ap.component)::text = 'ofed'::text)
          GROUP BY ap.week
        ), p39 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS papi
           FROM ap
          WHERE ((ap.component)::text = 'papi'::text)
          GROUP BY ap.week
        ), p40 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS perf
           FROM ap
          WHERE ((ap.component)::text = 'perf'::text)
          GROUP BY ap.week
        ), p42 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS restcommon
           FROM ap
          WHERE ((ap.component)::text = 'restcommon'::text)
          GROUP BY ap.week
        ), p43 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS rpms
           FROM ap
          WHERE ((ap.component)::text = 'rpms'::text)
          GROUP BY ap.week
        ), p44 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS rpmsinfq
           FROM ap
          WHERE ((ap.component)::text = 'rpmsinfq'::text)
          GROUP BY ap.week
        ), p45 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS sade
           FROM ap
          WHERE ((ap.component)::text = 'sade'::text)
          GROUP BY ap.week
        ), p46 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS safe
           FROM ap
          WHERE ((ap.component)::text = 'safe'::text)
          GROUP BY ap.week
        ), p47 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS security
           FROM ap
          WHERE ((ap.component)::text = 'security'::text)
          GROUP BY ap.week
        ), p48 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS serviceability
           FROM ap
          WHERE ((ap.component)::text = 'serviceability'::text)
          GROUP BY ap.week
        ), p50 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS sles
           FROM ap
          WHERE ((ap.component)::text = 'sles'::text)
          GROUP BY ap.week
        ), p51 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS "sys-common"
           FROM ap
          WHERE ((ap.component)::text = 'sys-common'::text)
          GROUP BY ap.week
        ), p52 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS systemtap
           FROM ap
          WHERE ((ap.component)::text = 'systemtap'::text)
          GROUP BY ap.week
        ), p53 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS tbn
           FROM ap
          WHERE ((ap.component)::text = 'tbn'::text)
          GROUP BY ap.week
        ), p54 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS tomcatcommon
           FROM ap
          WHERE ((ap.component)::text = 'tomcatcommon'::text)
          GROUP BY ap.week
        ), p55 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS udoctor
           FROM ap
          WHERE ((ap.component)::text = 'udoctor'::text)
          GROUP BY ap.week
        ), p56 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS uemcli
           FROM ap
          WHERE ((ap.component)::text = 'uemcli'::text)
          GROUP BY ap.week
        ), p57 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS unirest
           FROM ap
          WHERE ((ap.component)::text = 'unirest'::text)
          GROUP BY ap.week
        ), p58 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS univasa
           FROM ap
          WHERE ((ap.component)::text = 'univasa'::text)
          GROUP BY ap.week
        ), p59 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS upgrade
           FROM ap
          WHERE ((ap.component)::text = 'upgrade'::text)
          GROUP BY ap.week
        ), p60 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS vmwaresdkclient
           FROM ap
          WHERE ((ap.component)::text = 'vmwaresdkclient'::text)
          GROUP BY ap.week
        ), p61 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS vsockets
           FROM ap
          WHERE ((ap.component)::text = 'vsockets'::text)
          GROUP BY ap.week
        ), p62 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS vtune
           FROM ap
          WHERE ((ap.component)::text = 'vtune'::text)
          GROUP BY ap.week
        ), p63 AS (
         SELECT ap.week,
            ((round(avg(ap.duration), 0) || ' seconds'::text))::interval AS vvnxdeploydual
           FROM ap
          WHERE ((ap.component)::text = 'vvnxdeploydual'::text)
          GROUP BY ap.week
        ), pp AS (
         SELECT aa.week,
            p02.bamxml,
            p03.blockshim_ng,
            p04.bootflash,
            p06.bseyecov,
            p07.build,
            p09.c4core,
            p10.c4csx,
            p11.cemgui,
            p12.clariion,
            p13.cloudarray,
            p14.cp,
            p15.cstarball,
            p16.cta,
            p17.cumulus,
            p18.driver,
            p19.econtrolstation,
            p20.gms,
            p21.healthchecks,
            p22.image,
            p23.imager,
            p24.infrastructureproviders,
            p25.ipreflect,
            p26.javacli,
            p27.jiff,
            p28.jiffcommon,
            p29.jmi,
            p30.kernel,
            p31.languages,
            p32.libpsm,
            p33.mf,
            p34.mf_common,
            p35.nxgui,
            p36.observability,
            p37.ofed,
            p39.papi,
            p40.perf,
            p42.restcommon,
            p43.rpms,
            p44.rpmsinfq,
            p45.sade,
            p46.safe,
            p47.security,
            p48.serviceability,
            p50.sles,
            p51."sys-common",
            p52.systemtap,
            p53.tbn,
            p54.tomcatcommon,
            p55.udoctor,
            p56.uemcli,
            p57.unirest,
            p58.univasa,
            p59.upgrade,
            p60.vmwaresdkclient,
            p61.vsockets,
            p62.vtune,
            p63.vvnxdeploydual
           FROM (((((((((((((((((((((((((((((((((((((((((((((((((((((((((aa
             LEFT JOIN p02 USING (week))
             LEFT JOIN p03 USING (week))
             LEFT JOIN p04 USING (week))
             LEFT JOIN p06 USING (week))
             LEFT JOIN p07 USING (week))
             LEFT JOIN p09 USING (week))
             LEFT JOIN p10 USING (week))
             LEFT JOIN p11 USING (week))
             LEFT JOIN p12 USING (week))
             LEFT JOIN p13 USING (week))
             LEFT JOIN p14 USING (week))
             LEFT JOIN p15 USING (week))
             LEFT JOIN p16 USING (week))
             LEFT JOIN p17 USING (week))
             LEFT JOIN p18 USING (week))
             LEFT JOIN p19 USING (week))
             LEFT JOIN p20 USING (week))
             LEFT JOIN p21 USING (week))
             LEFT JOIN p22 USING (week))
             LEFT JOIN p23 USING (week))
             LEFT JOIN p24 USING (week))
             LEFT JOIN p25 USING (week))
             LEFT JOIN p26 USING (week))
             LEFT JOIN p27 USING (week))
             LEFT JOIN p28 USING (week))
             LEFT JOIN p29 USING (week))
             LEFT JOIN p30 USING (week))
             LEFT JOIN p31 USING (week))
             LEFT JOIN p32 USING (week))
             LEFT JOIN p33 USING (week))
             LEFT JOIN p34 USING (week))
             LEFT JOIN p35 USING (week))
             LEFT JOIN p36 USING (week))
             LEFT JOIN p37 USING (week))
             LEFT JOIN p39 USING (week))
             LEFT JOIN p40 USING (week))
             LEFT JOIN p42 USING (week))
             LEFT JOIN p43 USING (week))
             LEFT JOIN p44 USING (week))
             LEFT JOIN p45 USING (week))
             LEFT JOIN p46 USING (week))
             LEFT JOIN p47 USING (week))
             LEFT JOIN p48 USING (week))
             LEFT JOIN p50 USING (week))
             LEFT JOIN p51 USING (week))
             LEFT JOIN p52 USING (week))
             LEFT JOIN p53 USING (week))
             LEFT JOIN p54 USING (week))
             LEFT JOIN p55 USING (week))
             LEFT JOIN p56 USING (week))
             LEFT JOIN p57 USING (week))
             LEFT JOIN p58 USING (week))
             LEFT JOIN p59 USING (week))
             LEFT JOIN p60 USING (week))
             LEFT JOIN p61 USING (week))
             LEFT JOIN p62 USING (week))
             LEFT JOIN p63 USING (week))
        )
 SELECT pp.week,
    pp.bamxml,
    pp.blockshim_ng,
    pp.bootflash,
    pp.bseyecov,
    pp.build,
    pp.c4core,
    pp.c4csx,
    pp.cemgui,
    pp.clariion,
    pp.cloudarray,
    pp.cp,
    pp.cstarball,
    pp.cta,
    pp.cumulus,
    pp.driver,
    pp.econtrolstation,
    pp.gms,
    pp.healthchecks,
    pp.image,
    pp.imager,
    pp.infrastructureproviders,
    pp.ipreflect,
    pp.javacli,
    pp.jiff,
    pp.jiffcommon,
    pp.jmi,
    pp.kernel,
    pp.languages,
    pp.libpsm,
    pp.mf,
    pp.mf_common,
    pp.nxgui,
    pp.observability,
    pp.ofed,
    pp.papi,
    pp.perf,
    pp.restcommon,
    pp.rpms,
    pp.rpmsinfq,
    pp.sade,
    pp.safe,
    pp.security,
    pp.serviceability,
    pp.sles,
    pp."sys-common",
    pp.systemtap,
    pp.tbn,
    pp.tomcatcommon,
    pp.udoctor,
    pp.uemcli,
    pp.unirest,
    pp.univasa,
    pp.upgrade,
    pp.vmwaresdkclient,
    pp.vsockets,
    pp.vtune,
    pp.vvnxdeploydual
   FROM pp
  ORDER BY pp.week;


ALTER TABLE "Weekly averages - components" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Weekly averages - components_bld (CI); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - components_bld (CI)" AS
 SELECT average_components_bld.week,
    average_components_bld.bamxml,
    average_components_bld.blockshim_ng,
    average_components_bld.c4core,
    average_components_bld.c4csx,
    average_components_bld.cemgui,
    average_components_bld.clariion,
    average_components_bld.cp,
    average_components_bld.cta,
    average_components_bld.cumulus,
    average_components_bld.gms,
    average_components_bld.healthchecks,
    average_components_bld.infrastructureproviders,
    average_components_bld.jmi,
    average_components_bld.kernel,
    average_components_bld.libpsm,
    average_components_bld.mf,
    average_components_bld.mf_common,
    average_components_bld.nxgui,
    average_components_bld.observability,
    average_components_bld.papi,
    average_components_bld.restcommon,
    average_components_bld.sade,
    average_components_bld.safe,
    average_components_bld.security,
    average_components_bld.serviceability,
    average_components_bld.tbn,
    average_components_bld.tomcatcommon,
    average_components_bld.udoctor,
    average_components_bld.uemcli,
    average_components_bld.unirest,
    average_components_bld.univasa,
    average_components_bld.vmwaresdkclient,
    average_components_bld.vvnxdeploydual
   FROM average_components_bld('Jenkins'::text) average_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual);


ALTER TABLE "Weekly averages - components_bld (CI)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_bld (CI)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_bld (CI)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Weekly averages - components_bld (DE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - components_bld (DE)" AS
 SELECT average_components_bld.week,
    average_components_bld.bamxml,
    average_components_bld.blockshim_ng,
    average_components_bld.c4core,
    average_components_bld.c4csx,
    average_components_bld.cemgui,
    average_components_bld.clariion,
    average_components_bld.cp,
    average_components_bld.cta,
    average_components_bld.cumulus,
    average_components_bld.gms,
    average_components_bld.healthchecks,
    average_components_bld.infrastructureproviders,
    average_components_bld.jmi,
    average_components_bld.kernel,
    average_components_bld.libpsm,
    average_components_bld.mf,
    average_components_bld.mf_common,
    average_components_bld.nxgui,
    average_components_bld.observability,
    average_components_bld.papi,
    average_components_bld.restcommon,
    average_components_bld.sade,
    average_components_bld.safe,
    average_components_bld.security,
    average_components_bld.serviceability,
    average_components_bld.tbn,
    average_components_bld.tomcatcommon,
    average_components_bld.udoctor,
    average_components_bld.uemcli,
    average_components_bld.unirest,
    average_components_bld.univasa,
    average_components_bld.vmwaresdkclient,
    average_components_bld.vvnxdeploydual
   FROM average_components_bld('Developer'::text) average_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual);


ALTER TABLE "Weekly averages - components_bld (DE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_bld (DE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_bld (DE)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Weekly averages - components_bld (RE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - components_bld (RE)" AS
 SELECT average_components_bld.week,
    average_components_bld.bamxml,
    average_components_bld.blockshim_ng,
    average_components_bld.c4core,
    average_components_bld.c4csx,
    average_components_bld.cemgui,
    average_components_bld.clariion,
    average_components_bld.cp,
    average_components_bld.cta,
    average_components_bld.cumulus,
    average_components_bld.gms,
    average_components_bld.healthchecks,
    average_components_bld.infrastructureproviders,
    average_components_bld.jmi,
    average_components_bld.kernel,
    average_components_bld.libpsm,
    average_components_bld.mf,
    average_components_bld.mf_common,
    average_components_bld.nxgui,
    average_components_bld.observability,
    average_components_bld.papi,
    average_components_bld.restcommon,
    average_components_bld.sade,
    average_components_bld.safe,
    average_components_bld.security,
    average_components_bld.serviceability,
    average_components_bld.tbn,
    average_components_bld.tomcatcommon,
    average_components_bld.udoctor,
    average_components_bld.uemcli,
    average_components_bld.unirest,
    average_components_bld.univasa,
    average_components_bld.vmwaresdkclient,
    average_components_bld.vvnxdeploydual
   FROM average_components_bld('Rel Eng'::text) average_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual);


ALTER TABLE "Weekly averages - components_bld (RE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_bld (RE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_bld (RE)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Weekly averages - components_meta (CI); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - components_meta (CI)" AS
 SELECT average_components_meta.week,
    average_components_meta."all",
    average_components_meta.build,
    average_components_meta.package,
    average_components_meta.prepare,
    average_components_meta.setup
   FROM average_components_meta('Jenkins'::text) average_components_meta(week, "all", build, package, prepare, setup);


ALTER TABLE "Weekly averages - components_meta (CI)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_meta (CI)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_meta (CI)" IS 'Data to produce graph of ''Distribution of Component average meta duration for week''';


--
-- Name: Weekly averages - components_meta (DE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - components_meta (DE)" AS
 SELECT average_components_meta.week,
    average_components_meta."all",
    average_components_meta.build,
    average_components_meta.package,
    average_components_meta.prepare,
    average_components_meta.setup
   FROM average_components_meta('Developer'::text) average_components_meta(week, "all", build, package, prepare, setup);


ALTER TABLE "Weekly averages - components_meta (DE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_meta (DE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_meta (DE)" IS 'Data to produce graph of ''Distribution of Component average meta duration for week''';


--
-- Name: Weekly averages - components_meta (RE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - components_meta (RE)" AS
 SELECT average_components_meta.week,
    average_components_meta."all",
    average_components_meta.build,
    average_components_meta.package,
    average_components_meta.prepare,
    average_components_meta.setup
   FROM average_components_meta('Rel Eng'::text) average_components_meta(week, "all", build, package, prepare, setup);


ALTER TABLE "Weekly averages - components_meta (RE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_meta (RE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_meta (RE)" IS 'Data to produce graph of ''Distribution of Component average meta duration for week''';


--
-- Name: Weekly averages - components_pkg (CI); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - components_pkg (CI)" AS
 SELECT average_components_pkg.week,
    average_components_pkg.bootflash,
    average_components_pkg.econtrolstation,
    average_components_pkg.image,
    average_components_pkg.languages,
    average_components_pkg.rpms,
    average_components_pkg.rpmsinfq,
    average_components_pkg.systemtap,
    average_components_pkg.vtune
   FROM average_components_pkg('Jenkins'::text) average_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune);


ALTER TABLE "Weekly averages - components_pkg (CI)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_pkg (CI)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_pkg (CI)" IS 'Data to produce graph of ''Distribution of Component average package duration for week''';


--
-- Name: Weekly averages - components_pkg (DE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - components_pkg (DE)" AS
 SELECT average_components_pkg.week,
    average_components_pkg.bootflash,
    average_components_pkg.econtrolstation,
    average_components_pkg.image,
    average_components_pkg.languages,
    average_components_pkg.rpms,
    average_components_pkg.rpmsinfq,
    average_components_pkg.systemtap,
    average_components_pkg.vtune
   FROM average_components_pkg('Developer'::text) average_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune);


ALTER TABLE "Weekly averages - components_pkg (DE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_pkg (DE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_pkg (DE)" IS 'Data to produce graph of ''Distribution of Component average package duration for week''';


--
-- Name: Weekly averages - components_pkg (RE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly averages - components_pkg (RE)" AS
 SELECT average_components_pkg.week,
    average_components_pkg.bootflash,
    average_components_pkg.econtrolstation,
    average_components_pkg.image,
    average_components_pkg.languages,
    average_components_pkg.rpms,
    average_components_pkg.rpmsinfq,
    average_components_pkg.systemtap,
    average_components_pkg.vtune
   FROM average_components_pkg('Rel Eng'::text) average_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune);


ALTER TABLE "Weekly averages - components_pkg (RE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_pkg (RE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_pkg (RE)" IS 'Data to produce graph of ''Distribution of Component average package duration for week''';


--
-- Name: Weekly counts - Build Types; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - Build Types" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir
           FROM baseresults
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), ibid AS (
         SELECT z.id,
            z.fault_class,
            z.prepare_count,
            z.build2_count,
            z.package_count,
            z.ibid,
            y.host_class,
            x.build_class,
            (x.week)::date AS week
           FROM (((ibidresults z
             LEFT JOIN base ON ((z.id = base.id)))
             LEFT JOIN hosts y ON (((base.host)::text = (y.host)::text)))
             LEFT JOIN etlresults x ON ((z.id = x.id)))
        ), rslts AS (
         SELECT ibid.id,
            ibid.fault_class,
            ibid.prepare_count,
            ibid.build2_count,
            ibid.package_count,
            ibid.ibid,
            ibid.host_class,
            ibid.build_class,
            ibid.week
           FROM ibid
          WHERE ((ibid.week < public.startofweek((('now'::text)::date)::timestamp with time zone)) AND (NOT ((ibid.prepare_count >= 0) AND (ibid.build2_count = 0) AND (ibid.package_count = 0))))
        ), a AS (
         SELECT rslts.week,
            count(*) AS "Developer"
           FROM rslts
          WHERE ((rslts.build_class)::text = 'Developer'::text)
          GROUP BY rslts.week
        ), b AS (
         SELECT rslts.week,
            count(*) AS "Jenkins"
           FROM rslts
          WHERE ((rslts.build_class)::text = 'Jenkins'::text)
          GROUP BY rslts.week
        ), c AS (
         SELECT rslts.week,
            count(*) AS "Rel Eng"
           FROM rslts
          WHERE ((rslts.build_class)::text = 'Rel Eng'::text)
          GROUP BY rslts.week
        ), d AS (
         SELECT a.week,
            a."Developer",
            b."Jenkins",
            c."Rel Eng",
            ((a."Developer" + b."Jenkins") + c."Rel Eng") AS total
           FROM ((a
             LEFT JOIN b USING (week))
             LEFT JOIN c USING (week))
        )
 SELECT d.week,
    d."Developer",
    d."Jenkins",
    d."Rel Eng",
    d.total
   FROM d
  ORDER BY d.week;


ALTER TABLE "Weekly counts - Build Types" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Build Types"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Build Types" IS 'Data to produce graph of ''Distribution of Builds by Build Type''';


--
-- Name: Weekly counts - Builds; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - Builds" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir
           FROM baseresults
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), ibid AS (
         SELECT z.result,
            (x.week)::date AS week
           FROM (ibidresults z
             LEFT JOIN etlresults x USING (id))
        ), a AS (
         SELECT ibid.week,
            ibid.result
           FROM ibid
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), b AS (
         SELECT a.week,
            count(*) AS pass
           FROM a
          WHERE ((a.result)::text = 'pass'::text)
          GROUP BY a.week
        ), c AS (
         SELECT a.week,
            count(*) AS fail
           FROM a
          WHERE ((a.result)::text = 'fail'::text)
          GROUP BY a.week
        ), d AS (
         SELECT aa.week,
            b.pass,
            c.fail
           FROM ((aa
             LEFT JOIN b USING (week))
             LEFT JOIN c USING (week))
          WHERE (aa.week < public.startofweek((('now'::text)::date)::timestamp with time zone))
        )
 SELECT d.week,
    d.pass,
    d.fail
   FROM d
  ORDER BY d.week;


ALTER TABLE "Weekly counts - Builds" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Builds"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Builds" IS 'Data to produce graph of ''Number of Builds per Week''';


--
-- Name: Weekly counts - Fault-Categories; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - Fault-Categories" AS
 WITH a AS (
         SELECT (metrics.week)::date AS week,
            metrics.fault_category,
            metrics.build_class
           FROM metrics
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), a0 AS (
         SELECT a.week,
            count(*) AS "All: Under Investigation"
           FROM a
          WHERE ((a.fault_category)::text = 'Under Investigation'::text)
          GROUP BY a.week
        ), a1 AS (
         SELECT a.week,
            count(*) AS "All: Accurev/CMTools"
           FROM a
          WHERE ((a.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY a.week
        ), a2 AS (
         SELECT a.week,
            count(*) AS "All: Developer Environment"
           FROM a
          WHERE ((a.fault_category)::text = 'Developer Environment'::text)
          GROUP BY a.week
        ), a3 AS (
         SELECT a.week,
            count(*) AS "All: Pass"
           FROM a
          WHERE ((a.fault_category)::text = 'Pass'::text)
          GROUP BY a.week
        ), a4 AS (
         SELECT a.week,
            count(*) AS "All: Developer Error"
           FROM a
          WHERE ((a.fault_category)::text = 'Developer Error'::text)
          GROUP BY a.week
        ), a5 AS (
         SELECT a.week,
            count(*) AS "All: Build Avoidance"
           FROM a
          WHERE ((a.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY a.week
        ), a6 AS (
         SELECT a.week,
            count(*) AS "All: MULTIPLE FAULTS"
           FROM a
          WHERE ((a.fault_category)::text = 'MULTIPLE FAULTS'::text)
          GROUP BY a.week
        ), b AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Developer'::text)
        ), bb AS (
         SELECT b.week,
            count(*) AS "DV: All"
           FROM b
          GROUP BY b.week
        ), b0 AS (
         SELECT b.week,
            count(*) AS "DV: Under Investigation"
           FROM b
          WHERE ((b.fault_category)::text = 'Under Investigation'::text)
          GROUP BY b.week
        ), b1 AS (
         SELECT b.week,
            count(*) AS "DV: Accurev/CMTools"
           FROM b
          WHERE ((b.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY b.week
        ), b2 AS (
         SELECT b.week,
            count(*) AS "DV: Developer Environment"
           FROM b
          WHERE ((b.fault_category)::text = 'Developer Environment'::text)
          GROUP BY b.week
        ), b3 AS (
         SELECT b.week,
            count(*) AS "DV: Pass"
           FROM b
          WHERE ((b.fault_category)::text = 'Pass'::text)
          GROUP BY b.week
        ), b4 AS (
         SELECT b.week,
            count(*) AS "DV: Developer Error"
           FROM b
          WHERE ((b.fault_category)::text = 'Developer Error'::text)
          GROUP BY b.week
        ), b5 AS (
         SELECT b.week,
            count(*) AS "DV: Build Avoidance"
           FROM b
          WHERE ((b.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY b.week
        ), b6 AS (
         SELECT b.week,
            count(*) AS "DV: MULTIPLE FAULTS"
           FROM b
          WHERE ((b.fault_category)::text = 'MULTIPLE FAULTS'::text)
          GROUP BY b.week
        ), c AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Jenkins'::text)
        ), cc AS (
         SELECT c.week,
            count(*) AS "CI: All"
           FROM c
          GROUP BY c.week
        ), c0 AS (
         SELECT c.week,
            count(*) AS "CI: Under Investigation"
           FROM c
          WHERE ((c.fault_category)::text = 'Under Investigation'::text)
          GROUP BY c.week
        ), c1 AS (
         SELECT c.week,
            count(*) AS "CI: Accurev/CMTools"
           FROM c
          WHERE ((c.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY c.week
        ), c2 AS (
         SELECT c.week,
            count(*) AS "CI: Developer Environment"
           FROM c
          WHERE ((c.fault_category)::text = 'Developer Environment'::text)
          GROUP BY c.week
        ), c3 AS (
         SELECT c.week,
            count(*) AS "CI: Pass"
           FROM c
          WHERE ((c.fault_category)::text = 'Pass'::text)
          GROUP BY c.week
        ), c4 AS (
         SELECT c.week,
            count(*) AS "CI: Developer Error"
           FROM c
          WHERE ((c.fault_category)::text = 'Developer Error'::text)
          GROUP BY c.week
        ), c5 AS (
         SELECT c.week,
            count(*) AS "CI: Build Avoidance"
           FROM c
          WHERE ((c.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY c.week
        ), c6 AS (
         SELECT c.week,
            count(*) AS "CI: MULTIPLE FAULTS"
           FROM c
          WHERE ((c.fault_category)::text = 'MULTIPLE FAULTS'::text)
          GROUP BY c.week
        ), d AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Rel Eng'::text)
        ), dd AS (
         SELECT d.week,
            count(*) AS "RE: All"
           FROM d
          GROUP BY d.week
        ), d0 AS (
         SELECT d.week,
            count(*) AS "RE: Under Investigation"
           FROM d
          WHERE ((d.fault_category)::text = 'Under Investigation'::text)
          GROUP BY d.week
        ), d1 AS (
         SELECT d.week,
            count(*) AS "RE: Accurev/CMTools"
           FROM d
          WHERE ((d.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY d.week
        ), d2 AS (
         SELECT d.week,
            count(*) AS "RE: Developer Environment"
           FROM d
          WHERE ((d.fault_category)::text = 'Developer Environment'::text)
          GROUP BY d.week
        ), d3 AS (
         SELECT d.week,
            count(*) AS "RE: Pass"
           FROM d
          WHERE ((d.fault_category)::text = 'Pass'::text)
          GROUP BY d.week
        ), d4 AS (
         SELECT d.week,
            count(*) AS "RE: Developer Error"
           FROM d
          WHERE ((d.fault_category)::text = 'Developer Error'::text)
          GROUP BY d.week
        ), d5 AS (
         SELECT d.week,
            count(*) AS "RE: Build Avoidance"
           FROM d
          WHERE ((d.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY d.week
        ), d6 AS (
         SELECT d.week,
            count(*) AS "RE: MULTIPLE FAULTS"
           FROM d
          WHERE ((d.fault_category)::text = 'MULTIPLE FAULTS'::text)
          GROUP BY d.week
        ), ee AS (
         SELECT aa.week,
            a0."All: Under Investigation",
            a1."All: Accurev/CMTools",
            a2."All: Developer Environment",
            a3."All: Pass",
            a4."All: Developer Error",
            a5."All: Build Avoidance",
            a6."All: MULTIPLE FAULTS",
            bb."DV: All",
            b0."DV: Under Investigation",
            b1."DV: Accurev/CMTools",
            b2."DV: Developer Environment",
            b3."DV: Pass",
            b4."DV: Developer Error",
            b5."DV: Build Avoidance",
            b6."DV: MULTIPLE FAULTS",
            cc."CI: All",
            c0."CI: Under Investigation",
            c1."CI: Accurev/CMTools",
            c2."CI: Developer Environment",
            c3."CI: Pass",
            c4."CI: Developer Error",
            c5."CI: Build Avoidance",
            c6."CI: MULTIPLE FAULTS",
            dd."RE: All",
            d0."RE: Under Investigation",
            d1."RE: Accurev/CMTools",
            d2."RE: Developer Environment",
            d3."RE: Pass",
            d4."RE: Developer Error",
            d5."RE: Build Avoidance",
            d6."RE: MULTIPLE FAULTS"
           FROM (((((((((((((((((((((((((((((((aa
             LEFT JOIN a0 USING (week))
             LEFT JOIN a1 USING (week))
             LEFT JOIN a2 USING (week))
             LEFT JOIN a3 USING (week))
             LEFT JOIN a4 USING (week))
             LEFT JOIN a5 USING (week))
             LEFT JOIN a6 USING (week))
             LEFT JOIN bb USING (week))
             LEFT JOIN b0 USING (week))
             LEFT JOIN b1 USING (week))
             LEFT JOIN b2 USING (week))
             LEFT JOIN b3 USING (week))
             LEFT JOIN b4 USING (week))
             LEFT JOIN b5 USING (week))
             LEFT JOIN b6 USING (week))
             LEFT JOIN cc USING (week))
             LEFT JOIN c0 USING (week))
             LEFT JOIN c1 USING (week))
             LEFT JOIN c2 USING (week))
             LEFT JOIN c3 USING (week))
             LEFT JOIN c4 USING (week))
             LEFT JOIN c5 USING (week))
             LEFT JOIN c6 USING (week))
             LEFT JOIN dd USING (week))
             LEFT JOIN d0 USING (week))
             LEFT JOIN d1 USING (week))
             LEFT JOIN d2 USING (week))
             LEFT JOIN d3 USING (week))
             LEFT JOIN d4 USING (week))
             LEFT JOIN d5 USING (week))
             LEFT JOIN d6 USING (week))
        )
 SELECT ee.week,
    ee."All: Under Investigation",
    ee."All: Accurev/CMTools",
    ee."All: Developer Environment",
    ee."All: Pass",
    ee."All: Developer Error",
    ee."All: Build Avoidance",
    ee."All: MULTIPLE FAULTS",
    ee."DV: All",
    ee."DV: Under Investigation",
    ee."DV: Accurev/CMTools",
    ee."DV: Developer Environment",
    ee."DV: Pass",
    ee."DV: Developer Error",
    ee."DV: Build Avoidance",
    ee."DV: MULTIPLE FAULTS",
    ee."CI: All",
    ee."CI: Under Investigation",
    ee."CI: Accurev/CMTools",
    ee."CI: Developer Environment",
    ee."CI: Pass",
    ee."CI: Developer Error",
    ee."CI: Build Avoidance",
    ee."CI: MULTIPLE FAULTS",
    ee."RE: All",
    ee."RE: Under Investigation",
    ee."RE: Accurev/CMTools",
    ee."RE: Developer Environment",
    ee."RE: Pass",
    ee."RE: Developer Error",
    ee."RE: Build Avoidance",
    ee."RE: MULTIPLE FAULTS"
   FROM ee
  ORDER BY ee.week;


ALTER TABLE "Weekly counts - Fault-Categories" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Fault-Categories"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Fault-Categories" IS 'Data to produce graph of ''Weekly Counts for each Fault-Category''';


--
-- Name: Weekly counts - Fault-Categories.2; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - Fault-Categories.2" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir,
            etlresults.build_class,
            etlresults.result,
            etlresults.ntid,
            etlresults.build_duration,
            etlresults.comp_count,
            etlresults.arg_count,
            etlresults.hour,
            etlresults.date,
            etlresults.week,
            etlresults.prepare_duration,
            etlresults.prepare_count,
            etlresults.build2_duration,
            etlresults.build2_count,
            etlresults.package_duration,
            etlresults.package_count,
            etlresults.ibid_calc,
            etlresults.m_id,
            etlresults.mask
           FROM (baseresults
             LEFT JOIN etlresults USING (id))
          WHERE ((NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults))) AND (etlresults.build_duration IS NOT NULL))
        ), i0 AS (
         SELECT z.ibid_calc AS ibid,
            z.id,
            z.component,
            v.phase,
            v.duration,
            u.packaging,
            u.last_improvement,
            u.component_class,
            u.build_type,
            u.mask,
            u."kittyhawk-all",
            z.week
           FROM ((base z
             LEFT JOIN componentsbyoccurrence v ON ((v.id = z.id)))
             LEFT JOIN componentmeta u ON (((u.component)::text = (v.component)::text)))
        ), i1 AS (
         SELECT i0.id,
            i0.ibid,
            i0.week,
            i0.component,
            i0.duration,
            '8821886970380'::bigint AS mask,
            0 AS cnt
           FROM i0
          WHERE (i0.phase IS NULL)
        ), i2 AS (
         SELECT i0.id,
            i0.ibid,
            i0.week,
            i0.component,
            sum(i0.duration) AS duration,
            bit_and(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          WHERE ((((i0.phase)::text = 'build'::text) OR ((i0.phase)::text = 'package'::text)) AND (i0."kittyhawk-all" = true) AND ((i0.component_class)::text <> 'meta'::text))
          GROUP BY i0.id, i0.ibid, i0.week, i0.component
        ), j2 AS (
         SELECT i2.id,
            i2.ibid,
            i2.week,
            i2.component,
            i2.duration,
            i2.mask,
            (i2.cnt / 2) AS cnt
           FROM i2
          WHERE ((mod(i2.cnt, (2)::bigint) = 0) AND (i2.mask > 0) AND (i2.cnt > 0))
        ), k1 AS (
         SELECT i1.id,
            i1.ibid,
            i1.week,
            i1.component,
            i1.duration,
            i1.mask,
            i1.cnt
           FROM i1
        UNION
         SELECT j2.id,
            j2.ibid,
            j2.week,
            j2.component,
            j2.duration,
            j2.mask,
            j2.cnt
           FROM j2
        ), bld AS (
         SELECT x.week,
            x.build_class,
            ((y.build_duration || ' seconds'::text))::interval AS duration
           FROM (((k1 p
             LEFT JOIN base z ON ((z.id = p.id)))
             LEFT JOIN ibidresults y ON (((y.ibid)::text = (p.ibid)::text)))
             LEFT JOIN etlresults x ON ((x.id = y.id)))
          WHERE (((y.fault_class)::text = 'PASS'::text) AND (y.build_duration IS NOT NULL) AND (y.build_duration < 34500) AND ((p.mask & '8821886970380'::bigint) = '8821886970380'::bigint))
        ), ibid AS (
         SELECT z.ibid,
            x.build_class,
                CASE
                    WHEN (strpos((z.fault_class)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE w.fault_category
                END AS fault_category,
            ((x.build_duration || ' seconds'::text))::interval AS build_duration,
            x.week
           FROM ((ibidresults z
             LEFT JOIN etlresults x USING (id))
             LEFT JOIN fault_class w ON (((z.fault_class)::text = (w.fault_class)::text)))
          WHERE (NOT ((z.prepare_count >= 0) AND (z.build2_count = 0) AND (z.package_count = 0)))
        ), ibid2 AS (
         SELECT xx.ibid,
            xx.build_class,
            xx.fault_category,
            xx.build_duration,
            xx.week
           FROM ((((ibid xx
             LEFT JOIN ibidresults z ON (((z.ibid)::text = (xx.ibid)::text)))
             LEFT JOIN baseresults y USING (id))
             LEFT JOIN etlresults x USING (id))
             LEFT JOIN hosts v ON (((v.host)::text = (y.host)::text)))
          WHERE (x.build_duration IS NOT NULL)
        ), dv AS (
         SELECT ibid.ibid,
            ibid.build_class,
            ibid.fault_category,
            ibid.build_duration,
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Developer'::text)
        ), dv0 AS (
         SELECT ibid2.ibid,
            ibid2.build_class,
            ibid2.fault_category,
            ibid2.build_duration,
            ibid2.week
           FROM ibid2
          WHERE ((ibid2.build_class)::text = 'Developer'::text)
        ), dv1 AS (
         SELECT '1.Average Build Duration'::text AS id,
            dv0.week,
            date_part('epoch'::text, avg(dv0.build_duration)) AS "Dev"
           FROM dv0
          GROUP BY dv0.week
        UNION
         SELECT '2.Full Build Duration'::text AS id,
            bld.week,
            date_part('epoch'::text, avg(bld.duration)) AS "Dev"
           FROM bld
          WHERE ((bld.build_class)::text = 'Developer'::text)
          GROUP BY bld.week
        UNION
         SELECT '3.Pass__'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Pass'::text)
          GROUP BY dv.week
        UNION
         SELECT '4.Accurev/CMTools'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY dv.week
        UNION
         SELECT '5.Build Avoidance'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY dv.week
        UNION
         SELECT '6.Developer Environment'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Developer Environment'::text)
          GROUP BY dv.week
        UNION
         SELECT '7.NON-developer error'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text IN ( SELECT x.fault_category
                   FROM ( VALUES ('MULTIPLE FAULTS'::text), ('Developer Environment'::text), ('Build Avoidance'::text), ('Accurev/CMTools'::text)) x(fault_category)))
          GROUP BY dv.week
        UNION
         SELECT '8.Developer Error__'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Developer Error'::text)
          GROUP BY dv.week
        UNION
         SELECT '9.Unknown'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          WHERE ((dv.fault_category)::text = 'Under Investigation'::text)
          GROUP BY dv.week
        UNION
         SELECT 'A.Total builds'::text AS id,
            dv.week,
            count(*) AS "Dev"
           FROM dv
          GROUP BY dv.week
        ), ci AS (
         SELECT ibid.ibid,
            ibid.build_class,
            ibid.fault_category,
            ibid.build_duration,
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Jenkins'::text)
        ), ci0 AS (
         SELECT ibid2.ibid,
            ibid2.build_class,
            ibid2.fault_category,
            ibid2.build_duration,
            ibid2.week
           FROM ibid2
          WHERE ((ibid2.build_class)::text = 'Jenkins'::text)
        ), ci1 AS (
         SELECT '1.Average Build Duration'::text AS id,
            ci0.week,
            date_part('epoch'::text, avg(ci0.build_duration)) AS "CI"
           FROM ci0
          GROUP BY ci0.week
        UNION
         SELECT '2.Full Build Duration'::text AS id,
            bld.week,
            date_part('epoch'::text, avg(bld.duration)) AS "CI"
           FROM bld
          WHERE ((bld.build_class)::text = 'Jenkins'::text)
          GROUP BY bld.week
        UNION
         SELECT '3.Pass__'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Pass'::text)
          GROUP BY ci.week
        UNION
         SELECT '4.Accurev/CMTools'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY ci.week
        UNION
         SELECT '5.Build Avoidance'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY ci.week
        UNION
         SELECT '6.Developer Environment'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Developer Environment'::text)
          GROUP BY ci.week
        UNION
         SELECT '7.NON-developer error'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text IN ( SELECT x.fault_category
                   FROM ( VALUES ('MULTIPLE FAULTS'::text), ('Developer Environment'::text), ('Build Avoidance'::text), ('Accurev/CMTools'::text)) x(fault_category)))
          GROUP BY ci.week
        UNION
         SELECT '8.Developer Error__'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Developer Error'::text)
          GROUP BY ci.week
        UNION
         SELECT '9.Unknown'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          WHERE ((ci.fault_category)::text = 'Under Investigation'::text)
          GROUP BY ci.week
        UNION
         SELECT 'A.Total builds'::text AS id,
            ci.week,
            count(*) AS "CI"
           FROM ci
          GROUP BY ci.week
        ), re AS (
         SELECT ibid.ibid,
            ibid.build_class,
            ibid.fault_category,
            ibid.build_duration,
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Rel Eng'::text)
        ), re0 AS (
         SELECT ibid2.ibid,
            ibid2.build_class,
            ibid2.fault_category,
            ibid2.build_duration,
            ibid2.week
           FROM ibid2
          WHERE ((ibid2.build_class)::text = 'Rel Eng'::text)
        ), re1 AS (
         SELECT '1.Average Build Duration'::text AS id,
            re0.week,
            date_part('epoch'::text, avg(re0.build_duration)) AS "RE"
           FROM re0
          GROUP BY re0.week
        UNION
         SELECT '2.Full Build Duration'::text AS id,
            bld.week,
            date_part('epoch'::text, avg(bld.duration)) AS "RE"
           FROM bld
          WHERE ((bld.build_class)::text = 'Rel Eng'::text)
          GROUP BY bld.week
        UNION
         SELECT '3.Pass__'::text AS id,
            re.week,
            count(*) AS "CI"
           FROM re
          WHERE ((re.fault_category)::text = 'Pass'::text)
          GROUP BY re.week
        UNION
         SELECT '4.Accurev/CMTools'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY re.week
        UNION
         SELECT '5.Build Avoidance'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY re.week
        UNION
         SELECT '6.Developer Environment'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text = 'Developer Environment'::text)
          GROUP BY re.week
        UNION
         SELECT '7.NON-developer error'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text IN ( SELECT x.fault_category
                   FROM ( VALUES ('MULTIPLE FAULTS'::text), ('Developer Environment'::text), ('Build Avoidance'::text), ('Accurev/CMTools'::text)) x(fault_category)))
          GROUP BY re.week
        UNION
         SELECT '8.Developer Error__'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text = 'Developer Error'::text)
          GROUP BY re.week
        UNION
         SELECT '9.Unknown'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          WHERE ((re.fault_category)::text = 'Under Investigation'::text)
          GROUP BY re.week
        UNION
         SELECT 'A.Total builds'::text AS id,
            re.week,
            count(*) AS "RE"
           FROM re
          GROUP BY re.week
        ), ax1 AS (
         SELECT '1.Average Build Duration'::text AS id,
            ibid2.week,
            date_part('epoch'::text, avg(ibid2.build_duration)) AS "All"
           FROM ibid2
          GROUP BY ibid2.week
        UNION
         SELECT '2.Full Build Duration'::text AS id,
            bld.week,
            date_part('epoch'::text, avg(bld.duration)) AS "All"
           FROM bld
          GROUP BY bld.week
        UNION
         SELECT '3.Pass__'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Pass'::text)
          GROUP BY ibid.week
        UNION
         SELECT '4.Accurev/CMTools'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY ibid.week
        UNION
         SELECT '5.Build Avoidance'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY ibid.week
        UNION
         SELECT '6.Developer Environment'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Developer Environment'::text)
          GROUP BY ibid.week
        UNION
         SELECT '7.NON-developer error'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text IN ( SELECT x.fault_category
                   FROM ( VALUES ('MULTIPLE FAULTS'::text), ('Developer Environment'::text), ('Build Avoidance'::text), ('Accurev/CMTools'::text)) x(fault_category)))
          GROUP BY ibid.week
        UNION
         SELECT '8.Developer Error__'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Developer Error'::text)
          GROUP BY ibid.week
        UNION
         SELECT '9.Unknown'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          WHERE ((ibid.fault_category)::text = 'Under Investigation'::text)
          GROUP BY ibid.week
        UNION
         SELECT 'A.Total builds'::text AS id,
            ibid.week,
            count(*) AS "All"
           FROM ibid
          GROUP BY ibid.week
        ), smry AS (
         SELECT dv1.week,
            substr(dv1.id, 3) AS "desc",
            dv1."Dev",
            ci1."CI",
            re1."RE",
            ax1."All"
           FROM (((dv1
             LEFT JOIN ci1 ON (((ci1.week = dv1.week) AND (ci1.id = dv1.id))))
             LEFT JOIN re1 ON (((re1.week = dv1.week) AND (re1.id = dv1.id))))
             LEFT JOIN ax1 ON (((ax1.week = dv1.week) AND (ax1.id = dv1.id))))
          ORDER BY dv1.week, dv1.id
        )
 SELECT smry.week,
    smry."desc",
    smry."Dev",
    smry."CI",
    smry."RE",
    smry."All"
   FROM smry;


ALTER TABLE "Weekly counts - Fault-Categories.2" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Fault-Categories.2"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Fault-Categories.2" IS 'Data to produce graph of ''Average "Clean Build+Packaging" Duration for Developers''';


--
-- Name: Weekly counts - Fault-Types; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - Fault-Types" AS
 WITH a AS (
         SELECT (metrics.week)::date AS week,
            metrics.build_duration,
            metrics.fault_class
           FROM metrics
        ), b AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), c AS (
         SELECT a.week,
            count(*) AS "ABORTED"
           FROM a
          WHERE ((a.fault_class)::text = 'ABORTED'::text)
          GROUP BY a.week
        ), d AS (
         SELECT a.week,
            count(*) AS "ACCUREV_ISSUE"
           FROM a
          WHERE ((a.fault_class)::text = 'ACCUREV_ISSUE'::text)
          GROUP BY a.week
        ), e AS (
         SELECT a.week,
            count(*) AS "ASSEMBLER_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'ASSEMBLER_ERROR'::text)
          GROUP BY a.week
        ), f AS (
         SELECT a.week,
            count(*) AS "AUTO_BUILD_ENV"
           FROM a
          WHERE ((a.fault_class)::text = 'AUTO_BUILD_ENV'::text)
          GROUP BY a.week
        ), g AS (
         SELECT a.week,
            count(*) AS "BAD_EXIT_STATUS"
           FROM a
          WHERE ((a.fault_class)::text = 'BAD_EXIT_STATUS'::text)
          GROUP BY a.week
        ), h AS (
         SELECT a.week,
            count(*) AS "BUILD_CMDLINE_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'BUILD_CMDLINE_ERROR'::text)
          GROUP BY a.week
        ), i AS (
         SELECT a.week,
            count(*) AS "BUILD_FAILURE"
           FROM a
          WHERE ((a.fault_class)::text = 'BUILD_FAILURE'::text)
          GROUP BY a.week
        ), j AS (
         SELECT a.week,
            count(*) AS "BUILDENV_NEEDS_UPDATE"
           FROM a
          WHERE ((a.fault_class)::text = 'BUILDENV_NEEDS_UPDATE'::text)
          GROUP BY a.week
        ), k AS (
         SELECT a.week,
            count(*) AS "CANT_CREATE_FILE"
           FROM a
          WHERE ((a.fault_class)::text = 'CANT_CREATE_FILE'::text)
          GROUP BY a.week
        ), l AS (
         SELECT a.week,
            count(*) AS "CATALOG_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'CATALOG_ERROR'::text)
          GROUP BY a.week
        ), m AS (
         SELECT a.week,
            count(*) AS "CERTIFICATE_ERR"
           FROM a
          WHERE ((a.fault_class)::text = 'CERTIFICATE_ERR'::text)
          GROUP BY a.week
        ), n AS (
         SELECT a.week,
            count(*) AS "CMAKE_FAILURE"
           FROM a
          WHERE ((a.fault_class)::text = 'CMAKE_FAILURE'::text)
          GROUP BY a.week
        ), o AS (
         SELECT a.week,
            count(*) AS "CMTOOLS"
           FROM a
          WHERE ((a.fault_class)::text = 'CMTOOLS'::text)
          GROUP BY a.week
        ), p AS (
         SELECT a.week,
            count(*) AS "CMVERSION"
           FROM a
          WHERE ((a.fault_class)::text = 'CMVERSION'::text)
          GROUP BY a.week
        ), q AS (
         SELECT a.week,
            count(*) AS "DEPENDSMK_USAGE"
           FROM a
          WHERE ((a.fault_class)::text = 'DEPENDSMK_USAGE'::text)
          GROUP BY a.week
        ), r AS (
         SELECT a.week,
            count(*) AS "ERR_IGNORED"
           FROM a
          WHERE ((a.fault_class)::text = 'ERR_IGNORED'::text)
          GROUP BY a.week
        ), s AS (
         SELECT a.week,
            count(*) AS "FAIL"
           FROM a
          WHERE ((a.fault_class)::text = 'FAIL'::text)
          GROUP BY a.week
        ), t AS (
         SELECT a.week,
            count(*) AS "GENERIC_COMPILER_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'GENERIC_COMPILER_ERROR'::text)
          GROUP BY a.week
        ), u AS (
         SELECT a.week,
            count(*) AS "INVALID_MODULE"
           FROM a
          WHERE ((a.fault_class)::text = 'INVALID_MODULE'::text)
          GROUP BY a.week
        ), v AS (
         SELECT a.week,
            count(*) AS "INVALID_OPERANDS"
           FROM a
          WHERE ((a.fault_class)::text = 'INVALID_OPERANDS'::text)
          GROUP BY a.week
        ), w AS (
         SELECT a.week,
            count(*) AS "MISSING_ELEMENT"
           FROM a
          WHERE ((a.fault_class)::text = 'MISSING_ELEMENT'::text)
          GROUP BY a.week
        ), x AS (
         SELECT a.week,
            count(*) AS "MISSING_HEADER"
           FROM a
          WHERE ((a.fault_class)::text = 'MISSING_HEADER'::text)
          GROUP BY a.week
        ), c1 AS (
         SELECT a.week,
            count(*) AS "MISSING_RPM"
           FROM a
          WHERE ((a.fault_class)::text = 'MISSING_RPM'::text)
          GROUP BY a.week
        ), d1 AS (
         SELECT a.week,
            count(*) AS "NINJA_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'NINJA_ERROR'::text)
          GROUP BY a.week
        ), e1 AS (
         SELECT a.week,
            count(*) AS "NO_LOG_FILES_TO_ANALYZE"
           FROM a
          WHERE ((a.fault_class)::text = 'NO_LOG_FILES_TO_ANALYZE'::text)
          GROUP BY a.week
        ), f1 AS (
         SELECT a.week,
            count(*) AS "NO_MATCHING_FUNCTION"
           FROM a
          WHERE ((a.fault_class)::text = 'NO_MATCHING_FUNCTION'::text)
          GROUP BY a.week
        ), g1 AS (
         SELECT a.week,
            count(*) AS "NO_MEMBER_NAMED"
           FROM a
          WHERE ((a.fault_class)::text = 'NO_MEMBER_NAMED'::text)
          GROUP BY a.week
        ), h1 AS (
         SELECT a.week,
            count(*) AS "NO_SPACE"
           FROM a
          WHERE ((a.fault_class)::text = 'NO_SPACE'::text)
          GROUP BY a.week
        ), i1 AS (
         SELECT a.week,
            count(*) AS "NOT LOGGED IN"
           FROM a
          WHERE ((a.fault_class)::text = 'NOT LOGGED IN'::text)
          GROUP BY a.week
        ), j1 AS (
         SELECT a.week,
            count(*) AS "NOT_A_MEMBER"
           FROM a
          WHERE ((a.fault_class)::text = 'NOT_A_MEMBER'::text)
          GROUP BY a.week
        ), k1 AS (
         SELECT a.week,
            count(*) AS "PACKAGING_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'PACKAGING_ERROR'::text)
          GROUP BY a.week
        ), l1 AS (
         SELECT a.week,
            count(*) AS "PASS"
           FROM a
          WHERE ((a.fault_class)::text = 'PASS'::text)
          GROUP BY a.week
        ), m1 AS (
         SELECT a.week,
            count(*) AS "RPM_DEPENDENCY"
           FROM a
          WHERE ((a.fault_class)::text = 'RPM_DEPENDENCY'::text)
          GROUP BY a.week
        ), n1 AS (
         SELECT a.week,
            count(*) AS "RPM_DEPENDENCY_BUILD_ALL_CHECK"
           FROM a
          WHERE ((a.fault_class)::text = 'RPM_DEPENDENCY_BUILD_ALL_CHECK'::text)
          GROUP BY a.week
        ), o1 AS (
         SELECT a.week,
            count(*) AS "RPM_FIND"
           FROM a
          WHERE ((a.fault_class)::text = 'RPM_FIND'::text)
          GROUP BY a.week
        ), p1 AS (
         SELECT a.week,
            count(*) AS "RPM_INSTALL"
           FROM a
          WHERE ((a.fault_class)::text = 'RPM_INSTALL'::text)
          GROUP BY a.week
        ), q1 AS (
         SELECT a.week,
            count(*) AS "RPM_PACKAGE_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'RPM_PACKAGE_ERROR'::text)
          GROUP BY a.week
        ), r1 AS (
         SELECT a.week,
            count(*) AS "RPMLIST_UPDATE"
           FROM a
          WHERE ((a.fault_class)::text = 'RPMLIST_UPDATE'::text)
          GROUP BY a.week
        ), s1 AS (
         SELECT a.week,
            count(*) AS "RSYNC_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'RSYNC_ERROR'::text)
          GROUP BY a.week
        ), t1 AS (
         SELECT a.week,
            count(*) AS "SCRIPTLET_FAILED"
           FROM a
          WHERE ((a.fault_class)::text = 'SCRIPTLET_FAILED'::text)
          GROUP BY a.week
        ), u1 AS (
         SELECT a.week,
            count(*) AS "SEMANTIC_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'SEMANTIC_ERROR'::text)
          GROUP BY a.week
        ), v1 AS (
         SELECT a.week,
            count(*) AS "SETUPWSPACE"
           FROM a
          WHERE ((a.fault_class)::text = 'SETUPWSPACE'::text)
          GROUP BY a.week
        ), w1 AS (
         SELECT a.week,
            count(*) AS "SOURCE_CHECKSUM_CHANGED"
           FROM a
          WHERE ((a.fault_class)::text = 'SOURCE_CHECKSUM_CHANGED'::text)
          GROUP BY a.week
        ), x1 AS (
         SELECT a.week,
            count(*) AS "SYMBOL_NOT_FOUND"
           FROM a
          WHERE ((a.fault_class)::text = 'SYMBOL_NOT_FOUND'::text)
          GROUP BY a.week
        ), c2 AS (
         SELECT a.week,
            count(*) AS "SYMBOL_UNDECLARED"
           FROM a
          WHERE ((a.fault_class)::text = 'SYMBOL_UNDECLARED'::text)
          GROUP BY a.week
        ), d2 AS (
         SELECT a.week,
            count(*) AS "SYNTAX_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'SYNTAX_ERROR'::text)
          GROUP BY a.week
        ), e2 AS (
         SELECT a.week,
            count(*) AS "UNDEFINED_REFERENCE"
           FROM a
          WHERE ((a.fault_class)::text = 'UNDEFINED_REFERENCE'::text)
          GROUP BY a.week
        ), f2 AS (
         SELECT a.week,
            count(*) AS "UNEXPECTED_ERROR"
           FROM a
          WHERE ((a.fault_class)::text = 'UNEXPECTED_ERROR'::text)
          GROUP BY a.week
        ), g2 AS (
         SELECT a.week,
            count(*) AS "UNIT_TEST_FAILURE"
           FROM a
          WHERE ((a.fault_class)::text = 'UNIT_TEST_FAILURE'::text)
          GROUP BY a.week
        ), h2 AS (
         SELECT a.week,
            count(*) AS "UNKNOWN"
           FROM a
          WHERE ((a.fault_class)::text = 'UNKNOWN'::text)
          GROUP BY a.week
        ), i2 AS (
         SELECT a.week,
            count(*) AS "UNSUPPORTED_SEVERITY"
           FROM a
          WHERE ((a.fault_class)::text = 'UNSUPPORTED_SEVERITY'::text)
          GROUP BY a.week
        ), j2 AS (
         SELECT a.week,
            count(*) AS "WRONG_DISTRO"
           FROM a
          WHERE ((a.fault_class)::text = 'WRONG_DISTRO'::text)
          GROUP BY a.week
        ), y AS (
         SELECT b.week,
            c."ABORTED",
            d."ACCUREV_ISSUE",
            e."ASSEMBLER_ERROR",
            f."AUTO_BUILD_ENV",
            g."BAD_EXIT_STATUS",
            h."BUILD_CMDLINE_ERROR",
            i."BUILD_FAILURE",
            j."BUILDENV_NEEDS_UPDATE",
            k."CANT_CREATE_FILE",
            l."CATALOG_ERROR",
            m."CERTIFICATE_ERR",
            n."CMAKE_FAILURE",
            o."CMTOOLS",
            p."CMVERSION",
            q."DEPENDSMK_USAGE",
            r."ERR_IGNORED",
            s."FAIL",
            t."GENERIC_COMPILER_ERROR",
            u."INVALID_MODULE",
            v."INVALID_OPERANDS",
            w."MISSING_ELEMENT",
            x."MISSING_HEADER",
            c1."MISSING_RPM",
            d1."NINJA_ERROR",
            e1."NO_LOG_FILES_TO_ANALYZE",
            f1."NO_MATCHING_FUNCTION",
            g1."NO_MEMBER_NAMED",
            h1."NO_SPACE",
            i1."NOT LOGGED IN",
            j1."NOT_A_MEMBER",
            k1."PACKAGING_ERROR",
            l1."PASS",
            m1."RPM_DEPENDENCY",
            n1."RPM_DEPENDENCY_BUILD_ALL_CHECK",
            o1."RPM_FIND",
            p1."RPM_INSTALL",
            q1."RPM_PACKAGE_ERROR",
            r1."RPMLIST_UPDATE",
            s1."RSYNC_ERROR",
            t1."SCRIPTLET_FAILED",
            u1."SEMANTIC_ERROR",
            v1."SETUPWSPACE",
            w1."SOURCE_CHECKSUM_CHANGED",
            x1."SYMBOL_NOT_FOUND",
            c2."SYMBOL_UNDECLARED",
            d2."SYNTAX_ERROR",
            e2."UNDEFINED_REFERENCE",
            f2."UNEXPECTED_ERROR",
            g2."UNIT_TEST_FAILURE",
            h2."UNKNOWN",
            i2."UNSUPPORTED_SEVERITY",
            j2."WRONG_DISTRO"
           FROM ((((((((((((((((((((((((((((((((((((((((((((((((((((b
             LEFT JOIN c USING (week))
             LEFT JOIN d USING (week))
             LEFT JOIN e USING (week))
             LEFT JOIN f USING (week))
             LEFT JOIN g USING (week))
             LEFT JOIN h USING (week))
             LEFT JOIN i USING (week))
             LEFT JOIN j USING (week))
             LEFT JOIN k USING (week))
             LEFT JOIN l USING (week))
             LEFT JOIN m USING (week))
             LEFT JOIN n USING (week))
             LEFT JOIN o USING (week))
             LEFT JOIN p USING (week))
             LEFT JOIN q USING (week))
             LEFT JOIN r USING (week))
             LEFT JOIN s USING (week))
             LEFT JOIN t USING (week))
             LEFT JOIN u USING (week))
             LEFT JOIN v USING (week))
             LEFT JOIN w USING (week))
             LEFT JOIN x USING (week))
             LEFT JOIN c1 USING (week))
             LEFT JOIN d1 USING (week))
             LEFT JOIN e1 USING (week))
             LEFT JOIN f1 USING (week))
             LEFT JOIN g1 USING (week))
             LEFT JOIN h1 USING (week))
             LEFT JOIN i1 USING (week))
             LEFT JOIN j1 USING (week))
             LEFT JOIN k1 USING (week))
             LEFT JOIN l1 USING (week))
             LEFT JOIN m1 USING (week))
             LEFT JOIN n1 USING (week))
             LEFT JOIN o1 USING (week))
             LEFT JOIN p1 USING (week))
             LEFT JOIN q1 USING (week))
             LEFT JOIN r1 USING (week))
             LEFT JOIN s1 USING (week))
             LEFT JOIN t1 USING (week))
             LEFT JOIN u1 USING (week))
             LEFT JOIN v1 USING (week))
             LEFT JOIN w1 USING (week))
             LEFT JOIN x1 USING (week))
             LEFT JOIN c2 USING (week))
             LEFT JOIN d2 USING (week))
             LEFT JOIN e2 USING (week))
             LEFT JOIN f2 USING (week))
             LEFT JOIN g2 USING (week))
             LEFT JOIN h2 USING (week))
             LEFT JOIN i2 USING (week))
             LEFT JOIN j2 USING (week))
        )
 SELECT y.week,
    y."ABORTED",
    y."ACCUREV_ISSUE",
    y."ASSEMBLER_ERROR",
    y."AUTO_BUILD_ENV",
    y."BAD_EXIT_STATUS",
    y."BUILD_CMDLINE_ERROR",
    y."BUILD_FAILURE",
    y."BUILDENV_NEEDS_UPDATE",
    y."CANT_CREATE_FILE",
    y."CATALOG_ERROR",
    y."CERTIFICATE_ERR",
    y."CMAKE_FAILURE",
    y."CMTOOLS",
    y."CMVERSION",
    y."DEPENDSMK_USAGE",
    y."ERR_IGNORED",
    y."FAIL",
    y."GENERIC_COMPILER_ERROR",
    y."INVALID_MODULE",
    y."INVALID_OPERANDS",
    y."MISSING_ELEMENT",
    y."MISSING_HEADER",
    y."MISSING_RPM",
    y."NINJA_ERROR",
    y."NO_LOG_FILES_TO_ANALYZE",
    y."NO_MATCHING_FUNCTION",
    y."NO_MEMBER_NAMED",
    y."NO_SPACE",
    y."NOT LOGGED IN",
    y."NOT_A_MEMBER",
    y."PACKAGING_ERROR",
    y."PASS",
    y."RPM_DEPENDENCY",
    y."RPM_DEPENDENCY_BUILD_ALL_CHECK",
    y."RPM_FIND",
    y."RPM_INSTALL",
    y."RPM_PACKAGE_ERROR",
    y."RPMLIST_UPDATE",
    y."RSYNC_ERROR",
    y."SCRIPTLET_FAILED",
    y."SEMANTIC_ERROR",
    y."SETUPWSPACE",
    y."SOURCE_CHECKSUM_CHANGED",
    y."SYMBOL_NOT_FOUND",
    y."SYMBOL_UNDECLARED",
    y."SYNTAX_ERROR",
    y."UNDEFINED_REFERENCE",
    y."UNEXPECTED_ERROR",
    y."UNIT_TEST_FAILURE",
    y."UNKNOWN",
    y."UNSUPPORTED_SEVERITY",
    y."WRONG_DISTRO"
   FROM y
  ORDER BY y.week;


ALTER TABLE "Weekly counts - Fault-Types" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Fault-Types"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Fault-Types" IS 'Data to produce graph of ''Weekly Counts for each Fault-Type''';


--
-- Name: Weekly counts - Full Build Times; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - Full Build Times" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir,
            etlresults.build_class,
            etlresults.result,
            etlresults.ntid,
            etlresults.build_duration,
            etlresults.comp_count,
            etlresults.arg_count,
            etlresults.hour,
            etlresults.date,
            etlresults.week,
            etlresults.prepare_duration,
            etlresults.prepare_count,
            etlresults.build2_duration,
            etlresults.build2_count,
            etlresults.package_duration,
            etlresults.package_count,
            etlresults.ibid_calc,
            etlresults.m_id,
            etlresults.mask
           FROM (baseresults
             LEFT JOIN etlresults USING (id))
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), i0 AS (
         SELECT z.ibid_calc AS ibid,
            z.id,
            z.component,
            v.phase,
            v.duration,
            u.packaging,
            u.last_improvement,
            u.component_class,
            u.build_type,
            u.mask,
            u."kittyhawk-all"
           FROM ((base z
             LEFT JOIN componentsbyoccurrence v ON ((v.id = z.id)))
             LEFT JOIN componentmeta u ON (((u.component)::text = (v.component)::text)))
          WHERE ((z.fault_class)::text = 'PASS'::text)
        ), i1 AS (
         SELECT i0.id,
            i0.ibid,
            i0.component,
            i0.duration,
            i0.mask
           FROM i0
          WHERE (i0.phase IS NULL)
        ), j1 AS (
         SELECT i0.ibid,
            bit_or(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          GROUP BY i0.ibid
        ), i2 AS (
         SELECT i0.id,
            i0.ibid,
            i0.component,
            bit_and(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          WHERE ((((i0.phase)::text = 'build'::text) OR ((i0.phase)::text = 'package'::text)) AND (i0."kittyhawk-all" = true) AND ((i0.component_class)::text <> 'meta'::text))
          GROUP BY i0.id, i0.ibid, i0.component
        ), i2a AS (
         SELECT i2.id,
            i2.ibid,
            i2.component,
            i2.mask
           FROM i2
          WHERE ((i2.cnt > 1) AND (i2.mask > 0))
        ), j2 AS (
         SELECT i2a.ibid,
            bit_or(i2a.mask) AS mask,
            count(*) AS cnt
           FROM i2a
          GROUP BY i2a.ibid
        ), k1 AS (
         SELECT j1.ibid,
            j1.mask
           FROM j1
        UNION
         SELECT j2.ibid,
            j2.mask
           FROM j2
        ), ibid AS (
         SELECT p.ibid,
            y.host_class,
            x.build_class,
            (x.week)::date AS week
           FROM (((((k1 p
             LEFT JOIN ibidresults z ON (((z.ibid)::text = (p.ibid)::text)))
             LEFT JOIN base ON ((z.id = base.id)))
             LEFT JOIN hosts y ON (((base.host)::text = (y.host)::text)))
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN fault_class w ON (((z.fault_class)::text = (w.fault_class)::text)))
          WHERE (((x.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)) AND ((z.fault_class)::text = 'PASS'::text) AND ((p.mask & '8821886970380'::bigint) = '8821886970380'::bigint))
        ), re AS (
         SELECT count(*) AS "RE builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Rel Eng'::text)
          GROUP BY ibid.week
        ), ci AS (
         SELECT count(*) AS "CI builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Jenkins'::text)
          GROUP BY ibid.week
        ), dev AS (
         SELECT count(*) AS "Developer builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Developer'::text)
          GROUP BY ibid.week
        ), ave AS (
         SELECT count(*) AS "Total builds",
            ibid.week
           FROM ibid
          GROUP BY ibid.week
        ), rslts AS (
         SELECT ave.week AS "Week ending",
            ave."Total builds",
            re."RE builds",
            ci."CI builds",
            dev."Developer builds"
           FROM (((ave
             LEFT JOIN re USING (week))
             LEFT JOIN ci USING (week))
             LEFT JOIN dev USING (week))
        )
 SELECT rslts."Week ending",
    rslts."Total builds",
    rslts."RE builds",
    rslts."CI builds",
    rslts."Developer builds"
   FROM rslts
  ORDER BY rslts."Week ending";


ALTER TABLE "Weekly counts - Full Build Times" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Full Build Times"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Full Build Times" IS 'Data to produce graph of ''Weekly counts - Full Build Times''';


--
-- Name: Weekly counts - Host Types; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - Host Types" AS
 WITH a AS (
         SELECT (x.week)::date AS "Week Ending",
                CASE
                    WHEN ((v.site)::text ~* 'New Jersey|Paris|RTP|Shanghai|St Petersburg'::text) THEN v.site
                    WHEN ((v.cloud)::text ~* 'CEC'::text) THEN (((v.site)::text || ' CEC'::text))::character varying
                    WHEN ((v.site)::text ~* 'Durham|Hopkinton'::text) THEN ((((v.site)::text || ' '::text) || (v.cloud)::text))::character varying
                    ELSE 'Other'::character varying
                END AS host_category
           FROM ((ibidresults z
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN ibidextended v ON (((v.id = z.id) AND ((v.ibid)::text = (z.ibid)::text))))
        ), b AS (
         SELECT a."Week Ending"
           FROM a
          GROUP BY a."Week Ending"
        ), c AS (
         SELECT a."Week Ending",
            count(*) AS "Durham CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Durham CEC'::text)
          GROUP BY a."Week Ending"
        ), d AS (
         SELECT a."Week Ending",
            count(*) AS "Durham EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Durham EOS2'::text)
          GROUP BY a."Week Ending"
        ), e AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton CEC'::text)
          GROUP BY a."Week Ending"
        ), f AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton EOS2'::text)
          GROUP BY a."Week Ending"
        ), g AS (
         SELECT a."Week Ending",
            count(*) AS "New Jersey"
           FROM a
          WHERE ((a.host_category)::text = 'New Jersey'::text)
          GROUP BY a."Week Ending"
        ), h AS (
         SELECT a."Week Ending",
            count(*) AS "Paris"
           FROM a
          WHERE ((a.host_category)::text = 'Paris'::text)
          GROUP BY a."Week Ending"
        ), i AS (
         SELECT a."Week Ending",
            count(*) AS "RTP"
           FROM a
          WHERE ((a.host_category)::text = 'RTP'::text)
          GROUP BY a."Week Ending"
        ), j AS (
         SELECT a."Week Ending",
            count(*) AS "Shanghai"
           FROM a
          WHERE ((a.host_category)::text = 'Shanghai'::text)
          GROUP BY a."Week Ending"
        ), k AS (
         SELECT a."Week Ending",
            count(*) AS "St Petersburg"
           FROM a
          WHERE ((a.host_category)::text = 'St Petersburg'::text)
          GROUP BY a."Week Ending"
        ), l AS (
         SELECT a."Week Ending",
            count(*) AS "Other"
           FROM a
          WHERE ((a.host_category)::text = 'Other'::text)
          GROUP BY a."Week Ending"
        ), y AS (
         SELECT b."Week Ending",
            c."Durham CEC",
            d."Durham EOS2",
            e."Hopkinton CEC",
            f."Hopkinton EOS2",
            g."New Jersey",
            h."Paris",
            i."RTP",
            j."Shanghai",
            k."St Petersburg",
            l."Other"
           FROM ((((((((((b
             LEFT JOIN c USING ("Week Ending"))
             LEFT JOIN d USING ("Week Ending"))
             LEFT JOIN e USING ("Week Ending"))
             LEFT JOIN f USING ("Week Ending"))
             LEFT JOIN g USING ("Week Ending"))
             LEFT JOIN h USING ("Week Ending"))
             LEFT JOIN i USING ("Week Ending"))
             LEFT JOIN j USING ("Week Ending"))
             LEFT JOIN k USING ("Week Ending"))
             LEFT JOIN l USING ("Week Ending"))
        )
 SELECT y."Week Ending",
    y."Durham CEC",
    y."Durham EOS2",
    y."Hopkinton CEC",
    y."Hopkinton EOS2",
    y."New Jersey",
    y."Paris",
    y."RTP",
    y."Shanghai",
    y."St Petersburg",
    y."Other"
   FROM y
  ORDER BY y."Week Ending";


ALTER TABLE "Weekly counts - Host Types" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Host Types"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Host Types" IS 'Data to produce graph of ''Weekly counts - Host Types''';


--
-- Name: Weekly counts - Host Types (CI); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - Host Types (CI)" AS
 WITH a AS (
         SELECT (x.week)::date AS "Week Ending",
                CASE
                    WHEN ((v.site)::text ~* 'New Jersey|Paris|RTP|Shanghai|St Petersburg'::text) THEN v.site
                    WHEN ((v.cloud)::text ~* 'CEC'::text) THEN (((v.site)::text || ' CEC'::text))::character varying
                    WHEN ((v.site)::text ~* 'Durham|Hopkinton'::text) THEN ((((v.site)::text || ' '::text) || (v.cloud)::text))::character varying
                    ELSE 'Other'::character varying
                END AS host_category
           FROM ((ibidresults z
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN ibidextended v ON (((v.id = z.id) AND ((v.ibid)::text = (z.ibid)::text))))
          WHERE ((x.build_class)::text = 'Jenkins'::text)
        ), b AS (
         SELECT a."Week Ending"
           FROM a
          GROUP BY a."Week Ending"
        ), c AS (
         SELECT a."Week Ending",
            count(*) AS "Durham CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Durham CEC'::text)
          GROUP BY a."Week Ending"
        ), d AS (
         SELECT a."Week Ending",
            count(*) AS "Durham EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Durham EOS2'::text)
          GROUP BY a."Week Ending"
        ), e AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton CEC'::text)
          GROUP BY a."Week Ending"
        ), f AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton EOS2'::text)
          GROUP BY a."Week Ending"
        ), g AS (
         SELECT a."Week Ending",
            count(*) AS "New Jersey"
           FROM a
          WHERE ((a.host_category)::text = 'New Jersey'::text)
          GROUP BY a."Week Ending"
        ), h AS (
         SELECT a."Week Ending",
            count(*) AS "Paris"
           FROM a
          WHERE ((a.host_category)::text = 'Paris'::text)
          GROUP BY a."Week Ending"
        ), i AS (
         SELECT a."Week Ending",
            count(*) AS "RTP"
           FROM a
          WHERE ((a.host_category)::text = 'RTP'::text)
          GROUP BY a."Week Ending"
        ), j AS (
         SELECT a."Week Ending",
            count(*) AS "Shanghai"
           FROM a
          WHERE ((a.host_category)::text = 'Shanghai'::text)
          GROUP BY a."Week Ending"
        ), k AS (
         SELECT a."Week Ending",
            count(*) AS "St Petersburg"
           FROM a
          WHERE ((a.host_category)::text = 'St Petersburg'::text)
          GROUP BY a."Week Ending"
        ), l AS (
         SELECT a."Week Ending",
            count(*) AS "Other"
           FROM a
          WHERE ((a.host_category)::text = 'Other'::text)
          GROUP BY a."Week Ending"
        ), y AS (
         SELECT b."Week Ending",
            c."Durham CEC",
            d."Durham EOS2",
            e."Hopkinton CEC",
            f."Hopkinton EOS2",
            g."New Jersey",
            h."Paris",
            i."RTP",
            j."Shanghai",
            k."St Petersburg",
            l."Other"
           FROM ((((((((((b
             LEFT JOIN c USING ("Week Ending"))
             LEFT JOIN d USING ("Week Ending"))
             LEFT JOIN e USING ("Week Ending"))
             LEFT JOIN f USING ("Week Ending"))
             LEFT JOIN g USING ("Week Ending"))
             LEFT JOIN h USING ("Week Ending"))
             LEFT JOIN i USING ("Week Ending"))
             LEFT JOIN j USING ("Week Ending"))
             LEFT JOIN k USING ("Week Ending"))
             LEFT JOIN l USING ("Week Ending"))
        )
 SELECT y."Week Ending",
    y."Durham CEC",
    y."Durham EOS2",
    y."Hopkinton CEC",
    y."Hopkinton EOS2",
    y."New Jersey",
    y."Paris",
    y."RTP",
    y."Shanghai",
    y."St Petersburg",
    y."Other"
   FROM y
  ORDER BY y."Week Ending";


ALTER TABLE "Weekly counts - Host Types (CI)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Host Types (CI)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Host Types (CI)" IS 'Data to produce graph of ''Weekly counts - Host Types''';


--
-- Name: Weekly counts - Host Types (DE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - Host Types (DE)" AS
 WITH a AS (
         SELECT (x.week)::date AS "Week Ending",
                CASE
                    WHEN ((v.site)::text ~* 'New Jersey|Paris|RTP|Shanghai|St Petersburg'::text) THEN v.site
                    WHEN ((v.cloud)::text ~* 'CEC'::text) THEN (((v.site)::text || ' CEC'::text))::character varying
                    WHEN ((v.site)::text ~* 'Durham|Hopkinton'::text) THEN ((((v.site)::text || ' '::text) || (v.cloud)::text))::character varying
                    ELSE 'Other'::character varying
                END AS host_category
           FROM ((ibidresults z
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN ibidextended v ON (((v.id = z.id) AND ((v.ibid)::text = (z.ibid)::text))))
          WHERE ((x.build_class)::text = 'Developer'::text)
        ), b AS (
         SELECT a."Week Ending"
           FROM a
          GROUP BY a."Week Ending"
        ), c AS (
         SELECT a."Week Ending",
            count(*) AS "Durham CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Durham CEC'::text)
          GROUP BY a."Week Ending"
        ), d AS (
         SELECT a."Week Ending",
            count(*) AS "Durham EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Durham EOS2'::text)
          GROUP BY a."Week Ending"
        ), e AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton CEC'::text)
          GROUP BY a."Week Ending"
        ), f AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton EOS2'::text)
          GROUP BY a."Week Ending"
        ), g AS (
         SELECT a."Week Ending",
            count(*) AS "New Jersey"
           FROM a
          WHERE ((a.host_category)::text = 'New Jersey'::text)
          GROUP BY a."Week Ending"
        ), h AS (
         SELECT a."Week Ending",
            count(*) AS "Paris"
           FROM a
          WHERE ((a.host_category)::text = 'Paris'::text)
          GROUP BY a."Week Ending"
        ), i AS (
         SELECT a."Week Ending",
            count(*) AS "RTP"
           FROM a
          WHERE ((a.host_category)::text = 'RTP'::text)
          GROUP BY a."Week Ending"
        ), j AS (
         SELECT a."Week Ending",
            count(*) AS "Shanghai"
           FROM a
          WHERE ((a.host_category)::text = 'Shanghai'::text)
          GROUP BY a."Week Ending"
        ), k AS (
         SELECT a."Week Ending",
            count(*) AS "St Petersburg"
           FROM a
          WHERE ((a.host_category)::text = 'St Petersburg'::text)
          GROUP BY a."Week Ending"
        ), l AS (
         SELECT a."Week Ending",
            count(*) AS "Other"
           FROM a
          WHERE ((a.host_category)::text = 'Other'::text)
          GROUP BY a."Week Ending"
        ), y AS (
         SELECT b."Week Ending",
            c."Durham CEC",
            d."Durham EOS2",
            e."Hopkinton CEC",
            f."Hopkinton EOS2",
            g."New Jersey",
            h."Paris",
            i."RTP",
            j."Shanghai",
            k."St Petersburg",
            l."Other"
           FROM ((((((((((b
             LEFT JOIN c USING ("Week Ending"))
             LEFT JOIN d USING ("Week Ending"))
             LEFT JOIN e USING ("Week Ending"))
             LEFT JOIN f USING ("Week Ending"))
             LEFT JOIN g USING ("Week Ending"))
             LEFT JOIN h USING ("Week Ending"))
             LEFT JOIN i USING ("Week Ending"))
             LEFT JOIN j USING ("Week Ending"))
             LEFT JOIN k USING ("Week Ending"))
             LEFT JOIN l USING ("Week Ending"))
        )
 SELECT y."Week Ending",
    y."Durham CEC",
    y."Durham EOS2",
    y."Hopkinton CEC",
    y."Hopkinton EOS2",
    y."New Jersey",
    y."Paris",
    y."RTP",
    y."Shanghai",
    y."St Petersburg",
    y."Other"
   FROM y
  ORDER BY y."Week Ending";


ALTER TABLE "Weekly counts - Host Types (DE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Host Types (DE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Host Types (DE)" IS 'Data to produce graph of ''Weekly counts - Host Types''';


--
-- Name: Weekly counts - Host Types (RE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - Host Types (RE)" AS
 WITH a AS (
         SELECT (x.week)::date AS "Week Ending",
                CASE
                    WHEN ((v.site)::text ~* 'New Jersey|Paris|RTP|Shanghai|St Petersburg'::text) THEN v.site
                    WHEN ((v.cloud)::text ~* 'CEC'::text) THEN (((v.site)::text || ' CEC'::text))::character varying
                    WHEN ((v.site)::text ~* 'Durham|Hopkinton'::text) THEN ((((v.site)::text || ' '::text) || (v.cloud)::text))::character varying
                    ELSE 'Other'::character varying
                END AS host_category
           FROM ((ibidresults z
             LEFT JOIN etlresults x ON ((z.id = x.id)))
             LEFT JOIN ibidextended v ON (((v.id = z.id) AND ((v.ibid)::text = (z.ibid)::text))))
          WHERE ((x.build_class)::text = 'Rel Eng'::text)
        ), b AS (
         SELECT a."Week Ending"
           FROM a
          GROUP BY a."Week Ending"
        ), c AS (
         SELECT a."Week Ending",
            count(*) AS "Durham CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Durham CEC'::text)
          GROUP BY a."Week Ending"
        ), d AS (
         SELECT a."Week Ending",
            count(*) AS "Durham EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Durham EOS2'::text)
          GROUP BY a."Week Ending"
        ), e AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton CEC'::text)
          GROUP BY a."Week Ending"
        ), f AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton EOS2'::text)
          GROUP BY a."Week Ending"
        ), g AS (
         SELECT a."Week Ending",
            count(*) AS "New Jersey"
           FROM a
          WHERE ((a.host_category)::text = 'New Jersey'::text)
          GROUP BY a."Week Ending"
        ), h AS (
         SELECT a."Week Ending",
            count(*) AS "Paris"
           FROM a
          WHERE ((a.host_category)::text = 'Paris'::text)
          GROUP BY a."Week Ending"
        ), i AS (
         SELECT a."Week Ending",
            count(*) AS "RTP"
           FROM a
          WHERE ((a.host_category)::text = 'RTP'::text)
          GROUP BY a."Week Ending"
        ), j AS (
         SELECT a."Week Ending",
            count(*) AS "Shanghai"
           FROM a
          WHERE ((a.host_category)::text = 'Shanghai'::text)
          GROUP BY a."Week Ending"
        ), k AS (
         SELECT a."Week Ending",
            count(*) AS "St Petersburg"
           FROM a
          WHERE ((a.host_category)::text = 'St Petersburg'::text)
          GROUP BY a."Week Ending"
        ), l AS (
         SELECT a."Week Ending",
            count(*) AS "Other"
           FROM a
          WHERE ((a.host_category)::text = 'Other'::text)
          GROUP BY a."Week Ending"
        ), y AS (
         SELECT b."Week Ending",
            c."Durham CEC",
            d."Durham EOS2",
            e."Hopkinton CEC",
            f."Hopkinton EOS2",
            g."New Jersey",
            h."Paris",
            i."RTP",
            j."Shanghai",
            k."St Petersburg",
            l."Other"
           FROM ((((((((((b
             LEFT JOIN c USING ("Week Ending"))
             LEFT JOIN d USING ("Week Ending"))
             LEFT JOIN e USING ("Week Ending"))
             LEFT JOIN f USING ("Week Ending"))
             LEFT JOIN g USING ("Week Ending"))
             LEFT JOIN h USING ("Week Ending"))
             LEFT JOIN i USING ("Week Ending"))
             LEFT JOIN j USING ("Week Ending"))
             LEFT JOIN k USING ("Week Ending"))
             LEFT JOIN l USING ("Week Ending"))
        )
 SELECT y."Week Ending",
    y."Durham CEC",
    y."Durham EOS2",
    y."Hopkinton CEC",
    y."Hopkinton EOS2",
    y."New Jersey",
    y."Paris",
    y."RTP",
    y."Shanghai",
    y."St Petersburg",
    y."Other"
   FROM y
  ORDER BY y."Week Ending";


ALTER TABLE "Weekly counts - Host Types (RE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Host Types (RE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Host Types (RE)" IS 'Data to produce graph of ''Weekly counts - Host Types''';


--
-- Name: Weekly counts - components; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - components" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.fault_class,
            baseresults.ibid,
            baseresults."user",
            baseresults.acuser,
            baseresults.host,
            baseresults.hostname,
            baseresults.ipaddr,
            baseresults.status,
            baseresults.stream,
            baseresults.fault_component,
            baseresults.fault_msg,
            baseresults.fault_detail,
            baseresults.init_val,
            baseresults.pwd,
            baseresults.basis,
            baseresults.env_type,
            baseresults.native_env,
            baseresults.run_env,
            baseresults.workspace,
            baseresults.logerr,
            baseresults.logout,
            baseresults.log_subdir,
            baseresults.component,
            baseresults.component_outdir
           FROM baseresults
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), bcmpts AS (
         SELECT z.id,
            z.component,
            sum(z.duration) AS duration,
            every(((z.phase)::text = 'prepare'::text)) AS prepare,
            y.component_class AS packaging
           FROM (componentsbyoccurrence z
             LEFT JOIN componentmeta y ON (((y.component)::text = (z.component)::text)))
          WHERE ((y.component_class)::text <> 'meta'::text)
          GROUP BY z.id, z.component, y.component_class
        ), cmpts AS (
         SELECT bcmpts.id,
            bcmpts.component,
            bcmpts.duration,
            bcmpts.packaging
           FROM bcmpts
          WHERE ((bcmpts.prepare = false) OR (bcmpts.prepare IS NULL))
        ), a AS (
         SELECT (y.week)::date AS week,
                CASE
                    WHEN (((cmpts.component)::text = 'bseye'::text) OR ((cmpts.component)::text = 'bullseye'::text)) THEN 'bseyecov'::character varying
                    ELSE cmpts.component
                END AS component,
            y.result,
            base.fault_component
           FROM ((((base
             LEFT JOIN etlresults y ON ((base.id = y.id)))
             LEFT JOIN hosts x ON (((base.host)::text = (x.host)::text)))
             LEFT JOIN fault_class w ON (((base.fault_class)::text = (w.fault_class)::text)))
             LEFT JOIN cmpts ON ((base.id = cmpts.id)))
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), af AS (
         SELECT a.week,
            a.component
           FROM a
          WHERE ((a.result)::text = 'fail'::text)
        ), f02 AS (
         SELECT af.week,
            count(*) AS bamxml
           FROM af
          WHERE ((af.component)::text = 'bamxml'::text)
          GROUP BY af.week
        ), f03 AS (
         SELECT af.week,
            count(*) AS blockshim_ng
           FROM af
          WHERE ((af.component)::text = 'blockshim_ng'::text)
          GROUP BY af.week
        ), f04 AS (
         SELECT af.week,
            count(*) AS bootflash
           FROM af
          WHERE ((af.component)::text = 'bootflash'::text)
          GROUP BY af.week
        ), f06 AS (
         SELECT af.week,
            count(*) AS bseyecov
           FROM af
          WHERE ((af.component)::text = 'bseyecov'::text)
          GROUP BY af.week
        ), f07 AS (
         SELECT af.week,
            count(*) AS build
           FROM af
          WHERE ((af.component)::text = 'build'::text)
          GROUP BY af.week
        ), f09 AS (
         SELECT af.week,
            count(*) AS c4core
           FROM af
          WHERE ((af.component)::text = 'c4core'::text)
          GROUP BY af.week
        ), f10 AS (
         SELECT af.week,
            count(*) AS c4csx
           FROM af
          WHERE ((af.component)::text = 'c4csx'::text)
          GROUP BY af.week
        ), f11 AS (
         SELECT af.week,
            count(*) AS cemgui
           FROM af
          WHERE ((af.component)::text = 'cemgui'::text)
          GROUP BY af.week
        ), f12 AS (
         SELECT af.week,
            count(*) AS clariion
           FROM af
          WHERE ((af.component)::text = 'clariion'::text)
          GROUP BY af.week
        ), f13 AS (
         SELECT af.week,
            count(*) AS cloudarray
           FROM af
          WHERE ((af.component)::text = 'cloudarray'::text)
          GROUP BY af.week
        ), f14 AS (
         SELECT af.week,
            count(*) AS cp
           FROM af
          WHERE ((af.component)::text = 'cp'::text)
          GROUP BY af.week
        ), f15 AS (
         SELECT af.week,
            count(*) AS cstarball
           FROM af
          WHERE ((af.component)::text = 'cstarball'::text)
          GROUP BY af.week
        ), f16 AS (
         SELECT af.week,
            count(*) AS cta
           FROM af
          WHERE ((af.component)::text = 'cta'::text)
          GROUP BY af.week
        ), f17 AS (
         SELECT af.week,
            count(*) AS cumulus
           FROM af
          WHERE ((af.component)::text = 'cumulus'::text)
          GROUP BY af.week
        ), f18 AS (
         SELECT af.week,
            count(*) AS driver
           FROM af
          WHERE ((af.component)::text = 'driver'::text)
          GROUP BY af.week
        ), f19 AS (
         SELECT af.week,
            count(*) AS econtrolstation
           FROM af
          WHERE ((af.component)::text = 'econtrolstation'::text)
          GROUP BY af.week
        ), f20 AS (
         SELECT af.week,
            count(*) AS gms
           FROM af
          WHERE ((af.component)::text = 'gms'::text)
          GROUP BY af.week
        ), f21 AS (
         SELECT af.week,
            count(*) AS healthchecks
           FROM af
          WHERE ((af.component)::text = 'healthchecks'::text)
          GROUP BY af.week
        ), f22 AS (
         SELECT af.week,
            count(*) AS image
           FROM af
          WHERE ((af.component)::text = 'image'::text)
          GROUP BY af.week
        ), f23 AS (
         SELECT af.week,
            count(*) AS imager
           FROM af
          WHERE ((af.component)::text = 'imager'::text)
          GROUP BY af.week
        ), f24 AS (
         SELECT af.week,
            count(*) AS infrastructureproviders
           FROM af
          WHERE ((af.component)::text = 'infrastructureproviders'::text)
          GROUP BY af.week
        ), f25 AS (
         SELECT af.week,
            count(*) AS ipreflect
           FROM af
          WHERE ((af.component)::text = 'ipreflect'::text)
          GROUP BY af.week
        ), f26 AS (
         SELECT af.week,
            count(*) AS javacli
           FROM af
          WHERE ((af.component)::text = 'javacli'::text)
          GROUP BY af.week
        ), f27 AS (
         SELECT af.week,
            count(*) AS jiff
           FROM af
          WHERE ((af.component)::text = 'jiff'::text)
          GROUP BY af.week
        ), f28 AS (
         SELECT af.week,
            count(*) AS jiffcommon
           FROM af
          WHERE ((af.component)::text = 'jiffcommon'::text)
          GROUP BY af.week
        ), f29 AS (
         SELECT af.week,
            count(*) AS jmi
           FROM af
          WHERE ((af.component)::text = 'jmi'::text)
          GROUP BY af.week
        ), f30 AS (
         SELECT af.week,
            count(*) AS kernel
           FROM af
          WHERE ((af.component)::text = 'kernel'::text)
          GROUP BY af.week
        ), f31 AS (
         SELECT af.week,
            count(*) AS languages
           FROM af
          WHERE ((af.component)::text = 'languages'::text)
          GROUP BY af.week
        ), f32 AS (
         SELECT af.week,
            count(*) AS libpsm
           FROM af
          WHERE ((af.component)::text = 'libpsm'::text)
          GROUP BY af.week
        ), f33 AS (
         SELECT af.week,
            count(*) AS mf
           FROM af
          WHERE ((af.component)::text = 'mf'::text)
          GROUP BY af.week
        ), f34 AS (
         SELECT af.week,
            count(*) AS mf_common
           FROM af
          WHERE ((af.component)::text = 'mf_common'::text)
          GROUP BY af.week
        ), f35 AS (
         SELECT af.week,
            count(*) AS nxgui
           FROM af
          WHERE ((af.component)::text = 'nxgui'::text)
          GROUP BY af.week
        ), f36 AS (
         SELECT af.week,
            count(*) AS observability
           FROM af
          WHERE ((af.component)::text = 'observability'::text)
          GROUP BY af.week
        ), f37 AS (
         SELECT af.week,
            count(*) AS ofed
           FROM af
          WHERE ((af.component)::text = 'ofed'::text)
          GROUP BY af.week
        ), f39 AS (
         SELECT af.week,
            count(*) AS papi
           FROM af
          WHERE ((af.component)::text = 'papi'::text)
          GROUP BY af.week
        ), f40 AS (
         SELECT af.week,
            count(*) AS perf
           FROM af
          WHERE ((af.component)::text = 'perf'::text)
          GROUP BY af.week
        ), f42 AS (
         SELECT af.week,
            count(*) AS restcommon
           FROM af
          WHERE ((af.component)::text = 'restcommon'::text)
          GROUP BY af.week
        ), f43 AS (
         SELECT af.week,
            count(*) AS rpms
           FROM af
          WHERE ((af.component)::text = 'rpms'::text)
          GROUP BY af.week
        ), f44 AS (
         SELECT af.week,
            count(*) AS rpmsinfq
           FROM af
          WHERE ((af.component)::text = 'rpmsinfq'::text)
          GROUP BY af.week
        ), f45 AS (
         SELECT af.week,
            count(*) AS sade
           FROM af
          WHERE ((af.component)::text = 'sade'::text)
          GROUP BY af.week
        ), f46 AS (
         SELECT af.week,
            count(*) AS safe
           FROM af
          WHERE ((af.component)::text = 'safe'::text)
          GROUP BY af.week
        ), f47 AS (
         SELECT af.week,
            count(*) AS security
           FROM af
          WHERE ((af.component)::text = 'security'::text)
          GROUP BY af.week
        ), f48 AS (
         SELECT af.week,
            count(*) AS serviceability
           FROM af
          WHERE ((af.component)::text = 'serviceability'::text)
          GROUP BY af.week
        ), f50 AS (
         SELECT af.week,
            count(*) AS sles
           FROM af
          WHERE ((af.component)::text = 'sles'::text)
          GROUP BY af.week
        ), f51 AS (
         SELECT af.week,
            count(*) AS "sys-common"
           FROM af
          WHERE ((af.component)::text = 'sys-common'::text)
          GROUP BY af.week
        ), f52 AS (
         SELECT af.week,
            count(*) AS systemtap
           FROM af
          WHERE ((af.component)::text = 'systemtap'::text)
          GROUP BY af.week
        ), f53 AS (
         SELECT af.week,
            count(*) AS tbn
           FROM af
          WHERE ((af.component)::text = 'tbn'::text)
          GROUP BY af.week
        ), f54 AS (
         SELECT af.week,
            count(*) AS tomcatcommon
           FROM af
          WHERE ((af.component)::text = 'tomcatcommon'::text)
          GROUP BY af.week
        ), f55 AS (
         SELECT af.week,
            count(*) AS udoctor
           FROM af
          WHERE ((af.component)::text = 'udoctor'::text)
          GROUP BY af.week
        ), f56 AS (
         SELECT af.week,
            count(*) AS uemcli
           FROM af
          WHERE ((af.component)::text = 'uemcli'::text)
          GROUP BY af.week
        ), f57 AS (
         SELECT af.week,
            count(*) AS unirest
           FROM af
          WHERE ((af.component)::text = 'unirest'::text)
          GROUP BY af.week
        ), f58 AS (
         SELECT af.week,
            count(*) AS univasa
           FROM af
          WHERE ((af.component)::text = 'univasa'::text)
          GROUP BY af.week
        ), f59 AS (
         SELECT af.week,
            count(*) AS upgrade
           FROM af
          WHERE ((af.component)::text = 'upgrade'::text)
          GROUP BY af.week
        ), f60 AS (
         SELECT af.week,
            count(*) AS vmwaresdkclient
           FROM af
          WHERE ((af.component)::text = 'vmwaresdkclient'::text)
          GROUP BY af.week
        ), f61 AS (
         SELECT af.week,
            count(*) AS vsockets
           FROM af
          WHERE ((af.component)::text = 'vsockets'::text)
          GROUP BY af.week
        ), f62 AS (
         SELECT af.week,
            count(*) AS vtune
           FROM af
          WHERE ((af.component)::text = 'vtune'::text)
          GROUP BY af.week
        ), f63 AS (
         SELECT af.week,
            count(*) AS vvnxdeploydual
           FROM af
          WHERE ((af.component)::text = 'vvnxdeploydual'::text)
          GROUP BY af.week
        ), ff AS (
         SELECT aa.week,
            f02.bamxml,
            f03.blockshim_ng,
            f04.bootflash,
            f06.bseyecov,
            f07.build,
            f09.c4core,
            f10.c4csx,
            f11.cemgui,
            f12.clariion,
            f13.cloudarray,
            f14.cp,
            f15.cstarball,
            f16.cta,
            f17.cumulus,
            f18.driver,
            f19.econtrolstation,
            f20.gms,
            f21.healthchecks,
            f22.image,
            f23.imager,
            f24.infrastructureproviders,
            f25.ipreflect,
            f26.javacli,
            f27.jiff,
            f28.jiffcommon,
            f29.jmi,
            f30.kernel,
            f31.languages,
            f32.libpsm,
            f33.mf,
            f34.mf_common,
            f35.nxgui,
            f36.observability,
            f37.ofed,
            f39.papi,
            f40.perf,
            f42.restcommon,
            f43.rpms,
            f44.rpmsinfq,
            f45.sade,
            f46.safe,
            f47.security,
            f48.serviceability,
            f50.sles,
            f51."sys-common",
            f52.systemtap,
            f53.tbn,
            f54.tomcatcommon,
            f55.udoctor,
            f56.uemcli,
            f57.unirest,
            f58.univasa,
            f59.upgrade,
            f60.vmwaresdkclient,
            f61.vsockets,
            f62.vtune,
            f63.vvnxdeploydual,
            'fail'::text AS result
           FROM (((((((((((((((((((((((((((((((((((((((((((((((((((((((((aa
             LEFT JOIN f02 USING (week))
             LEFT JOIN f03 USING (week))
             LEFT JOIN f04 USING (week))
             LEFT JOIN f06 USING (week))
             LEFT JOIN f07 USING (week))
             LEFT JOIN f09 USING (week))
             LEFT JOIN f10 USING (week))
             LEFT JOIN f11 USING (week))
             LEFT JOIN f12 USING (week))
             LEFT JOIN f13 USING (week))
             LEFT JOIN f14 USING (week))
             LEFT JOIN f15 USING (week))
             LEFT JOIN f16 USING (week))
             LEFT JOIN f17 USING (week))
             LEFT JOIN f18 USING (week))
             LEFT JOIN f19 USING (week))
             LEFT JOIN f20 USING (week))
             LEFT JOIN f21 USING (week))
             LEFT JOIN f22 USING (week))
             LEFT JOIN f23 USING (week))
             LEFT JOIN f24 USING (week))
             LEFT JOIN f25 USING (week))
             LEFT JOIN f26 USING (week))
             LEFT JOIN f27 USING (week))
             LEFT JOIN f28 USING (week))
             LEFT JOIN f29 USING (week))
             LEFT JOIN f30 USING (week))
             LEFT JOIN f31 USING (week))
             LEFT JOIN f32 USING (week))
             LEFT JOIN f33 USING (week))
             LEFT JOIN f34 USING (week))
             LEFT JOIN f35 USING (week))
             LEFT JOIN f36 USING (week))
             LEFT JOIN f37 USING (week))
             LEFT JOIN f39 USING (week))
             LEFT JOIN f40 USING (week))
             LEFT JOIN f42 USING (week))
             LEFT JOIN f43 USING (week))
             LEFT JOIN f44 USING (week))
             LEFT JOIN f45 USING (week))
             LEFT JOIN f46 USING (week))
             LEFT JOIN f47 USING (week))
             LEFT JOIN f48 USING (week))
             LEFT JOIN f50 USING (week))
             LEFT JOIN f51 USING (week))
             LEFT JOIN f52 USING (week))
             LEFT JOIN f53 USING (week))
             LEFT JOIN f54 USING (week))
             LEFT JOIN f55 USING (week))
             LEFT JOIN f56 USING (week))
             LEFT JOIN f57 USING (week))
             LEFT JOIN f58 USING (week))
             LEFT JOIN f59 USING (week))
             LEFT JOIN f60 USING (week))
             LEFT JOIN f61 USING (week))
             LEFT JOIN f62 USING (week))
             LEFT JOIN f63 USING (week))
        ), ap AS (
         SELECT a.week,
            a.component
           FROM a
          WHERE (((a.result)::text = 'pass'::text) AND ((a.component)::text <> (a.fault_component)::text))
        ), p02 AS (
         SELECT ap.week,
            count(*) AS bamxml
           FROM ap
          WHERE ((ap.component)::text = 'bamxml'::text)
          GROUP BY ap.week
        ), p03 AS (
         SELECT ap.week,
            count(*) AS blockshim_ng
           FROM ap
          WHERE ((ap.component)::text = 'blockshim_ng'::text)
          GROUP BY ap.week
        ), p04 AS (
         SELECT ap.week,
            count(*) AS bootflash
           FROM ap
          WHERE ((ap.component)::text = 'bootflash'::text)
          GROUP BY ap.week
        ), p06 AS (
         SELECT ap.week,
            count(*) AS bseyecov
           FROM ap
          WHERE ((ap.component)::text = 'bseyecov'::text)
          GROUP BY ap.week
        ), p07 AS (
         SELECT ap.week,
            count(*) AS build
           FROM ap
          WHERE ((ap.component)::text = 'build'::text)
          GROUP BY ap.week
        ), p09 AS (
         SELECT ap.week,
            count(*) AS c4core
           FROM ap
          WHERE ((ap.component)::text = 'c4core'::text)
          GROUP BY ap.week
        ), p10 AS (
         SELECT ap.week,
            count(*) AS c4csx
           FROM ap
          WHERE ((ap.component)::text = 'c4csx'::text)
          GROUP BY ap.week
        ), p11 AS (
         SELECT ap.week,
            count(*) AS cemgui
           FROM ap
          WHERE ((ap.component)::text = 'cemgui'::text)
          GROUP BY ap.week
        ), p12 AS (
         SELECT ap.week,
            count(*) AS clariion
           FROM ap
          WHERE ((ap.component)::text = 'clariion'::text)
          GROUP BY ap.week
        ), p13 AS (
         SELECT ap.week,
            count(*) AS cloudarray
           FROM ap
          WHERE ((ap.component)::text = 'cloudarray'::text)
          GROUP BY ap.week
        ), p14 AS (
         SELECT ap.week,
            count(*) AS cp
           FROM ap
          WHERE ((ap.component)::text = 'cp'::text)
          GROUP BY ap.week
        ), p15 AS (
         SELECT ap.week,
            count(*) AS cstarball
           FROM ap
          WHERE ((ap.component)::text = 'cstarball'::text)
          GROUP BY ap.week
        ), p16 AS (
         SELECT ap.week,
            count(*) AS cta
           FROM ap
          WHERE ((ap.component)::text = 'cta'::text)
          GROUP BY ap.week
        ), p17 AS (
         SELECT ap.week,
            count(*) AS cumulus
           FROM ap
          WHERE ((ap.component)::text = 'cumulus'::text)
          GROUP BY ap.week
        ), p18 AS (
         SELECT ap.week,
            count(*) AS driver
           FROM ap
          WHERE ((ap.component)::text = 'driver'::text)
          GROUP BY ap.week
        ), p19 AS (
         SELECT ap.week,
            count(*) AS econtrolstation
           FROM ap
          WHERE ((ap.component)::text = 'econtrolstation'::text)
          GROUP BY ap.week
        ), p20 AS (
         SELECT ap.week,
            count(*) AS gms
           FROM ap
          WHERE ((ap.component)::text = 'gms'::text)
          GROUP BY ap.week
        ), p21 AS (
         SELECT ap.week,
            count(*) AS healthchecks
           FROM ap
          WHERE ((ap.component)::text = 'healthchecks'::text)
          GROUP BY ap.week
        ), p22 AS (
         SELECT ap.week,
            count(*) AS image
           FROM ap
          WHERE ((ap.component)::text = 'image'::text)
          GROUP BY ap.week
        ), p23 AS (
         SELECT ap.week,
            count(*) AS imager
           FROM ap
          WHERE ((ap.component)::text = 'imager'::text)
          GROUP BY ap.week
        ), p24 AS (
         SELECT ap.week,
            count(*) AS infrastructureproviders
           FROM ap
          WHERE ((ap.component)::text = 'infrastructureproviders'::text)
          GROUP BY ap.week
        ), p25 AS (
         SELECT ap.week,
            count(*) AS ipreflect
           FROM ap
          WHERE ((ap.component)::text = 'ipreflect'::text)
          GROUP BY ap.week
        ), p26 AS (
         SELECT ap.week,
            count(*) AS javacli
           FROM ap
          WHERE ((ap.component)::text = 'javacli'::text)
          GROUP BY ap.week
        ), p27 AS (
         SELECT ap.week,
            count(*) AS jiff
           FROM ap
          WHERE ((ap.component)::text = 'jiff'::text)
          GROUP BY ap.week
        ), p28 AS (
         SELECT ap.week,
            count(*) AS jiffcommon
           FROM ap
          WHERE ((ap.component)::text = 'jiffcommon'::text)
          GROUP BY ap.week
        ), p29 AS (
         SELECT ap.week,
            count(*) AS jmi
           FROM ap
          WHERE ((ap.component)::text = 'jmi'::text)
          GROUP BY ap.week
        ), p30 AS (
         SELECT ap.week,
            count(*) AS kernel
           FROM ap
          WHERE ((ap.component)::text = 'kernel'::text)
          GROUP BY ap.week
        ), p31 AS (
         SELECT ap.week,
            count(*) AS languages
           FROM ap
          WHERE ((ap.component)::text = 'languages'::text)
          GROUP BY ap.week
        ), p32 AS (
         SELECT ap.week,
            count(*) AS libpsm
           FROM ap
          WHERE ((ap.component)::text = 'libpsm'::text)
          GROUP BY ap.week
        ), p33 AS (
         SELECT ap.week,
            count(*) AS mf
           FROM ap
          WHERE ((ap.component)::text = 'mf'::text)
          GROUP BY ap.week
        ), p34 AS (
         SELECT ap.week,
            count(*) AS mf_common
           FROM ap
          WHERE ((ap.component)::text = 'mf_common'::text)
          GROUP BY ap.week
        ), p35 AS (
         SELECT ap.week,
            count(*) AS nxgui
           FROM ap
          WHERE ((ap.component)::text = 'nxgui'::text)
          GROUP BY ap.week
        ), p36 AS (
         SELECT ap.week,
            count(*) AS observability
           FROM ap
          WHERE ((ap.component)::text = 'observability'::text)
          GROUP BY ap.week
        ), p37 AS (
         SELECT ap.week,
            count(*) AS ofed
           FROM ap
          WHERE ((ap.component)::text = 'ofed'::text)
          GROUP BY ap.week
        ), p39 AS (
         SELECT ap.week,
            count(*) AS papi
           FROM ap
          WHERE ((ap.component)::text = 'papi'::text)
          GROUP BY ap.week
        ), p40 AS (
         SELECT ap.week,
            count(*) AS perf
           FROM ap
          WHERE ((ap.component)::text = 'perf'::text)
          GROUP BY ap.week
        ), p42 AS (
         SELECT ap.week,
            count(*) AS restcommon
           FROM ap
          WHERE ((ap.component)::text = 'restcommon'::text)
          GROUP BY ap.week
        ), p43 AS (
         SELECT ap.week,
            count(*) AS rpms
           FROM ap
          WHERE ((ap.component)::text = 'rpms'::text)
          GROUP BY ap.week
        ), p44 AS (
         SELECT ap.week,
            count(*) AS rpmsinfq
           FROM ap
          WHERE ((ap.component)::text = 'rpmsinfq'::text)
          GROUP BY ap.week
        ), p45 AS (
         SELECT ap.week,
            count(*) AS sade
           FROM ap
          WHERE ((ap.component)::text = 'sade'::text)
          GROUP BY ap.week
        ), p46 AS (
         SELECT ap.week,
            count(*) AS safe
           FROM ap
          WHERE ((ap.component)::text = 'safe'::text)
          GROUP BY ap.week
        ), p47 AS (
         SELECT ap.week,
            count(*) AS security
           FROM ap
          WHERE ((ap.component)::text = 'security'::text)
          GROUP BY ap.week
        ), p48 AS (
         SELECT ap.week,
            count(*) AS serviceability
           FROM ap
          WHERE ((ap.component)::text = 'serviceability'::text)
          GROUP BY ap.week
        ), p50 AS (
         SELECT ap.week,
            count(*) AS sles
           FROM ap
          WHERE ((ap.component)::text = 'sles'::text)
          GROUP BY ap.week
        ), p51 AS (
         SELECT ap.week,
            count(*) AS "sys-common"
           FROM ap
          WHERE ((ap.component)::text = 'sys-common'::text)
          GROUP BY ap.week
        ), p52 AS (
         SELECT ap.week,
            count(*) AS systemtap
           FROM ap
          WHERE ((ap.component)::text = 'systemtap'::text)
          GROUP BY ap.week
        ), p53 AS (
         SELECT ap.week,
            count(*) AS tbn
           FROM ap
          WHERE ((ap.component)::text = 'tbn'::text)
          GROUP BY ap.week
        ), p54 AS (
         SELECT ap.week,
            count(*) AS tomcatcommon
           FROM ap
          WHERE ((ap.component)::text = 'tomcatcommon'::text)
          GROUP BY ap.week
        ), p55 AS (
         SELECT ap.week,
            count(*) AS udoctor
           FROM ap
          WHERE ((ap.component)::text = 'udoctor'::text)
          GROUP BY ap.week
        ), p56 AS (
         SELECT ap.week,
            count(*) AS uemcli
           FROM ap
          WHERE ((ap.component)::text = 'uemcli'::text)
          GROUP BY ap.week
        ), p57 AS (
         SELECT ap.week,
            count(*) AS unirest
           FROM ap
          WHERE ((ap.component)::text = 'unirest'::text)
          GROUP BY ap.week
        ), p58 AS (
         SELECT ap.week,
            count(*) AS univasa
           FROM ap
          WHERE ((ap.component)::text = 'univasa'::text)
          GROUP BY ap.week
        ), p59 AS (
         SELECT ap.week,
            count(*) AS upgrade
           FROM ap
          WHERE ((ap.component)::text = 'upgrade'::text)
          GROUP BY ap.week
        ), p60 AS (
         SELECT ap.week,
            count(*) AS vmwaresdkclient
           FROM ap
          WHERE ((ap.component)::text = 'vmwaresdkclient'::text)
          GROUP BY ap.week
        ), p61 AS (
         SELECT ap.week,
            count(*) AS vsockets
           FROM ap
          WHERE ((ap.component)::text = 'vsockets'::text)
          GROUP BY ap.week
        ), p62 AS (
         SELECT ap.week,
            count(*) AS vtune
           FROM ap
          WHERE ((ap.component)::text = 'vtune'::text)
          GROUP BY ap.week
        ), p63 AS (
         SELECT ap.week,
            count(*) AS vvnxdeploydual
           FROM ap
          WHERE ((ap.component)::text = 'vvnxdeploydual'::text)
          GROUP BY ap.week
        ), pp AS (
         SELECT aa.week,
            p02.bamxml,
            p03.blockshim_ng,
            p04.bootflash,
            p06.bseyecov,
            p07.build,
            p09.c4core,
            p10.c4csx,
            p11.cemgui,
            p12.clariion,
            p13.cloudarray,
            p14.cp,
            p15.cstarball,
            p16.cta,
            p17.cumulus,
            p18.driver,
            p19.econtrolstation,
            p20.gms,
            p21.healthchecks,
            p22.image,
            p23.imager,
            p24.infrastructureproviders,
            p25.ipreflect,
            p26.javacli,
            p27.jiff,
            p28.jiffcommon,
            p29.jmi,
            p30.kernel,
            p31.languages,
            p32.libpsm,
            p33.mf,
            p34.mf_common,
            p35.nxgui,
            p36.observability,
            p37.ofed,
            p39.papi,
            p40.perf,
            p42.restcommon,
            p43.rpms,
            p44.rpmsinfq,
            p45.sade,
            p46.safe,
            p47.security,
            p48.serviceability,
            p50.sles,
            p51."sys-common",
            p52.systemtap,
            p53.tbn,
            p54.tomcatcommon,
            p55.udoctor,
            p56.uemcli,
            p57.unirest,
            p58.univasa,
            p59.upgrade,
            p60.vmwaresdkclient,
            p61.vsockets,
            p62.vtune,
            p63.vvnxdeploydual,
            'pass'::text AS result
           FROM (((((((((((((((((((((((((((((((((((((((((((((((((((((((((aa
             LEFT JOIN p02 USING (week))
             LEFT JOIN p03 USING (week))
             LEFT JOIN p04 USING (week))
             LEFT JOIN p06 USING (week))
             LEFT JOIN p07 USING (week))
             LEFT JOIN p09 USING (week))
             LEFT JOIN p10 USING (week))
             LEFT JOIN p11 USING (week))
             LEFT JOIN p12 USING (week))
             LEFT JOIN p13 USING (week))
             LEFT JOIN p14 USING (week))
             LEFT JOIN p15 USING (week))
             LEFT JOIN p16 USING (week))
             LEFT JOIN p17 USING (week))
             LEFT JOIN p18 USING (week))
             LEFT JOIN p19 USING (week))
             LEFT JOIN p20 USING (week))
             LEFT JOIN p21 USING (week))
             LEFT JOIN p22 USING (week))
             LEFT JOIN p23 USING (week))
             LEFT JOIN p24 USING (week))
             LEFT JOIN p25 USING (week))
             LEFT JOIN p26 USING (week))
             LEFT JOIN p27 USING (week))
             LEFT JOIN p28 USING (week))
             LEFT JOIN p29 USING (week))
             LEFT JOIN p30 USING (week))
             LEFT JOIN p31 USING (week))
             LEFT JOIN p32 USING (week))
             LEFT JOIN p33 USING (week))
             LEFT JOIN p34 USING (week))
             LEFT JOIN p35 USING (week))
             LEFT JOIN p36 USING (week))
             LEFT JOIN p37 USING (week))
             LEFT JOIN p39 USING (week))
             LEFT JOIN p40 USING (week))
             LEFT JOIN p42 USING (week))
             LEFT JOIN p43 USING (week))
             LEFT JOIN p44 USING (week))
             LEFT JOIN p45 USING (week))
             LEFT JOIN p46 USING (week))
             LEFT JOIN p47 USING (week))
             LEFT JOIN p48 USING (week))
             LEFT JOIN p50 USING (week))
             LEFT JOIN p51 USING (week))
             LEFT JOIN p52 USING (week))
             LEFT JOIN p53 USING (week))
             LEFT JOIN p54 USING (week))
             LEFT JOIN p55 USING (week))
             LEFT JOIN p56 USING (week))
             LEFT JOIN p57 USING (week))
             LEFT JOIN p58 USING (week))
             LEFT JOIN p59 USING (week))
             LEFT JOIN p60 USING (week))
             LEFT JOIN p61 USING (week))
             LEFT JOIN p62 USING (week))
             LEFT JOIN p63 USING (week))
        ), r02 AS (
         SELECT f02.week,
            ((f02.bamxml)::real / ((f02.bamxml + p02.bamxml))::real) AS bamxml
           FROM (f02
             LEFT JOIN p02 USING (week))
        ), r03 AS (
         SELECT f03.week,
            ((f03.blockshim_ng)::real / ((f03.blockshim_ng + p03.blockshim_ng))::real) AS blockshim_ng
           FROM (f03
             LEFT JOIN p03 USING (week))
        ), r04 AS (
         SELECT f04.week,
            ((f04.bootflash)::real / ((f04.bootflash + p04.bootflash))::real) AS bootflash
           FROM (f04
             LEFT JOIN p04 USING (week))
        ), r06 AS (
         SELECT f06.week,
            ((f06.bseyecov)::real / ((f06.bseyecov + p06.bseyecov))::real) AS bseyecov
           FROM (f06
             LEFT JOIN p06 USING (week))
        ), r07 AS (
         SELECT f07.week,
            ((f07.build)::real / ((f07.build + p07.build))::real) AS build
           FROM (f07
             LEFT JOIN p07 USING (week))
        ), r09 AS (
         SELECT f09.week,
            ((f09.c4core)::real / ((f09.c4core + p09.c4core))::real) AS c4core
           FROM (f09
             LEFT JOIN p09 USING (week))
        ), r10 AS (
         SELECT f10.week,
            ((f10.c4csx)::real / ((f10.c4csx + p10.c4csx))::real) AS c4csx
           FROM (f10
             LEFT JOIN p10 USING (week))
        ), r11 AS (
         SELECT f11.week,
            ((f11.cemgui)::real / ((f11.cemgui + p11.cemgui))::real) AS cemgui
           FROM (f11
             LEFT JOIN p11 USING (week))
        ), r12 AS (
         SELECT f12.week,
            ((f12.clariion)::real / ((f12.clariion + p12.clariion))::real) AS clariion
           FROM (f12
             LEFT JOIN p12 USING (week))
        ), r13 AS (
         SELECT f13.week,
            ((f13.cloudarray)::real / ((f13.cloudarray + p13.cloudarray))::real) AS cloudarray
           FROM (f13
             LEFT JOIN p13 USING (week))
        ), r14 AS (
         SELECT f14.week,
            ((f14.cp)::real / ((f14.cp + p14.cp))::real) AS cp
           FROM (f14
             LEFT JOIN p14 USING (week))
        ), r15 AS (
         SELECT f15.week,
            ((f15.cstarball)::real / ((f15.cstarball + p15.cstarball))::real) AS cstarball
           FROM (f15
             LEFT JOIN p15 USING (week))
        ), r16 AS (
         SELECT f16.week,
            ((f16.cta)::real / ((f16.cta + p16.cta))::real) AS cta
           FROM (f16
             LEFT JOIN p16 USING (week))
        ), r17 AS (
         SELECT f17.week,
            ((f17.cumulus)::real / ((f17.cumulus + p17.cumulus))::real) AS cumulus
           FROM (f17
             LEFT JOIN p17 USING (week))
        ), r18 AS (
         SELECT f18.week,
            ((f18.driver)::real / ((f18.driver + p18.driver))::real) AS driver
           FROM (f18
             LEFT JOIN p18 USING (week))
        ), r19 AS (
         SELECT f19.week,
            ((f19.econtrolstation)::real / ((f19.econtrolstation + p19.econtrolstation))::real) AS econtrolstation
           FROM (f19
             LEFT JOIN p19 USING (week))
        ), r20 AS (
         SELECT f20.week,
            ((f20.gms)::real / ((f20.gms + p20.gms))::real) AS gms
           FROM (f20
             LEFT JOIN p20 USING (week))
        ), r21 AS (
         SELECT f21.week,
            ((f21.healthchecks)::real / ((f21.healthchecks + p21.healthchecks))::real) AS healthchecks
           FROM (f21
             LEFT JOIN p21 USING (week))
        ), r22 AS (
         SELECT f22.week,
            ((f22.image)::real / ((f22.image + p22.image))::real) AS image
           FROM (f22
             LEFT JOIN p22 USING (week))
        ), r23 AS (
         SELECT f23.week,
            ((f23.imager)::real / ((f23.imager + p23.imager))::real) AS imager
           FROM (f23
             LEFT JOIN p23 USING (week))
        ), r24 AS (
         SELECT f24.week,
            ((f24.infrastructureproviders)::real / ((f24.infrastructureproviders + p24.infrastructureproviders))::real) AS infrastructureproviders
           FROM (f24
             LEFT JOIN p24 USING (week))
        ), r25 AS (
         SELECT f25.week,
            ((f25.ipreflect)::real / ((f25.ipreflect + p25.ipreflect))::real) AS ipreflect
           FROM (f25
             LEFT JOIN p25 USING (week))
        ), r26 AS (
         SELECT f26.week,
            ((f26.javacli)::real / ((f26.javacli + p26.javacli))::real) AS javacli
           FROM (f26
             LEFT JOIN p26 USING (week))
        ), r27 AS (
         SELECT f27.week,
            ((f27.jiff)::real / ((f27.jiff + p27.jiff))::real) AS jiff
           FROM (f27
             LEFT JOIN p27 USING (week))
        ), r28 AS (
         SELECT f28.week,
            ((f28.jiffcommon)::real / ((f28.jiffcommon + p28.jiffcommon))::real) AS jiffcommon
           FROM (f28
             LEFT JOIN p28 USING (week))
        ), r29 AS (
         SELECT f29.week,
            ((f29.jmi)::real / ((f29.jmi + p29.jmi))::real) AS jmi
           FROM (f29
             LEFT JOIN p29 USING (week))
        ), r30 AS (
         SELECT f30.week,
            ((f30.kernel)::real / ((f30.kernel + p30.kernel))::real) AS kernel
           FROM (f30
             LEFT JOIN p30 USING (week))
        ), r31 AS (
         SELECT f31.week,
            ((f31.languages)::real / ((f31.languages + p31.languages))::real) AS languages
           FROM (f31
             LEFT JOIN p31 USING (week))
        ), r32 AS (
         SELECT f32.week,
            ((f32.libpsm)::real / ((f32.libpsm + p32.libpsm))::real) AS libpsm
           FROM (f32
             LEFT JOIN p32 USING (week))
        ), r33 AS (
         SELECT f33.week,
            ((f33.mf)::real / ((f33.mf + p33.mf))::real) AS mf
           FROM (f33
             LEFT JOIN p33 USING (week))
        ), r34 AS (
         SELECT f34.week,
            ((f34.mf_common)::real / ((f34.mf_common + p34.mf_common))::real) AS mf_common
           FROM (f34
             LEFT JOIN p34 USING (week))
        ), r35 AS (
         SELECT f35.week,
            ((f35.nxgui)::real / ((f35.nxgui + p35.nxgui))::real) AS nxgui
           FROM (f35
             LEFT JOIN p35 USING (week))
        ), r36 AS (
         SELECT f36.week,
            ((f36.observability)::real / ((f36.observability + p36.observability))::real) AS observability
           FROM (f36
             LEFT JOIN p36 USING (week))
        ), r37 AS (
         SELECT f37.week,
            ((f37.ofed)::real / ((f37.ofed + p37.ofed))::real) AS ofed
           FROM (f37
             LEFT JOIN p37 USING (week))
        ), r39 AS (
         SELECT f39.week,
            ((f39.papi)::real / ((f39.papi + p39.papi))::real) AS papi
           FROM (f39
             LEFT JOIN p39 USING (week))
        ), r40 AS (
         SELECT f40.week,
            ((f40.perf)::real / ((f40.perf + p40.perf))::real) AS perf
           FROM (f40
             LEFT JOIN p40 USING (week))
        ), r42 AS (
         SELECT f42.week,
            ((f42.restcommon)::real / ((f42.restcommon + p42.restcommon))::real) AS restcommon
           FROM (f42
             LEFT JOIN p42 USING (week))
        ), r43 AS (
         SELECT f43.week,
            ((f43.rpms)::real / ((f43.rpms + p43.rpms))::real) AS rpms
           FROM (f43
             LEFT JOIN p43 USING (week))
        ), r44 AS (
         SELECT f44.week,
            ((f44.rpmsinfq)::real / ((f44.rpmsinfq + p44.rpmsinfq))::real) AS rpmsinfq
           FROM (f44
             LEFT JOIN p44 USING (week))
        ), r45 AS (
         SELECT f45.week,
            ((f45.sade)::real / ((f45.sade + p45.sade))::real) AS sade
           FROM (f45
             LEFT JOIN p45 USING (week))
        ), r46 AS (
         SELECT f46.week,
            ((f46.safe)::real / ((f46.safe + p46.safe))::real) AS safe
           FROM (f46
             LEFT JOIN p46 USING (week))
        ), r47 AS (
         SELECT f47.week,
            ((f47.security)::real / ((f47.security + p47.security))::real) AS security
           FROM (f47
             LEFT JOIN p47 USING (week))
        ), r48 AS (
         SELECT f48.week,
            ((f48.serviceability)::real / ((f48.serviceability + p48.serviceability))::real) AS serviceability
           FROM (f48
             LEFT JOIN p48 USING (week))
        ), r50 AS (
         SELECT f50.week,
            ((f50.sles)::real / ((f50.sles + p50.sles))::real) AS sles
           FROM (f50
             LEFT JOIN p50 USING (week))
        ), r51 AS (
         SELECT f51.week,
            ((f51."sys-common")::real / ((f51."sys-common" + p51."sys-common"))::real) AS "sys-common"
           FROM (f51
             LEFT JOIN p51 USING (week))
        ), r52 AS (
         SELECT f52.week,
            ((f52.systemtap)::real / ((f52.systemtap + p52.systemtap))::real) AS systemtap
           FROM (f52
             LEFT JOIN p52 USING (week))
        ), r53 AS (
         SELECT f53.week,
            ((f53.tbn)::real / ((f53.tbn + p53.tbn))::real) AS tbn
           FROM (f53
             LEFT JOIN p53 USING (week))
        ), r54 AS (
         SELECT f54.week,
            ((f54.tomcatcommon)::real / ((f54.tomcatcommon + p54.tomcatcommon))::real) AS tomcatcommon
           FROM (f54
             LEFT JOIN p54 USING (week))
        ), r55 AS (
         SELECT f55.week,
            ((f55.udoctor)::real / ((f55.udoctor + p55.udoctor))::real) AS udoctor
           FROM (f55
             LEFT JOIN p55 USING (week))
        ), r56 AS (
         SELECT f56.week,
            ((f56.uemcli)::real / ((f56.uemcli + p56.uemcli))::real) AS uemcli
           FROM (f56
             LEFT JOIN p56 USING (week))
        ), r57 AS (
         SELECT f57.week,
            ((f57.unirest)::real / ((f57.unirest + p57.unirest))::real) AS unirest
           FROM (f57
             LEFT JOIN p57 USING (week))
        ), r58 AS (
         SELECT f58.week,
            ((f58.univasa)::real / ((f58.univasa + p58.univasa))::real) AS univasa
           FROM (f58
             LEFT JOIN p58 USING (week))
        ), r59 AS (
         SELECT f59.week,
            ((f59.upgrade)::real / ((f59.upgrade + p59.upgrade))::real) AS upgrade
           FROM (f59
             LEFT JOIN p59 USING (week))
        ), r60 AS (
         SELECT f60.week,
            ((f60.vmwaresdkclient)::real / ((f60.vmwaresdkclient + p60.vmwaresdkclient))::real) AS vmwaresdkclient
           FROM (f60
             LEFT JOIN p60 USING (week))
        ), r61 AS (
         SELECT f61.week,
            ((f61.vsockets)::real / ((f61.vsockets + p61.vsockets))::real) AS vsockets
           FROM (f61
             LEFT JOIN p61 USING (week))
        ), r62 AS (
         SELECT f62.week,
            ((f62.vtune)::real / ((f62.vtune + p62.vtune))::real) AS vtune
           FROM (f62
             LEFT JOIN p62 USING (week))
        ), r63 AS (
         SELECT f63.week,
            ((f63.vvnxdeploydual)::real / ((f63.vvnxdeploydual + p63.vvnxdeploydual))::real) AS vvnxdeploydual
           FROM (f63
             LEFT JOIN p63 USING (week))
        ), rr AS (
         SELECT aa.week,
            r02.bamxml,
            r03.blockshim_ng,
            r04.bootflash,
            r06.bseyecov,
            r07.build,
            r09.c4core,
            r10.c4csx,
            r11.cemgui,
            r12.clariion,
            r13.cloudarray,
            r14.cp,
            r15.cstarball,
            r16.cta,
            r17.cumulus,
            r18.driver,
            r19.econtrolstation,
            r20.gms,
            r21.healthchecks,
            r22.image,
            r23.imager,
            r24.infrastructureproviders,
            r25.ipreflect,
            r26.javacli,
            r27.jiff,
            r28.jiffcommon,
            r29.jmi,
            r30.kernel,
            r31.languages,
            r32.libpsm,
            r33.mf,
            r34.mf_common,
            r35.nxgui,
            r36.observability,
            r37.ofed,
            r39.papi,
            r40.perf,
            r42.restcommon,
            r43.rpms,
            r44.rpmsinfq,
            r45.sade,
            r46.safe,
            r47.security,
            r48.serviceability,
            r50.sles,
            r51."sys-common",
            r52.systemtap,
            r53.tbn,
            r54.tomcatcommon,
            r55.udoctor,
            r56.uemcli,
            r57.unirest,
            r58.univasa,
            r59.upgrade,
            r60.vmwaresdkclient,
            r61.vsockets,
            r62.vtune,
            r63.vvnxdeploydual,
            'reliability'::text AS result
           FROM (((((((((((((((((((((((((((((((((((((((((((((((((((((((((aa
             LEFT JOIN r02 USING (week))
             LEFT JOIN r03 USING (week))
             LEFT JOIN r04 USING (week))
             LEFT JOIN r06 USING (week))
             LEFT JOIN r07 USING (week))
             LEFT JOIN r09 USING (week))
             LEFT JOIN r10 USING (week))
             LEFT JOIN r11 USING (week))
             LEFT JOIN r12 USING (week))
             LEFT JOIN r13 USING (week))
             LEFT JOIN r14 USING (week))
             LEFT JOIN r15 USING (week))
             LEFT JOIN r16 USING (week))
             LEFT JOIN r17 USING (week))
             LEFT JOIN r18 USING (week))
             LEFT JOIN r19 USING (week))
             LEFT JOIN r20 USING (week))
             LEFT JOIN r21 USING (week))
             LEFT JOIN r22 USING (week))
             LEFT JOIN r23 USING (week))
             LEFT JOIN r24 USING (week))
             LEFT JOIN r25 USING (week))
             LEFT JOIN r26 USING (week))
             LEFT JOIN r27 USING (week))
             LEFT JOIN r28 USING (week))
             LEFT JOIN r29 USING (week))
             LEFT JOIN r30 USING (week))
             LEFT JOIN r31 USING (week))
             LEFT JOIN r32 USING (week))
             LEFT JOIN r33 USING (week))
             LEFT JOIN r34 USING (week))
             LEFT JOIN r35 USING (week))
             LEFT JOIN r36 USING (week))
             LEFT JOIN r37 USING (week))
             LEFT JOIN r39 USING (week))
             LEFT JOIN r40 USING (week))
             LEFT JOIN r42 USING (week))
             LEFT JOIN r43 USING (week))
             LEFT JOIN r44 USING (week))
             LEFT JOIN r45 USING (week))
             LEFT JOIN r46 USING (week))
             LEFT JOIN r47 USING (week))
             LEFT JOIN r48 USING (week))
             LEFT JOIN r50 USING (week))
             LEFT JOIN r51 USING (week))
             LEFT JOIN r52 USING (week))
             LEFT JOIN r53 USING (week))
             LEFT JOIN r54 USING (week))
             LEFT JOIN r55 USING (week))
             LEFT JOIN r56 USING (week))
             LEFT JOIN r57 USING (week))
             LEFT JOIN r58 USING (week))
             LEFT JOIN r59 USING (week))
             LEFT JOIN r60 USING (week))
             LEFT JOIN r61 USING (week))
             LEFT JOIN r62 USING (week))
             LEFT JOIN r63 USING (week))
        ), bb AS (
         SELECT ff.week,
            ff.bamxml,
            ff.blockshim_ng,
            ff.bootflash,
            ff.bseyecov,
            ff.build,
            ff.c4core,
            ff.c4csx,
            ff.cemgui,
            ff.clariion,
            ff.cloudarray,
            ff.cp,
            ff.cstarball,
            ff.cta,
            ff.cumulus,
            ff.driver,
            ff.econtrolstation,
            ff.gms,
            ff.healthchecks,
            ff.image,
            ff.imager,
            ff.infrastructureproviders,
            ff.ipreflect,
            ff.javacli,
            ff.jiff,
            ff.jiffcommon,
            ff.jmi,
            ff.kernel,
            ff.languages,
            ff.libpsm,
            ff.mf,
            ff.mf_common,
            ff.nxgui,
            ff.observability,
            ff.ofed,
            ff.papi,
            ff.perf,
            ff.restcommon,
            ff.rpms,
            ff.rpmsinfq,
            ff.sade,
            ff.safe,
            ff.security,
            ff.serviceability,
            ff.sles,
            ff."sys-common",
            ff.systemtap,
            ff.tbn,
            ff.tomcatcommon,
            ff.udoctor,
            ff.uemcli,
            ff.unirest,
            ff.univasa,
            ff.upgrade,
            ff.vmwaresdkclient,
            ff.vsockets,
            ff.vtune,
            ff.vvnxdeploydual,
            ff.result
           FROM ff
        UNION
         SELECT pp.week,
            pp.bamxml,
            pp.blockshim_ng,
            pp.bootflash,
            pp.bseyecov,
            pp.build,
            pp.c4core,
            pp.c4csx,
            pp.cemgui,
            pp.clariion,
            pp.cloudarray,
            pp.cp,
            pp.cstarball,
            pp.cta,
            pp.cumulus,
            pp.driver,
            pp.econtrolstation,
            pp.gms,
            pp.healthchecks,
            pp.image,
            pp.imager,
            pp.infrastructureproviders,
            pp.ipreflect,
            pp.javacli,
            pp.jiff,
            pp.jiffcommon,
            pp.jmi,
            pp.kernel,
            pp.languages,
            pp.libpsm,
            pp.mf,
            pp.mf_common,
            pp.nxgui,
            pp.observability,
            pp.ofed,
            pp.papi,
            pp.perf,
            pp.restcommon,
            pp.rpms,
            pp.rpmsinfq,
            pp.sade,
            pp.safe,
            pp.security,
            pp.serviceability,
            pp.sles,
            pp."sys-common",
            pp.systemtap,
            pp.tbn,
            pp.tomcatcommon,
            pp.udoctor,
            pp.uemcli,
            pp.unirest,
            pp.univasa,
            pp.upgrade,
            pp.vmwaresdkclient,
            pp.vsockets,
            pp.vtune,
            pp.vvnxdeploydual,
            pp.result
           FROM pp
        UNION
         SELECT rr.week,
            rr.bamxml,
            rr.blockshim_ng,
            rr.bootflash,
            rr.bseyecov,
            rr.build,
            rr.c4core,
            rr.c4csx,
            rr.cemgui,
            rr.clariion,
            rr.cloudarray,
            rr.cp,
            rr.cstarball,
            rr.cta,
            rr.cumulus,
            rr.driver,
            rr.econtrolstation,
            rr.gms,
            rr.healthchecks,
            rr.image,
            rr.imager,
            rr.infrastructureproviders,
            rr.ipreflect,
            rr.javacli,
            rr.jiff,
            rr.jiffcommon,
            rr.jmi,
            rr.kernel,
            rr.languages,
            rr.libpsm,
            rr.mf,
            rr.mf_common,
            rr.nxgui,
            rr.observability,
            rr.ofed,
            rr.papi,
            rr.perf,
            rr.restcommon,
            rr.rpms,
            rr.rpmsinfq,
            rr.sade,
            rr.safe,
            rr.security,
            rr.serviceability,
            rr.sles,
            rr."sys-common",
            rr.systemtap,
            rr.tbn,
            rr.tomcatcommon,
            rr.udoctor,
            rr.uemcli,
            rr.unirest,
            rr.univasa,
            rr.upgrade,
            rr.vmwaresdkclient,
            rr.vsockets,
            rr.vtune,
            rr.vvnxdeploydual,
            rr.result
           FROM rr
        )
 SELECT bb.week,
    bb.bamxml,
    bb.blockshim_ng,
    bb.bootflash,
    bb.bseyecov,
    bb.build,
    bb.c4core,
    bb.c4csx,
    bb.cemgui,
    bb.clariion,
    bb.cloudarray,
    bb.cp,
    bb.cstarball,
    bb.cta,
    bb.cumulus,
    bb.driver,
    bb.econtrolstation,
    bb.gms,
    bb.healthchecks,
    bb.image,
    bb.imager,
    bb.infrastructureproviders,
    bb.ipreflect,
    bb.javacli,
    bb.jiff,
    bb.jiffcommon,
    bb.jmi,
    bb.kernel,
    bb.languages,
    bb.libpsm,
    bb.mf,
    bb.mf_common,
    bb.nxgui,
    bb.observability,
    bb.ofed,
    bb.papi,
    bb.perf,
    bb.restcommon,
    bb.rpms,
    bb.rpmsinfq,
    bb.sade,
    bb.safe,
    bb.security,
    bb.serviceability,
    bb.sles,
    bb."sys-common",
    bb.systemtap,
    bb.tbn,
    bb.tomcatcommon,
    bb.udoctor,
    bb.uemcli,
    bb.unirest,
    bb.univasa,
    bb.upgrade,
    bb.vmwaresdkclient,
    bb.vsockets,
    bb.vtune,
    bb.vvnxdeploydual,
    bb.result
   FROM bb
  ORDER BY bb.week;


ALTER TABLE "Weekly counts - components" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - components"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - components" IS 'Data to produce graph of ''Distribution of Component Build Count for week''';


--
-- Name: Weekly counts - components_bld (CI); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - components_bld (CI)" AS
 SELECT counts_components_bld.week,
    counts_components_bld.bamxml,
    counts_components_bld.blockshim_ng,
    counts_components_bld.c4core,
    counts_components_bld.c4csx,
    counts_components_bld.cemgui,
    counts_components_bld.clariion,
    counts_components_bld.cp,
    counts_components_bld.cta,
    counts_components_bld.cumulus,
    counts_components_bld.gms,
    counts_components_bld.healthchecks,
    counts_components_bld.infrastructureproviders,
    counts_components_bld.jmi,
    counts_components_bld.kernel,
    counts_components_bld.libpsm,
    counts_components_bld.mf,
    counts_components_bld.mf_common,
    counts_components_bld.nxgui,
    counts_components_bld.observability,
    counts_components_bld.papi,
    counts_components_bld.restcommon,
    counts_components_bld.sade,
    counts_components_bld.safe,
    counts_components_bld.security,
    counts_components_bld.serviceability,
    counts_components_bld.tbn,
    counts_components_bld.tomcatcommon,
    counts_components_bld.udoctor,
    counts_components_bld.uemcli,
    counts_components_bld.unirest,
    counts_components_bld.univasa,
    counts_components_bld.vmwaresdkclient,
    counts_components_bld.vvnxdeploydual,
    counts_components_bld.result
   FROM counts_components_bld('Jenkins'::text) counts_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual, result);


ALTER TABLE "Weekly counts - components_bld (CI)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - components_bld (CI)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - components_bld (CI)" IS 'Data to produce graph of ''Distribution of Component build Count for week''';


--
-- Name: Weekly counts - components_bld (DE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - components_bld (DE)" AS
 SELECT counts_components_bld.week,
    counts_components_bld.bamxml,
    counts_components_bld.blockshim_ng,
    counts_components_bld.c4core,
    counts_components_bld.c4csx,
    counts_components_bld.cemgui,
    counts_components_bld.clariion,
    counts_components_bld.cp,
    counts_components_bld.cta,
    counts_components_bld.cumulus,
    counts_components_bld.gms,
    counts_components_bld.healthchecks,
    counts_components_bld.infrastructureproviders,
    counts_components_bld.jmi,
    counts_components_bld.kernel,
    counts_components_bld.libpsm,
    counts_components_bld.mf,
    counts_components_bld.mf_common,
    counts_components_bld.nxgui,
    counts_components_bld.observability,
    counts_components_bld.papi,
    counts_components_bld.restcommon,
    counts_components_bld.sade,
    counts_components_bld.safe,
    counts_components_bld.security,
    counts_components_bld.serviceability,
    counts_components_bld.tbn,
    counts_components_bld.tomcatcommon,
    counts_components_bld.udoctor,
    counts_components_bld.uemcli,
    counts_components_bld.unirest,
    counts_components_bld.univasa,
    counts_components_bld.vmwaresdkclient,
    counts_components_bld.vvnxdeploydual,
    counts_components_bld.result
   FROM counts_components_bld('Developer'::text) counts_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual, result);


ALTER TABLE "Weekly counts - components_bld (DE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - components_bld (DE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - components_bld (DE)" IS 'Data to produce graph of ''Distribution of Component build Count for week''';


--
-- Name: Weekly counts - components_bld (RE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - components_bld (RE)" AS
 SELECT counts_components_bld.week,
    counts_components_bld.bamxml,
    counts_components_bld.blockshim_ng,
    counts_components_bld.c4core,
    counts_components_bld.c4csx,
    counts_components_bld.cemgui,
    counts_components_bld.clariion,
    counts_components_bld.cp,
    counts_components_bld.cta,
    counts_components_bld.cumulus,
    counts_components_bld.gms,
    counts_components_bld.healthchecks,
    counts_components_bld.infrastructureproviders,
    counts_components_bld.jmi,
    counts_components_bld.kernel,
    counts_components_bld.libpsm,
    counts_components_bld.mf,
    counts_components_bld.mf_common,
    counts_components_bld.nxgui,
    counts_components_bld.observability,
    counts_components_bld.papi,
    counts_components_bld.restcommon,
    counts_components_bld.sade,
    counts_components_bld.safe,
    counts_components_bld.security,
    counts_components_bld.serviceability,
    counts_components_bld.tbn,
    counts_components_bld.tomcatcommon,
    counts_components_bld.udoctor,
    counts_components_bld.uemcli,
    counts_components_bld.unirest,
    counts_components_bld.univasa,
    counts_components_bld.vmwaresdkclient,
    counts_components_bld.vvnxdeploydual,
    counts_components_bld.result
   FROM counts_components_bld('Rel Eng'::text) counts_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual, result);


ALTER TABLE "Weekly counts - components_bld (RE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - components_bld (RE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - components_bld (RE)" IS 'Data to produce graph of ''Distribution of Component build Count for week''';


--
-- Name: Weekly counts - components_meta (CI); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - components_meta (CI)" AS
 SELECT counts_components_meta.week,
    counts_components_meta."all",
    counts_components_meta.build,
    counts_components_meta.package,
    counts_components_meta.prepare,
    counts_components_meta.setup,
    counts_components_meta.result
   FROM counts_components_meta('Jenkins'::text) counts_components_meta(week, "all", build, package, prepare, setup, result);


ALTER TABLE "Weekly counts - components_meta (CI)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - components_meta (CI)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - components_meta (CI)" IS 'Data to produce graph of ''Distribution of Component meta Count for week''';


--
-- Name: Weekly counts - components_meta (DE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - components_meta (DE)" AS
 SELECT counts_components_meta.week,
    counts_components_meta."all",
    counts_components_meta.build,
    counts_components_meta.package,
    counts_components_meta.prepare,
    counts_components_meta.setup,
    counts_components_meta.result
   FROM counts_components_meta('Developer'::text) counts_components_meta(week, "all", build, package, prepare, setup, result);


ALTER TABLE "Weekly counts - components_meta (DE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - components_meta (DE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - components_meta (DE)" IS 'Data to produce graph of ''Distribution of Component meta Count for week''';


--
-- Name: Weekly counts - components_meta (RE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - components_meta (RE)" AS
 SELECT counts_components_meta.week,
    counts_components_meta."all",
    counts_components_meta.build,
    counts_components_meta.package,
    counts_components_meta.prepare,
    counts_components_meta.setup,
    counts_components_meta.result
   FROM counts_components_meta('Rel Eng'::text) counts_components_meta(week, "all", build, package, prepare, setup, result);


ALTER TABLE "Weekly counts - components_meta (RE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - components_meta (RE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - components_meta (RE)" IS 'Data to produce graph of ''Distribution of Component meta Count for week''';


--
-- Name: Weekly counts - components_pkg (CI); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - components_pkg (CI)" AS
 SELECT counts_components_pkg.week,
    counts_components_pkg.bootflash,
    counts_components_pkg.econtrolstation,
    counts_components_pkg.image,
    counts_components_pkg.languages,
    counts_components_pkg.rpms,
    counts_components_pkg.rpmsinfq,
    counts_components_pkg.systemtap,
    counts_components_pkg.vtune,
    counts_components_pkg.result
   FROM counts_components_pkg('Jenkins'::text) counts_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune, result);


ALTER TABLE "Weekly counts - components_pkg (CI)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - components_pkg (CI)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - components_pkg (CI)" IS 'Data to produce graph of ''Distribution of Component Package Count for week''';


--
-- Name: Weekly counts - components_pkg (DE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - components_pkg (DE)" AS
 SELECT counts_components_pkg.week,
    counts_components_pkg.bootflash,
    counts_components_pkg.econtrolstation,
    counts_components_pkg.image,
    counts_components_pkg.languages,
    counts_components_pkg.rpms,
    counts_components_pkg.rpmsinfq,
    counts_components_pkg.systemtap,
    counts_components_pkg.vtune,
    counts_components_pkg.result
   FROM counts_components_pkg('Developer'::text) counts_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune, result);


ALTER TABLE "Weekly counts - components_pkg (DE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - components_pkg (DE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - components_pkg (DE)" IS 'Data to produce graph of ''Distribution of Component Package Count for week''';


--
-- Name: Weekly counts - components_pkg (RE); Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts - components_pkg (RE)" AS
 SELECT counts_components_pkg.week,
    counts_components_pkg.bootflash,
    counts_components_pkg.econtrolstation,
    counts_components_pkg.image,
    counts_components_pkg.languages,
    counts_components_pkg.rpms,
    counts_components_pkg.rpmsinfq,
    counts_components_pkg.systemtap,
    counts_components_pkg.vtune,
    counts_components_pkg.result
   FROM counts_components_pkg('Rel Eng'::text) counts_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune, result);


ALTER TABLE "Weekly counts - components_pkg (RE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - components_pkg (RE)"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - components_pkg (RE)" IS 'Data to produce graph of ''Distribution of Component Package Count for week''';


--
-- Name: Weekly counts for each Build-User Category; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "Weekly counts for each Build-User Category" AS
 WITH rslts AS (
         SELECT
                CASE
                    WHEN (((y."user")::text = 'c4dev'::text) OR ((y."user")::text = 'root'::text)) THEN y."user"
                    WHEN (((y."user")::text ~* '^svc_usdciauto'::text) OR ((y."user")::text ~* '^svc_ctdciauto'::text)) THEN 'CI service'::character varying
                    WHEN ((y."user")::text ~* 'builder$'::text) THEN 'RE builder'::character varying
                    WHEN ((y."user")::text = (x.ntid)::text) THEN 'emclogin'::character varying
                    ELSE 'other'::character varying
                END AS build_category,
            x.build_class,
            (x.week)::date AS week
           FROM ((ibidresults z
             LEFT JOIN baseresults y ON ((y.id = z.id)))
             LEFT JOIN etlresults x ON ((x.id = z.id)))
        ), a AS (
         SELECT rslts.week,
            rslts.build_category,
            rslts.build_class
           FROM rslts
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), b AS (
         SELECT a.week,
            a.build_category
           FROM a
          WHERE ((a.build_class)::text = 'Developer'::text)
        ), bb AS (
         SELECT b.week,
            count(*) AS "DV: All"
           FROM b
          GROUP BY b.week
        ), e AS (
         SELECT b.week,
            count(*) AS "DV: root"
           FROM b
          WHERE ((b.build_category)::text = 'root'::text)
          GROUP BY b.week
        ), f AS (
         SELECT b.week,
            count(*) AS "DV: c4dev"
           FROM b
          WHERE ((b.build_category)::text = 'c4dev'::text)
          GROUP BY b.week
        ), g AS (
         SELECT b.week,
            count(*) AS "DV: CI service"
           FROM b
          WHERE ((b.build_category)::text = 'CI service'::text)
          GROUP BY b.week
        ), h AS (
         SELECT b.week,
            count(*) AS "DV: RE builder"
           FROM b
          WHERE ((b.build_category)::text = 'RE builder'::text)
          GROUP BY b.week
        ), i AS (
         SELECT b.week,
            count(*) AS "DV: emclogin"
           FROM b
          WHERE ((b.build_category)::text = 'emclogin'::text)
          GROUP BY b.week
        ), j AS (
         SELECT b.week,
            count(*) AS "DV: other"
           FROM b
          WHERE ((b.build_category)::text = 'other'::text)
          GROUP BY b.week
        ), c AS (
         SELECT a.week,
            a.build_category
           FROM a
          WHERE ((a.build_class)::text = 'Jenkins'::text)
        ), cc AS (
         SELECT c.week,
            count(*) AS "CI: All"
           FROM c
          GROUP BY c.week
        ), l AS (
         SELECT c.week,
            count(*) AS "CI: root"
           FROM c
          WHERE ((c.build_category)::text = 'root'::text)
          GROUP BY c.week
        ), m AS (
         SELECT c.week,
            count(*) AS "CI: c4dev"
           FROM c
          WHERE ((c.build_category)::text = 'c4dev'::text)
          GROUP BY c.week
        ), n AS (
         SELECT c.week,
            count(*) AS "CI: CI service"
           FROM c
          WHERE ((c.build_category)::text = 'CI service'::text)
          GROUP BY c.week
        ), o AS (
         SELECT c.week,
            count(*) AS "CI: RE builder"
           FROM c
          WHERE ((c.build_category)::text = 'RE builder'::text)
          GROUP BY c.week
        ), p AS (
         SELECT c.week,
            count(*) AS "CI: emclogin"
           FROM c
          WHERE ((c.build_category)::text = 'emclogin'::text)
          GROUP BY c.week
        ), q AS (
         SELECT c.week,
            count(*) AS "CI: other"
           FROM c
          WHERE ((c.build_category)::text = 'other'::text)
          GROUP BY c.week
        ), d AS (
         SELECT a.week,
            a.build_category
           FROM a
          WHERE ((a.build_class)::text = 'Rel Eng'::text)
        ), dd AS (
         SELECT d.week,
            count(*) AS "RE: All"
           FROM d
          GROUP BY d.week
        ), s AS (
         SELECT d.week,
            count(*) AS "RE: root"
           FROM d
          WHERE ((d.build_category)::text = 'root'::text)
          GROUP BY d.week
        ), t AS (
         SELECT d.week,
            count(*) AS "RE: c4dev"
           FROM d
          WHERE ((d.build_category)::text = 'c4dev'::text)
          GROUP BY d.week
        ), u AS (
         SELECT d.week,
            count(*) AS "RE: CI service"
           FROM d
          WHERE ((d.build_category)::text = 'CI service'::text)
          GROUP BY d.week
        ), v AS (
         SELECT d.week,
            count(*) AS "RE: RE builder"
           FROM d
          WHERE ((d.build_category)::text = 'RE builder'::text)
          GROUP BY d.week
        ), w AS (
         SELECT d.week,
            count(*) AS "RE: emclogin"
           FROM d
          WHERE ((d.build_category)::text = 'emclogin'::text)
          GROUP BY d.week
        ), x AS (
         SELECT d.week,
            count(*) AS "RE: other"
           FROM d
          WHERE ((d.build_category)::text = 'other'::text)
          GROUP BY d.week
        ), ee AS (
         SELECT aa.week,
            e."DV: root",
            f."DV: c4dev",
            g."DV: CI service",
            h."DV: RE builder",
            i."DV: emclogin",
            j."DV: other",
            bb."DV: All",
            l."CI: root",
            m."CI: c4dev",
            n."CI: CI service",
            o."CI: RE builder",
            p."CI: emclogin",
            q."CI: other",
            cc."CI: All",
            s."RE: root",
            t."RE: c4dev",
            u."RE: CI service",
            v."RE: RE builder",
            w."RE: emclogin",
            x."RE: other",
            dd."RE: All"
           FROM (((((((((((((((((((((aa
             LEFT JOIN e USING (week))
             LEFT JOIN f USING (week))
             LEFT JOIN g USING (week))
             LEFT JOIN h USING (week))
             LEFT JOIN i USING (week))
             LEFT JOIN j USING (week))
             LEFT JOIN bb USING (week))
             LEFT JOIN l USING (week))
             LEFT JOIN m USING (week))
             LEFT JOIN n USING (week))
             LEFT JOIN o USING (week))
             LEFT JOIN p USING (week))
             LEFT JOIN q USING (week))
             LEFT JOIN cc USING (week))
             LEFT JOIN s USING (week))
             LEFT JOIN t USING (week))
             LEFT JOIN u USING (week))
             LEFT JOIN v USING (week))
             LEFT JOIN w USING (week))
             LEFT JOIN x USING (week))
             LEFT JOIN dd USING (week))
        )
 SELECT ee.week,
    ee."DV: root",
    ee."DV: c4dev",
    ee."DV: CI service",
    ee."DV: RE builder",
    ee."DV: emclogin",
    ee."DV: other",
    ee."DV: All",
    ee."CI: root",
    ee."CI: c4dev",
    ee."CI: CI service",
    ee."CI: RE builder",
    ee."CI: emclogin",
    ee."CI: other",
    ee."CI: All",
    ee."RE: root",
    ee."RE: c4dev",
    ee."RE: CI service",
    ee."RE: RE builder",
    ee."RE: emclogin",
    ee."RE: other",
    ee."RE: All"
   FROM ee
  ORDER BY ee.week;


ALTER TABLE "Weekly counts for each Build-User Category" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts for each Build-User Category"; Type: COMMENT; Schema: buildlog; Owner: postgres
--

COMMENT ON VIEW "Weekly counts for each Build-User Category" IS 'Data to produce graph of ''Weekly Counts for each Build-User Category''';


--
-- Name: build-summary; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "build-summary" AS
 SELECT "build-summary2".comment,
    "build-summary2"."combined totals",
    "build-summary2"."Developer totals",
    "build-summary2"."Jenkins totals",
    "build-summary2"."Rel Eng totals"
   FROM "build-summary2"
  ORDER BY "build-summary2".id;


ALTER TABLE "build-summary" OWNER TO postgres;

--
-- Name: build-summary-data; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "build-summary-data" AS
 WITH weeks AS (
         SELECT weeks.id,
            weeks.name,
            weeks.week
           FROM ( VALUES (1,'lastweek'::text,public.endofweek((('now'::text)::date - '7 days'::interval))), (2,'previousweek'::text,((public.endofweek((('now'::text)::date)::timestamp with time zone) - '14 days'::interval))::date)) weeks(id, name, week)
        ), base AS (
         SELECT z.id,
            z.tm,
            z.fault_class,
            z.ibid,
            z."user",
            z.acuser,
            z.host,
            z.hostname,
            z.ipaddr,
            z.status,
            z.stream,
            z.fault_component,
            z.fault_msg,
            z.fault_detail,
            z.init_val,
            z.pwd,
            z.basis,
            z.env_type,
            z.native_env,
            z.run_env,
            z.workspace,
            z.logerr,
            z.logout,
            z.log_subdir,
            z.component,
            z.component_outdir,
            y.week,
            y.build_class
           FROM (baseresults z
             LEFT JOIN etlresults y ON ((y.id = z.id)))
        ), blastwk AS (
         SELECT base.id,
            base.tm,
            base.fault_class,
            base.ibid,
            base."user",
            base.acuser,
            base.host,
            base.hostname,
            base.ipaddr,
            base.status,
            base.stream,
            base.fault_component,
            base.fault_msg,
            base.fault_detail,
            base.init_val,
            base.pwd,
            base.basis,
            base.env_type,
            base.native_env,
            base.run_env,
            base.workspace,
            base.logerr,
            base.logout,
            base.log_subdir,
            base.component,
            base.component_outdir,
            base.week,
            base.build_class
           FROM base
          WHERE ((base.week)::date = public.endofweek((('now'::text)::date - '7 days'::interval)))
        ), bprevwk AS (
         SELECT base.id,
            base.tm,
            base.fault_class,
            base.ibid,
            base."user",
            base.acuser,
            base.host,
            base.hostname,
            base.ipaddr,
            base.status,
            base.stream,
            base.fault_component,
            base.fault_msg,
            base.fault_detail,
            base.init_val,
            base.pwd,
            base.basis,
            base.env_type,
            base.native_env,
            base.run_env,
            base.workspace,
            base.logerr,
            base.logout,
            base.log_subdir,
            base.component,
            base.component_outdir,
            base.week,
            base.build_class
           FROM base
          WHERE ((base.week)::date = public.endofweek((('now'::text)::date - '14 days'::interval)))
        ), ibase AS (
         SELECT x.id,
            x.endid,
            x.ibid,
            x.status,
            x.result,
            x.fault_class,
            x.start_tm,
            x.end_tm,
            x.bld_count,
            x.comp_count,
            x.build_duration,
            x.prepare_duration,
            x.prepare_count,
            x.build2_duration,
            x.build2_count,
            x.package_duration,
            x.package_count,
            x.mask,
            y.week,
            y.build_class,
            z."user",
            z.acuser
           FROM ((ibidresults x
             LEFT JOIN baseresults z USING (id))
             LEFT JOIN etlresults y ON (((y.id = x.id) AND (NOT ((x.prepare_count >= 0) AND (x.build2_count = 0) AND (x.package_count = 0))))))
        ), ilastwk AS (
         SELECT ibase.id,
            ibase.endid,
            ibase.ibid,
            ibase.status,
            ibase.result,
            ibase.fault_class,
            ibase.start_tm,
            ibase.end_tm,
            ibase.bld_count,
            ibase.comp_count,
            ibase.build_duration,
            ibase.prepare_duration,
            ibase.prepare_count,
            ibase.build2_duration,
            ibase.build2_count,
            ibase.package_duration,
            ibase.package_count,
            ibase.mask,
            ibase.week,
            ibase.build_class,
            ibase."user",
            ibase.acuser
           FROM ibase
          WHERE (date(ibase.week) IN ( SELECT weeks.week
                   FROM weeks
                  WHERE (weeks.id = 1)))
        ), iprevwk AS (
         SELECT ibase.id,
            ibase.endid,
            ibase.ibid,
            ibase.status,
            ibase.result,
            ibase.fault_class,
            ibase.start_tm,
            ibase.end_tm,
            ibase.bld_count,
            ibase.comp_count,
            ibase.build_duration,
            ibase.prepare_duration,
            ibase.prepare_count,
            ibase.build2_duration,
            ibase.build2_count,
            ibase.package_duration,
            ibase.package_count,
            ibase.mask,
            ibase.week,
            ibase.build_class,
            ibase."user",
            ibase.acuser
           FROM ibase
          WHERE (date(ibase.week) IN ( SELECT weeks.week
                   FROM weeks
                  WHERE (weeks.id = 2)))
        ), a0 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM base
        ), b0 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM blastwk
        ), c0 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM bprevwk
        ), d0 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ibase
        ), e0 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ilastwk
        ), f0 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM iprevwk
        ), g00 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
        ), h00 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
        ), i00 AS (
         SELECT ilastwk.id,
            ilastwk.endid,
            ilastwk.ibid,
            ilastwk.status,
            ilastwk.result,
            ilastwk.fault_class,
            ilastwk.start_tm,
            ilastwk.end_tm,
            ilastwk.bld_count,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.prepare_duration,
            ilastwk.prepare_count,
            ilastwk.build2_duration,
            ilastwk.build2_count,
            ilastwk.package_duration,
            ilastwk.package_count,
            ilastwk.mask,
            ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL))
        ), j00 AS (
         SELECT DISTINCT i00.acuser
           FROM i00
        ), g0 AS (
         SELECT count(g00.acuser) AS cnt,
            0 AS id
           FROM g00
        ), h0 AS (
         SELECT count(h00.acuser) AS cnt,
            0 AS id
           FROM h00
        ), i0 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM i00
        ), j0 AS (
         SELECT count(j00.acuser) AS cnt,
            0 AS id
           FROM j00
        ), blds0 AS (
         SELECT ' 0'::text AS id,
            'combined totals'::text AS comment,
            d0.cnt AS "AA",
            e0.cnt AS "BB",
            f0.cnt AS "CC",
                CASE
                    WHEN (f0.cnt = 0) THEN (0)::numeric
                    ELSE round(((((e0.cnt)::numeric - (f0.cnt)::numeric) * (100)::numeric) / (f0.cnt)::numeric), 2)
                END AS "DD",
            a0.cnt AS "EE",
            b0.cnt AS "FF",
            c0.cnt AS "GG",
                CASE
                    WHEN (c0.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b0.cnt)::numeric - (c0.cnt)::numeric) * (100)::numeric) / (c0.cnt)::numeric), 2)
                END AS "HH",
            g0.cnt AS "II",
            h0.cnt AS "JJ",
            i0.cnt AS "KK",
            j0.cnt AS "LL"
           FROM (((((((((a0
             LEFT JOIN b0 ON ((b0.id = a0.id)))
             LEFT JOIN c0 ON ((c0.id = a0.id)))
             LEFT JOIN d0 ON ((d0.id = a0.id)))
             LEFT JOIN e0 ON ((e0.id = a0.id)))
             LEFT JOIN f0 ON ((f0.id = a0.id)))
             LEFT JOIN g0 ON ((g0.id = a0.id)))
             LEFT JOIN h0 ON ((h0.id = a0.id)))
             LEFT JOIN i0 ON ((i0.id = a0.id)))
             LEFT JOIN j0 ON ((j0.id = a0.id)))
        ), a1 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM base
          WHERE ((base.build_class)::text = 'Developer'::text)
        ), b1 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Developer'::text)
        ), c1 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Developer'::text)
        ), d1 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Developer'::text)
        ), e1 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Developer'::text)
        ), f1 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM iprevwk
          WHERE ((iprevwk.build_class)::text = 'Developer'::text)
        ), g11 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Developer'::text)
        ), h11 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Developer'::text)
        ), i11 AS (
         SELECT ilastwk.id,
            ilastwk.endid,
            ilastwk.ibid,
            ilastwk.status,
            ilastwk.result,
            ilastwk.fault_class,
            ilastwk.start_tm,
            ilastwk.end_tm,
            ilastwk.bld_count,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.prepare_duration,
            ilastwk.prepare_count,
            ilastwk.build2_duration,
            ilastwk.build2_count,
            ilastwk.package_duration,
            ilastwk.package_count,
            ilastwk.mask,
            ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL) AND ((ilastwk.build_class)::text = 'Developer'::text))
        ), j11 AS (
         SELECT DISTINCT i11.acuser
           FROM i11
        ), g1 AS (
         SELECT count(g11.acuser) AS cnt,
            1 AS id
           FROM g11
        ), h1 AS (
         SELECT count(h11.acuser) AS cnt,
            1 AS id
           FROM h11
        ), i1 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM i11
        ), j1 AS (
         SELECT count(j11.acuser) AS cnt,
            1 AS id
           FROM j11
        ), blds1 AS (
         SELECT ' 1'::text AS id,
            'Developer totals'::text AS comment,
            d1.cnt AS "AA",
            e1.cnt AS "BB",
            f1.cnt AS "CC",
                CASE
                    WHEN (f1.cnt = 0) THEN (0)::numeric
                    ELSE round(((((e1.cnt)::numeric - (f1.cnt)::numeric) * (100)::numeric) / (f1.cnt)::numeric), 2)
                END AS "DD",
            a1.cnt AS "EE",
            b1.cnt AS "FF",
            c1.cnt AS "GG",
                CASE
                    WHEN (c1.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b1.cnt)::numeric - (c1.cnt)::numeric) * (100)::numeric) / (c1.cnt)::numeric), 2)
                END AS "HH",
            g1.cnt AS "II",
            h1.cnt AS "JJ",
            i1.cnt AS "KK",
            j1.cnt AS "LL"
           FROM (((((((((a1
             LEFT JOIN b1 ON ((b1.id = a1.id)))
             LEFT JOIN c1 ON ((c1.id = a1.id)))
             LEFT JOIN d1 ON ((d1.id = a1.id)))
             LEFT JOIN e1 ON ((e1.id = a1.id)))
             LEFT JOIN f1 ON ((f1.id = a1.id)))
             LEFT JOIN g1 ON ((g1.id = a1.id)))
             LEFT JOIN h1 ON ((h1.id = a1.id)))
             LEFT JOIN i1 ON ((i1.id = a1.id)))
             LEFT JOIN j1 ON ((j1.id = a1.id)))
        ), a2 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM base
          WHERE ((base.build_class)::text = 'Jenkins'::text)
        ), b2 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Jenkins'::text)
        ), c2 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Jenkins'::text)
        ), d2 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Jenkins'::text)
        ), e2 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Jenkins'::text)
        ), f2 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM iprevwk
          WHERE ((iprevwk.build_class)::text = 'Jenkins'::text)
        ), g22 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Jenkins'::text)
        ), h22 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Jenkins'::text)
        ), i22 AS (
         SELECT ilastwk.id,
            ilastwk.endid,
            ilastwk.ibid,
            ilastwk.status,
            ilastwk.result,
            ilastwk.fault_class,
            ilastwk.start_tm,
            ilastwk.end_tm,
            ilastwk.bld_count,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.prepare_duration,
            ilastwk.prepare_count,
            ilastwk.build2_duration,
            ilastwk.build2_count,
            ilastwk.package_duration,
            ilastwk.package_count,
            ilastwk.mask,
            ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL) AND ((ilastwk.build_class)::text = 'Jenkins'::text))
        ), j22 AS (
         SELECT DISTINCT i22.acuser
           FROM i22
        ), g2 AS (
         SELECT count(g22.acuser) AS cnt,
            2 AS id
           FROM g22
        ), h2 AS (
         SELECT count(h22.acuser) AS cnt,
            2 AS id
           FROM h22
        ), i2 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM i22
        ), j2 AS (
         SELECT count(j22.acuser) AS cnt,
            2 AS id
           FROM j22
        ), blds2 AS (
         SELECT ' 2'::text AS id,
            'Jenkins totals'::text AS comment,
            d2.cnt AS "AA",
            e2.cnt AS "BB",
            f2.cnt AS "CC",
                CASE
                    WHEN (f2.cnt = 0) THEN (0)::numeric
                    ELSE round(((((e2.cnt)::numeric - (f2.cnt)::numeric) * (100)::numeric) / (f2.cnt)::numeric), 2)
                END AS "DD",
            a2.cnt AS "EE",
            b2.cnt AS "FF",
            c2.cnt AS "GG",
                CASE
                    WHEN (c2.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b2.cnt)::numeric - (c2.cnt)::numeric) * (100)::numeric) / (c2.cnt)::numeric), 2)
                END AS "HH",
            g2.cnt AS "II",
            h2.cnt AS "JJ",
            i2.cnt AS "KK",
            j2.cnt AS "LL"
           FROM (((((((((a2
             LEFT JOIN b2 ON ((b2.id = a2.id)))
             LEFT JOIN c2 ON ((c2.id = a2.id)))
             LEFT JOIN d2 ON ((d2.id = a2.id)))
             LEFT JOIN e2 ON ((e2.id = a2.id)))
             LEFT JOIN f2 ON ((f2.id = a2.id)))
             LEFT JOIN g2 ON ((g2.id = a2.id)))
             LEFT JOIN h2 ON ((h2.id = a2.id)))
             LEFT JOIN i2 ON ((i2.id = a2.id)))
             LEFT JOIN j2 ON ((j2.id = a2.id)))
        ), a3 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM base
          WHERE ((base.build_class)::text = 'Rel Eng'::text)
        ), b3 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Rel Eng'::text)
        ), c3 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Rel Eng'::text)
        ), d3 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Rel Eng'::text)
        ), e3 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Rel Eng'::text)
        ), f3 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM iprevwk
          WHERE ((iprevwk.build_class)::text = 'Rel Eng'::text)
        ), g33 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Rel Eng'::text)
        ), h33 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Rel Eng'::text)
        ), i33 AS (
         SELECT ilastwk.id,
            ilastwk.endid,
            ilastwk.ibid,
            ilastwk.status,
            ilastwk.result,
            ilastwk.fault_class,
            ilastwk.start_tm,
            ilastwk.end_tm,
            ilastwk.bld_count,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.prepare_duration,
            ilastwk.prepare_count,
            ilastwk.build2_duration,
            ilastwk.build2_count,
            ilastwk.package_duration,
            ilastwk.package_count,
            ilastwk.mask,
            ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL) AND ((ilastwk.build_class)::text = 'Rel Eng'::text))
        ), j33 AS (
         SELECT DISTINCT i33.acuser
           FROM i33
        ), g3 AS (
         SELECT count(g33.acuser) AS cnt,
            3 AS id
           FROM g33
        ), h3 AS (
         SELECT count(h33.acuser) AS cnt,
            3 AS id
           FROM h33
        ), i3 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM i33
        ), j3 AS (
         SELECT count(j33.acuser) AS cnt,
            3 AS id
           FROM j33
        ), blds3 AS (
         SELECT ' 3'::text AS id,
            'Rel Eng totals'::text AS comment,
            d3.cnt AS "AA",
            e3.cnt AS "BB",
            f3.cnt AS "CC",
                CASE
                    WHEN (f3.cnt = 0) THEN (0)::numeric
                    ELSE round(((((e3.cnt)::numeric - (f3.cnt)::numeric) * (100)::numeric) / (f3.cnt)::numeric), 2)
                END AS "DD",
            a3.cnt AS "EE",
            b3.cnt AS "FF",
            c3.cnt AS "GG",
                CASE
                    WHEN (c3.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b3.cnt)::numeric - (c3.cnt)::numeric) * (100)::numeric) / (c3.cnt)::numeric), 2)
                END AS "HH",
            g3.cnt AS "II",
            h3.cnt AS "JJ",
            i3.cnt AS "KK",
            j3.cnt AS "LL"
           FROM (((((((((a3
             LEFT JOIN b3 ON ((b3.id = a3.id)))
             LEFT JOIN c3 ON ((c3.id = a3.id)))
             LEFT JOIN d3 ON ((d3.id = a3.id)))
             LEFT JOIN e3 ON ((e3.id = a3.id)))
             LEFT JOIN f3 ON ((f3.id = a3.id)))
             LEFT JOIN g3 ON ((g3.id = a3.id)))
             LEFT JOIN h3 ON ((h3.id = a3.id)))
             LEFT JOIN i3 ON ((i3.id = a3.id)))
             LEFT JOIN j3 ON ((j3.id = a3.id)))
        ), data AS (
         SELECT blds0.id,
            blds0.comment,
            blds0."AA",
            blds0."BB",
            blds0."CC",
            blds0."DD",
            blds0."EE",
            blds0."FF",
            blds0."GG",
            blds0."HH",
            blds0."II",
            blds0."JJ",
            blds0."KK",
            blds0."LL"
           FROM blds0
        UNION
         SELECT blds1.id,
            blds1.comment,
            blds1."AA",
            blds1."BB",
            blds1."CC",
            blds1."DD",
            blds1."EE",
            blds1."FF",
            blds1."GG",
            blds1."HH",
            blds1."II",
            blds1."JJ",
            blds1."KK",
            blds1."LL"
           FROM blds1
        UNION
         SELECT blds2.id,
            blds2.comment,
            blds2."AA",
            blds2."BB",
            blds2."CC",
            blds2."DD",
            blds2."EE",
            blds2."FF",
            blds2."GG",
            blds2."HH",
            blds2."II",
            blds2."JJ",
            blds2."KK",
            blds2."LL"
           FROM blds2
        UNION
         SELECT blds3.id,
            blds3.comment,
            blds3."AA",
            blds3."BB",
            blds3."CC",
            blds3."DD",
            blds3."EE",
            blds3."FF",
            blds3."GG",
            blds3."HH",
            blds3."II",
            blds3."JJ",
            blds3."KK",
            blds3."LL"
           FROM blds3
  ORDER BY 1
        )
 SELECT data.id,
    data.comment,
    data."AA",
    data."BB",
    data."CC",
    data."DD",
    data."EE",
    data."FF",
    data."GG",
    data."HH",
    data."II",
    data."JJ",
    data."KK",
    data."LL"
   FROM data;


ALTER TABLE "build-summary-data" OWNER TO postgres;

--
-- Name: cmdargs; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE cmdargs (
    id bigint NOT NULL,
    argument character varying,
    value character varying,
    "position" integer,
    orginalcommand character varying
);


ALTER TABLE cmdargs OWNER TO postgres;

--
-- Name: component_heatmaps; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW component_heatmaps AS
 WITH hclass AS (
         SELECT h.host_class
           FROM regexp_split_to_table('Kittyhawk Dev VM,SLES12 Dev VM,Jenkins build VM,Jenkins SLES12 VM,Jenkins DBMS server VM,Rel Eng build VM'::text, ','::text) h(host_class)
        ), compvalues AS (
         SELECT z.id,
            z.component,
            z.duration,
            z.phase,
                CASE
                    WHEN (((v.host_class)::text = 'Kittyhawk Dev VM'::text) OR ((v.host_class)::text = 'SLES12 Dev VM'::text)) THEN 'Developer VM'::character varying
                    WHEN (((v.host_class)::text = 'Jenkins build VM'::text) OR ((v.host_class)::text = 'Jenkins SLES12 VM'::text) OR ((v.host_class)::text = 'Jenkins DBMS server VM'::text)) THEN 'Jenkins VM'::character varying
                    ELSE v.host_class
                END AS host_class
           FROM ((((componentsbyoccurrence z
             LEFT JOIN etlresults y ON ((y.id = z.id)))
             LEFT JOIN componentmeta x ON (((x.component)::text = (z.component)::text)))
             LEFT JOIN baseresults w ON ((w.id = z.id)))
             LEFT JOIN hosts v ON (((v.host)::text = (w.host)::text)))
          WHERE ((NOT (z.id IN ( SELECT suspectresults.id
                   FROM suspectresults))) AND ((y.result)::text = 'pass'::text) AND (x."kittyhawk-all" = true) AND ((y.week)::date = public.endofweek((('now'::text)::date - '7 days'::interval))) AND ((v.host_class)::text IN ( SELECT hclass.host_class
                   FROM hclass)))
        ), compsummary AS (
         SELECT compvalues.component,
            count(*) AS cnt,
            min(compvalues.duration) AS lo,
            max(compvalues.duration) AS hi,
            round(avg(compvalues.duration), 2) AS av
           FROM compvalues
          GROUP BY compvalues.component
        ), compranges AS (
         SELECT z.component,
            z.host_class,
            y.cnt AS "all-cnt",
            y.hi AS "all-hi",
            y.lo AS "all-lo",
            y.av AS "all-av",
            count(z.*) AS "host-cnt",
            max(z.duration) AS "host-hi",
            min(z.duration) AS "host-lo",
            round(avg(z.duration), 2) AS "host-av"
           FROM (compvalues z
             LEFT JOIN compsummary y ON (((y.component)::text = (z.component)::text)))
          GROUP BY z.component, z.host_class, y.*, y.cnt, y.lo, y.hi, y.av
        ), compx AS (
         SELECT z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            round((((z."host-cnt" * 100) / z."all-cnt"))::numeric, 2) AS "host-pct",
            t.x
           FROM (compranges z
             CROSS JOIN regexp_split_to_table('0,1,2,3,4,5,6,7,8,9'::text, ','::text) t(x))
        ), compbuckets AS (
         SELECT z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            y.duration,
                CASE
                    WHEN (z."host-hi" = z."host-lo") THEN 0
                    ELSE (((((y.duration - z."host-lo"))::double precision * (9)::real) / ((z."host-hi" - z."host-lo"))::real))::integer
                END AS t
           FROM (compranges z
             LEFT JOIN compvalues y ON ((((y.component)::text = (z.component)::text) AND ((y.host_class)::text = (z.host_class)::text))))
        ), results AS (
         SELECT z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            z."host-pct",
            z.x,
            count(y.t) AS b
           FROM (compx z
             FULL JOIN compbuckets y ON ((((y.component)::text = (z.component)::text) AND ((y.host_class)::text = (z.host_class)::text) AND ((y.t)::text = z.x))))
          GROUP BY z.component, z.host_class, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-pct", z."host-cnt", z."host-hi", z."host-lo", z."host-av", z.x
          ORDER BY z.component, z."host-cnt", z.host_class, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-hi", z."host-lo", z."host-av", z.x
        ), data AS (
         SELECT z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-pct",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            array_agg(round((((z.b * 100) / z."all-cnt"))::numeric, 2)) AS v,
            array_agg(round((((z.b * 100) / z."host-cnt"))::numeric, 2)) AS u
           FROM results z
          GROUP BY z.host_class, z.component, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-pct", z."host-cnt", z."host-hi", z."host-lo", z."host-av"
          ORDER BY z.host_class, z.component, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-pct", z."host-cnt", z."host-hi", z."host-lo", z."host-av"
        ), devel_host AS (
         SELECT 'host'::text AS id,
            data.component,
            data."host-pct" AS dev_pct,
            data."host-cnt" AS dev_cnt,
            data."host-hi" AS dev_hi,
            data."host-lo" AS dev_lo,
            data."host-av" AS dev_av,
            data.u AS dev_heat
           FROM data
          WHERE ((data.host_class)::text = 'Developer VM'::text)
        ), devel_all AS (
         SELECT 'all'::text AS id,
            data.component,
            data."host-pct" AS dev_pct,
            data."all-cnt" AS dev_cnt,
            data."all-hi" AS dev_hi,
            data."all-lo" AS dev_lo,
            data."all-av" AS dev_av,
            data.v AS dev_heat
           FROM data
          WHERE ((data.host_class)::text = 'Developer VM'::text)
        ), jenkins_host AS (
         SELECT 'host'::text AS id,
            data.component,
            data."host-pct" AS ci_pct,
            data."host-cnt" AS ci_cnt,
            data."host-hi" AS ci_hi,
            data."host-lo" AS ci_lo,
            data."host-av" AS ci_av,
            data.u AS ci_heat
           FROM data
          WHERE ((data.host_class)::text = 'Jenkins VM'::text)
        ), jenkins_all AS (
         SELECT 'all'::text AS id,
            data.component,
            data."host-pct" AS ci_pct,
            data."all-cnt" AS ci_cnt,
            data."all-hi" AS ci_hi,
            data."all-lo" AS ci_lo,
            data."all-av" AS ci_av,
            data.v AS ci_heat
           FROM data
          WHERE ((data.host_class)::text = 'Jenkins VM'::text)
        ), releng_host AS (
         SELECT 'host'::text AS id,
            data.component,
            data."host-pct" AS re_pct,
            data."host-cnt" AS re_cnt,
            data."host-hi" AS re_hi,
            data."host-lo" AS re_lo,
            data."host-av" AS re_av,
            data.u AS re_heat
           FROM data
          WHERE ((data.host_class)::text = 'Rel Eng build VM'::text)
        ), releng_all AS (
         SELECT 'all'::text AS id,
            data.component,
            data."host-pct" AS re_pct,
            data."all-cnt" AS re_cnt,
            data."all-hi" AS re_hi,
            data."all-lo" AS re_lo,
            data."all-av" AS re_av,
            data.v AS re_heat
           FROM data
          WHERE ((data.host_class)::text = 'Rel Eng build VM'::text)
        ), host_heatmap AS (
         SELECT a.id,
            a.component,
            a.dev_pct,
            a.dev_cnt,
            a.dev_hi,
            a.dev_lo,
            a.dev_av,
            a.dev_heat[1] AS "D 0-10%",
            a.dev_heat[2] AS "D 10-20%",
            a.dev_heat[3] AS "D 20-30%",
            a.dev_heat[4] AS "D 30-40%",
            a.dev_heat[5] AS "D 40-50%",
            a.dev_heat[6] AS "D 50-60%",
            a.dev_heat[7] AS "D 60-70%",
            a.dev_heat[8] AS "D 70-80%",
            a.dev_heat[9] AS "D 80-90%",
            a.dev_heat[10] AS "D 90-100%",
            b.ci_pct,
            b.ci_cnt,
            b.ci_hi,
            b.ci_lo,
            b.ci_av,
            b.ci_heat[1] AS "J 0-10%",
            b.ci_heat[2] AS "J 10-20%",
            b.ci_heat[3] AS "J 20-30%",
            b.ci_heat[4] AS "J 30-40%",
            b.ci_heat[5] AS "J 40-50%",
            b.ci_heat[6] AS "J 50-60%",
            b.ci_heat[7] AS "J 60-70%",
            b.ci_heat[8] AS "J 70-80%",
            b.ci_heat[9] AS "J 80-90%",
            b.ci_heat[10] AS "J 90-100%",
            c.re_pct,
            c.re_cnt,
            c.re_hi,
            c.re_lo,
            c.re_av,
            c.re_heat[1] AS "R 0-10%",
            c.re_heat[2] AS "R 10-20%",
            c.re_heat[3] AS "R 20-30%",
            c.re_heat[4] AS "R 30-40%",
            c.re_heat[5] AS "R 40-50%",
            c.re_heat[6] AS "R 50-60%",
            c.re_heat[7] AS "R 60-70%",
            c.re_heat[8] AS "R 70-80%",
            c.re_heat[9] AS "R 80-90%",
            c.re_heat[10] AS "R 90-100%"
           FROM ((devel_host a
             JOIN jenkins_host b ON (((b.component)::text = (a.component)::text)))
             JOIN releng_host c ON (((c.component)::text = (a.component)::text)))
        ), all_heatmap AS (
         SELECT a.id,
            a.component,
            a.dev_pct,
            a.dev_cnt,
            a.dev_hi,
            a.dev_lo,
            a.dev_av,
            a.dev_heat[1] AS "D 0-10%",
            a.dev_heat[2] AS "D 10-20%",
            a.dev_heat[3] AS "D 20-30%",
            a.dev_heat[4] AS "D 30-40%",
            a.dev_heat[5] AS "D 40-50%",
            a.dev_heat[6] AS "D 50-60%",
            a.dev_heat[7] AS "D 60-70%",
            a.dev_heat[8] AS "D 70-80%",
            a.dev_heat[9] AS "D 80-90%",
            a.dev_heat[10] AS "D 90-100%",
            b.ci_pct,
            b.ci_cnt,
            b.ci_hi,
            b.ci_lo,
            b.ci_av,
            b.ci_heat[1] AS "J 0-10%",
            b.ci_heat[2] AS "J 10-20%",
            b.ci_heat[3] AS "J 20-30%",
            b.ci_heat[4] AS "J 30-40%",
            b.ci_heat[5] AS "J 40-50%",
            b.ci_heat[6] AS "J 50-60%",
            b.ci_heat[7] AS "J 60-70%",
            b.ci_heat[8] AS "J 70-80%",
            b.ci_heat[9] AS "J 80-90%",
            b.ci_heat[10] AS "J 90-100%",
            c.re_pct,
            c.re_cnt,
            c.re_hi,
            c.re_lo,
            c.re_av,
            c.re_heat[1] AS "R 0-10%",
            c.re_heat[2] AS "R 10-20%",
            c.re_heat[3] AS "R 20-30%",
            c.re_heat[4] AS "R 30-40%",
            c.re_heat[5] AS "R 40-50%",
            c.re_heat[6] AS "R 50-60%",
            c.re_heat[7] AS "R 60-70%",
            c.re_heat[8] AS "R 70-80%",
            c.re_heat[9] AS "R 80-90%",
            c.re_heat[10] AS "R 90-100%"
           FROM ((devel_all a
             JOIN jenkins_all b ON (((b.component)::text = (a.component)::text)))
             JOIN releng_all c ON (((c.component)::text = (a.component)::text)))
        ), heatmap AS (
         SELECT host_heatmap.id,
            host_heatmap.component,
            host_heatmap.dev_pct,
            host_heatmap.dev_cnt,
            host_heatmap.dev_hi,
            host_heatmap.dev_lo,
            host_heatmap.dev_av,
            host_heatmap."D 0-10%",
            host_heatmap."D 10-20%",
            host_heatmap."D 20-30%",
            host_heatmap."D 30-40%",
            host_heatmap."D 40-50%",
            host_heatmap."D 50-60%",
            host_heatmap."D 60-70%",
            host_heatmap."D 70-80%",
            host_heatmap."D 80-90%",
            host_heatmap."D 90-100%",
            host_heatmap.ci_pct,
            host_heatmap.ci_cnt,
            host_heatmap.ci_hi,
            host_heatmap.ci_lo,
            host_heatmap.ci_av,
            host_heatmap."J 0-10%",
            host_heatmap."J 10-20%",
            host_heatmap."J 20-30%",
            host_heatmap."J 30-40%",
            host_heatmap."J 40-50%",
            host_heatmap."J 50-60%",
            host_heatmap."J 60-70%",
            host_heatmap."J 70-80%",
            host_heatmap."J 80-90%",
            host_heatmap."J 90-100%",
            host_heatmap.re_pct,
            host_heatmap.re_cnt,
            host_heatmap.re_hi,
            host_heatmap.re_lo,
            host_heatmap.re_av,
            host_heatmap."R 0-10%",
            host_heatmap."R 10-20%",
            host_heatmap."R 20-30%",
            host_heatmap."R 30-40%",
            host_heatmap."R 40-50%",
            host_heatmap."R 50-60%",
            host_heatmap."R 60-70%",
            host_heatmap."R 70-80%",
            host_heatmap."R 80-90%",
            host_heatmap."R 90-100%"
           FROM host_heatmap
        UNION
         SELECT all_heatmap.id,
            all_heatmap.component,
            all_heatmap.dev_pct,
            all_heatmap.dev_cnt,
            all_heatmap.dev_hi,
            all_heatmap.dev_lo,
            all_heatmap.dev_av,
            all_heatmap."D 0-10%",
            all_heatmap."D 10-20%",
            all_heatmap."D 20-30%",
            all_heatmap."D 30-40%",
            all_heatmap."D 40-50%",
            all_heatmap."D 50-60%",
            all_heatmap."D 60-70%",
            all_heatmap."D 70-80%",
            all_heatmap."D 80-90%",
            all_heatmap."D 90-100%",
            all_heatmap.ci_pct,
            all_heatmap.ci_cnt,
            all_heatmap.ci_hi,
            all_heatmap.ci_lo,
            all_heatmap.ci_av,
            all_heatmap."J 0-10%",
            all_heatmap."J 10-20%",
            all_heatmap."J 20-30%",
            all_heatmap."J 30-40%",
            all_heatmap."J 40-50%",
            all_heatmap."J 50-60%",
            all_heatmap."J 60-70%",
            all_heatmap."J 70-80%",
            all_heatmap."J 80-90%",
            all_heatmap."J 90-100%",
            all_heatmap.re_pct,
            all_heatmap.re_cnt,
            all_heatmap.re_hi,
            all_heatmap.re_lo,
            all_heatmap.re_av,
            all_heatmap."R 0-10%",
            all_heatmap."R 10-20%",
            all_heatmap."R 20-30%",
            all_heatmap."R 30-40%",
            all_heatmap."R 40-50%",
            all_heatmap."R 50-60%",
            all_heatmap."R 60-70%",
            all_heatmap."R 70-80%",
            all_heatmap."R 80-90%",
            all_heatmap."R 90-100%"
           FROM all_heatmap
  ORDER BY 1 DESC, 2
        )
 SELECT heatmap.id,
    heatmap.component,
    heatmap.dev_pct,
    heatmap.dev_cnt,
    heatmap.dev_hi,
    heatmap.dev_lo,
    heatmap.dev_av,
    heatmap."D 0-10%",
    heatmap."D 10-20%",
    heatmap."D 20-30%",
    heatmap."D 30-40%",
    heatmap."D 40-50%",
    heatmap."D 50-60%",
    heatmap."D 60-70%",
    heatmap."D 70-80%",
    heatmap."D 80-90%",
    heatmap."D 90-100%",
    heatmap.ci_pct,
    heatmap.ci_cnt,
    heatmap.ci_hi,
    heatmap.ci_lo,
    heatmap.ci_av,
    heatmap."J 0-10%",
    heatmap."J 10-20%",
    heatmap."J 20-30%",
    heatmap."J 30-40%",
    heatmap."J 40-50%",
    heatmap."J 50-60%",
    heatmap."J 60-70%",
    heatmap."J 70-80%",
    heatmap."J 80-90%",
    heatmap."J 90-100%",
    heatmap.re_pct,
    heatmap.re_cnt,
    heatmap.re_hi,
    heatmap.re_lo,
    heatmap.re_av,
    heatmap."R 0-10%",
    heatmap."R 10-20%",
    heatmap."R 20-30%",
    heatmap."R 30-40%",
    heatmap."R 40-50%",
    heatmap."R 50-60%",
    heatmap."R 60-70%",
    heatmap."R 70-80%",
    heatmap."R 80-90%",
    heatmap."R 90-100%"
   FROM heatmap;


ALTER TABLE component_heatmaps OWNER TO postgres;

--
-- Name: component_heatmaps2; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW component_heatmaps2 AS
 WITH hclass AS (
         SELECT h.host_class
           FROM regexp_split_to_table('Kittyhawk Dev VM,SLES12 Dev VM,Jenkins build VM,Jenkins SLES12 VM,Jenkins DBMS server VM,Rel Eng build VM'::text, ','::text) h(host_class)
        ), compvalues AS (
         SELECT z.id,
            z.component,
            z.duration,
            z.phase,
                CASE
                    WHEN (((v.host_class)::text = 'Kittyhawk Dev VM'::text) OR ((v.host_class)::text = 'SLES12 Dev VM'::text)) THEN 'Developer VM'::character varying
                    WHEN (((v.host_class)::text = 'Jenkins build VM'::text) OR ((v.host_class)::text = 'Jenkins SLES12 VM'::text) OR ((v.host_class)::text = 'Jenkins DBMS server VM'::text)) THEN 'Jenkins VM'::character varying
                    ELSE v.host_class
                END AS host_class
           FROM ((((componentsbyoccurrence z
             LEFT JOIN etlresults y ON ((z.id = y.id)))
             LEFT JOIN componentmeta x ON (((z.component)::text = (x.component)::text)))
             LEFT JOIN baseresults w ON ((z.id = w.id)))
             LEFT JOIN hosts v ON (((w.host)::text = (v.host)::text)))
          WHERE ((NOT (z.id IN ( SELECT suspectresults.id
                   FROM suspectresults))) AND ((y.result)::text = 'pass'::text) AND (x."kittyhawk-all" = true) AND ((y.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)) AND ((y.week)::date > public.endofweek((('now'::text)::date - '196 days'::interval))) AND ((v.host_class)::text IN ( SELECT hclass.host_class
                   FROM hclass)))
        ), compsummary AS (
         SELECT compvalues.component,
            count(*) AS cnt,
            min(compvalues.duration) AS lo,
            max(compvalues.duration) AS hi,
            round(avg(compvalues.duration), 2) AS av
           FROM compvalues
          GROUP BY compvalues.component
        ), compranges AS (
         SELECT z.component,
            z.host_class,
            y.cnt AS "all-cnt",
            y.hi AS "all-hi",
            y.lo AS "all-lo",
            y.av AS "all-av",
            count(z.*) AS "host-cnt",
            max(z.duration) AS "host-hi",
            min(z.duration) AS "host-lo",
            round(avg(z.duration), 2) AS "host-av"
           FROM (compvalues z
             LEFT JOIN compsummary y ON (((z.component)::text = (y.component)::text)))
          GROUP BY z.component, z.host_class, y.*, y.cnt, y.lo, y.hi, y.av
        ), compx AS (
         SELECT z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            round((((z."host-cnt" * 100) / z."all-cnt"))::numeric, 2) AS "host-pct",
            t.x
           FROM (compranges z
             CROSS JOIN regexp_split_to_table('0,1,2,3,4,5,6,7,8,9'::text, ','::text) t(x))
        ), compbuckets AS (
         SELECT z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            y.duration,
                CASE
                    WHEN (z."host-hi" = z."host-lo") THEN 0
                    ELSE (((((y.duration - z."host-lo"))::double precision * (9)::real) / ((z."host-hi" - z."host-lo"))::real))::integer
                END AS t
           FROM (compranges z
             LEFT JOIN compvalues y ON ((((z.component)::text = (y.component)::text) AND ((z.host_class)::text = (y.host_class)::text))))
        ), results AS (
         SELECT z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            z."host-pct",
            z.x,
            count(y.t) AS b
           FROM (compx z
             FULL JOIN compbuckets y ON ((((z.component)::text = (y.component)::text) AND ((z.host_class)::text = (y.host_class)::text) AND ((y.t)::text = z.x))))
          GROUP BY z.component, z.host_class, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-pct", z."host-cnt", z."host-hi", z."host-lo", z."host-av", z.x
          ORDER BY z.component, z."host-cnt", z.host_class, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-hi", z."host-lo", z."host-av", z.x
        ), data AS (
         SELECT z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-pct",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            array_agg(round((((z.b * 100) / z."all-cnt"))::numeric, 2)) AS v,
            array_agg(round((((z.b * 100) / z."host-cnt"))::numeric, 2)) AS u
           FROM results z
          GROUP BY z.host_class, z.component, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-pct", z."host-cnt", z."host-hi", z."host-lo", z."host-av"
          ORDER BY z.host_class, z.component, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-pct", z."host-cnt", z."host-hi", z."host-lo", z."host-av"
        ), devel_host AS (
         SELECT 'host'::text AS id,
            data.component,
            data."host-pct" AS dev_pct,
            data."host-cnt" AS dev_cnt,
            data."host-hi" AS dev_hi,
            data."host-lo" AS dev_lo,
            data."host-av" AS dev_av,
            data.u AS dev_heat
           FROM data
          WHERE ((data.host_class)::text = 'Developer VM'::text)
        ), devel_all AS (
         SELECT 'all'::text AS id,
            data.component,
            data."host-pct" AS dev_pct,
            data."all-cnt" AS dev_cnt,
            data."all-hi" AS dev_hi,
            data."all-lo" AS dev_lo,
            data."all-av" AS dev_av,
            data.v AS dev_heat
           FROM data
          WHERE ((data.host_class)::text = 'Developer VM'::text)
        ), jenkins_host AS (
         SELECT 'host'::text AS id,
            data.component,
            data."host-pct" AS ci_pct,
            data."host-cnt" AS ci_cnt,
            data."host-hi" AS ci_hi,
            data."host-lo" AS ci_lo,
            data."host-av" AS ci_av,
            data.u AS ci_heat
           FROM data
          WHERE ((data.host_class)::text = 'Jenkins VM'::text)
        ), jenkins_all AS (
         SELECT 'all'::text AS id,
            data.component,
            data."host-pct" AS ci_pct,
            data."all-cnt" AS ci_cnt,
            data."all-hi" AS ci_hi,
            data."all-lo" AS ci_lo,
            data."all-av" AS ci_av,
            data.v AS ci_heat
           FROM data
          WHERE ((data.host_class)::text = 'Jenkins VM'::text)
        ), releng_host AS (
         SELECT 'host'::text AS id,
            data.component,
            data."host-pct" AS re_pct,
            data."host-cnt" AS re_cnt,
            data."host-hi" AS re_hi,
            data."host-lo" AS re_lo,
            data."host-av" AS re_av,
            data.u AS re_heat
           FROM data
          WHERE ((data.host_class)::text = 'Rel Eng build VM'::text)
        ), releng_all AS (
         SELECT 'all'::text AS id,
            data.component,
            data."host-pct" AS re_pct,
            data."all-cnt" AS re_cnt,
            data."all-hi" AS re_hi,
            data."all-lo" AS re_lo,
            data."all-av" AS re_av,
            data.v AS re_heat
           FROM data
          WHERE ((data.host_class)::text = 'Rel Eng build VM'::text)
        ), host_heatmap AS (
         SELECT a.id,
            a.component,
            a.dev_pct,
            a.dev_cnt,
            a.dev_hi,
            a.dev_lo,
            a.dev_av,
            a.dev_heat[1] AS "D 0-10%",
            a.dev_heat[2] AS "D 10-20%",
            a.dev_heat[3] AS "D 20-30%",
            a.dev_heat[4] AS "D 30-40%",
            a.dev_heat[5] AS "D 40-50%",
            a.dev_heat[6] AS "D 50-60%",
            a.dev_heat[7] AS "D 60-70%",
            a.dev_heat[8] AS "D 70-80%",
            a.dev_heat[9] AS "D 80-90%",
            a.dev_heat[10] AS "D 90-100%",
            b.ci_pct,
            b.ci_cnt,
            b.ci_hi,
            b.ci_lo,
            b.ci_av,
            b.ci_heat[1] AS "J 0-10%",
            b.ci_heat[2] AS "J 10-20%",
            b.ci_heat[3] AS "J 20-30%",
            b.ci_heat[4] AS "J 30-40%",
            b.ci_heat[5] AS "J 40-50%",
            b.ci_heat[6] AS "J 50-60%",
            b.ci_heat[7] AS "J 60-70%",
            b.ci_heat[8] AS "J 70-80%",
            b.ci_heat[9] AS "J 80-90%",
            b.ci_heat[10] AS "J 90-100%",
            c.re_pct,
            c.re_cnt,
            c.re_hi,
            c.re_lo,
            c.re_av,
            c.re_heat[1] AS "R 0-10%",
            c.re_heat[2] AS "R 10-20%",
            c.re_heat[3] AS "R 20-30%",
            c.re_heat[4] AS "R 30-40%",
            c.re_heat[5] AS "R 40-50%",
            c.re_heat[6] AS "R 50-60%",
            c.re_heat[7] AS "R 60-70%",
            c.re_heat[8] AS "R 70-80%",
            c.re_heat[9] AS "R 80-90%",
            c.re_heat[10] AS "R 90-100%"
           FROM ((devel_host a
             JOIN jenkins_host b ON (((b.component)::text = (a.component)::text)))
             JOIN releng_host c ON (((c.component)::text = (a.component)::text)))
        ), all_heatmap AS (
         SELECT a.id,
            a.component,
            a.dev_pct,
            a.dev_cnt,
            a.dev_hi,
            a.dev_lo,
            a.dev_av,
            a.dev_heat[1] AS "D 0-10%",
            a.dev_heat[2] AS "D 10-20%",
            a.dev_heat[3] AS "D 20-30%",
            a.dev_heat[4] AS "D 30-40%",
            a.dev_heat[5] AS "D 40-50%",
            a.dev_heat[6] AS "D 50-60%",
            a.dev_heat[7] AS "D 60-70%",
            a.dev_heat[8] AS "D 70-80%",
            a.dev_heat[9] AS "D 80-90%",
            a.dev_heat[10] AS "D 90-100%",
            b.ci_pct,
            b.ci_cnt,
            b.ci_hi,
            b.ci_lo,
            b.ci_av,
            b.ci_heat[1] AS "J 0-10%",
            b.ci_heat[2] AS "J 10-20%",
            b.ci_heat[3] AS "J 20-30%",
            b.ci_heat[4] AS "J 30-40%",
            b.ci_heat[5] AS "J 40-50%",
            b.ci_heat[6] AS "J 50-60%",
            b.ci_heat[7] AS "J 60-70%",
            b.ci_heat[8] AS "J 70-80%",
            b.ci_heat[9] AS "J 80-90%",
            b.ci_heat[10] AS "J 90-100%",
            c.re_pct,
            c.re_cnt,
            c.re_hi,
            c.re_lo,
            c.re_av,
            c.re_heat[1] AS "R 0-10%",
            c.re_heat[2] AS "R 10-20%",
            c.re_heat[3] AS "R 20-30%",
            c.re_heat[4] AS "R 30-40%",
            c.re_heat[5] AS "R 40-50%",
            c.re_heat[6] AS "R 50-60%",
            c.re_heat[7] AS "R 60-70%",
            c.re_heat[8] AS "R 70-80%",
            c.re_heat[9] AS "R 80-90%",
            c.re_heat[10] AS "R 90-100%"
           FROM ((devel_all a
             JOIN jenkins_all b ON (((b.component)::text = (a.component)::text)))
             JOIN releng_all c ON (((c.component)::text = (a.component)::text)))
        ), heatmap AS (
         SELECT host_heatmap.id,
            host_heatmap.component,
            host_heatmap.dev_pct,
            host_heatmap.dev_cnt,
            host_heatmap.dev_hi,
            host_heatmap.dev_lo,
            host_heatmap.dev_av,
            host_heatmap."D 0-10%",
            host_heatmap."D 10-20%",
            host_heatmap."D 20-30%",
            host_heatmap."D 30-40%",
            host_heatmap."D 40-50%",
            host_heatmap."D 50-60%",
            host_heatmap."D 60-70%",
            host_heatmap."D 70-80%",
            host_heatmap."D 80-90%",
            host_heatmap."D 90-100%",
            host_heatmap.ci_pct,
            host_heatmap.ci_cnt,
            host_heatmap.ci_hi,
            host_heatmap.ci_lo,
            host_heatmap.ci_av,
            host_heatmap."J 0-10%",
            host_heatmap."J 10-20%",
            host_heatmap."J 20-30%",
            host_heatmap."J 30-40%",
            host_heatmap."J 40-50%",
            host_heatmap."J 50-60%",
            host_heatmap."J 60-70%",
            host_heatmap."J 70-80%",
            host_heatmap."J 80-90%",
            host_heatmap."J 90-100%",
            host_heatmap.re_pct,
            host_heatmap.re_cnt,
            host_heatmap.re_hi,
            host_heatmap.re_lo,
            host_heatmap.re_av,
            host_heatmap."R 0-10%",
            host_heatmap."R 10-20%",
            host_heatmap."R 20-30%",
            host_heatmap."R 30-40%",
            host_heatmap."R 40-50%",
            host_heatmap."R 50-60%",
            host_heatmap."R 60-70%",
            host_heatmap."R 70-80%",
            host_heatmap."R 80-90%",
            host_heatmap."R 90-100%"
           FROM host_heatmap
        UNION
         SELECT all_heatmap.id,
            all_heatmap.component,
            all_heatmap.dev_pct,
            all_heatmap.dev_cnt,
            all_heatmap.dev_hi,
            all_heatmap.dev_lo,
            all_heatmap.dev_av,
            all_heatmap."D 0-10%",
            all_heatmap."D 10-20%",
            all_heatmap."D 20-30%",
            all_heatmap."D 30-40%",
            all_heatmap."D 40-50%",
            all_heatmap."D 50-60%",
            all_heatmap."D 60-70%",
            all_heatmap."D 70-80%",
            all_heatmap."D 80-90%",
            all_heatmap."D 90-100%",
            all_heatmap.ci_pct,
            all_heatmap.ci_cnt,
            all_heatmap.ci_hi,
            all_heatmap.ci_lo,
            all_heatmap.ci_av,
            all_heatmap."J 0-10%",
            all_heatmap."J 10-20%",
            all_heatmap."J 20-30%",
            all_heatmap."J 30-40%",
            all_heatmap."J 40-50%",
            all_heatmap."J 50-60%",
            all_heatmap."J 60-70%",
            all_heatmap."J 70-80%",
            all_heatmap."J 80-90%",
            all_heatmap."J 90-100%",
            all_heatmap.re_pct,
            all_heatmap.re_cnt,
            all_heatmap.re_hi,
            all_heatmap.re_lo,
            all_heatmap.re_av,
            all_heatmap."R 0-10%",
            all_heatmap."R 10-20%",
            all_heatmap."R 20-30%",
            all_heatmap."R 30-40%",
            all_heatmap."R 40-50%",
            all_heatmap."R 50-60%",
            all_heatmap."R 60-70%",
            all_heatmap."R 70-80%",
            all_heatmap."R 80-90%",
            all_heatmap."R 90-100%"
           FROM all_heatmap
  ORDER BY 1 DESC, 2
        )
 SELECT heatmap.id,
    heatmap.component,
    heatmap.dev_pct,
    heatmap.dev_cnt,
    heatmap.dev_hi,
    heatmap.dev_lo,
    heatmap.dev_av,
    heatmap."D 0-10%",
    heatmap."D 10-20%",
    heatmap."D 20-30%",
    heatmap."D 30-40%",
    heatmap."D 40-50%",
    heatmap."D 50-60%",
    heatmap."D 60-70%",
    heatmap."D 70-80%",
    heatmap."D 80-90%",
    heatmap."D 90-100%",
    heatmap.ci_pct,
    heatmap.ci_cnt,
    heatmap.ci_hi,
    heatmap.ci_lo,
    heatmap.ci_av,
    heatmap."J 0-10%",
    heatmap."J 10-20%",
    heatmap."J 20-30%",
    heatmap."J 30-40%",
    heatmap."J 40-50%",
    heatmap."J 50-60%",
    heatmap."J 60-70%",
    heatmap."J 70-80%",
    heatmap."J 80-90%",
    heatmap."J 90-100%",
    heatmap.re_pct,
    heatmap.re_cnt,
    heatmap.re_hi,
    heatmap.re_lo,
    heatmap.re_av,
    heatmap."R 0-10%",
    heatmap."R 10-20%",
    heatmap."R 20-30%",
    heatmap."R 30-40%",
    heatmap."R 40-50%",
    heatmap."R 50-60%",
    heatmap."R 60-70%",
    heatmap."R 70-80%",
    heatmap."R 80-90%",
    heatmap."R 90-100%"
   FROM heatmap;


ALTER TABLE component_heatmaps2 OWNER TO postgres;

--
-- Name: component_heatmaps3; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW component_heatmaps3 AS
 WITH hclass AS (
         SELECT h.host_class
           FROM regexp_split_to_table('Kittyhawk Dev VM,SLES12 Dev VM,Jenkins build VM,Jenkins SLES12 VM,Jenkins DBMS server VM,Rel Eng build VM'::text, ','::text) h(host_class)
        ), compvalues AS (
         SELECT (y.week)::date AS week,
            z.component,
            z.duration,
                CASE
                    WHEN (((v.host_class)::text = 'Kittyhawk Dev VM'::text) OR ((v.host_class)::text = 'SLES12 Dev VM'::text)) THEN 'Developer VM'::character varying
                    WHEN (((v.host_class)::text = 'Jenkins build VM'::text) OR ((v.host_class)::text = 'Jenkins SLES12 VM'::text) OR ((v.host_class)::text = 'Jenkins DBMS server VM'::text)) THEN 'Jenkins VM'::character varying
                    ELSE v.host_class
                END AS host_class
           FROM ((((componentsbyoccurrence z
             LEFT JOIN etlresults y ON ((y.id = z.id)))
             LEFT JOIN componentmeta x ON (((x.component)::text = (z.component)::text)))
             LEFT JOIN baseresults w ON ((w.id = z.id)))
             LEFT JOIN hosts v ON (((v.host)::text = (w.host)::text)))
          WHERE ((NOT (z.id IN ( SELECT suspectresults.id
                   FROM suspectresults))) AND ((y.result)::text = 'pass'::text) AND (x."kittyhawk-all" = true) AND ((v.host_class)::text IN ( SELECT hclass.host_class
                   FROM hclass)) AND ((y.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)) AND ((y.week)::date > public.endofweek((('now'::text)::date - '77 days'::interval))))
        ), compsummary AS (
         SELECT compvalues.week,
            compvalues.component,
            count(*) AS cnt,
            min(compvalues.duration) AS lo,
            max(compvalues.duration) AS hi,
            round(avg(compvalues.duration), 2) AS av
           FROM compvalues
          GROUP BY compvalues.week, compvalues.component
        ), compranges AS (
         SELECT z.week,
            z.component,
            z.host_class,
            y.cnt AS "all-cnt",
            y.hi AS "all-hi",
            y.lo AS "all-lo",
            y.av AS "all-av",
            count(z.*) AS "host-cnt",
            max(z.duration) AS "host-hi",
            min(z.duration) AS "host-lo",
            round(avg(z.duration), 2) AS "host-av"
           FROM (compvalues z
             LEFT JOIN compsummary y USING (week, component))
          GROUP BY z.week, z.component, z.host_class, y.*, y.cnt, y.lo, y.hi, y.av
        ), compx AS (
         SELECT z.week,
            z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            round((((z."host-cnt" * 100) / z."all-cnt"))::numeric, 2) AS "host-pct",
            (t.x)::integer AS bucket
           FROM (compranges z
             CROSS JOIN regexp_split_to_table('0,1,2,3,4,5,6,7,8,9'::text, ','::text) t(x))
        ), compbuckets AS (
         SELECT z.week,
            z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            y.duration,
                CASE
                    WHEN (z."host-hi" = z."host-lo") THEN 0
                    ELSE (((((y.duration - z."host-lo"))::double precision * (9)::real) / ((z."host-hi" - z."host-lo"))::real))::integer
                END AS bucket
           FROM (compranges z
             LEFT JOIN compvalues y USING (component, host_class))
        ), results AS (
         SELECT z.week,
            z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            z."host-pct",
            z.bucket,
            count(y.bucket) AS b
           FROM (compx z
             FULL JOIN compbuckets y USING (component, host_class, bucket))
          GROUP BY z.week, z.component, z.host_class, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-pct", z."host-cnt", z."host-hi", z."host-lo", z."host-av", z.bucket
          ORDER BY z.week, z.component, z."host-cnt", z.host_class, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-hi", z."host-lo", z."host-av", z.bucket
        ), data AS (
         SELECT z.week,
            z.component,
            z.host_class,
            z."all-cnt",
            z."all-hi",
            z."all-lo",
            z."all-av",
            z."host-pct",
            z."host-cnt",
            z."host-hi",
            z."host-lo",
            z."host-av",
            array_agg(round((((z.b * 100) / z."all-cnt"))::numeric, 2)) AS v,
            array_agg(round((((z.b * 100) / z."host-cnt"))::numeric, 2)) AS u
           FROM results z
          WHERE (z.component IS NOT NULL)
          GROUP BY z.week, z.component, z.host_class, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-pct", z."host-cnt", z."host-hi", z."host-lo", z."host-av"
          ORDER BY z.week, z.host_class, z.component, z."all-cnt", z."all-hi", z."all-lo", z."all-av", z."host-pct", z."host-cnt", z."host-hi", z."host-lo", z."host-av"
        ), devel_host AS (
         SELECT data.week,
            data.component,
            data."host-pct" AS dev_pct,
            data."host-cnt" AS dev_cnt,
            data."host-hi" AS dev_hi,
            data."host-lo" AS dev_lo,
            data."host-av" AS dev_av,
            ((((((((((data.u[1] + data.u[2]) + data.u[2]) + data.u[3]) + data.u[4]) + data.u[5]) + data.u[6]) + data.u[7]) + data.u[8]) + data.u[9]) + data.u[10]) AS dev_sum,
            data.u AS dev_heat
           FROM data
          WHERE ((data.host_class)::text = 'Developer VM'::text)
        ), devel_all AS (
         SELECT data.week,
            data.component,
            data."host-pct" AS dev_pct,
            data."all-cnt" AS dev_cnt,
            data."all-hi" AS dev_hi,
            data."all-lo" AS dev_lo,
            data."all-av" AS dev_av,
            ((((((((((data.u[1] + data.u[2]) + data.u[2]) + data.u[3]) + data.u[4]) + data.u[5]) + data.u[6]) + data.u[7]) + data.u[8]) + data.u[9]) + data.u[10]) AS dev_sum,
            data.v AS dev_heat
           FROM data
          WHERE ((data.host_class)::text = 'Developer VM'::text)
        ), jenkins_host AS (
         SELECT data.week,
            data.component,
            data."host-pct" AS ci_pct,
            data."host-cnt" AS ci_cnt,
            data."host-hi" AS ci_hi,
            data."host-lo" AS ci_lo,
            data."host-av" AS ci_av,
            ((((((((((data.u[1] + data.u[2]) + data.u[2]) + data.u[3]) + data.u[4]) + data.u[5]) + data.u[6]) + data.u[7]) + data.u[8]) + data.u[9]) + data.u[10]) AS ci_sum,
            data.u AS ci_heat
           FROM data
          WHERE ((data.host_class)::text = 'Jenkins VM'::text)
        ), jenkins_all AS (
         SELECT data.week,
            data.component,
            data."host-pct" AS ci_pct,
            data."all-cnt" AS ci_cnt,
            data."all-hi" AS ci_hi,
            data."all-lo" AS ci_lo,
            data."all-av" AS ci_av,
            ((((((((((data.u[1] + data.u[2]) + data.u[2]) + data.u[3]) + data.u[4]) + data.u[5]) + data.u[6]) + data.u[7]) + data.u[8]) + data.u[9]) + data.u[10]) AS ci_sum,
            data.v AS ci_heat
           FROM data
          WHERE ((data.host_class)::text = 'Jenkins VM'::text)
        ), releng_host AS (
         SELECT data.week,
            data.component,
            data."host-pct" AS re_pct,
            data."host-cnt" AS re_cnt,
            data."host-hi" AS re_hi,
            data."host-lo" AS re_lo,
            data."host-av" AS re_av,
            ((((((((((data.u[1] + data.u[2]) + data.u[2]) + data.u[3]) + data.u[4]) + data.u[5]) + data.u[6]) + data.u[7]) + data.u[8]) + data.u[9]) + data.u[10]) AS re_sum,
            data.u AS re_heat
           FROM data
          WHERE ((data.host_class)::text = 'Rel Eng build VM'::text)
        ), releng_all AS (
         SELECT data.week,
            data.component,
            data."host-pct" AS re_pct,
            data."all-cnt" AS re_cnt,
            data."all-hi" AS re_hi,
            data."all-lo" AS re_lo,
            data."all-av" AS re_av,
            ((((((((((data.u[1] + data.u[2]) + data.u[2]) + data.u[3]) + data.u[4]) + data.u[5]) + data.u[6]) + data.u[7]) + data.u[8]) + data.u[9]) + data.u[10]) AS re_sum,
            data.v AS re_heat
           FROM data
          WHERE ((data.host_class)::text = 'Rel Eng build VM'::text)
        ), host_heatmap AS (
         SELECT a.week,
            a.component,
            'host'::text AS id,
            b.dev_pct,
            b.dev_cnt,
            b.dev_hi,
            b.dev_lo,
            b.dev_av,
            b.dev_sum,
            b.dev_heat[1] AS "D 0-10%",
            b.dev_heat[2] AS "D 10-20%",
            b.dev_heat[3] AS "D 20-30%",
            b.dev_heat[4] AS "D 30-40%",
            b.dev_heat[5] AS "D 40-50%",
            b.dev_heat[6] AS "D 50-60%",
            b.dev_heat[7] AS "D 60-70%",
            b.dev_heat[8] AS "D 70-80%",
            b.dev_heat[9] AS "D 80-90%",
            b.dev_heat[10] AS "D 90-100%",
            c.ci_pct,
            c.ci_cnt,
            c.ci_hi,
            c.ci_lo,
            c.ci_av,
            c.ci_sum,
            c.ci_heat[1] AS "J 0-10%",
            c.ci_heat[2] AS "J 10-20%",
            c.ci_heat[3] AS "J 20-30%",
            c.ci_heat[4] AS "J 30-40%",
            c.ci_heat[5] AS "J 40-50%",
            c.ci_heat[6] AS "J 50-60%",
            c.ci_heat[7] AS "J 60-70%",
            c.ci_heat[8] AS "J 70-80%",
            c.ci_heat[9] AS "J 80-90%",
            c.ci_heat[10] AS "J 90-100%",
            d.re_pct,
            d.re_cnt,
            d.re_hi,
            d.re_lo,
            d.re_av,
            d.re_sum,
            d.re_heat[1] AS "R 0-10%",
            d.re_heat[2] AS "R 10-20%",
            d.re_heat[3] AS "R 20-30%",
            d.re_heat[4] AS "R 30-40%",
            d.re_heat[5] AS "R 40-50%",
            d.re_heat[6] AS "R 50-60%",
            d.re_heat[7] AS "R 60-70%",
            d.re_heat[8] AS "R 70-80%",
            d.re_heat[9] AS "R 80-90%",
            d.re_heat[10] AS "R 90-100%"
           FROM (((data a
             JOIN devel_host b ON ((((b.component)::text = (a.component)::text) AND (b.week = a.week))))
             JOIN jenkins_host c ON ((((c.component)::text = (a.component)::text) AND (c.week = a.week))))
             JOIN releng_host d ON ((((d.component)::text = (a.component)::text) AND (d.week = a.week))))
        ), all_heatmap AS (
         SELECT a.week,
            a.component,
            'all'::text AS id,
            b.dev_pct,
            b.dev_cnt,
            b.dev_hi,
            b.dev_lo,
            b.dev_av,
            b.dev_sum,
            b.dev_heat[1] AS "D 0-10%",
            b.dev_heat[2] AS "D 10-20%",
            b.dev_heat[3] AS "D 20-30%",
            b.dev_heat[4] AS "D 30-40%",
            b.dev_heat[5] AS "D 40-50%",
            b.dev_heat[6] AS "D 50-60%",
            b.dev_heat[7] AS "D 60-70%",
            b.dev_heat[8] AS "D 70-80%",
            b.dev_heat[9] AS "D 80-90%",
            b.dev_heat[10] AS "D 90-100%",
            c.ci_pct,
            c.ci_cnt,
            c.ci_hi,
            c.ci_lo,
            c.ci_av,
            c.ci_sum,
            c.ci_heat[1] AS "J 0-10%",
            c.ci_heat[2] AS "J 10-20%",
            c.ci_heat[3] AS "J 20-30%",
            c.ci_heat[4] AS "J 30-40%",
            c.ci_heat[5] AS "J 40-50%",
            c.ci_heat[6] AS "J 50-60%",
            c.ci_heat[7] AS "J 60-70%",
            c.ci_heat[8] AS "J 70-80%",
            c.ci_heat[9] AS "J 80-90%",
            c.ci_heat[10] AS "J 90-100%",
            d.re_pct,
            d.re_cnt,
            d.re_hi,
            d.re_lo,
            d.re_av,
            d.re_sum,
            d.re_heat[1] AS "R 0-10%",
            d.re_heat[2] AS "R 10-20%",
            d.re_heat[3] AS "R 20-30%",
            d.re_heat[4] AS "R 30-40%",
            d.re_heat[5] AS "R 40-50%",
            d.re_heat[6] AS "R 50-60%",
            d.re_heat[7] AS "R 60-70%",
            d.re_heat[8] AS "R 70-80%",
            d.re_heat[9] AS "R 80-90%",
            d.re_heat[10] AS "R 90-100%"
           FROM (((data a
             JOIN devel_all b ON ((((b.component)::text = (a.component)::text) AND (b.week = a.week))))
             JOIN jenkins_all c ON ((((c.component)::text = (a.component)::text) AND (c.week = a.week))))
             JOIN releng_all d ON ((((d.component)::text = (a.component)::text) AND (d.week = a.week))))
        ), heatmap AS (
         SELECT host_heatmap.week,
            host_heatmap.component,
            host_heatmap.id,
            host_heatmap.dev_pct,
            host_heatmap.dev_cnt,
            host_heatmap.dev_hi,
            host_heatmap.dev_lo,
            host_heatmap.dev_av,
            host_heatmap.dev_sum,
            host_heatmap."D 0-10%",
            host_heatmap."D 10-20%",
            host_heatmap."D 20-30%",
            host_heatmap."D 30-40%",
            host_heatmap."D 40-50%",
            host_heatmap."D 50-60%",
            host_heatmap."D 60-70%",
            host_heatmap."D 70-80%",
            host_heatmap."D 80-90%",
            host_heatmap."D 90-100%",
            host_heatmap.ci_pct,
            host_heatmap.ci_cnt,
            host_heatmap.ci_hi,
            host_heatmap.ci_lo,
            host_heatmap.ci_av,
            host_heatmap.ci_sum,
            host_heatmap."J 0-10%",
            host_heatmap."J 10-20%",
            host_heatmap."J 20-30%",
            host_heatmap."J 30-40%",
            host_heatmap."J 40-50%",
            host_heatmap."J 50-60%",
            host_heatmap."J 60-70%",
            host_heatmap."J 70-80%",
            host_heatmap."J 80-90%",
            host_heatmap."J 90-100%",
            host_heatmap.re_pct,
            host_heatmap.re_cnt,
            host_heatmap.re_hi,
            host_heatmap.re_lo,
            host_heatmap.re_av,
            host_heatmap.re_sum,
            host_heatmap."R 0-10%",
            host_heatmap."R 10-20%",
            host_heatmap."R 20-30%",
            host_heatmap."R 30-40%",
            host_heatmap."R 40-50%",
            host_heatmap."R 50-60%",
            host_heatmap."R 60-70%",
            host_heatmap."R 70-80%",
            host_heatmap."R 80-90%",
            host_heatmap."R 90-100%"
           FROM host_heatmap
        UNION
         SELECT all_heatmap.week,
            all_heatmap.component,
            all_heatmap.id,
            all_heatmap.dev_pct,
            all_heatmap.dev_cnt,
            all_heatmap.dev_hi,
            all_heatmap.dev_lo,
            all_heatmap.dev_av,
            all_heatmap.dev_sum,
            all_heatmap."D 0-10%",
            all_heatmap."D 10-20%",
            all_heatmap."D 20-30%",
            all_heatmap."D 30-40%",
            all_heatmap."D 40-50%",
            all_heatmap."D 50-60%",
            all_heatmap."D 60-70%",
            all_heatmap."D 70-80%",
            all_heatmap."D 80-90%",
            all_heatmap."D 90-100%",
            all_heatmap.ci_pct,
            all_heatmap.ci_cnt,
            all_heatmap.ci_hi,
            all_heatmap.ci_lo,
            all_heatmap.ci_av,
            all_heatmap.ci_sum,
            all_heatmap."J 0-10%",
            all_heatmap."J 10-20%",
            all_heatmap."J 20-30%",
            all_heatmap."J 30-40%",
            all_heatmap."J 40-50%",
            all_heatmap."J 50-60%",
            all_heatmap."J 60-70%",
            all_heatmap."J 70-80%",
            all_heatmap."J 80-90%",
            all_heatmap."J 90-100%",
            all_heatmap.re_pct,
            all_heatmap.re_cnt,
            all_heatmap.re_hi,
            all_heatmap.re_lo,
            all_heatmap.re_av,
            all_heatmap.re_sum,
            all_heatmap."R 0-10%",
            all_heatmap."R 10-20%",
            all_heatmap."R 20-30%",
            all_heatmap."R 30-40%",
            all_heatmap."R 40-50%",
            all_heatmap."R 50-60%",
            all_heatmap."R 60-70%",
            all_heatmap."R 70-80%",
            all_heatmap."R 80-90%",
            all_heatmap."R 90-100%"
           FROM all_heatmap
  ORDER BY 3 DESC, 2
        )
 SELECT heatmap.week,
    heatmap.component,
    heatmap.id,
    heatmap.dev_pct,
    heatmap.dev_cnt,
    heatmap.dev_hi,
    heatmap.dev_lo,
    heatmap.dev_av,
    heatmap.dev_sum,
    heatmap."D 0-10%",
    heatmap."D 10-20%",
    heatmap."D 20-30%",
    heatmap."D 30-40%",
    heatmap."D 40-50%",
    heatmap."D 50-60%",
    heatmap."D 60-70%",
    heatmap."D 70-80%",
    heatmap."D 80-90%",
    heatmap."D 90-100%",
    heatmap.ci_pct,
    heatmap.ci_cnt,
    heatmap.ci_hi,
    heatmap.ci_lo,
    heatmap.ci_av,
    heatmap.ci_sum,
    heatmap."J 0-10%",
    heatmap."J 10-20%",
    heatmap."J 20-30%",
    heatmap."J 30-40%",
    heatmap."J 40-50%",
    heatmap."J 50-60%",
    heatmap."J 60-70%",
    heatmap."J 70-80%",
    heatmap."J 80-90%",
    heatmap."J 90-100%",
    heatmap.re_pct,
    heatmap.re_cnt,
    heatmap.re_hi,
    heatmap.re_lo,
    heatmap.re_av,
    heatmap.re_sum,
    heatmap."R 0-10%",
    heatmap."R 10-20%",
    heatmap."R 20-30%",
    heatmap."R 30-40%",
    heatmap."R 40-50%",
    heatmap."R 50-60%",
    heatmap."R 60-70%",
    heatmap."R 70-80%",
    heatmap."R 80-90%",
    heatmap."R 90-100%"
   FROM heatmap;


ALTER TABLE component_heatmaps3 OWNER TO postgres;

--
-- Name: developer-root-data; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "developer-root-data" AS
 WITH results AS (
         SELECT y."user",
            x.ntid,
            x.week
           FROM ((ibidresults z
             LEFT JOIN baseresults y ON ((y.id = z.id)))
             LEFT JOIN etlresults x ON ((x.id = z.id)))
        ), root AS (
         SELECT results."user",
            results.ntid,
            results.week
           FROM results
          WHERE ((results."user")::text = 'root'::text)
        ), blds AS (
         SELECT count(*) AS "all",
            results.week
           FROM results
          GROUP BY results.week
        ), r1u AS (
         SELECT count(*) AS "all",
            root.week
           FROM root
          GROUP BY root.week
        ), r2 AS (
         SELECT DISTINCT results.ntid,
            results.week
           FROM results
        ), r2all AS (
         SELECT count(*) AS "all",
            r2.week
           FROM r2
          GROUP BY r2.week
        ), r3 AS (
         SELECT DISTINCT root.ntid,
            root.week
           FROM root
        ), r3all AS (
         SELECT count(*) AS "all",
            r3.week
           FROM r3
          GROUP BY r3.week
        ), data AS (
         SELECT blds.week,
            blds."all" AS "total builds",
            r2all."all" AS "# developers",
            r1u."all" AS "root builds",
            r3all."all" AS "as root"
           FROM (((blds
             LEFT JOIN r1u ON ((blds.week = r1u.week)))
             LEFT JOIN r2all ON ((blds.week = r2all.week)))
             LEFT JOIN r3all ON ((blds.week = r3all.week)))
          WHERE ((blds.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone))
          ORDER BY blds.week
        )
 SELECT data.week,
    data."total builds",
    data."# developers",
    data."root builds",
    data."as root"
   FROM data
  ORDER BY data.week;


ALTER TABLE "developer-root-data" OWNER TO postgres;

--
-- Name: developer-root-names; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "developer-root-names" AS
 WITH results AS (
         SELECT z.id,
            z.tm,
            z.fault_class,
            z.ibid,
            z."user",
            z.acuser,
            z.host,
            z.hostname,
            z.ipaddr,
            z.status,
            z.stream,
            z.fault_component,
            z.fault_msg,
            z.fault_detail,
            z.init_val,
            z.pwd,
            z.basis,
            z.env_type,
            z.native_env,
            z.run_env,
            z.workspace,
            z.logerr,
            z.logout,
            z.log_subdir,
            z.component,
            z.component_outdir,
            y.week,
            y.build_class
           FROM (baseresults z
             LEFT JOIN etlresults y ON ((y.id = z.id)))
          WHERE ((y.build_class)::text = 'Developer'::text)
        ), lastwk AS (
         SELECT results.id,
            results.tm,
            results.fault_class,
            results.ibid,
            results."user",
            results.acuser,
            results.host,
            results.hostname,
            results.ipaddr,
            results.status,
            results.stream,
            results.fault_component,
            results.fault_msg,
            results.fault_detail,
            results.init_val,
            results.pwd,
            results.basis,
            results.env_type,
            results.native_env,
            results.run_env,
            results.workspace,
            results.logerr,
            results.logout,
            results.log_subdir,
            results.component,
            results.component_outdir,
            results.week,
            results.build_class
           FROM results
          WHERE ((results.week)::date = public.endofweek((('now'::text)::date - '7 days'::interval)))
        ), root AS (
         SELECT lastwk.id,
            lastwk.tm,
            lastwk.fault_class,
            lastwk.ibid,
            lastwk."user",
            lastwk.acuser,
            lastwk.host,
            lastwk.hostname,
            lastwk.ipaddr,
            lastwk.status,
            lastwk.stream,
            lastwk.fault_component,
            lastwk.fault_msg,
            lastwk.fault_detail,
            lastwk.init_val,
            lastwk.pwd,
            lastwk.basis,
            lastwk.env_type,
            lastwk.native_env,
            lastwk.run_env,
            lastwk.workspace,
            lastwk.logerr,
            lastwk.logout,
            lastwk.log_subdir,
            lastwk.component,
            lastwk.component_outdir,
            lastwk.week,
            lastwk.build_class
           FROM lastwk
          WHERE (((lastwk."user")::text = 'root'::text) AND ((lastwk.acuser)::text <> '(not logged in)'::text) AND (lastwk.acuser IS NOT NULL))
        ), people AS (
         SELECT p1.name,
            p1.city,
            p1.country,
            p1.badgeid AS id,
            p1.mgr_name AS supervisorname,
            p1.mgr_badgeid AS supervisorid,
            root.acuser,
            count(*) AS count
           FROM (root
             LEFT JOIN empdata.employee_data p1 ON (((root.acuser)::text = (p1.ntlogin)::text)))
          GROUP BY p1.name, p1.city, p1.country, p1.badgeid, p1.mgr_name, p1.mgr_badgeid, root.acuser
        )
 SELECT people.name,
    people.city,
    people.country,
    people.id,
    people.supervisorname,
    people.supervisorid,
    people.acuser,
    people.count
   FROM people
  ORDER BY people.count DESC;


ALTER TABLE "developer-root-names" OWNER TO postgres;

--
-- Name: developer-root-summary; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "developer-root-summary" AS
 WITH results AS (
         SELECT z.id,
            z.tm,
            z.fault_class,
            z.ibid,
            z."user",
            z.acuser,
            z.host,
            z.hostname,
            z.ipaddr,
            z.status,
            z.stream,
            z.fault_component,
            z.fault_msg,
            z.fault_detail,
            z.init_val,
            z.pwd,
            z.basis,
            z.env_type,
            z.native_env,
            z.run_env,
            z.workspace,
            z.logerr,
            z.logout,
            z.log_subdir,
            z.component,
            z.component_outdir,
            y.week,
            y.build_class
           FROM (baseresults z
             LEFT JOIN etlresults y ON ((y.id = z.id)))
          WHERE ((y.build_class)::text = 'Developer'::text)
        ), lastwk AS (
         SELECT results.id,
            results.tm,
            results.fault_class,
            results.ibid,
            results."user",
            results.acuser,
            results.host,
            results.hostname,
            results.ipaddr,
            results.status,
            results.stream,
            results.fault_component,
            results.fault_msg,
            results.fault_detail,
            results.init_val,
            results.pwd,
            results.basis,
            results.env_type,
            results.native_env,
            results.run_env,
            results.workspace,
            results.logerr,
            results.logout,
            results.log_subdir,
            results.component,
            results.component_outdir,
            results.week,
            results.build_class
           FROM results
          WHERE ((results.week)::date = public.endofweek((('now'::text)::date - '7 days'::interval)))
        ), blds AS (
         SELECT count(*) AS cnt,
            'developer builds'::text AS comment,
            1 AS id
           FROM results
        ), r2a AS (
         SELECT count(*) AS cnt,
            'developer builds last week'::text AS comment,
            3 AS id
           FROM lastwk
        ), r1u AS (
         SELECT DISTINCT results.acuser
           FROM results
        ), r1 AS (
         SELECT count(r1u.acuser) AS cnt,
            'unique users'::text AS comment,
            2 AS id
           FROM r1u
        ), r2u AS (
         SELECT DISTINCT lastwk.acuser
           FROM lastwk
        ), r2 AS (
         SELECT count(r2u.acuser) AS cnt,
            'unique users performing builds last week'::text AS comment,
            4 AS id
           FROM r2u
        ), root AS (
         SELECT lastwk.id,
            lastwk.tm,
            lastwk.fault_class,
            lastwk.ibid,
            lastwk."user",
            lastwk.acuser,
            lastwk.host,
            lastwk.hostname,
            lastwk.ipaddr,
            lastwk.status,
            lastwk.stream,
            lastwk.fault_component,
            lastwk.fault_msg,
            lastwk.fault_detail,
            lastwk.init_val,
            lastwk.pwd,
            lastwk.basis,
            lastwk.env_type,
            lastwk.native_env,
            lastwk.run_env,
            lastwk.workspace,
            lastwk.logerr,
            lastwk.logout,
            lastwk.log_subdir,
            lastwk.component,
            lastwk.component_outdir,
            lastwk.week,
            lastwk.build_class
           FROM lastwk
          WHERE (((lastwk."user")::text = 'root'::text) AND ((lastwk.acuser)::text <> '(not logged in)'::text) AND (lastwk.acuser IS NOT NULL))
        ), r3a AS (
         SELECT count(*) AS cnt,
            'developer builds AS root last week'::text AS comment,
            5 AS id
           FROM root
        ), r3u AS (
         SELECT DISTINCT root.acuser
           FROM root
        ), r3 AS (
         SELECT count(r3u.acuser) AS cnt,
            'unique users building AS root last week'::text AS comment,
            6 AS id
           FROM r3u
        ), data AS (
         SELECT blds.cnt,
            blds.comment,
            blds.id
           FROM blds
        UNION
         SELECT r1.cnt,
            r1.comment,
            r1.id
           FROM r1
        UNION
         SELECT r2a.cnt,
            r2a.comment,
            r2a.id
           FROM r2a
        UNION
         SELECT r2.cnt,
            r2.comment,
            r2.id
           FROM r2
        UNION
         SELECT r3a.cnt,
            r3a.comment,
            r3a.id
           FROM r3a
        UNION
         SELECT r3.cnt,
            r3.comment,
            r3.id
           FROM r3
        )
 SELECT data.comment,
    data.cnt
   FROM data
  ORDER BY data.id;


ALTER TABLE "developer-root-summary" OWNER TO postgres;

--
-- Name: faults_overview; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW faults_overview AS
 WITH a AS (
         SELECT
                CASE
                    WHEN ("position"((z.fault_class)::text, ','::text) > 0) THEN 'Multiple Faults'::character varying
                    ELSE w.fault_category
                END AS fault_category,
                CASE
                    WHEN ("position"((z.fault_class)::text, ','::text) > 0) THEN 'Multiple Faults'::character varying
                    ELSE z.fault_class
                END AS fault_class,
            z.id,
            x.week,
            x.build_class
           FROM (((ibidresults z
             LEFT JOIN baseresults y ON ((y.id = z.id)))
             LEFT JOIN etlresults x ON ((x.id = z.id)))
             LEFT JOIN fault_class w ON (((w.fault_class)::text = (z.fault_class)::text)))
        ), b AS (
         SELECT a.build_class,
            a.fault_category,
            a.fault_class,
            count(a.id) AS overall_total
           FROM a
          GROUP BY a.fault_category, a.fault_class, a.build_class
        ), c AS (
         SELECT a.build_class,
            a.fault_category,
            a.fault_class,
            count(a.id) AS monthly_total
           FROM a
          WHERE ((a.week)::date > public.endofweek((('now'::text)::date - '31 days'::interval)))
          GROUP BY a.fault_category, a.fault_class, a.build_class
        ), d AS (
         SELECT b.build_class,
            b.fault_category,
            b.fault_class,
            c.monthly_total,
            b.overall_total
           FROM (b
             LEFT JOIN c ON ((((b.build_class)::text = (c.build_class)::text) AND ((b.fault_category)::text = (c.fault_category)::text) AND ((b.fault_class)::text = (c.fault_class)::text))))
        )
 SELECT d.build_class,
    d.fault_category,
    d.fault_class,
    d.monthly_total,
    d.overall_total
   FROM d
  ORDER BY d.build_class, d.fault_category, d.fault_class;


ALTER TABLE faults_overview OWNER TO postgres;

--
-- Name: host_class_id; Type: SEQUENCE; Schema: buildlog; Owner: postgres
--

CREATE SEQUENCE host_class_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE host_class_id OWNER TO postgres;

--
-- Name: host_class; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE host_class (
    id bigint DEFAULT nextval('host_class_id'::regclass) NOT NULL,
    host_class character varying,
    match character varying,
    category character varying
);


ALTER TABLE host_class OWNER TO postgres;

--
-- Name: ibidmaskresults; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE ibidmaskresults (
    ibid character varying,
    mask bigint
);


ALTER TABLE ibidmaskresults OWNER TO postgres;

--
-- Name: idmaskresults; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE idmaskresults (
    id bigint,
    mask bigint
);


ALTER TABLE idmaskresults OWNER TO postgres;

--
-- Name: logrange_info; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE logrange_info (
    idorder bigint,
    start_id bigint,
    end_id bigint
);


ALTER TABLE logrange_info OWNER TO postgres;

--
-- Name: raw_baseresults; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE raw_baseresults (
    id bigint,
    tm timestamp without time zone,
    fault_class character varying,
    ibid character varying,
    "user" character varying,
    acuser character varying,
    host character varying,
    hostname character varying,
    ipaddr character varying,
    status integer,
    stream character varying,
    fault_component character varying,
    fault_msg character varying,
    fault_detail character varying,
    init_val character varying,
    pwd character varying,
    basis character varying,
    env_type character varying,
    native_env character varying,
    run_env character varying,
    workspace character varying,
    logerr character varying,
    logout character varying,
    log_subdir character varying,
    component character varying,
    component_outdir character varying
);


ALTER TABLE raw_baseresults OWNER TO postgres;

--
-- Name: raw_cmdargs; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE raw_cmdargs (
    id bigint,
    argument character varying,
    value character varying,
    "position" integer,
    orginalcommand character varying
);


ALTER TABLE raw_cmdargs OWNER TO postgres;

--
-- Name: raw_componentsbyoccurrence; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE raw_componentsbyoccurrence (
    id bigint,
    component character varying,
    duration integer,
    phase character varying
);


ALTER TABLE raw_componentsbyoccurrence OWNER TO postgres;

--
-- Name: raw_ibidresults; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE raw_ibidresults (
    id bigint,
    endid bigint,
    ibid character varying,
    status integer,
    result character varying,
    fault_class character varying,
    start_tm timestamp without time zone,
    end_tm timestamp without time zone,
    bld_count integer,
    comp_count integer,
    build_duration bigint,
    prepare_duration bigint,
    prepare_count integer,
    build2_duration bigint,
    build2_count integer,
    package_duration bigint,
    package_count integer,
    mask bigint
);


ALTER TABLE raw_ibidresults OWNER TO postgres;

--
-- Name: usermatch; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE usermatch (
    m_acuser character varying,
    m_user character varying,
    m_host_class character varying,
    m_host character varying,
    m_workspace character varying,
    m_pwd character varying,
    build_class character varying,
    ntid character varying,
    m_id integer NOT NULL
);


ALTER TABLE usermatch OWNER TO postgres;

--
-- Name: weekly; Type: TABLE; Schema: buildlog; Owner: postgres
--

CREATE TABLE weekly (
    week date NOT NULL,
    component character varying NOT NULL,
    host_class character varying NOT NULL,
    hi bigint,
    lo bigint,
    cnt bigint,
    avg bigint,
    med bigint,
    "0-10%" bigint,
    "10-20%" bigint,
    "20-30%" bigint,
    "30-40%" bigint,
    "40-50%" bigint,
    "50-60%" bigint,
    "60-70%" bigint,
    "70-80%" bigint,
    "80-90%" bigint,
    "90-100%" bigint
);


ALTER TABLE weekly OWNER TO postgres;

SET search_path = wscommands, pg_catalog;

--
-- Name: baseresults_id; Type: SEQUENCE; Schema: wscommands; Owner: postgres
--

CREATE SEQUENCE baseresults_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE baseresults_id OWNER TO postgres;

--
-- Name: baseresults; Type: TABLE; Schema: wscommands; Owner: postgres
--

CREATE TABLE baseresults (
    id bigint DEFAULT nextval('baseresults_id'::regclass) NOT NULL,
    tm timestamp without time zone,
    workspace character varying,
    workingdir character varying,
    version real,
    stream character varying,
    duration bigint,
    "user" character varying,
    command character varying,
    code integer,
    host character varying,
    accurev_user character varying,
    accurev_topdir character varying
);


ALTER TABLE baseresults OWNER TO postgres;

--
-- Name: etlresults; Type: TABLE; Schema: wscommands; Owner: postgres
--

CREATE TABLE etlresults (
    id bigint NOT NULL,
    result character varying,
    arg_count integer,
    line_count integer,
    hour integer,
    date timestamp without time zone,
    week timestamp without time zone
);


ALTER TABLE etlresults OWNER TO postgres;

SET search_path = buildlog, pg_catalog;

--
-- Name: ws-adoption; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "ws-adoption" AS
 WITH RECURSIVE a0 AS (
         SELECT z.accurev_user,
            y.week
           FROM (wscommands.baseresults z
             LEFT JOIN wscommands.etlresults y ON ((y.id = z.id)))
          WHERE ((z.accurev_user IS NOT NULL) AND ((z.accurev_user)::text <> '(not logged in)'::text))
        ), b0 AS (
         SELECT min(etlresults.week) AS begin
           FROM wscommands.etlresults
        ), c1(wk, bldusers, wsusers, delta) AS (
         SELECT b0.begin AS wk,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM etlresults,
                            b0 b0_1
                          WHERE (etlresults.week <= b0_1.begin)) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT a0.accurev_user
                           FROM a0,
                            b0 b0_1
                          WHERE (a0.week <= b0_1.begin)) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM etlresults,
                            b0 b0_1
                          WHERE ((etlresults.week <= b0_1.begin) AND (NOT ((etlresults.ntid)::text IN ( SELECT DISTINCT a0.accurev_user
                                   FROM a0,
                                    b0 b0_2
                                  WHERE (a0.week <= b0_2.begin)))))) z(ntid)) AS count
           FROM b0
        UNION ALL
         SELECT (c1_1.wk + '7 days'::interval) AS wk,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM etlresults
                          WHERE (etlresults.week <= (c1_1.wk + '7 days'::interval))) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT a0.accurev_user
                           FROM a0
                          WHERE (a0.week <= (c1_1.wk + '7 days'::interval))) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM etlresults
                          WHERE ((etlresults.week <= (c1_1.wk + '7 days'::interval)) AND (NOT ((etlresults.ntid)::text IN ( SELECT DISTINCT a0.accurev_user
                                   FROM a0
                                  WHERE (a0.week <= (c1_1.wk + '7 days'::interval))))))) z(ntid)) AS count
           FROM c1 c1_1
          WHERE (c1_1.wk <= (date_trunc('week'::text, (('now'::text)::date + '1 day'::interval)) - '1 day'::interval))
        )
 SELECT c1.wk AS "Week",
    c1.bldusers AS "Build Users",
    c1.wsusers AS "Ws Command Users",
    c1.delta AS "Delta"
   FROM c1;


ALTER TABLE "ws-adoption" OWNER TO postgres;

--
-- Name: ws-adoption2; Type: VIEW; Schema: buildlog; Owner: postgres
--

CREATE VIEW "ws-adoption2" AS
 WITH RECURSIVE a0 AS (
         SELECT z.accurev_user,
            y.week
           FROM (wscommands.baseresults z
             LEFT JOIN wscommands.etlresults y ON ((y.id = z.id)))
          WHERE ((z.accurev_user IS NOT NULL) AND ((z.accurev_user)::text <> '(not logged in)'::text))
        ), b0 AS (
         SELECT min(etlresults.week) AS begin
           FROM wscommands.etlresults
        ), c1(wk, bldusers, wsusers, delta) AS (
         SELECT b0.begin AS wk,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM etlresults,
                            b0 b0_1
                          WHERE (etlresults.week <= b0_1.begin)) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT a0.accurev_user
                           FROM a0,
                            b0 b0_1
                          WHERE (a0.week <= b0_1.begin)) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM etlresults,
                            b0 b0_1
                          WHERE ((etlresults.week <= b0_1.begin) AND (NOT ((etlresults.ntid)::text IN ( SELECT DISTINCT a0.accurev_user
                                   FROM a0,
                                    b0 b0_2
                                  WHERE (a0.week <= b0_2.begin)))))) z(ntid)) AS count
           FROM b0
        UNION ALL
         SELECT (c1_1.wk + '7 days'::interval) AS wk,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM etlresults
                          WHERE (etlresults.week <= (c1_1.wk + '7 days'::interval))) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT a0.accurev_user
                           FROM a0
                          WHERE (a0.week <= (c1_1.wk + '7 days'::interval))) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM etlresults
                          WHERE ((etlresults.week <= (c1_1.wk + '7 days'::interval)) AND (NOT ((etlresults.ntid)::text IN ( SELECT DISTINCT a0.accurev_user
                                   FROM a0
                                  WHERE (a0.week <= (c1_1.wk + '7 days'::interval))))))) z(ntid)) AS count
           FROM c1 c1_1
          WHERE (c1_1.wk <= (date_trunc('week'::text, (('now'::text)::date + '1 day'::interval)) - '1 day'::interval))
        )
 SELECT c1.wk AS "Week",
    c1.bldusers AS "Build Users",
    c1.wsusers AS "Ws Command Users",
    c1.delta AS "Delta"
   FROM c1;


ALTER TABLE "ws-adoption2" OWNER TO postgres;

SET search_path = buildlog_new, pg_catalog;

--
-- Name: ix_ipaddress_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_ipaddress_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_ipaddress_id OWNER TO postgres;

--
-- Name: ix_ipaddress; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_ipaddress (
    id bigint DEFAULT nextval('ix_ipaddress_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_ipaddress OWNER TO postgres;

--
-- Name: IP address ranges; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "IP address ranges" AS
 WITH bx AS (
         SELECT ix_ipaddress.name AS ipaddress
           FROM ix_ipaddress
          WHERE ((ix_ipaddress.name)::text ~* '^\d+\.\d+\.\d+\.\d+$'::text)
        ), c AS (
         SELECT network((((bx.ipaddress)::text || '/16'::text))::inet) AS network_16,
            "substring"((bx.ipaddress)::text, '^\d+\.\d+'::text) AS ip_16s,
            network((((bx.ipaddress)::text || '/24'::text))::inet) AS network_24,
            "substring"((bx.ipaddress)::text, '^\d+\.\d+\.\d+'::text) AS ip_24s
           FROM bx
        ), d AS (
         SELECT c.network_16,
            c.ip_16s,
            c.network_24,
            c.ip_24s,
            count(*) AS host_count
           FROM c
          WHERE ((c.ip_16s <> '10.0'::text) AND (c.ip_16s <> '1.1'::text) AND (c.ip_16s <> '192.168'::text) AND (c.ip_16s <> '127.0'::text) AND (c.ip_16s !~* '^0\.'::text) AND (c.ip_16s !~* '^128'::text) AND (c.ip_16s !~* '^172'::text))
          GROUP BY c.network_16, c.ip_16s, c.network_24, c.ip_24s
          ORDER BY c.network_24
        ), e AS (
         SELECT d.network_16,
            d.ip_16s,
            sum(d.host_count) AS "host count",
            array_agg(d.ip_24s) AS networks
           FROM d
          GROUP BY d.network_16, d.ip_16s
        ), f AS (
         SELECT e.ip_16s AS network_ip,
            e."host count",
            e.networks
           FROM e
          ORDER BY e.network_16
        )
 SELECT f.network_ip,
    f."host count",
    f.networks
   FROM f;


ALTER TABLE "IP address ranges" OWNER TO postgres;

--
-- Name: tbl_faults; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_faults (
    tbl_results_id bigint NOT NULL,
    status integer,
    usr_fault_class_id bigint,
    ix_fault_component_id bigint,
    ix_fault_msg_id bigint,
    ix_fault_detail_id bigint
);


ALTER TABLE tbl_faults OWNER TO postgres;

--
-- Name: tbl_ibidinfo; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_ibidinfo (
    ix_ibid_id bigint NOT NULL,
    tbl_results_start_id bigint NOT NULL,
    tbl_results_end_id bigint NOT NULL,
    tm_bld_start timestamp without time zone,
    tm_bld_end timestamp without time zone,
    build_count integer,
    component_count integer,
    prep_phase_count integer,
    bld_phase_count integer,
    pkg_phase_count integer,
    components_mask bigint,
    build_duration interval,
    prep_phase_duration interval,
    bld_phase_duration interval,
    pkg_phase_duration interval,
    ix_site_id bigint,
    ix_cloud_id bigint,
    ix_director_ntlogin_id bigint
);


ALTER TABLE tbl_ibidinfo OWNER TO postgres;

--
-- Name: tbl_results; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_results (
    id bigint NOT NULL,
    tm timestamp without time zone,
    build_duration interval,
    prep_phase_duration interval,
    bld_phase_duration interval,
    pkg_phase_duration interval,
    prep_phase_count integer,
    bld_phase_count integer,
    pkg_phase_count integer,
    components_mask bigint,
    components_count integer,
    arg_count integer,
    usr_build_class_id bigint,
    ix_ibid_id bigint,
    tbl_users_id bigint,
    usr_match_owner_to_log_id bigint NOT NULL,
    tbl_hosts_id bigint,
    ix_environment_native_id bigint,
    ix_environment_run_id bigint,
    ix_env_type_id bigint,
    ix_stream_id bigint,
    ix_streambasis_id bigint,
    ix_init_val_id bigint,
    data_src bit(1) DEFAULT B'0'::"bit" NOT NULL
);


ALTER TABLE tbl_results OWNER TO postgres;

--
-- Name: tbl_timeslots; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_timeslots (
    tbl_results_id bigint NOT NULL,
    hour integer,
    date date,
    week timestamp without time zone,
    iteration character(6)
);


ALTER TABLE tbl_timeslots OWNER TO postgres;

--
-- Name: usr_build_class_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE usr_build_class_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_build_class_id OWNER TO postgres;

--
-- Name: usr_build_class; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_build_class (
    id bigint DEFAULT nextval('usr_build_class_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE usr_build_class OWNER TO postgres;

--
-- Name: usr_fault_category_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE usr_fault_category_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_fault_category_id OWNER TO postgres;

--
-- Name: usr_fault_category; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_fault_category (
    id bigint DEFAULT nextval('usr_fault_category_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE usr_fault_category OWNER TO postgres;

--
-- Name: usr_fault_class_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE usr_fault_class_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_fault_class_id OWNER TO postgres;

--
-- Name: usr_fault_class; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_fault_class (
    id bigint DEFAULT nextval('usr_fault_class_id'::regclass) NOT NULL,
    name character varying NOT NULL,
    usr_fault_category_id bigint DEFAULT 2 NOT NULL
);


ALTER TABLE usr_fault_class OWNER TO postgres;

--
-- Name: Indicators Summary; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Indicators Summary" AS
 WITH a AS (
         SELECT (w.week)::date AS week,
                CASE
                    WHEN (x.tbl_results_id IS NULL) THEN 'Pass'::character varying
                    WHEN (strpos((x2.name)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE x2.name
                END AS fault_category,
            date_part('epoch'::text, z.build_duration) AS build_duration,
            z.component_count AS comp_count,
            v.name AS build_class,
            x.status
           FROM ((((((tbl_ibidinfo z
             LEFT JOIN tbl_results y ON ((y.id = z.tbl_results_start_id)))
             LEFT JOIN tbl_faults x ON ((x.tbl_results_id = y.id)))
             LEFT JOIN usr_fault_class x1 ON ((x1.id = x.usr_fault_class_id)))
             LEFT JOIN usr_fault_category x2 ON ((x2.id = x1.usr_fault_category_id)))
             LEFT JOIN tbl_timeslots w ON ((w.tbl_results_id = y.id)))
             LEFT JOIN usr_build_class v ON ((v.id = y.usr_build_class_id)))
          WHERE (((w.week)::date < public.startofweek((CURRENT_DATE)::timestamp with time zone)) AND (z.component_count > 40))
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), b AS (
         SELECT a.week,
            a.fault_category,
            a.build_duration,
            a.comp_count,
            a.build_class,
            a.status
           FROM a
          WHERE ((a.build_class)::text = 'Developer'::text)
        ), c AS (
         SELECT a.week,
            a.fault_category,
            a.build_duration,
            a.comp_count,
            a.build_class,
            a.status
           FROM a
          WHERE ((a.build_class)::text = 'Jenkins'::text)
        ), d AS (
         SELECT a.week,
            a.fault_category,
            a.build_duration,
            a.comp_count,
            a.build_class,
            a.status
           FROM a
          WHERE ((a.build_class)::text = 'Rel Eng'::text)
        ), e AS (
         SELECT a.week,
            a.fault_category,
            a.build_duration,
            a.comp_count,
            a.build_class,
            a.status
           FROM a
          WHERE (a.status IS NULL)
        ), f AS (
         SELECT e.week,
            e.fault_category,
            e.build_duration,
            e.comp_count,
            e.build_class,
            e.status
           FROM e
          WHERE ((e.build_class)::text = 'Developer'::text)
        ), g AS (
         SELECT e.week,
            e.fault_category,
            e.build_duration,
            e.comp_count,
            e.build_class,
            e.status
           FROM e
          WHERE ((e.build_class)::text = 'Jenkins'::text)
        ), h AS (
         SELECT e.week,
            e.fault_category,
            e.build_duration,
            e.comp_count,
            e.build_class,
            e.status
           FROM e
          WHERE ((e.build_class)::text = 'Rel Eng'::text)
        ), a1 AS (
         SELECT a.week,
            count(*) AS "All: total",
            ((round((avg(a.build_duration))::numeric, 0) || ' seconds'::text))::interval AS "All: avg duration",
            max(a.build_duration) AS "All: max duration"
           FROM a
          GROUP BY a.week
        ), a4 AS (
         SELECT a.week,
            count(*) AS "All: total full"
           FROM a
          WHERE ((a.comp_count > 40) AND (a.build_duration > (7200)::double precision))
          GROUP BY a.week
        ), a2 AS (
         SELECT a.week,
            count(*) AS "All: Pass"
           FROM a
          WHERE ((a.fault_category)::text = 'Pass'::text)
          GROUP BY a.week
        ), a3 AS (
         SELECT e.week,
            public.quantile(e.comp_count, (0.5)::double precision) AS "All: median comp count",
            ((public.quantile(e.build_duration, (0.5)::double precision) || ' seconds'::text))::interval AS "All: median build time",
            ((round(public.quantile((e.build_duration / (e.comp_count)::double precision), (0.5)::double precision)) || ' seconds'::text))::interval AS "All: normalized median time"
           FROM e
          GROUP BY e.week
        ), b1 AS (
         SELECT b.week,
            count(*) AS "DV: total",
            ((round((avg(b.build_duration))::numeric, 0) || ' seconds'::text))::interval AS "DV: avg duration",
            max(b.build_duration) AS "DV: max duration"
           FROM b
          GROUP BY b.week
        ), b4 AS (
         SELECT b.week,
            count(*) AS "DV: total full"
           FROM b
          WHERE ((b.comp_count > 40) AND (b.build_duration > (7200)::double precision))
          GROUP BY b.week
        ), b5 AS (
         SELECT b.week,
            count(*) AS "DV: Developer Error"
           FROM b
          WHERE ((b.fault_category)::text = 'Developer Error'::text)
          GROUP BY b.week
        ), b2 AS (
         SELECT b.week,
            count(*) AS "DV: Pass"
           FROM b
          WHERE ((b.fault_category)::text = 'Pass'::text)
          GROUP BY b.week
        ), b3 AS (
         SELECT f.week,
            public.quantile(f.comp_count, (0.5)::double precision) AS "DV: median comp count",
            ((public.quantile(f.build_duration, (0.5)::double precision) || ' seconds'::text))::interval AS "DV: median build time",
            ((round(public.quantile((f.build_duration / (f.comp_count)::double precision), (0.5)::double precision)) || ' seconds'::text))::interval AS "DV: normalized median time"
           FROM f
          GROUP BY f.week
        ), c1 AS (
         SELECT c.week,
            count(*) AS "CI: total",
            ((round((avg(c.build_duration))::numeric, 0) || ' seconds'::text))::interval AS "CI: avg duration",
            max(c.build_duration) AS "CI: max duration"
           FROM c
          GROUP BY c.week
        ), c4 AS (
         SELECT c.week,
            count(*) AS "CI: total full"
           FROM c
          WHERE ((c.comp_count > 40) AND (c.build_duration > (7200)::double precision))
          GROUP BY c.week
        ), c2 AS (
         SELECT c.week,
            count(*) AS "CI: Pass"
           FROM c
          WHERE ((c.fault_category)::text = 'Pass'::text)
          GROUP BY c.week
        ), c3 AS (
         SELECT g.week,
            public.quantile(g.comp_count, (0.5)::double precision) AS "CI: median comp count",
            ((public.quantile(g.build_duration, (0.5)::double precision) || ' seconds'::text))::interval AS "CI: median build time",
            ((round(public.quantile((g.build_duration / (g.comp_count)::double precision), (0.5)::double precision)) || ' seconds'::text))::interval AS "CI: normalized median time"
           FROM g
          GROUP BY g.week
        ), d1 AS (
         SELECT d.week,
            count(*) AS "RE: total",
            ((round((avg(d.build_duration))::numeric, 0) || ' seconds'::text))::interval AS "RE: avg duration",
            max(d.build_duration) AS "RE: max duration"
           FROM d
          GROUP BY d.week
        ), d4 AS (
         SELECT d.week,
            count(*) AS "RE: total full"
           FROM d
          WHERE ((d.comp_count > 40) AND (d.build_duration > (7200)::double precision))
          GROUP BY d.week
        ), d2 AS (
         SELECT d.week,
            count(*) AS "RE: Pass"
           FROM d
          WHERE ((d.fault_category)::text = 'Pass'::text)
          GROUP BY d.week
        ), d3 AS (
         SELECT h.week,
            public.quantile(h.comp_count, (0.5)::double precision) AS "RE: median comp count",
            ((public.quantile(h.build_duration, (0.5)::double precision) || ' seconds'::text))::interval AS "RE: median build time",
            ((round(public.quantile((h.build_duration / (h.comp_count)::double precision), (0.5)::double precision)) || ' seconds'::text))::interval AS "RE: normalized median time"
           FROM h
          GROUP BY h.week
        ), zz AS (
         SELECT aa.week,
            a1."All: total",
            a4."All: total full",
            a3."All: median build time",
            a1."All: avg duration",
            a1."All: max duration",
            a3."All: normalized median time",
            a3."All: median comp count",
            round((((((a1."All: total" - a2."All: Pass") - b5."DV: Developer Error") * 100) / a1."All: total"))::numeric, 0) AS "All: Build Issues",
            b1."DV: total",
            b4."DV: total full",
            b3."DV: median build time",
            b1."DV: avg duration",
            b1."DV: max duration",
            b3."DV: normalized median time",
            b3."DV: median comp count",
            round((((((b1."DV: total" - b2."DV: Pass") - b5."DV: Developer Error") * 100) / b1."DV: total"))::numeric, 0) AS "DV: Build Issues",
            c1."CI: total",
            c4."CI: total full",
            c3."CI: median build time",
            c1."CI: avg duration",
            c1."CI: max duration",
            c3."CI: normalized median time",
            c3."CI: median comp count",
            round(((((c1."CI: total" - c2."CI: Pass") * 100) / c1."CI: total"))::numeric, 0) AS "CI: Build Issues",
            d1."RE: total",
            d4."RE: total full",
            d3."RE: median build time",
            d1."RE: avg duration",
            d1."RE: max duration",
            d3."RE: normalized median time",
            d3."RE: median comp count",
            round(((((d1."RE: total" - d2."RE: Pass") * 100) / d1."RE: total"))::numeric, 0) AS "RE: Build Issues"
           FROM (((((((((((((((((aa
             LEFT JOIN a1 USING (week))
             LEFT JOIN a2 USING (week))
             LEFT JOIN a3 USING (week))
             LEFT JOIN a4 USING (week))
             LEFT JOIN b1 USING (week))
             LEFT JOIN b2 USING (week))
             LEFT JOIN b3 USING (week))
             LEFT JOIN b4 USING (week))
             LEFT JOIN b5 USING (week))
             LEFT JOIN c1 USING (week))
             LEFT JOIN c2 USING (week))
             LEFT JOIN c3 USING (week))
             LEFT JOIN c4 USING (week))
             LEFT JOIN d1 USING (week))
             LEFT JOIN d2 USING (week))
             LEFT JOIN d3 USING (week))
             LEFT JOIN d4 USING (week))
        )
 SELECT zz.week,
    zz."All: total",
    zz."All: total full",
    zz."All: median build time",
    zz."All: avg duration",
    zz."All: max duration",
    zz."All: normalized median time",
    zz."All: median comp count",
    zz."All: Build Issues",
    zz."DV: total",
    zz."DV: total full",
    zz."DV: median build time",
    zz."DV: avg duration",
    zz."DV: max duration",
    zz."DV: normalized median time",
    zz."DV: median comp count",
    zz."DV: Build Issues",
    zz."CI: total",
    zz."CI: total full",
    zz."CI: median build time",
    zz."CI: avg duration",
    zz."CI: max duration",
    zz."CI: normalized median time",
    zz."CI: median comp count",
    zz."CI: Build Issues",
    zz."RE: total",
    zz."RE: total full",
    zz."RE: median build time",
    zz."RE: avg duration",
    zz."RE: max duration",
    zz."RE: normalized median time",
    zz."RE: median comp count",
    zz."RE: Build Issues"
   FROM zz
  ORDER BY zz.week;


ALTER TABLE "Indicators Summary" OWNER TO postgres;

--
-- Name: Last weeks faults; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Last weeks faults" AS
 WITH ibid AS (
         SELECT v.name AS build_class,
                CASE
                    WHEN (strpos((x2.name)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE x2.name
                END AS fault_category,
            (w.week)::date AS week
           FROM ((((((tbl_ibidinfo z
             LEFT JOIN tbl_results y ON ((y.id = z.tbl_results_start_id)))
             LEFT JOIN tbl_faults x ON ((x.tbl_results_id = y.id)))
             LEFT JOIN usr_fault_class x1 ON ((x1.id = x.usr_fault_class_id)))
             LEFT JOIN usr_fault_category x2 ON ((x2.id = x1.usr_fault_category_id)))
             LEFT JOIN tbl_timeslots w ON ((w.tbl_results_id = y.id)))
             LEFT JOIN usr_build_class v ON ((v.id = y.usr_build_class_id)))
          WHERE ((w.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone))
        ), a AS (
         SELECT ibid.week,
            ibid.fault_category AS "Category",
            count(*) AS faults
           FROM ibid
          WHERE (ibid.fault_category IS NOT NULL)
          GROUP BY ibid.week, ibid.fault_category
        ), b AS (
         SELECT a."Category",
            a.faults
           FROM a
          WHERE (a.week IN ( SELECT max(a_1.week) AS max
                   FROM a a_1))
        )
 SELECT b."Category",
    b.faults
   FROM b;


ALTER TABLE "Last weeks faults" OWNER TO postgres;

--
-- Name: VIEW "Last weeks faults"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Last weeks faults" IS 'Data to produce graph of ''Build Reliability over last 52 weeks''';


--
-- Name: ix_cloud_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_cloud_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_cloud_id OWNER TO postgres;

--
-- Name: ix_cloud; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_cloud (
    id bigint DEFAULT nextval('ix_cloud_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_cloud OWNER TO postgres;

--
-- Name: ix_ntlogin_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_ntlogin_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_ntlogin_id OWNER TO postgres;

--
-- Name: ix_ntlogin; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_ntlogin (
    id bigint DEFAULT nextval('ix_ntlogin_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_ntlogin OWNER TO postgres;

--
-- Name: tbl_users_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE tbl_users_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tbl_users_id OWNER TO postgres;

--
-- Name: tbl_users; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_users (
    id bigint DEFAULT nextval('tbl_users_id'::regclass) NOT NULL,
    ix_ntlogin_owner_id bigint,
    ix_ntlogin_user_id bigint,
    ix_ntlogin_acuser_id bigint
);


ALTER TABLE tbl_users OWNER TO postgres;

--
-- Name: build-summary2; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "build-summary2" AS
 WITH aa AS (
         SELECT x.id,
            x.comment
           FROM ( VALUES ('9A'::text,'all builds since 6/3/2014'::text), ('9B'::text,'prev:last %ge change in builds'::text), ('9C'::text,'all CEC builds since 6/3/2014'::text), ('9D'::text,'all non-CEC builds since 6/3/2014'::text), ('9E'::text,'builds during last week'::text), ('9F'::text,'CEC builds during last week'::text), ('9G'::text,'non-CEC builds during last week'::text), ('9H'::text,'builds during previous week'::text), ('9I'::text,'CEC builds during previous week'::text), ('9J'::text,'non-CEC builds during previous week'::text), ('9K'::text,'full builds during last week'::text), ('9L'::text,'full builds during previous week'::text), ('9M'::text,'failed builds during last week'::text), ('9N'::text,'failed builds during previous week'::text), ('9O'::text,'all "bld_alls" invocations since 6/3/2014'::text), ('9P'::text,'bld_all invocations during last week'::text), ('9Q'::text,'bld_all invocationsduring previous week'::text), ('9R'::text,'prev:last %ge change in build_all'::text), ('9S'::text,'total number of users since 6/3/2014'::text), ('9T'::text,'users running builds last week'::text), ('9U'::text,'build_all invoked as root last week'::text), ('9V'::text,'users running builds as root last week'::text)) x(id, comment)
        ), weeks AS (
         SELECT weeks.id,
            weeks.name,
            weeks.week
           FROM ( VALUES (1,'lastweek'::text,public.endofweek((CURRENT_DATE - '7 days'::interval))), (2,'previousweek'::text,public.endofweek((CURRENT_DATE - '14 days'::interval)))) weeks(id, name, week)
        ), base AS (
         SELECT s0.name AS "user",
            s1.name AS acuser,
            u.week,
            t.name AS build_class
           FROM (((((((tbl_results z
             LEFT JOIN tbl_faults w ON ((w.tbl_results_id = z.id)))
             LEFT JOIN tbl_ibidinfo v USING (ix_ibid_id))
             LEFT JOIN tbl_timeslots u ON ((u.tbl_results_id = z.id)))
             LEFT JOIN usr_build_class t ON ((t.id = z.usr_build_class_id)))
             LEFT JOIN tbl_users s ON ((s.id = z.tbl_users_id)))
             LEFT JOIN ix_ntlogin s0 ON ((s0.id = s.ix_ntlogin_user_id)))
             LEFT JOIN ix_ntlogin s1 ON ((s1.id = s.ix_ntlogin_acuser_id)))
        ), blastwk AS (
         SELECT base."user",
            base.acuser,
            base.week,
            base.build_class
           FROM base
          WHERE ((base.week)::date = public.endofweek((CURRENT_DATE - '7 days'::interval)))
        ), bprevwk AS (
         SELECT base."user",
            base.acuser,
            base.week,
            base.build_class
           FROM base
          WHERE ((base.week)::date = public.endofweek((CURRENT_DATE - '14 days'::interval)))
        ), ibase AS (
         SELECT u.week,
            t.name AS build_class,
            s0.name AS "user",
            s1.name AS acuser,
            x.component_count AS comp_count,
            date_part('epoch'::text, x.build_duration) AS build_duration,
            r1.name AS fault_category,
            v.name AS cloud
           FROM (((((((((((tbl_ibidinfo x
             LEFT JOIN tbl_results z USING (ix_ibid_id))
             LEFT JOIN tbl_faults w ON ((w.tbl_results_id = z.id)))
             LEFT JOIN ix_cloud v ON ((v.id = x.ix_cloud_id)))
             LEFT JOIN tbl_timeslots u ON ((u.tbl_results_id = z.id)))
             LEFT JOIN usr_build_class t ON ((t.id = z.usr_build_class_id)))
             LEFT JOIN tbl_users s ON ((s.id = z.tbl_users_id)))
             LEFT JOIN ix_ntlogin s0 ON ((s0.id = s.ix_ntlogin_user_id)))
             LEFT JOIN ix_ntlogin s1 ON ((s1.id = s.ix_ntlogin_acuser_id)))
             LEFT JOIN tbl_faults r ON ((r.tbl_results_id = z.id)))
             LEFT JOIN usr_fault_class r0 ON ((r0.id = r.usr_fault_class_id)))
             LEFT JOIN usr_fault_category r1 ON ((r1.id = r0.usr_fault_category_id)))
          WHERE (NOT ((x.prep_phase_count >= 0) AND (x.bld_phase_count = 0) AND (x.pkg_phase_count = 0)))
        ), ilastwk AS (
         SELECT ibase.week,
            ibase.build_class,
            ibase."user",
            ibase.acuser,
            ibase.comp_count,
            ibase.build_duration,
            ibase.fault_category,
            ibase.cloud
           FROM ibase
          WHERE (date(ibase.week) IN ( SELECT weeks.week
                   FROM weeks
                  WHERE (weeks.id = 1)))
        ), iprevwk AS (
         SELECT ibase.week,
            ibase.build_class,
            ibase."user",
            ibase.acuser,
            ibase.comp_count,
            ibase.build_duration,
            ibase.fault_category,
            ibase.cloud
           FROM ibase
          WHERE (date(ibase.week) IN ( SELECT weeks.week
                   FROM weeks
                  WHERE (weeks.id = 2)))
        ), b00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM blastwk
        ), b01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Developer'::text)
        ), b02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Jenkins'::text)
        ), b03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Rel Eng'::text)
        ), c00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM bprevwk
        ), c01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Developer'::text)
        ), c02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Jenkins'::text)
        ), c03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Rel Eng'::text)
        ), g00 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
        ), g11 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Developer'::text)
        ), g22 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Jenkins'::text)
        ), g33 AS (
         SELECT DISTINCT ibase.acuser
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Rel Eng'::text)
        ), h00 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
        ), h11 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Developer'::text)
        ), h22 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Jenkins'::text)
        ), h33 AS (
         SELECT DISTINCT ilastwk.acuser
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Rel Eng'::text)
        ), i00 AS (
         SELECT ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.fault_category,
            ilastwk.cloud
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL))
        ), i11 AS (
         SELECT ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.fault_category,
            ilastwk.cloud
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL) AND ((ilastwk.build_class)::text = 'Developer'::text))
        ), i22 AS (
         SELECT ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.fault_category,
            ilastwk.cloud
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL) AND ((ilastwk.build_class)::text = 'Jenkins'::text))
        ), i33 AS (
         SELECT ilastwk.week,
            ilastwk.build_class,
            ilastwk."user",
            ilastwk.acuser,
            ilastwk.comp_count,
            ilastwk.build_duration,
            ilastwk.fault_category,
            ilastwk.cloud
           FROM ilastwk
          WHERE (((ilastwk."user")::text = 'root'::text) AND ((ilastwk.acuser)::text <> '(not logged in)'::text) AND (ilastwk.acuser IS NOT NULL) AND ((ilastwk.build_class)::text = 'Rel Eng'::text))
        ), j00 AS (
         SELECT DISTINCT i00.acuser
           FROM i00
        ), j11 AS (
         SELECT DISTINCT i11.acuser
           FROM i11
        ), j22 AS (
         SELECT DISTINCT i22.acuser
           FROM i22
        ), j33 AS (
         SELECT DISTINCT i33.acuser
           FROM i33
        ), k00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ibase
        ), k01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Developer'::text)
        ), k02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Jenkins'::text)
        ), k03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ibase
          WHERE ((ibase.build_class)::text = 'Rel Eng'::text)
        ), l00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ibase
          WHERE ((ibase.cloud)::text ~* 'CEC'::text)
        ), l01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Developer'::text) AND ((ibase.cloud)::text ~* 'CEC'::text))
        ), l02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Jenkins'::text) AND ((ibase.cloud)::text ~* 'CEC'::text))
        ), l03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Rel Eng'::text) AND ((ibase.cloud)::text ~* 'CEC'::text))
        ), m00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ibase
          WHERE (((ibase.cloud)::text !~* 'CEC'::text) OR (ibase.cloud IS NULL))
        ), m01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Developer'::text) AND (((ibase.cloud)::text !~* 'CEC'::text) OR (ibase.cloud IS NULL)))
        ), m02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Jenkins'::text) AND (((ibase.cloud)::text !~* 'CEC'::text) OR (ibase.cloud IS NULL)))
        ), m03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ibase
          WHERE (((ibase.build_class)::text = 'Rel Eng'::text) AND (((ibase.cloud)::text !~* 'CEC'::text) OR (ibase.cloud IS NULL)))
        ), n00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ilastwk
        ), n01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Developer'::text)
        ), n02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Jenkins'::text)
        ), n03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ilastwk
          WHERE ((ilastwk.build_class)::text = 'Rel Eng'::text)
        ), o00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ilastwk
          WHERE ((ilastwk.cloud)::text ~* 'CEC'::text)
        ), o01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Developer'::text) AND ((ilastwk.cloud)::text ~* 'CEC'::text))
        ), o02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Jenkins'::text) AND ((ilastwk.cloud)::text ~* 'CEC'::text))
        ), o03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Rel Eng'::text) AND ((ilastwk.cloud)::text ~* 'CEC'::text))
        ), p00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM ilastwk
          WHERE (((ilastwk.cloud)::text !~* 'CEC'::text) OR (ilastwk.cloud IS NULL))
        ), p01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Developer'::text) AND (((ilastwk.cloud)::text !~* 'CEC'::text) OR (ilastwk.cloud IS NULL)))
        ), p02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Jenkins'::text) AND (((ilastwk.cloud)::text !~* 'CEC'::text) OR (ilastwk.cloud IS NULL)))
        ), p03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM ilastwk
          WHERE (((ilastwk.build_class)::text = 'Rel Eng'::text) AND (((ilastwk.cloud)::text !~* 'CEC'::text) OR (ilastwk.cloud IS NULL)))
        ), q00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM iprevwk
        ), q01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM iprevwk
          WHERE ((iprevwk.build_class)::text = 'Developer'::text)
        ), q02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM iprevwk
          WHERE ((iprevwk.build_class)::text = 'Jenkins'::text)
        ), q03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM iprevwk
          WHERE ((iprevwk.build_class)::text = 'Rel Eng'::text)
        ), r00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM iprevwk
          WHERE ((iprevwk.cloud)::text ~* 'CEC'::text)
        ), r01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Developer'::text) AND ((iprevwk.cloud)::text ~* 'CEC'::text))
        ), r02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Jenkins'::text) AND ((iprevwk.cloud)::text ~* 'CEC'::text))
        ), r03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Rel Eng'::text) AND ((iprevwk.cloud)::text ~* 'CEC'::text))
        ), s00 AS (
         SELECT count(*) AS cnt,
            0 AS id
           FROM iprevwk
          WHERE (((iprevwk.cloud)::text !~* 'CEC'::text) OR (iprevwk.cloud IS NULL))
        ), s01 AS (
         SELECT count(*) AS cnt,
            1 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Developer'::text) AND (((iprevwk.cloud)::text !~* 'CEC'::text) OR (iprevwk.cloud IS NULL)))
        ), s02 AS (
         SELECT count(*) AS cnt,
            2 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Jenkins'::text) AND (((iprevwk.cloud)::text !~* 'CEC'::text) OR (iprevwk.cloud IS NULL)))
        ), s03 AS (
         SELECT count(*) AS cnt,
            3 AS id
           FROM iprevwk
          WHERE (((iprevwk.build_class)::text = 'Rel Eng'::text) AND (((iprevwk.cloud)::text !~* 'CEC'::text) OR (iprevwk.cloud IS NULL)))
        ), a1 AS (
         SELECT k00.cnt AS "combined totals",
            '9A'::text AS id
           FROM k00
        ), a2 AS (
         SELECT k01.cnt AS "Developer totals",
            '9A'::text AS id
           FROM k01
        ), a3 AS (
         SELECT k02.cnt AS "Jenkins totals",
            '9A'::text AS id
           FROM k02
        ), a4 AS (
         SELECT k03.cnt AS "Rel Eng totals",
            '9A'::text AS id
           FROM k03
        ), a0 AS (
         SELECT a1.id,
            a1."combined totals",
            a2."Developer totals",
            a3."Jenkins totals",
            a4."Rel Eng totals"
           FROM (((a1
             LEFT JOIN a2 USING (id))
             LEFT JOIN a3 USING (id))
             LEFT JOIN a4 USING (id))
        ), d1 AS (
         SELECT
                CASE
                    WHEN (q00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n00.cnt)::numeric - (q00.cnt)::numeric) * '100'::numeric) / (q00.cnt)::numeric), 2)
                END AS "combined totals",
            '9B'::text AS id
           FROM (n00
             LEFT JOIN q00 USING (id))
        ), d2 AS (
         SELECT
                CASE
                    WHEN (q01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n01.cnt)::numeric - (q01.cnt)::numeric) * '100'::numeric) / (q01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9B'::text AS id
           FROM (n01
             LEFT JOIN q01 USING (id))
        ), d3 AS (
         SELECT
                CASE
                    WHEN (q02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n02.cnt)::numeric - (q02.cnt)::numeric) * '100'::numeric) / (q02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9B'::text AS id
           FROM (n02
             LEFT JOIN q02 USING (id))
        ), d4 AS (
         SELECT
                CASE
                    WHEN (q03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n03.cnt)::numeric - (q03.cnt)::numeric) * '100'::numeric) / (q03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9B'::text AS id
           FROM (n03
             LEFT JOIN q03 USING (id))
        ), d0 AS (
         SELECT d1.id,
            d1."combined totals",
            d2."Developer totals",
            d3."Jenkins totals",
            d4."Rel Eng totals"
           FROM (((d1
             LEFT JOIN d2 USING (id))
             LEFT JOIN d3 USING (id))
             LEFT JOIN d4 USING (id))
        ), q1 AS (
         SELECT
                CASE
                    WHEN (k00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k00.cnt)::numeric - (l00.cnt)::numeric) * '100'::numeric) / (k00.cnt)::numeric), 2)
                END AS "combined totals",
            '9C'::text AS id
           FROM (l00
             LEFT JOIN k00 USING (id))
        ), q2 AS (
         SELECT
                CASE
                    WHEN (k01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k01.cnt)::numeric - (l01.cnt)::numeric) * '100'::numeric) / (k01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9C'::text AS id
           FROM (l01
             LEFT JOIN k01 USING (id))
        ), q3 AS (
         SELECT
                CASE
                    WHEN (k02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k02.cnt)::numeric - (l02.cnt)::numeric) * '100'::numeric) / (k02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9C'::text AS id
           FROM (l02
             LEFT JOIN k02 USING (id))
        ), q4 AS (
         SELECT
                CASE
                    WHEN (k03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k03.cnt)::numeric - (l03.cnt)::numeric) * '100'::numeric) / (k03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9C'::text AS id
           FROM (l03
             LEFT JOIN k03 USING (id))
        ), q0 AS (
         SELECT q1.id,
            q1."combined totals",
            q2."Developer totals",
            q3."Jenkins totals",
            q4."Rel Eng totals"
           FROM (((q1
             LEFT JOIN q2 USING (id))
             LEFT JOIN q3 USING (id))
             LEFT JOIN q4 USING (id))
        ), t1 AS (
         SELECT
                CASE
                    WHEN (k00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k00.cnt)::numeric - (m00.cnt)::numeric) * '100'::numeric) / (k00.cnt)::numeric), 2)
                END AS "combined totals",
            '9D'::text AS id
           FROM (m00
             LEFT JOIN k00 USING (id))
        ), t2 AS (
         SELECT
                CASE
                    WHEN (k01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k01.cnt)::numeric - (m01.cnt)::numeric) * '100'::numeric) / (k01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9D'::text AS id
           FROM (m01
             LEFT JOIN k01 USING (id))
        ), t3 AS (
         SELECT
                CASE
                    WHEN (k02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k02.cnt)::numeric - (m02.cnt)::numeric) * '100'::numeric) / (k02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9D'::text AS id
           FROM (m02
             LEFT JOIN k02 USING (id))
        ), t4 AS (
         SELECT
                CASE
                    WHEN (k03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((k03.cnt)::numeric - (m03.cnt)::numeric) * '100'::numeric) / (k03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9D'::text AS id
           FROM (m03
             LEFT JOIN k03 USING (id))
        ), t0 AS (
         SELECT t1.id,
            t1."combined totals",
            t2."Developer totals",
            t3."Jenkins totals",
            t4."Rel Eng totals"
           FROM (((t1
             LEFT JOIN t2 USING (id))
             LEFT JOIN t3 USING (id))
             LEFT JOIN t4 USING (id))
        ), b1 AS (
         SELECT n00.cnt AS "combined totals",
            '9E'::text AS id
           FROM n00
        ), b2 AS (
         SELECT n01.cnt AS "Developer totals",
            '9E'::text AS id
           FROM n01
        ), b3 AS (
         SELECT n02.cnt AS "Jenkins totals",
            '9E'::text AS id
           FROM n02
        ), b4 AS (
         SELECT n03.cnt AS "Rel Eng totals",
            '9E'::text AS id
           FROM n03
        ), b0 AS (
         SELECT b1.id,
            b1."combined totals",
            b2."Developer totals",
            b3."Jenkins totals",
            b4."Rel Eng totals"
           FROM (((b1
             LEFT JOIN b2 USING (id))
             LEFT JOIN b3 USING (id))
             LEFT JOIN b4 USING (id))
        ), r1 AS (
         SELECT
                CASE
                    WHEN (n00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n00.cnt)::numeric - (o00.cnt)::numeric) * '100'::numeric) / (n00.cnt)::numeric), 2)
                END AS "combined totals",
            '9F'::text AS id
           FROM (o00
             LEFT JOIN n00 USING (id))
        ), r2 AS (
         SELECT
                CASE
                    WHEN (n01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n01.cnt)::numeric - (o01.cnt)::numeric) * '100'::numeric) / (n01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9F'::text AS id
           FROM (o01
             LEFT JOIN n01 USING (id))
        ), r3 AS (
         SELECT
                CASE
                    WHEN (n02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n02.cnt)::numeric - (o02.cnt)::numeric) * '100'::numeric) / (n02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9F'::text AS id
           FROM (o02
             LEFT JOIN n02 USING (id))
        ), r4 AS (
         SELECT
                CASE
                    WHEN (n03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n03.cnt)::numeric - (o03.cnt)::numeric) * '100'::numeric) / (n03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9F'::text AS id
           FROM (o03
             LEFT JOIN n03 USING (id))
        ), r0 AS (
         SELECT r1.id,
            r1."combined totals",
            r2."Developer totals",
            r3."Jenkins totals",
            r4."Rel Eng totals"
           FROM (((r1
             LEFT JOIN r2 USING (id))
             LEFT JOIN r3 USING (id))
             LEFT JOIN r4 USING (id))
        ), u1 AS (
         SELECT
                CASE
                    WHEN (n00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n00.cnt)::numeric - (p00.cnt)::numeric) * '100'::numeric) / (n00.cnt)::numeric), 2)
                END AS "combined totals",
            '9G'::text AS id
           FROM (p00
             LEFT JOIN n00 USING (id))
        ), u2 AS (
         SELECT
                CASE
                    WHEN (n01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n01.cnt)::numeric - (p01.cnt)::numeric) * '100'::numeric) / (n01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9G'::text AS id
           FROM (p01
             LEFT JOIN n01 USING (id))
        ), u3 AS (
         SELECT
                CASE
                    WHEN (n02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n02.cnt)::numeric - (p02.cnt)::numeric) * '100'::numeric) / (n02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9G'::text AS id
           FROM (p02
             LEFT JOIN n02 USING (id))
        ), u4 AS (
         SELECT
                CASE
                    WHEN (n03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((n03.cnt)::numeric - (p03.cnt)::numeric) * '100'::numeric) / (n03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9G'::text AS id
           FROM (p03
             LEFT JOIN n03 USING (id))
        ), u0 AS (
         SELECT u1.id,
            u1."combined totals",
            u2."Developer totals",
            u3."Jenkins totals",
            u4."Rel Eng totals"
           FROM (((u1
             LEFT JOIN u2 USING (id))
             LEFT JOIN u3 USING (id))
             LEFT JOIN u4 USING (id))
        ), c1 AS (
         SELECT q00.cnt AS "combined totals",
            '9H'::text AS id
           FROM q00
        ), c2 AS (
         SELECT q01.cnt AS "Developer totals",
            '9H'::text AS id
           FROM q01
        ), c3 AS (
         SELECT q02.cnt AS "Jenkins totals",
            '9H'::text AS id
           FROM q02
        ), c4 AS (
         SELECT q03.cnt AS "Rel Eng totals",
            '9H'::text AS id
           FROM q03
        ), c0 AS (
         SELECT c1.id,
            c1."combined totals",
            c2."Developer totals",
            c3."Jenkins totals",
            c4."Rel Eng totals"
           FROM (((c1
             LEFT JOIN c2 USING (id))
             LEFT JOIN c3 USING (id))
             LEFT JOIN c4 USING (id))
        ), s1 AS (
         SELECT
                CASE
                    WHEN (q00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q00.cnt)::numeric - (r00.cnt)::numeric) * '100'::numeric) / (q00.cnt)::numeric), 2)
                END AS "combined totals",
            '9I'::text AS id
           FROM (r00
             LEFT JOIN q00 USING (id))
        ), s2 AS (
         SELECT
                CASE
                    WHEN (q01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q01.cnt)::numeric - (r01.cnt)::numeric) * '100'::numeric) / (q01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9I'::text AS id
           FROM (r01
             LEFT JOIN q01 USING (id))
        ), s3 AS (
         SELECT
                CASE
                    WHEN (q02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q02.cnt)::numeric - (r02.cnt)::numeric) * '100'::numeric) / (q02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9I'::text AS id
           FROM (r02
             LEFT JOIN q02 USING (id))
        ), s4 AS (
         SELECT
                CASE
                    WHEN (q03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q03.cnt)::numeric - (r03.cnt)::numeric) * '100'::numeric) / (q03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9I'::text AS id
           FROM (r03
             LEFT JOIN q03 USING (id))
        ), s0 AS (
         SELECT s1.id,
            s1."combined totals",
            s2."Developer totals",
            s3."Jenkins totals",
            s4."Rel Eng totals"
           FROM (((s1
             LEFT JOIN s2 USING (id))
             LEFT JOIN s3 USING (id))
             LEFT JOIN s4 USING (id))
        ), v1 AS (
         SELECT
                CASE
                    WHEN (q00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q00.cnt)::numeric - (s00.cnt)::numeric) * '100'::numeric) / (q00.cnt)::numeric), 2)
                END AS "combined totals",
            '9J'::text AS id
           FROM (s00
             LEFT JOIN q00 USING (id))
        ), v2 AS (
         SELECT
                CASE
                    WHEN (q01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q01.cnt)::numeric - (s01.cnt)::numeric) * '100'::numeric) / (q01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9J'::text AS id
           FROM (s01
             LEFT JOIN q01 USING (id))
        ), v3 AS (
         SELECT
                CASE
                    WHEN (q02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q02.cnt)::numeric - (s02.cnt)::numeric) * '100'::numeric) / (q02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9J'::text AS id
           FROM (s02
             LEFT JOIN q02 USING (id))
        ), v4 AS (
         SELECT
                CASE
                    WHEN (q03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((q03.cnt)::numeric - (s03.cnt)::numeric) * '100'::numeric) / (q03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9J'::text AS id
           FROM (s03
             LEFT JOIN q03 USING (id))
        ), v0 AS (
         SELECT v1.id,
            v1."combined totals",
            v2."Developer totals",
            v3."Jenkins totals",
            v4."Rel Eng totals"
           FROM (((v1
             LEFT JOIN v2 USING (id))
             LEFT JOIN v3 USING (id))
             LEFT JOIN v4 USING (id))
        ), e1 AS (
         SELECT count(*) AS "combined totals",
            '9K'::text AS id
           FROM ilastwk
          WHERE ((ilastwk.build_duration > (7200)::double precision) AND (ilastwk.comp_count > 40))
        ), e2 AS (
         SELECT count(*) AS "Developer totals",
            '9K'::text AS id
           FROM ilastwk
          WHERE ((ilastwk.build_duration > (7200)::double precision) AND (ilastwk.comp_count > 40) AND ((ilastwk.build_class)::text = 'Developer'::text))
        ), e3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9K'::text AS id
           FROM ilastwk
          WHERE ((ilastwk.build_duration > (7200)::double precision) AND (ilastwk.comp_count > 40) AND ((ilastwk.build_class)::text = 'Jenkins'::text))
        ), e4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9K'::text AS id
           FROM ilastwk
          WHERE ((ilastwk.build_duration > (7200)::double precision) AND (ilastwk.comp_count > 40) AND ((ilastwk.build_class)::text = 'Rel Eng'::text))
        ), e0 AS (
         SELECT e1.id,
            e1."combined totals",
            e2."Developer totals",
            e3."Jenkins totals",
            e4."Rel Eng totals"
           FROM (((e1
             LEFT JOIN e2 USING (id))
             LEFT JOIN e3 USING (id))
             LEFT JOIN e4 USING (id))
        ), f1 AS (
         SELECT count(*) AS "combined totals",
            '9L'::text AS id
           FROM iprevwk
          WHERE ((iprevwk.build_duration > (7200)::double precision) AND (iprevwk.comp_count > 40))
        ), f2 AS (
         SELECT count(*) AS "Developer totals",
            '9L'::text AS id
           FROM iprevwk
          WHERE ((iprevwk.build_duration > (7200)::double precision) AND (iprevwk.comp_count > 40) AND ((iprevwk.build_class)::text = 'Developer'::text))
        ), f3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9L'::text AS id
           FROM iprevwk
          WHERE ((iprevwk.build_duration > (7200)::double precision) AND (iprevwk.comp_count > 40) AND ((iprevwk.build_class)::text = 'Jenkins'::text))
        ), f4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9L'::text AS id
           FROM iprevwk
          WHERE ((iprevwk.build_duration > (7200)::double precision) AND (iprevwk.comp_count > 40) AND ((iprevwk.build_class)::text = 'Rel Eng'::text))
        ), f0 AS (
         SELECT f1.id,
            f1."combined totals",
            f2."Developer totals",
            f3."Jenkins totals",
            f4."Rel Eng totals"
           FROM (((f1
             LEFT JOIN f2 USING (id))
             LEFT JOIN f3 USING (id))
             LEFT JOIN f4 USING (id))
        ), g1 AS (
         SELECT count(*) AS "combined totals",
            '9M'::text AS id
           FROM ilastwk
          WHERE ((ilastwk.fault_category)::text !~* '((Pass)|(Developer Error))'::text)
        ), g2 AS (
         SELECT count(*) AS "Developer totals",
            '9M'::text AS id
           FROM ilastwk
          WHERE (((ilastwk.fault_category)::text !~* '((Pass)|(Developer Error))'::text) AND ((ilastwk.build_class)::text = 'Developer'::text))
        ), g3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9M'::text AS id
           FROM ilastwk
          WHERE (((ilastwk.fault_category)::text !~* 'Pass'::text) AND ((ilastwk.build_class)::text = 'Jenkins'::text))
        ), g4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9M'::text AS id
           FROM ilastwk
          WHERE (((ilastwk.fault_category)::text !~* 'Pass'::text) AND ((ilastwk.build_class)::text = 'Rel Eng'::text))
        ), g0 AS (
         SELECT g1.id,
            g1."combined totals",
            g2."Developer totals",
            g3."Jenkins totals",
            g4."Rel Eng totals"
           FROM (((g1
             LEFT JOIN g2 USING (id))
             LEFT JOIN g3 USING (id))
             LEFT JOIN g4 USING (id))
        ), h1 AS (
         SELECT count(*) AS "combined totals",
            '9N'::text AS id
           FROM iprevwk
          WHERE ((iprevwk.fault_category)::text !~* '((Pass)|(Developer Error))'::text)
        ), h2 AS (
         SELECT count(*) AS "Developer totals",
            '9N'::text AS id
           FROM iprevwk
          WHERE (((iprevwk.fault_category)::text !~* '((Pass)|(Developer Error))'::text) AND ((iprevwk.build_class)::text = 'Developer'::text))
        ), h3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9N'::text AS id
           FROM iprevwk
          WHERE (((iprevwk.fault_category)::text !~* 'Pass'::text) AND ((iprevwk.build_class)::text = 'Jenkins'::text))
        ), h4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9N'::text AS id
           FROM iprevwk
          WHERE (((iprevwk.fault_category)::text !~* 'Pass'::text) AND ((iprevwk.build_class)::text = 'Rel Eng'::text))
        ), h0 AS (
         SELECT h1.id,
            h1."combined totals",
            h2."Developer totals",
            h3."Jenkins totals",
            h4."Rel Eng totals"
           FROM (((h1
             LEFT JOIN h2 USING (id))
             LEFT JOIN h3 USING (id))
             LEFT JOIN h4 USING (id))
        ), i1 AS (
         SELECT count(*) AS "combined totals",
            '9O'::text AS id
           FROM base
        ), i2 AS (
         SELECT count(*) AS "Developer totals",
            '9O'::text AS id
           FROM base
          WHERE ((base.build_class)::text = 'Developer'::text)
        ), i3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9O'::text AS id
           FROM base
          WHERE ((base.build_class)::text = 'Jenkins'::text)
        ), i4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9O'::text AS id
           FROM base
          WHERE ((base.build_class)::text = 'Rel Eng'::text)
        ), i0 AS (
         SELECT i1.id,
            i1."combined totals",
            i2."Developer totals",
            i3."Jenkins totals",
            i4."Rel Eng totals"
           FROM (((i1
             LEFT JOIN i2 USING (id))
             LEFT JOIN i3 USING (id))
             LEFT JOIN i4 USING (id))
        ), j1 AS (
         SELECT count(*) AS "combined totals",
            '9P'::text AS id
           FROM blastwk
        ), j2 AS (
         SELECT count(*) AS "Developer totals",
            '9P'::text AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Developer'::text)
        ), j3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9P'::text AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Jenkins'::text)
        ), j4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9P'::text AS id
           FROM blastwk
          WHERE ((blastwk.build_class)::text = 'Rel Eng'::text)
        ), j0 AS (
         SELECT j1.id,
            j1."combined totals",
            j2."Developer totals",
            j3."Jenkins totals",
            j4."Rel Eng totals"
           FROM (((j1
             LEFT JOIN j2 USING (id))
             LEFT JOIN j3 USING (id))
             LEFT JOIN j4 USING (id))
        ), k1 AS (
         SELECT count(*) AS "combined totals",
            '9Q'::text AS id
           FROM bprevwk
        ), k2 AS (
         SELECT count(*) AS "Developer totals",
            '9Q'::text AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Developer'::text)
        ), k3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9Q'::text AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Jenkins'::text)
        ), k4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9Q'::text AS id
           FROM bprevwk
          WHERE ((bprevwk.build_class)::text = 'Rel Eng'::text)
        ), k0 AS (
         SELECT k1.id,
            k1."combined totals",
            k2."Developer totals",
            k3."Jenkins totals",
            k4."Rel Eng totals"
           FROM (((k1
             LEFT JOIN k2 USING (id))
             LEFT JOIN k3 USING (id))
             LEFT JOIN k4 USING (id))
        ), l1 AS (
         SELECT
                CASE
                    WHEN (c00.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b00.cnt)::numeric - (c00.cnt)::numeric) * '100'::numeric) / (c00.cnt)::numeric), 2)
                END AS "combined totals",
            '9R'::text AS id
           FROM (b00
             LEFT JOIN c00 USING (id))
        ), l2 AS (
         SELECT
                CASE
                    WHEN (c01.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b01.cnt)::numeric - (c01.cnt)::numeric) * '100'::numeric) / (c01.cnt)::numeric), 2)
                END AS "Developer totals",
            '9R'::text AS id
           FROM (b01
             LEFT JOIN c01 USING (id))
        ), l3 AS (
         SELECT
                CASE
                    WHEN (c02.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b02.cnt)::numeric - (c02.cnt)::numeric) * '100'::numeric) / (c02.cnt)::numeric), 2)
                END AS "Jenkins totals",
            '9R'::text AS id
           FROM (b02
             LEFT JOIN c02 USING (id))
        ), l4 AS (
         SELECT
                CASE
                    WHEN (c03.cnt = 0) THEN (0)::numeric
                    ELSE round(((((b03.cnt)::numeric - (c03.cnt)::numeric) * '100'::numeric) / (c03.cnt)::numeric), 2)
                END AS "Rel Eng totals",
            '9R'::text AS id
           FROM (b03
             LEFT JOIN c03 USING (id))
        ), l0 AS (
         SELECT l1.id,
            l1."combined totals",
            l2."Developer totals",
            l3."Jenkins totals",
            l4."Rel Eng totals"
           FROM (((l1
             LEFT JOIN l2 USING (id))
             LEFT JOIN l3 USING (id))
             LEFT JOIN l4 USING (id))
        ), m1 AS (
         SELECT count(g00.acuser) AS "combined totals",
            '9S'::text AS id
           FROM g00
        ), m2 AS (
         SELECT count(g11.acuser) AS "Developer totals",
            '9S'::text AS id
           FROM g11
        ), m3 AS (
         SELECT count(g22.acuser) AS "Jenkins totals",
            '9S'::text AS id
           FROM g22
        ), m4 AS (
         SELECT count(g33.acuser) AS "Rel Eng totals",
            '9S'::text AS id
           FROM g33
        ), m0 AS (
         SELECT m1.id,
            m1."combined totals",
            m2."Developer totals",
            m3."Jenkins totals",
            m4."Rel Eng totals"
           FROM (((m1
             LEFT JOIN m2 USING (id))
             LEFT JOIN m3 USING (id))
             LEFT JOIN m4 USING (id))
        ), n1 AS (
         SELECT count(h00.acuser) AS "combined totals",
            '9T'::text AS id
           FROM h00
        ), n2 AS (
         SELECT count(h11.acuser) AS "Developer totals",
            '9T'::text AS id
           FROM h11
        ), n3 AS (
         SELECT count(h22.acuser) AS "Jenkins totals",
            '9T'::text AS id
           FROM h22
        ), n4 AS (
         SELECT count(h33.acuser) AS "Rel Eng totals",
            '9T'::text AS id
           FROM h33
        ), n0 AS (
         SELECT n1.id,
            n1."combined totals",
            n2."Developer totals",
            n3."Jenkins totals",
            n4."Rel Eng totals"
           FROM (((n1
             LEFT JOIN n2 USING (id))
             LEFT JOIN n3 USING (id))
             LEFT JOIN n4 USING (id))
        ), o1 AS (
         SELECT count(*) AS "combined totals",
            '9U'::text AS id
           FROM i00
        ), o2 AS (
         SELECT count(*) AS "Developer totals",
            '9U'::text AS id
           FROM i00
          WHERE ((i00.build_class)::text = 'Developer'::text)
        ), o3 AS (
         SELECT count(*) AS "Jenkins totals",
            '9U'::text AS id
           FROM i00
          WHERE ((i00.build_class)::text = 'Jenkins'::text)
        ), o4 AS (
         SELECT count(*) AS "Rel Eng totals",
            '9U'::text AS id
           FROM i00
          WHERE ((i00.build_class)::text = 'Rel Eng'::text)
        ), o0 AS (
         SELECT o1.id,
            o1."combined totals",
            o2."Developer totals",
            o3."Jenkins totals",
            o4."Rel Eng totals"
           FROM (((o1
             LEFT JOIN o2 USING (id))
             LEFT JOIN o3 USING (id))
             LEFT JOIN o4 USING (id))
        ), p1 AS (
         SELECT count(j00.acuser) AS "combined totals",
            '9V'::text AS id
           FROM j00
        ), p2 AS (
         SELECT count(j11.acuser) AS "Developer totals",
            '9V'::text AS id
           FROM j11
        ), p3 AS (
         SELECT count(j22.acuser) AS "Jenkins totals",
            '9V'::text AS id
           FROM j22
        ), p4 AS (
         SELECT count(j33.acuser) AS "Rel Eng totals",
            '9V'::text AS id
           FROM j33
        ), p0 AS (
         SELECT p1.id,
            p1."combined totals",
            p2."Developer totals",
            p3."Jenkins totals",
            p4."Rel Eng totals"
           FROM (((p1
             LEFT JOIN p2 USING (id))
             LEFT JOIN p3 USING (id))
             LEFT JOIN p4 USING (id))
        ), zz AS (
         SELECT a0.id,
            a0."combined totals",
            a0."Developer totals",
            a0."Jenkins totals",
            a0."Rel Eng totals"
           FROM a0
        UNION
         SELECT b0.id,
            b0."combined totals",
            b0."Developer totals",
            b0."Jenkins totals",
            b0."Rel Eng totals"
           FROM b0
        UNION
         SELECT c0.id,
            c0."combined totals",
            c0."Developer totals",
            c0."Jenkins totals",
            c0."Rel Eng totals"
           FROM c0
        UNION
         SELECT d0.id,
            d0."combined totals",
            d0."Developer totals",
            d0."Jenkins totals",
            d0."Rel Eng totals"
           FROM d0
        UNION
         SELECT e0.id,
            e0."combined totals",
            e0."Developer totals",
            e0."Jenkins totals",
            e0."Rel Eng totals"
           FROM e0
        UNION
         SELECT f0.id,
            f0."combined totals",
            f0."Developer totals",
            f0."Jenkins totals",
            f0."Rel Eng totals"
           FROM f0
        UNION
         SELECT g0.id,
            g0."combined totals",
            g0."Developer totals",
            g0."Jenkins totals",
            g0."Rel Eng totals"
           FROM g0
        UNION
         SELECT h0.id,
            h0."combined totals",
            h0."Developer totals",
            h0."Jenkins totals",
            h0."Rel Eng totals"
           FROM h0
        UNION
         SELECT i0.id,
            i0."combined totals",
            i0."Developer totals",
            i0."Jenkins totals",
            i0."Rel Eng totals"
           FROM i0
        UNION
         SELECT j0.id,
            j0."combined totals",
            j0."Developer totals",
            j0."Jenkins totals",
            j0."Rel Eng totals"
           FROM j0
        UNION
         SELECT k0.id,
            k0."combined totals",
            k0."Developer totals",
            k0."Jenkins totals",
            k0."Rel Eng totals"
           FROM k0
        UNION
         SELECT l0.id,
            l0."combined totals",
            l0."Developer totals",
            l0."Jenkins totals",
            l0."Rel Eng totals"
           FROM l0
        UNION
         SELECT m0.id,
            m0."combined totals",
            m0."Developer totals",
            m0."Jenkins totals",
            m0."Rel Eng totals"
           FROM m0
        UNION
         SELECT n0.id,
            n0."combined totals",
            n0."Developer totals",
            n0."Jenkins totals",
            n0."Rel Eng totals"
           FROM n0
        UNION
         SELECT o0.id,
            o0."combined totals",
            o0."Developer totals",
            o0."Jenkins totals",
            o0."Rel Eng totals"
           FROM o0
        UNION
         SELECT p0.id,
            p0."combined totals",
            p0."Developer totals",
            p0."Jenkins totals",
            p0."Rel Eng totals"
           FROM p0
        UNION
         SELECT q0.id,
            q0."combined totals",
            q0."Developer totals",
            q0."Jenkins totals",
            q0."Rel Eng totals"
           FROM q0
        UNION
         SELECT r0.id,
            r0."combined totals",
            r0."Developer totals",
            r0."Jenkins totals",
            r0."Rel Eng totals"
           FROM r0
        UNION
         SELECT s0.id,
            s0."combined totals",
            s0."Developer totals",
            s0."Jenkins totals",
            s0."Rel Eng totals"
           FROM s0
        UNION
         SELECT t0.id,
            t0."combined totals",
            t0."Developer totals",
            t0."Jenkins totals",
            t0."Rel Eng totals"
           FROM t0
        UNION
         SELECT u0.id,
            u0."combined totals",
            u0."Developer totals",
            u0."Jenkins totals",
            u0."Rel Eng totals"
           FROM u0
        UNION
         SELECT v0.id,
            v0."combined totals",
            v0."Developer totals",
            v0."Jenkins totals",
            v0."Rel Eng totals"
           FROM v0
        ), data AS (
         SELECT zz.id,
            aa.comment,
            zz."combined totals",
            zz."Developer totals",
            zz."Jenkins totals",
            zz."Rel Eng totals"
           FROM (zz
             LEFT JOIN aa USING (id))
          ORDER BY zz.id
        )
 SELECT data.id,
    data.comment,
    data."combined totals",
    data."Developer totals",
    data."Jenkins totals",
    data."Rel Eng totals"
   FROM data;


ALTER TABLE "build-summary2" OWNER TO postgres;

--
-- Name: LiveWire-summary; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "LiveWire-summary" AS
 WITH weeks AS (
         SELECT weeks.id,
            weeks.name,
            weeks.week
           FROM ( VALUES (1,'lastweek'::text,public.endofweek((CURRENT_DATE - '7 days'::interval))), (2,'previousweek'::text,public.endofweek((CURRENT_DATE - '14 days'::interval)))) weeks(id, name, week)
        ), a AS (
         SELECT "build-summary2".id,
            "build-summary2".comment,
            "build-summary2"."combined totals",
            "build-summary2"."Developer totals",
            "build-summary2"."Jenkins totals",
            "build-summary2"."Rel Eng totals"
           FROM "build-summary2"
        ), b AS (
         SELECT
                CASE
                    WHEN (( SELECT (a."combined totals")::integer AS "combined totals"
                       FROM a
                      WHERE (a.id = '9B'::text)) > 0) THEN 'up '::text
                    ELSE 'down '::text
                END AS ibid_direction,
                CASE
                    WHEN (( SELECT (a."combined totals")::integer AS "combined totals"
                       FROM a
                      WHERE (a.id = '9E'::text)) > ( SELECT (a."combined totals")::integer AS "combined totals"
                       FROM a
                      WHERE (a.id = '9F'::text))) THEN 'up '::text
                    ELSE 'down '::text
                END AS full_direction,
                CASE
                    WHEN (( SELECT (a."combined totals")::integer AS "combined totals"
                       FROM a
                      WHERE (a.id = '9R'::text)) > 0) THEN 'up '::text
                    ELSE 'down '::text
                END AS ball_direction
        ), l1 AS (
         SELECT 1 AS linenum,
            (((('**Various build metrics and charts for the week: '::text || public.startofweek((weeks.week)::timestamp with time zone)) || ' - '::text) || weeks.week) || '**'::text) AS line
           FROM weeks
          WHERE (weeks.id = 1)
        ), l2 AS (
         SELECT 2 AS linenum,
            ((((('  -  '::text || ( SELECT a."combined totals"
                   FROM a
                  WHERE (a.id = '9E'::text))) || ' builds were recorded, which is '::text) || ( SELECT b.ibid_direction
                   FROM b)) || abs(( SELECT a."combined totals"
                   FROM a
                  WHERE (a.id = '9B'::text)))) || '% previous week'::text) AS line
        ), l3 AS (
         SELECT 3 AS linenum,
            (((('  -  '::text || ( SELECT a."combined totals"
                   FROM a
                  WHERE (a.id = '9K'::text))) || ' FULL builds were recorded, which is '::text) || ( SELECT b.full_direction
                   FROM b)) || 'from previous week'::text) AS line
        ), l4 AS (
         SELECT 4 AS linenum,
            (((('  -  '::text || ( SELECT a."combined totals"
                   FROM a
                  WHERE (a.id = '9P'::text))) || ' invocations of build_all were recorded, which is '::text) || ( SELECT b.ball_direction
                   FROM b)) || 'from previous week'::text) AS line
        ), l5 AS (
         SELECT 5 AS linenum,
            (((('  -  There were '::text || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9E'::text))) || ' developer builds, performed by '::text) || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9T'::text))) || ' unique users'::text) AS line
        ), l6 AS (
         SELECT 6 AS linenum,
            (((('  -  There were '::text || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9U'::text))) || ' developer builds as "root", performed by '::text) || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9V'::text))) || ' unique users'::text) AS line
        ), l7 AS (
         SELECT 7 AS linenum,
            (((('  -  Since 2014-03-06, there have been '::text || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9A'::text))) || ' developer builds, performed by '::text) || ( SELECT a."Developer totals"
                   FROM a
                  WHERE (a.id = '9S'::text))) || ' unique users'::text) AS line
        ), lines AS (
         SELECT l1.linenum,
            l1.line
           FROM l1
        UNION
         SELECT l2.linenum,
            l2.line
           FROM l2
        UNION
         SELECT l3.linenum,
            l3.line
           FROM l3
        UNION
         SELECT l4.linenum,
            l4.line
           FROM l4
        UNION
         SELECT l5.linenum,
            l5.line
           FROM l5
        UNION
         SELECT l6.linenum,
            l6.line
           FROM l6
        UNION
         SELECT l7.linenum,
            l7.line
           FROM l7
        )
 SELECT lines.line
   FROM lines
  ORDER BY lines.linenum;


ALTER TABLE "LiveWire-summary" OWNER TO postgres;

--
-- Name: ix_host_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_host_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_host_id OWNER TO postgres;

--
-- Name: ix_host; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_host (
    id bigint DEFAULT nextval('ix_host_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_host OWNER TO postgres;

--
-- Name: tbl_hosts_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE tbl_hosts_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tbl_hosts_id OWNER TO postgres;

--
-- Name: tbl_hosts; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_hosts (
    id bigint DEFAULT nextval('tbl_hosts_id'::regclass) NOT NULL,
    ix_ipaddress_ids bigint[],
    usr_host_class_id bigint,
    ix_host_id bigint,
    ix_hostname_id bigint
);


ALTER TABLE tbl_hosts OWNER TO postgres;

--
-- Name: PIE_builds; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "PIE_builds" AS
 WITH a AS (
         SELECT ix_host.id,
            ix_host.name
           FROM ix_host
          WHERE ((ix_host.name)::text ~* '^ci-sles12-slave-137*$'::text)
        ), b AS (
         SELECT z.id,
            z.ix_ipaddress_ids,
            z.usr_host_class_id,
            z.ix_host_id,
            z.ix_hostname_id
           FROM tbl_hosts z
          WHERE (z.ix_host_id IN ( SELECT a.id
                   FROM a))
        ), c AS (
         SELECT z.id,
            z.tm,
            z.build_duration,
            z.prep_phase_duration,
            z.bld_phase_duration,
            z.pkg_phase_duration,
            z.prep_phase_count,
            z.bld_phase_count,
            z.pkg_phase_count,
            z.components_mask,
            z.components_count,
            z.arg_count,
            z.usr_build_class_id,
            z.ix_ibid_id,
            z.tbl_users_id,
            z.usr_match_owner_to_log_id,
            z.tbl_hosts_id,
            z.ix_environment_native_id,
            z.ix_environment_run_id,
            z.ix_env_type_id,
            z.ix_stream_id,
            z.ix_streambasis_id,
            z.ix_init_val_id
           FROM tbl_results z
          WHERE (z.tbl_hosts_id IN ( SELECT b.id
                   FROM b))
        ), d AS (
         SELECT z.ix_ibid_id,
            z.tbl_results_start_id,
            z.tbl_results_end_id,
            z.tm_bld_start,
            z.tm_bld_end,
            z.build_count,
            z.component_count,
            z.prep_phase_count,
            z.bld_phase_count,
            z.pkg_phase_count,
            z.components_mask,
            z.build_duration,
            z.prep_phase_duration,
            z.bld_phase_duration,
            z.pkg_phase_duration
           FROM tbl_ibidinfo z
          WHERE (z.ix_ibid_id IN ( SELECT DISTINCT c.ix_ibid_id
                   FROM c))
        )
 SELECT d.ix_ibid_id,
    d.tbl_results_start_id,
    d.tbl_results_end_id,
    d.tm_bld_start,
    d.tm_bld_end,
    d.build_count,
    d.component_count,
    d.prep_phase_count,
    d.bld_phase_count,
    d.pkg_phase_count,
    d.components_mask,
    d.build_duration,
    d.prep_phase_duration,
    d.bld_phase_duration,
    d.pkg_phase_duration
   FROM d
  WHERE "overlaps"(d.tm_bld_start, d.tm_bld_end, '2016-09-16 14:04:51'::timestamp without time zone, '2016-09-18 18:04:12'::timestamp without time zone);


ALTER TABLE "PIE_builds" OWNER TO postgres;

--
-- Name: Reliability; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Reliability" AS
 WITH ibid AS (
         SELECT v.name AS build_class,
                CASE
                    WHEN (strpos((x2.name)::text, ','::text) > 0) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE x2.name
                END AS fault_category,
            (w.week)::date AS week
           FROM ((((((tbl_ibidinfo z
             LEFT JOIN tbl_results y ON ((y.id = z.tbl_results_start_id)))
             LEFT JOIN tbl_faults x ON ((x.tbl_results_id = y.id)))
             LEFT JOIN usr_fault_class x1 ON ((x1.id = x.usr_fault_class_id)))
             LEFT JOIN usr_fault_category x2 ON ((x2.id = x1.usr_fault_category_id)))
             LEFT JOIN tbl_timeslots w ON ((w.tbl_results_id = y.id)))
             LEFT JOIN usr_build_class v ON ((v.id = y.usr_build_class_id)))
          WHERE ((w.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone))
        ), a AS (
         SELECT ibid.week,
            ibid.fault_category,
            ibid.build_class
           FROM ibid
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
          ORDER BY a.week DESC
        ), b AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Developer'::text)
        ), bb AS (
         SELECT b.week,
            count(*) AS "DV: All"
           FROM b
          GROUP BY b.week
        ), h AS (
         SELECT b.week,
            count(*) AS "DV: Pass"
           FROM b
          WHERE (b.fault_category IS NULL)
          GROUP BY b.week
        ), i AS (
         SELECT b.week,
            count(*) AS "DV: Developer Error"
           FROM b
          WHERE ((b.fault_category)::text = 'Developer Error'::text)
          GROUP BY b.week
        ), c AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Jenkins'::text)
        ), cc AS (
         SELECT c.week,
            count(*) AS "CI: All"
           FROM c
          GROUP BY c.week
        ), o AS (
         SELECT c.week,
            count(*) AS "CI: Pass"
           FROM c
          WHERE (c.fault_category IS NULL)
          GROUP BY c.week
        ), d AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Rel Eng'::text)
        ), dd AS (
         SELECT d.week,
            count(*) AS "RE: All"
           FROM d
          GROUP BY d.week
        ), v AS (
         SELECT d.week,
            count(*) AS "RE: Pass"
           FROM d
          WHERE (d.fault_category IS NULL)
          GROUP BY d.week
        ), ee AS (
         SELECT aa.week,
            h."DV: Pass",
            i."DV: Developer Error",
            bb."DV: All",
            o."CI: Pass",
            cc."CI: All",
            v."RE: Pass",
            dd."RE: All"
           FROM (((((((aa
             LEFT JOIN h USING (week))
             LEFT JOIN i USING (week))
             LEFT JOIN bb USING (week))
             LEFT JOIN o USING (week))
             LEFT JOIN cc USING (week))
             LEFT JOIN v USING (week))
             LEFT JOIN dd USING (week))
        ), f AS (
         SELECT ee.week,
            round(((((ee."DV: Pass" + ee."DV: Developer Error") * 100) / ee."DV: All"))::numeric, 2) AS "DV: Reliability",
            round((((ee."CI: Pass" * 100) / ee."CI: All"))::numeric, 2) AS "CI: Reliability",
            round((((ee."RE: Pass" * 100) / ee."RE: All"))::numeric, 2) AS "RE: Reliability"
           FROM ee
          ORDER BY ee.week
        )
 SELECT f.week,
    f."DV: Reliability",
    f."CI: Reliability",
    f."RE: Reliability"
   FROM f;


ALTER TABLE "Reliability" OWNER TO postgres;

--
-- Name: VIEW "Reliability"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Reliability" IS 'Data to produce graph of ''Build Reliability over last 52 weeks''';


--
-- Name: Weekly Build Counts by Director (xtab); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly Build Counts by Director (xtab)" AS
 SELECT crosstab."Week ending",
    crosstab."Corniquet, Frederic",
    crosstab."Didier, John",
    crosstab."Flannery, Julie",
    crosstab."He, Zine",
    crosstab."Medhi, Gunajit",
    crosstab."Myers, Brandon",
    crosstab."Yang, Rong",
    crosstab."Zhang, Yiyang",
    crosstab."Other"
   FROM public.crosstab('
select "Week ending"
     , director
     , "number of builds"
  from buildlog_new."Weekly Build Stats by Director"
 order by "Week ending"
 '::text, '
select * from (values
        (''Corniquet, Frederic'')
      , (''Didier, John'')
      , (''Flannery, Julie'')
      , (''He, Zine'')
      , (''Medhi, Gunajit'')
      , (''Myers, Brandon'')
      , (''Yang, Rong'')
      , (''Zhang, Yiyang'')
      , (''Other'')
     ) x(director)
 '::text) crosstab("Week ending" date, "Corniquet, Frederic" bigint, "Didier, John" bigint, "Flannery, Julie" bigint, "He, Zine" bigint, "Medhi, Gunajit" bigint, "Myers, Brandon" bigint, "Yang, Rong" bigint, "Zhang, Yiyang" bigint, "Other" bigint);


ALTER TABLE "Weekly Build Counts by Director (xtab)" OWNER TO postgres;

--
-- Name: ix_site_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_site_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_site_id OWNER TO postgres;

--
-- Name: ix_site; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_site (
    id bigint DEFAULT nextval('ix_site_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_site OWNER TO postgres;

--
-- Name: Weekly statistics values; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly statistics values" AS
 WITH a AS (
         SELECT DISTINCT public.endofweek(tbl_ibidinfo.tm_bld_start) AS week
           FROM tbl_ibidinfo
          ORDER BY (public.endofweek(tbl_ibidinfo.tm_bld_start)) DESC
         LIMIT 27
        ), b AS (
         SELECT public.endofweek(z.tm_bld_start) AS week,
            x2.name AS fault_class,
            v.name AS build_class,
            z1.name AS director_ntlogin,
            z2.name AS site,
            z3.name AS cloud,
            ((z.prep_phase_duration + z.bld_phase_duration) + z.pkg_phase_duration) AS total_components_duration,
            z.build_duration,
            z.component_count
           FROM ((((((((tbl_ibidinfo z
             LEFT JOIN ix_ntlogin z1 ON ((z1.id = z.ix_director_ntlogin_id)))
             LEFT JOIN ix_site z2 ON ((z2.id = z.ix_site_id)))
             LEFT JOIN ix_cloud z3 ON ((z3.id = z.ix_cloud_id)))
             LEFT JOIN tbl_results y ON ((y.id = z.tbl_results_start_id)))
             LEFT JOIN tbl_faults x ON ((x.tbl_results_id = y.id)))
             LEFT JOIN usr_fault_class x1 ON ((x1.id = x.usr_fault_class_id)))
             LEFT JOIN usr_fault_category x2 ON ((x2.id = x1.usr_fault_category_id)))
             LEFT JOIN usr_build_class v ON ((v.id = y.usr_build_class_id)))
          WHERE (public.endofweek(z.tm_bld_start) IN ( SELECT a.week
                   FROM a))
        )
 SELECT b.week,
    b.fault_class,
    b.build_class,
    b.director_ntlogin,
    b.site,
    b.cloud,
    b.total_components_duration,
    b.build_duration,
    b.component_count
   FROM b;


ALTER TABLE "Weekly statistics values" OWNER TO postgres;

--
-- Name: Weekly Build Stats by Director; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly Build Stats by Director" AS
 WITH a AS (
         SELECT z.week,
                CASE
                    WHEN (((y.mgr_ntlogin)::text = 'papadg'::text) OR ((z.director_ntlogin)::text = 'medhig1'::text)) THEN y.name
                    ELSE 'Other'::character varying
                END AS director,
            z.build_duration
           FROM ("Weekly statistics values" z
             LEFT JOIN empdata.employee_data y ON (((y.ntlogin)::text = (z.director_ntlogin)::text)))
          WHERE (((z.build_class)::text = 'Developer'::text) AND (z.week > public.endofweek((CURRENT_DATE - '196 days'::interval))) AND (z.week < public.startofweek((CURRENT_DATE)::timestamp with time zone)))
        ), b AS (
         SELECT a.week,
            a.director,
            buildlog.weekly_stats(array_agg((date_part('epoch'::text, a.build_duration))::bigint)) AS data
           FROM a
          GROUP BY a.week, a.director
        ), c AS (
         SELECT b.week AS "Week ending",
            b.director,
            (b.data)."number of builds" AS "number of builds",
            (b.data)."median time" AS "median time",
            (b.data)."minimum time" AS "minimum time",
            (b.data)."maximum time" AS "maximum time",
            (b.data)."average time" AS "average time",
            (b.data)."stddev time" AS "stddev time"
           FROM b
          ORDER BY b.week DESC, b.director DESC
        )
 SELECT c."Week ending",
    c.director,
    c."number of builds",
    c."median time",
    c."minimum time",
    c."maximum time",
    c."average time",
    c."stddev time"
   FROM c;


ALTER TABLE "Weekly Build Stats by Director" OWNER TO postgres;

--
-- Name: Weekly Build Times by Director (xtab); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly Build Times by Director (xtab)" AS
 SELECT crosstab."Week ending",
    crosstab."Corniquet, Frederic",
    crosstab."Didier, John",
    crosstab."Flannery, Julie",
    crosstab."He, Zine",
    crosstab."Medhi, Gunajit",
    crosstab."Myers, Brandon",
    crosstab."Yang, Rong",
    crosstab."Zhang, Yiyang",
    crosstab."Other"
   FROM public.crosstab('
select "Week ending"
     , director
     , "median time"
  from buildlog_new."Weekly Build Stats by Director"
 order by "Week ending"
 '::text, '
select * from (values
        (''Corniquet, Frederic'')
      , (''Didier, John'')
      , (''Flannery, Julie'')
      , (''He, Zine'')
      , (''Medhi, Gunajit'')
      , (''Myers, Brandon'')
      , (''Yang, Rong'')
      , (''Zhang, Yiyang'')
      , (''Other'')
     ) x(director)
 '::text) crosstab("Week ending" date, "Corniquet, Frederic" character varying, "Didier, John" character varying, "Flannery, Julie" character varying, "He, Zine" character varying, "Medhi, Gunajit" character varying, "Myers, Brandon" character varying, "Yang, Rong" character varying, "Zhang, Yiyang" character varying, "Other" character varying);


ALTER TABLE "Weekly Build Times by Director (xtab)" OWNER TO postgres;

--
-- Name: ix_component_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_component_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_component_id OWNER TO postgres;

--
-- Name: ix_component; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_component (
    id bigint DEFAULT nextval('ix_component_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_component OWNER TO postgres;

--
-- Name: ix_ibid_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_ibid_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_ibid_id OWNER TO postgres;

--
-- Name: ix_ibid; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_ibid (
    id bigint DEFAULT nextval('ix_ibid_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_ibid OWNER TO postgres;

--
-- Name: tbl_suspectresults; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_suspectresults (
    tbl_results_id bigint NOT NULL,
    comment character varying
);


ALTER TABLE tbl_suspectresults OWNER TO postgres;

--
-- Name: usr_host_class_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE usr_host_class_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_host_class_id OWNER TO postgres;

--
-- Name: usr_host_class; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_host_class (
    id bigint DEFAULT nextval('usr_host_class_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE usr_host_class OWNER TO postgres;

--
-- Name: metrics; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW metrics AS
 WITH base AS (
         SELECT z.id,
            (y.week)::date AS week,
            z.ix_ibid_id,
            v.name AS build_class,
            w0.name AS host_class,
                CASE
                    WHEN (x.tbl_results_id IS NULL) THEN 'pass'::text
                    ELSE 'fail'::text
                END AS result,
            x0.name AS fault_component,
            x.usr_fault_class_id
           FROM ((((((tbl_results z
             LEFT JOIN tbl_timeslots y ON ((y.tbl_results_id = z.id)))
             LEFT JOIN tbl_faults x ON ((x.tbl_results_id = z.id)))
             LEFT JOIN ix_component x0 ON ((x0.id = x.ix_fault_component_id)))
             LEFT JOIN tbl_hosts w ON ((w.id = z.tbl_hosts_id)))
             LEFT JOIN usr_host_class w0 ON ((w0.id = w.usr_host_class_id)))
             LEFT JOIN usr_build_class v ON ((v.id = z.usr_build_class_id)))
          WHERE (NOT (z.id IN ( SELECT tbl_suspectresults.tbl_results_id
                   FROM tbl_suspectresults)))
        ), b0 AS (
         SELECT tbl_ibidinfo.ix_ibid_id,
            base.usr_fault_class_id
           FROM (tbl_ibidinfo
             LEFT JOIN base USING (ix_ibid_id))
        ), b1 AS (
         SELECT DISTINCT b0.ix_ibid_id,
            b0.usr_fault_class_id
           FROM b0
        ), b2 AS (
         SELECT b1.ix_ibid_id,
            count(*) AS cnt
           FROM b1
          GROUP BY b1.ix_ibid_id
        ), b3 AS (
         SELECT b2.ix_ibid_id,
                CASE
                    WHEN (b2.cnt > 1) THEN 'Multiple Faults'::character varying
                    ELSE z.name
                END AS fault_class,
                CASE
                    WHEN (b2.cnt > 1) THEN 'MULTIPLE FAULTS'::character varying
                    ELSE z1.name
                END AS fault_category
           FROM (((b2
             LEFT JOIN b0 USING (ix_ibid_id))
             LEFT JOIN usr_fault_class z ON ((z.id = b0.usr_fault_class_id)))
             LEFT JOIN usr_fault_category z1 ON ((z1.id = z.usr_fault_category_id)))
        ), ibid AS (
         SELECT x.name AS ibid,
            z.tm_bld_start AS tm,
            y.week,
            b3.fault_class,
            y.host_class,
            y.build_class,
            b3.fault_category,
            y.result,
            z.component_count,
            z.build_count,
            z.prep_phase_count,
            z.bld_phase_count,
            z.pkg_phase_count,
            z.build_duration,
            z.prep_phase_duration,
            z.bld_phase_duration,
            z.pkg_phase_duration,
                CASE
                    WHEN ((w.name)::text ~* 'New Jersey|Paris|RTP|Shanghai|St Petersburg'::text) THEN w.name
                    WHEN ((v.name)::text ~* 'CEC'::text) THEN (((w.name)::text || ' CEC'::text))::character varying
                    WHEN ((w.name)::text ~* 'Durham|Hopkinton'::text) THEN ((((w.name)::text || ' '::text) || (v.name)::text))::character varying
                    ELSE 'Other'::character varying
                END AS host_category
           FROM (((((tbl_ibidinfo z
             LEFT JOIN b3 USING (ix_ibid_id))
             LEFT JOIN ix_ibid x ON ((x.id = z.ix_ibid_id)))
             LEFT JOIN base y ON ((y.id = z.tbl_results_start_id)))
             LEFT JOIN ix_site w ON ((w.id = z.ix_site_id)))
             LEFT JOIN ix_cloud v ON ((v.id = z.ix_cloud_id)))
        )
 SELECT ibid.ibid,
    ibid.tm,
    ibid.week,
    ibid.fault_class,
    ibid.host_class,
    ibid.build_class,
    ibid.fault_category,
    ibid.result,
    ibid.component_count,
    ibid.build_count,
    ibid.prep_phase_count,
    ibid.bld_phase_count,
    ibid.pkg_phase_count,
    ibid.build_duration,
    ibid.prep_phase_duration,
    ibid.bld_phase_duration,
    ibid.pkg_phase_duration,
    ibid.host_category
   FROM ibid
  ORDER BY ibid.ibid;


ALTER TABLE metrics OWNER TO postgres;

--
-- Name: Weekly averages - Builds; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly averages - Builds" AS
 WITH a AS (
         SELECT metrics.week,
            date_part('epoch'::text, metrics.build_duration) AS build_duration,
            metrics.result
           FROM metrics
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), b AS (
         SELECT a.week,
            ((round((avg(a.build_duration))::numeric, 0) || ' seconds'::text))::interval AS pass
           FROM a
          WHERE (a.result = 'pass'::text)
          GROUP BY a.week
        ), c AS (
         SELECT a.week,
            ((round((avg(a.build_duration))::numeric, 0) || ' seconds'::text))::interval AS fail
           FROM a
          WHERE (a.result = 'fail'::text)
          GROUP BY a.week
        ), d AS (
         SELECT a.week,
            ((round((avg(a.build_duration))::numeric, 0) || ' seconds'::text))::interval AS overall
           FROM a
          GROUP BY a.week
        ), e AS (
         SELECT aa.week,
            b.pass,
            c.fail,
            d.overall
           FROM (((aa
             LEFT JOIN b USING (week))
             LEFT JOIN c USING (week))
             LEFT JOIN d USING (week))
        )
 SELECT e.week,
    e.pass,
    e.fail,
    e.overall
   FROM e
  ORDER BY e.week;


ALTER TABLE "Weekly averages - Builds" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - Builds"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - Builds" IS 'Data to produce graph of ''Average "Build+Packaging" Duration for Developers''';


--
-- Name: ix_phase_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_phase_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_phase_id OWNER TO postgres;

--
-- Name: ix_phase; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_phase (
    id bigint DEFAULT nextval('ix_phase_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_phase OWNER TO postgres;

--
-- Name: tbl_components; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_components (
    tbl_results_id bigint,
    ix_component_id bigint,
    ix_phase_id bigint,
    duration interval
);


ALTER TABLE tbl_components OWNER TO postgres;

--
-- Name: usr_component_class_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE usr_component_class_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_component_class_id OWNER TO postgres;

--
-- Name: usr_component_class; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_component_class (
    id bigint DEFAULT nextval('usr_component_class_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE usr_component_class OWNER TO postgres;

--
-- Name: usr_component_info; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_component_info (
    ix_component_id bigint,
    usr_component_class_id bigint,
    last_improvement timestamp without time zone,
    dorder integer,
    "kittyhawk-all" boolean,
    build_type character varying,
    mask bigint
);


ALTER TABLE usr_component_info OWNER TO postgres;

--
-- Name: Weekly averages - Full Build Times; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly averages - Full Build Times" AS
 WITH a AS (
         SELECT z.id,
            z.ix_ibid_id,
            z.tbl_hosts_id,
            z.usr_build_class_id,
            (x.week)::date AS week,
            z1.name AS build_class
           FROM ((((tbl_results z
             LEFT JOIN tbl_faults t ON ((t.tbl_results_id = z.id)))
             LEFT JOIN tbl_suspectresults s ON ((s.tbl_results_id = z.id)))
             LEFT JOIN tbl_timeslots x ON ((x.tbl_results_id = z.id)))
             LEFT JOIN usr_build_class z1 ON ((z1.id = z.usr_build_class_id)))
          WHERE ((s.tbl_results_id IS NULL) AND (t.tbl_results_id IS NULL))
        ), i0 AS (
         SELECT a.ix_ibid_id,
            a.id,
            x.ix_component_id,
            x.ix_phase_id,
            date_part('epoch'::text, x.duration) AS duration,
            v.last_improvement,
            v.usr_component_class_id,
            v.mask,
            v."kittyhawk-all"
           FROM ((a
             LEFT JOIN tbl_components x ON ((x.tbl_results_id = a.id)))
             LEFT JOIN usr_component_info v ON ((v.ix_component_id = x.ix_component_id)))
        ), i1 AS (
         SELECT i0.id,
            i0.ix_ibid_id,
            i0.ix_component_id,
            i0.duration,
            i0.mask
           FROM i0
          WHERE (i0.ix_phase_id IS NULL)
        ), j1 AS (
         SELECT i0.ix_ibid_id,
            sum(i0.duration) AS duration,
            bit_or(i0.mask) AS mask,
            count(*) AS cnt
           FROM i0
          GROUP BY i0.ix_ibid_id
        ), i2 AS (
         SELECT i0.id,
            i0.ix_ibid_id,
            i0.ix_component_id,
            sum(i0.duration) AS duration,
            bit_and(i0.mask) AS mask,
            count(*) AS cnt
           FROM ((i0
             LEFT JOIN ix_phase z ON ((z.id = i0.ix_phase_id)))
             LEFT JOIN usr_component_class u ON ((u.id = i0.usr_component_class_id)))
          WHERE ((((z.name)::text = 'build'::text) OR ((z.name)::text = 'package'::text)) AND (i0."kittyhawk-all" = true) AND ((u.name)::text <> 'meta'::text))
          GROUP BY i0.id, i0.ix_ibid_id, i0.ix_component_id
        ), i2a AS (
         SELECT i2.id,
            i2.ix_ibid_id,
            i2.ix_component_id,
            i2.duration,
            i2.mask,
            i2.cnt
           FROM i2
          WHERE ((i2.cnt > 1) AND (i2.mask > 0))
        ), j2 AS (
         SELECT i2a.ix_ibid_id,
            sum(i2a.duration) AS duration,
            bit_or(i2a.mask) AS mask,
            (count(*) / 2) AS cnt
           FROM i2a
          GROUP BY i2a.ix_ibid_id
        ), k1 AS (
         SELECT j1.ix_ibid_id,
            j1.duration,
            j1.mask,
            j1.cnt
           FROM j1
        UNION
         SELECT j2.ix_ibid_id,
            j2.duration,
            j2.mask,
            j2.cnt
           FROM j2
        ), ibid AS (
         SELECT a.week,
            k1.duration,
            a.build_class
           FROM ((k1
             LEFT JOIN tbl_ibidinfo z USING (ix_ibid_id))
             LEFT JOIN a ON ((a.id = z.tbl_results_start_id)))
          WHERE ((a.week < public.startofweek((CURRENT_DATE)::timestamp with time zone)) AND ((k1.mask & '8821886970380'::bigint) = '8821886970380'::bigint))
        ), re AS (
         SELECT ((round((avg(ibid.duration))::numeric, 0) || ' seconds'::text))::interval AS "RE builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Rel Eng'::text)
          GROUP BY ibid.week
        ), ci AS (
         SELECT ((round((avg(ibid.duration))::numeric, 0) || ' seconds'::text))::interval AS "CI builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Jenkins'::text)
          GROUP BY ibid.week
        ), dev AS (
         SELECT ((round((avg(ibid.duration))::numeric, 0) || ' seconds'::text))::interval AS "Developer builds",
            ibid.week
           FROM ibid
          WHERE ((ibid.build_class)::text = 'Developer'::text)
          GROUP BY ibid.week
        ), ave AS (
         SELECT ((round(avg((ibid.duration)::numeric), 0) || ' seconds'::text))::interval AS "Average build duration",
            ibid.week
           FROM ibid
          GROUP BY ibid.week
        ), rslts AS (
         SELECT ave.week AS "Week ending",
            ave."Average build duration",
            re."RE builds",
            ci."CI builds",
            dev."Developer builds"
           FROM (((ave
             LEFT JOIN re USING (week))
             LEFT JOIN ci USING (week))
             LEFT JOIN dev USING (week))
        )
 SELECT rslts."Week ending",
    rslts."Average build duration",
    rslts."RE builds",
    rslts."CI builds",
    rslts."Developer builds"
   FROM rslts
  ORDER BY rslts."Week ending";


ALTER TABLE "Weekly averages - Full Build Times" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - Full Build Times"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - Full Build Times" IS 'Data to produce graph of ''Average "Clean Build+Packaging" Duration for Developers''';


--
-- Name: Weekly averages - components_bld (CI); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly averages - components_bld (CI)" AS
 SELECT average_components_bld.week,
    average_components_bld.bamxml,
    average_components_bld.blockshim_ng,
    average_components_bld.c4core,
    average_components_bld.c4csx,
    average_components_bld.cemgui,
    average_components_bld.clariion,
    average_components_bld.cp,
    average_components_bld.cta,
    average_components_bld.cumulus,
    average_components_bld.gms,
    average_components_bld.healthchecks,
    average_components_bld.infrastructureproviders,
    average_components_bld.jmi,
    average_components_bld.kernel,
    average_components_bld.libpsm,
    average_components_bld.mf,
    average_components_bld.mf_common,
    average_components_bld.nxgui,
    average_components_bld.observability,
    average_components_bld.papi,
    average_components_bld.restcommon,
    average_components_bld.sade,
    average_components_bld.safe,
    average_components_bld.security,
    average_components_bld.serviceability,
    average_components_bld.tbn,
    average_components_bld.tomcatcommon,
    average_components_bld.udoctor,
    average_components_bld.uemcli,
    average_components_bld.unirest,
    average_components_bld.univasa,
    average_components_bld.vmwaresdkclient,
    average_components_bld.vvnxdeploydual
   FROM average_components_bld('Jenkins'::text) average_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual);


ALTER TABLE "Weekly averages - components_bld (CI)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_bld (CI)"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_bld (CI)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Weekly averages - components_bld (DE); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly averages - components_bld (DE)" AS
 SELECT average_components_bld.week,
    average_components_bld.bamxml,
    average_components_bld.blockshim_ng,
    average_components_bld.c4core,
    average_components_bld.c4csx,
    average_components_bld.cemgui,
    average_components_bld.clariion,
    average_components_bld.cp,
    average_components_bld.cta,
    average_components_bld.cumulus,
    average_components_bld.gms,
    average_components_bld.healthchecks,
    average_components_bld.infrastructureproviders,
    average_components_bld.jmi,
    average_components_bld.kernel,
    average_components_bld.libpsm,
    average_components_bld.mf,
    average_components_bld.mf_common,
    average_components_bld.nxgui,
    average_components_bld.observability,
    average_components_bld.papi,
    average_components_bld.restcommon,
    average_components_bld.sade,
    average_components_bld.safe,
    average_components_bld.security,
    average_components_bld.serviceability,
    average_components_bld.tbn,
    average_components_bld.tomcatcommon,
    average_components_bld.udoctor,
    average_components_bld.uemcli,
    average_components_bld.unirest,
    average_components_bld.univasa,
    average_components_bld.vmwaresdkclient,
    average_components_bld.vvnxdeploydual
   FROM average_components_bld('Developer'::text) average_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual);


ALTER TABLE "Weekly averages - components_bld (DE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_bld (DE)"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_bld (DE)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Weekly averages - components_bld (RE); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly averages - components_bld (RE)" AS
 SELECT average_components_bld.week,
    average_components_bld.bamxml,
    average_components_bld.blockshim_ng,
    average_components_bld.c4core,
    average_components_bld.c4csx,
    average_components_bld.cemgui,
    average_components_bld.clariion,
    average_components_bld.cp,
    average_components_bld.cta,
    average_components_bld.cumulus,
    average_components_bld.gms,
    average_components_bld.healthchecks,
    average_components_bld.infrastructureproviders,
    average_components_bld.jmi,
    average_components_bld.kernel,
    average_components_bld.libpsm,
    average_components_bld.mf,
    average_components_bld.mf_common,
    average_components_bld.nxgui,
    average_components_bld.observability,
    average_components_bld.papi,
    average_components_bld.restcommon,
    average_components_bld.sade,
    average_components_bld.safe,
    average_components_bld.security,
    average_components_bld.serviceability,
    average_components_bld.tbn,
    average_components_bld.tomcatcommon,
    average_components_bld.udoctor,
    average_components_bld.uemcli,
    average_components_bld.unirest,
    average_components_bld.univasa,
    average_components_bld.vmwaresdkclient,
    average_components_bld.vvnxdeploydual
   FROM average_components_bld('Rel Eng'::text) average_components_bld(week, bamxml, blockshim_ng, c4core, c4csx, cemgui, clariion, cp, cta, cumulus, gms, healthchecks, infrastructureproviders, jmi, kernel, libpsm, mf, mf_common, nxgui, observability, papi, restcommon, sade, safe, security, serviceability, tbn, tomcatcommon, udoctor, uemcli, unirest, univasa, vmwaresdkclient, vvnxdeploydual);


ALTER TABLE "Weekly averages - components_bld (RE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_bld (RE)"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_bld (RE)" IS 'Data to produce graph of ''Distribution of Component average build duration for week''';


--
-- Name: Weekly averages - components_pkg (CI); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly averages - components_pkg (CI)" AS
 SELECT average_components_pkg.week,
    average_components_pkg.bootflash,
    average_components_pkg.econtrolstation,
    average_components_pkg.image,
    average_components_pkg.languages,
    average_components_pkg.rpms,
    average_components_pkg.rpmsinfq,
    average_components_pkg.systemtap,
    average_components_pkg.vtune
   FROM average_components_pkg('Jenkins'::text) average_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune);


ALTER TABLE "Weekly averages - components_pkg (CI)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_pkg (CI)"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_pkg (CI)" IS 'Data to produce graph of ''Distribution of Component average package duration for week''';


--
-- Name: Weekly averages - components_pkg (DE); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly averages - components_pkg (DE)" AS
 SELECT average_components_pkg.week,
    average_components_pkg.bootflash,
    average_components_pkg.econtrolstation,
    average_components_pkg.image,
    average_components_pkg.languages,
    average_components_pkg.rpms,
    average_components_pkg.rpmsinfq,
    average_components_pkg.systemtap,
    average_components_pkg.vtune
   FROM average_components_pkg('Developer'::text) average_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune);


ALTER TABLE "Weekly averages - components_pkg (DE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_pkg (DE)"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_pkg (DE)" IS 'Data to produce graph of ''Distribution of Component average package duration for week''';


--
-- Name: Weekly averages - components_pkg (RE); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly averages - components_pkg (RE)" AS
 SELECT average_components_pkg.week,
    average_components_pkg.bootflash,
    average_components_pkg.econtrolstation,
    average_components_pkg.image,
    average_components_pkg.languages,
    average_components_pkg.rpms,
    average_components_pkg.rpmsinfq,
    average_components_pkg.systemtap,
    average_components_pkg.vtune
   FROM average_components_pkg('Rel Eng'::text) average_components_pkg(week, bootflash, econtrolstation, image, languages, rpms, rpmsinfq, systemtap, vtune);


ALTER TABLE "Weekly averages - components_pkg (RE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly averages - components_pkg (RE)"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly averages - components_pkg (RE)" IS 'Data to produce graph of ''Distribution of Component average package duration for week''';


--
-- Name: Weekly counts - Build Types; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly counts - Build Types" AS
 WITH ibid AS (
         SELECT z.prep_phase_count,
            z.bld_phase_count,
            z.pkg_phase_count,
            x.name AS build_class,
            (w.week)::date AS week
           FROM (((tbl_ibidinfo z
             LEFT JOIN tbl_results y ON ((y.id = z.ix_ibid_id)))
             LEFT JOIN usr_build_class x ON ((x.id = y.usr_build_class_id)))
             LEFT JOIN tbl_timeslots w ON ((w.tbl_results_id = y.id)))
        ), rslts AS (
         SELECT ibid.prep_phase_count,
            ibid.bld_phase_count,
            ibid.pkg_phase_count,
            ibid.build_class,
            ibid.week
           FROM ibid
        ), a AS (
         SELECT rslts.week,
            count(*) AS "Developer"
           FROM rslts
          WHERE ((rslts.build_class)::text = 'Developer'::text)
          GROUP BY rslts.week
        ), b AS (
         SELECT rslts.week,
            count(*) AS "Jenkins"
           FROM rslts
          WHERE ((rslts.build_class)::text = 'Jenkins'::text)
          GROUP BY rslts.week
        ), c AS (
         SELECT rslts.week,
            count(*) AS "Rel Eng"
           FROM rslts
          WHERE ((rslts.build_class)::text = 'Rel Eng'::text)
          GROUP BY rslts.week
        ), d AS (
         SELECT a.week,
            a."Developer",
            b."Jenkins",
            c."Rel Eng",
            ((a."Developer" + b."Jenkins") + c."Rel Eng") AS total
           FROM ((a
             LEFT JOIN b USING (week))
             LEFT JOIN c USING (week))
          ORDER BY a.week DESC
         LIMIT 52
        )
 SELECT d.week,
    d."Developer",
    d."Jenkins",
    d."Rel Eng",
    d.total
   FROM d
  ORDER BY d.week;


ALTER TABLE "Weekly counts - Build Types" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Build Types"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Build Types" IS 'Data to produce graph of ''Distribution of Builds by Build Type''';


--
-- Name: Weekly counts - Builds; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly counts - Builds" AS
 WITH a AS (
         SELECT (((date(z.tm) - (date_part('dow'::text, z.tm) * '1 day'::interval)) + '6 days 23:59:59.99'::interval))::date AS week,
            z.ix_ibid_id,
            count(z1.status) AS status
           FROM (tbl_results z
             LEFT JOIN tbl_faults z1 ON ((z1.tbl_results_id = z.id)))
          WHERE ((z.tm)::date < public.startofweek((('now'::text)::date)::timestamp with time zone))
          GROUP BY z.ix_ibid_id, ((((date(z.tm) - (date_part('dow'::text, z.tm) * '1 day'::interval)) + '6 days 23:59:59.99'::interval))::date)
        ), b0 AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), b1 AS (
         SELECT a.week,
            count(*) AS pass
           FROM a
          WHERE (a.status = 0)
          GROUP BY a.week
        ), b2 AS (
         SELECT a.week,
            count(*) AS fail
           FROM a
          WHERE (a.status <> 0)
          GROUP BY a.week
        ), c AS (
         SELECT b0.week,
            b2.fail,
            b1.pass
           FROM ((b0
             LEFT JOIN b1 USING (week))
             LEFT JOIN b2 USING (week))
          ORDER BY b0.week DESC
         LIMIT 53
        )
 SELECT c.week,
    c.fail,
    c.pass
   FROM c
  ORDER BY c.week;


ALTER TABLE "Weekly counts - Builds" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Builds"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Builds" IS 'Data to produce graph of ''Distribution of Builds by Builds''';


--
-- Name: Weekly counts - Fault-Categories; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly counts - Fault-Categories" AS
 WITH a AS (
         SELECT metrics.week,
            metrics.fault_category,
            metrics.build_class
           FROM metrics
        ), aa AS (
         SELECT a.week
           FROM a
          GROUP BY a.week
        ), b AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Developer'::text)
        ), bb AS (
         SELECT b.week,
            count(*) AS "DV: All"
           FROM b
          GROUP BY b.week
        ), e AS (
         SELECT b.week,
            count(*) AS "DV: Under Investigation"
           FROM b
          WHERE ((b.fault_category)::text = 'Under Investigation'::text)
          GROUP BY b.week
        ), f AS (
         SELECT b.week,
            count(*) AS "DV: Accurev/CMTools"
           FROM b
          WHERE ((b.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY b.week
        ), g AS (
         SELECT b.week,
            count(*) AS "DV: Developer Environment"
           FROM b
          WHERE ((b.fault_category)::text = 'Developer Environment'::text)
          GROUP BY b.week
        ), h AS (
         SELECT b.week,
            count(*) AS "DV: Pass"
           FROM b
          WHERE ((b.fault_category)::text = 'Pass'::text)
          GROUP BY b.week
        ), i AS (
         SELECT b.week,
            count(*) AS "DV: Developer Error"
           FROM b
          WHERE ((b.fault_category)::text = 'Developer Error'::text)
          GROUP BY b.week
        ), j AS (
         SELECT b.week,
            count(*) AS "DV: Build Avoidance"
           FROM b
          WHERE ((b.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY b.week
        ), k AS (
         SELECT b.week,
            count(*) AS "DV: MULTIPLE FAULTS"
           FROM b
          WHERE ((b.fault_category)::text = 'MULTIPLE FAULTS'::text)
          GROUP BY b.week
        ), c AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Jenkins'::text)
        ), cc AS (
         SELECT c.week,
            count(*) AS "CI: All"
           FROM c
          GROUP BY c.week
        ), l AS (
         SELECT c.week,
            count(*) AS "CI: Under Investigation"
           FROM c
          WHERE ((c.fault_category)::text = 'Under Investigation'::text)
          GROUP BY c.week
        ), m AS (
         SELECT c.week,
            count(*) AS "CI: Accurev/CMTools"
           FROM c
          WHERE ((c.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY c.week
        ), n AS (
         SELECT c.week,
            count(*) AS "CI: Developer Environment"
           FROM c
          WHERE ((c.fault_category)::text = 'Developer Environment'::text)
          GROUP BY c.week
        ), o AS (
         SELECT c.week,
            count(*) AS "CI: Pass"
           FROM c
          WHERE ((c.fault_category)::text = 'Pass'::text)
          GROUP BY c.week
        ), p AS (
         SELECT c.week,
            count(*) AS "CI: Developer Error"
           FROM c
          WHERE ((c.fault_category)::text = 'Developer Error'::text)
          GROUP BY c.week
        ), q AS (
         SELECT c.week,
            count(*) AS "CI: Build Avoidance"
           FROM c
          WHERE ((c.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY c.week
        ), r AS (
         SELECT c.week,
            count(*) AS "CI: MULTIPLE FAULTS"
           FROM c
          WHERE ((c.fault_category)::text = 'MULTIPLE FAULTS'::text)
          GROUP BY c.week
        ), d AS (
         SELECT a.week,
            a.fault_category
           FROM a
          WHERE ((a.build_class)::text = 'Rel Eng'::text)
        ), dd AS (
         SELECT d.week,
            count(*) AS "RE: All"
           FROM d
          GROUP BY d.week
        ), s AS (
         SELECT d.week,
            count(*) AS "RE: Under Investigation"
           FROM d
          WHERE ((d.fault_category)::text = 'Under Investigation'::text)
          GROUP BY d.week
        ), t AS (
         SELECT d.week,
            count(*) AS "RE: Accurev/CMTools"
           FROM d
          WHERE ((d.fault_category)::text = 'Accurev/CMTools'::text)
          GROUP BY d.week
        ), u AS (
         SELECT d.week,
            count(*) AS "RE: Developer Environment"
           FROM d
          WHERE ((d.fault_category)::text = 'Developer Environment'::text)
          GROUP BY d.week
        ), v AS (
         SELECT d.week,
            count(*) AS "RE: Pass"
           FROM d
          WHERE ((d.fault_category)::text = 'Pass'::text)
          GROUP BY d.week
        ), w AS (
         SELECT d.week,
            count(*) AS "RE: Developer Error"
           FROM d
          WHERE ((d.fault_category)::text = 'Developer Error'::text)
          GROUP BY d.week
        ), x AS (
         SELECT d.week,
            count(*) AS "RE: Build Avoidance"
           FROM d
          WHERE ((d.fault_category)::text = 'Build Avoidance'::text)
          GROUP BY d.week
        ), y AS (
         SELECT d.week,
            count(*) AS "RE: MULTIPLE FAULTS"
           FROM d
          WHERE ((d.fault_category)::text = 'MULTIPLE FAULTS'::text)
          GROUP BY d.week
        ), ee AS (
         SELECT aa.week,
            e."DV: Under Investigation",
            f."DV: Accurev/CMTools",
            g."DV: Developer Environment",
            h."DV: Pass",
            i."DV: Developer Error",
            j."DV: Build Avoidance",
            k."DV: MULTIPLE FAULTS",
            bb."DV: All",
            l."CI: Under Investigation",
            m."CI: Accurev/CMTools",
            n."CI: Developer Environment",
            o."CI: Pass",
            p."CI: Developer Error",
            q."CI: Build Avoidance",
            r."CI: MULTIPLE FAULTS",
            cc."CI: All",
            s."RE: Under Investigation",
            t."RE: Accurev/CMTools",
            u."RE: Developer Environment",
            v."RE: Pass",
            w."RE: Developer Error",
            x."RE: Build Avoidance",
            y."RE: MULTIPLE FAULTS",
            dd."RE: All"
           FROM ((((((((((((((((((((((((aa
             LEFT JOIN e USING (week))
             LEFT JOIN f USING (week))
             LEFT JOIN g USING (week))
             LEFT JOIN h USING (week))
             LEFT JOIN i USING (week))
             LEFT JOIN j USING (week))
             LEFT JOIN k USING (week))
             LEFT JOIN bb USING (week))
             LEFT JOIN l USING (week))
             LEFT JOIN m USING (week))
             LEFT JOIN n USING (week))
             LEFT JOIN o USING (week))
             LEFT JOIN p USING (week))
             LEFT JOIN q USING (week))
             LEFT JOIN r USING (week))
             LEFT JOIN cc USING (week))
             LEFT JOIN s USING (week))
             LEFT JOIN t USING (week))
             LEFT JOIN u USING (week))
             LEFT JOIN v USING (week))
             LEFT JOIN w USING (week))
             LEFT JOIN x USING (week))
             LEFT JOIN y USING (week))
             LEFT JOIN dd USING (week))
        )
 SELECT ee.week,
    ee."DV: Under Investigation",
    ee."DV: Accurev/CMTools",
    ee."DV: Developer Environment",
    ee."DV: Pass",
    ee."DV: Developer Error",
    ee."DV: Build Avoidance",
    ee."DV: MULTIPLE FAULTS",
    ee."DV: All",
    ee."CI: Under Investigation",
    ee."CI: Accurev/CMTools",
    ee."CI: Developer Environment",
    ee."CI: Pass",
    ee."CI: Developer Error",
    ee."CI: Build Avoidance",
    ee."CI: MULTIPLE FAULTS",
    ee."CI: All",
    ee."RE: Under Investigation",
    ee."RE: Accurev/CMTools",
    ee."RE: Developer Environment",
    ee."RE: Pass",
    ee."RE: Developer Error",
    ee."RE: Build Avoidance",
    ee."RE: MULTIPLE FAULTS",
    ee."RE: All"
   FROM ee
  ORDER BY ee.week;


ALTER TABLE "Weekly counts - Fault-Categories" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Fault-Categories"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Fault-Categories" IS 'Data to produce graph of ''Weekly Counts for each Fault-Category''';


--
-- Name: Weekly counts - Host Types; Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly counts - Host Types" AS
 WITH a AS (
         SELECT public.startofweek(z.tm_bld_start) AS "Week Ending",
                CASE
                    WHEN ((y_1.name)::text ~* 'New Jersey|Paris|RTP|Shanghai|St Petersburg'::text) THEN y_1.name
                    WHEN ((x.name)::text ~* 'CEC'::text) THEN (((y_1.name)::text || ' CEC'::text))::character varying
                    WHEN ((y_1.name)::text ~* 'Durham|Hopkinton'::text) THEN ((((y_1.name)::text || ' '::text) || (x.name)::text))::character varying
                    ELSE 'Other'::character varying
                END AS host_category
           FROM ((tbl_ibidinfo z
             LEFT JOIN ix_site y_1 ON ((y_1.id = z.ix_site_id)))
             LEFT JOIN ix_cloud x ON ((x.id = z.ix_cloud_id)))
        ), b AS (
         SELECT a."Week Ending"
           FROM a
          GROUP BY a."Week Ending"
        ), c AS (
         SELECT a."Week Ending",
            count(*) AS "Durham CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Durham CEC'::text)
          GROUP BY a."Week Ending"
        ), d AS (
         SELECT a."Week Ending",
            count(*) AS "Durham EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Durham EOS2'::text)
          GROUP BY a."Week Ending"
        ), e AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton CEC'::text)
          GROUP BY a."Week Ending"
        ), f AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton EOS2'::text)
          GROUP BY a."Week Ending"
        ), g AS (
         SELECT a."Week Ending",
            count(*) AS "New Jersey"
           FROM a
          WHERE ((a.host_category)::text = 'New Jersey'::text)
          GROUP BY a."Week Ending"
        ), h AS (
         SELECT a."Week Ending",
            count(*) AS "Paris"
           FROM a
          WHERE ((a.host_category)::text = 'Paris'::text)
          GROUP BY a."Week Ending"
        ), i AS (
         SELECT a."Week Ending",
            count(*) AS "RTP"
           FROM a
          WHERE ((a.host_category)::text = 'RTP'::text)
          GROUP BY a."Week Ending"
        ), j AS (
         SELECT a."Week Ending",
            count(*) AS "Shanghai"
           FROM a
          WHERE ((a.host_category)::text = 'Shanghai'::text)
          GROUP BY a."Week Ending"
        ), k AS (
         SELECT a."Week Ending",
            count(*) AS "St Petersburg"
           FROM a
          WHERE ((a.host_category)::text = 'St Petersburg'::text)
          GROUP BY a."Week Ending"
        ), l AS (
         SELECT a."Week Ending",
            count(*) AS "Other"
           FROM a
          WHERE ((a.host_category)::text = 'Other'::text)
          GROUP BY a."Week Ending"
        ), y AS (
         SELECT b."Week Ending",
            c."Durham CEC",
            d."Durham EOS2",
            e."Hopkinton CEC",
            f."Hopkinton EOS2",
            g."New Jersey",
            h."Paris",
            i."RTP",
            j."Shanghai",
            k."St Petersburg",
            l."Other"
           FROM ((((((((((b
             LEFT JOIN c USING ("Week Ending"))
             LEFT JOIN d USING ("Week Ending"))
             LEFT JOIN e USING ("Week Ending"))
             LEFT JOIN f USING ("Week Ending"))
             LEFT JOIN g USING ("Week Ending"))
             LEFT JOIN h USING ("Week Ending"))
             LEFT JOIN i USING ("Week Ending"))
             LEFT JOIN j USING ("Week Ending"))
             LEFT JOIN k USING ("Week Ending"))
             LEFT JOIN l USING ("Week Ending"))
        )
 SELECT y."Week Ending",
    y."Durham CEC",
    y."Durham EOS2",
    y."Hopkinton CEC",
    y."Hopkinton EOS2",
    y."New Jersey",
    y."Paris",
    y."RTP",
    y."Shanghai",
    y."St Petersburg",
    y."Other"
   FROM y
  ORDER BY y."Week Ending";


ALTER TABLE "Weekly counts - Host Types" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Host Types"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Host Types" IS 'Data to produce graph of ''Weekly counts - Host Types''';


--
-- Name: Weekly counts - Host Types (CI); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly counts - Host Types (CI)" AS
 WITH a AS (
         SELECT public.startofweek(z.tm_bld_start) AS "Week Ending",
                CASE
                    WHEN ((y_1.name)::text ~* 'New Jersey|Paris|RTP|Shanghai|St Petersburg'::text) THEN y_1.name
                    WHEN ((x.name)::text ~* 'CEC'::text) THEN (((y_1.name)::text || ' CEC'::text))::character varying
                    WHEN ((y_1.name)::text ~* 'Durham|Hopkinton'::text) THEN ((((y_1.name)::text || ' '::text) || (x.name)::text))::character varying
                    ELSE 'Other'::character varying
                END AS host_category
           FROM ((((tbl_ibidinfo z
             LEFT JOIN ix_site y_1 ON ((y_1.id = z.ix_site_id)))
             LEFT JOIN ix_cloud x ON ((x.id = z.ix_cloud_id)))
             LEFT JOIN tbl_results w ON ((w.id = z.tbl_results_start_id)))
             LEFT JOIN usr_build_class w0 ON ((w0.id = w.usr_build_class_id)))
          WHERE ((w0.name)::text = 'Jenkins'::text)
        ), b AS (
         SELECT a."Week Ending"
           FROM a
          GROUP BY a."Week Ending"
        ), c AS (
         SELECT a."Week Ending",
            count(*) AS "Durham CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Durham CEC'::text)
          GROUP BY a."Week Ending"
        ), d AS (
         SELECT a."Week Ending",
            count(*) AS "Durham EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Durham EOS2'::text)
          GROUP BY a."Week Ending"
        ), e AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton CEC'::text)
          GROUP BY a."Week Ending"
        ), f AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton EOS2'::text)
          GROUP BY a."Week Ending"
        ), g AS (
         SELECT a."Week Ending",
            count(*) AS "New Jersey"
           FROM a
          WHERE ((a.host_category)::text = 'New Jersey'::text)
          GROUP BY a."Week Ending"
        ), h AS (
         SELECT a."Week Ending",
            count(*) AS "Paris"
           FROM a
          WHERE ((a.host_category)::text = 'Paris'::text)
          GROUP BY a."Week Ending"
        ), i AS (
         SELECT a."Week Ending",
            count(*) AS "RTP"
           FROM a
          WHERE ((a.host_category)::text = 'RTP'::text)
          GROUP BY a."Week Ending"
        ), j AS (
         SELECT a."Week Ending",
            count(*) AS "Shanghai"
           FROM a
          WHERE ((a.host_category)::text = 'Shanghai'::text)
          GROUP BY a."Week Ending"
        ), k AS (
         SELECT a."Week Ending",
            count(*) AS "St Petersburg"
           FROM a
          WHERE ((a.host_category)::text = 'St Petersburg'::text)
          GROUP BY a."Week Ending"
        ), l AS (
         SELECT a."Week Ending",
            count(*) AS "Other"
           FROM a
          WHERE ((a.host_category)::text = 'Other'::text)
          GROUP BY a."Week Ending"
        ), y AS (
         SELECT b."Week Ending",
            c."Durham CEC",
            d."Durham EOS2",
            e."Hopkinton CEC",
            f."Hopkinton EOS2",
            g."New Jersey",
            h."Paris",
            i."RTP",
            j."Shanghai",
            k."St Petersburg",
            l."Other"
           FROM ((((((((((b
             LEFT JOIN c USING ("Week Ending"))
             LEFT JOIN d USING ("Week Ending"))
             LEFT JOIN e USING ("Week Ending"))
             LEFT JOIN f USING ("Week Ending"))
             LEFT JOIN g USING ("Week Ending"))
             LEFT JOIN h USING ("Week Ending"))
             LEFT JOIN i USING ("Week Ending"))
             LEFT JOIN j USING ("Week Ending"))
             LEFT JOIN k USING ("Week Ending"))
             LEFT JOIN l USING ("Week Ending"))
        )
 SELECT y."Week Ending",
    y."Durham CEC",
    y."Durham EOS2",
    y."Hopkinton CEC",
    y."Hopkinton EOS2",
    y."New Jersey",
    y."Paris",
    y."RTP",
    y."Shanghai",
    y."St Petersburg",
    y."Other"
   FROM y
  ORDER BY y."Week Ending";


ALTER TABLE "Weekly counts - Host Types (CI)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Host Types (CI)"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Host Types (CI)" IS 'Data to produce graph of ''Weekly counts - Host Types''';


--
-- Name: Weekly counts - Host Types (DE); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly counts - Host Types (DE)" AS
 WITH a AS (
         SELECT public.startofweek(z.tm_bld_start) AS "Week Ending",
                CASE
                    WHEN ((y_1.name)::text ~* 'New Jersey|Paris|RTP|Shanghai|St Petersburg'::text) THEN y_1.name
                    WHEN ((x.name)::text ~* 'CEC'::text) THEN (((y_1.name)::text || ' CEC'::text))::character varying
                    WHEN ((y_1.name)::text ~* 'Durham|Hopkinton'::text) THEN ((((y_1.name)::text || ' '::text) || (x.name)::text))::character varying
                    ELSE 'Other'::character varying
                END AS host_category
           FROM ((((tbl_ibidinfo z
             LEFT JOIN ix_site y_1 ON ((y_1.id = z.ix_site_id)))
             LEFT JOIN ix_cloud x ON ((x.id = z.ix_cloud_id)))
             LEFT JOIN tbl_results w ON ((w.id = z.tbl_results_start_id)))
             LEFT JOIN usr_build_class w0 ON ((w0.id = w.usr_build_class_id)))
          WHERE ((w0.name)::text = 'Developer'::text)
        ), b AS (
         SELECT a."Week Ending"
           FROM a
          GROUP BY a."Week Ending"
        ), c AS (
         SELECT a."Week Ending",
            count(*) AS "Durham CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Durham CEC'::text)
          GROUP BY a."Week Ending"
        ), d AS (
         SELECT a."Week Ending",
            count(*) AS "Durham EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Durham EOS2'::text)
          GROUP BY a."Week Ending"
        ), e AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton CEC'::text)
          GROUP BY a."Week Ending"
        ), f AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton EOS2'::text)
          GROUP BY a."Week Ending"
        ), g AS (
         SELECT a."Week Ending",
            count(*) AS "New Jersey"
           FROM a
          WHERE ((a.host_category)::text = 'New Jersey'::text)
          GROUP BY a."Week Ending"
        ), h AS (
         SELECT a."Week Ending",
            count(*) AS "Paris"
           FROM a
          WHERE ((a.host_category)::text = 'Paris'::text)
          GROUP BY a."Week Ending"
        ), i AS (
         SELECT a."Week Ending",
            count(*) AS "RTP"
           FROM a
          WHERE ((a.host_category)::text = 'RTP'::text)
          GROUP BY a."Week Ending"
        ), j AS (
         SELECT a."Week Ending",
            count(*) AS "Shanghai"
           FROM a
          WHERE ((a.host_category)::text = 'Shanghai'::text)
          GROUP BY a."Week Ending"
        ), k AS (
         SELECT a."Week Ending",
            count(*) AS "St Petersburg"
           FROM a
          WHERE ((a.host_category)::text = 'St Petersburg'::text)
          GROUP BY a."Week Ending"
        ), l AS (
         SELECT a."Week Ending",
            count(*) AS "Other"
           FROM a
          WHERE ((a.host_category)::text = 'Other'::text)
          GROUP BY a."Week Ending"
        ), y AS (
         SELECT b."Week Ending",
            c."Durham CEC",
            d."Durham EOS2",
            e."Hopkinton CEC",
            f."Hopkinton EOS2",
            g."New Jersey",
            h."Paris",
            i."RTP",
            j."Shanghai",
            k."St Petersburg",
            l."Other"
           FROM ((((((((((b
             LEFT JOIN c USING ("Week Ending"))
             LEFT JOIN d USING ("Week Ending"))
             LEFT JOIN e USING ("Week Ending"))
             LEFT JOIN f USING ("Week Ending"))
             LEFT JOIN g USING ("Week Ending"))
             LEFT JOIN h USING ("Week Ending"))
             LEFT JOIN i USING ("Week Ending"))
             LEFT JOIN j USING ("Week Ending"))
             LEFT JOIN k USING ("Week Ending"))
             LEFT JOIN l USING ("Week Ending"))
        )
 SELECT y."Week Ending",
    y."Durham CEC",
    y."Durham EOS2",
    y."Hopkinton CEC",
    y."Hopkinton EOS2",
    y."New Jersey",
    y."Paris",
    y."RTP",
    y."Shanghai",
    y."St Petersburg",
    y."Other"
   FROM y
  ORDER BY y."Week Ending";


ALTER TABLE "Weekly counts - Host Types (DE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Host Types (DE)"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Host Types (DE)" IS 'Data to produce graph of ''Weekly counts - Host Types''';


--
-- Name: Weekly counts - Host Types (RE); Type: VIEW; Schema: buildlog_new; Owner: postgres
--

CREATE VIEW "Weekly counts - Host Types (RE)" AS
 WITH a AS (
         SELECT public.startofweek(z.tm_bld_start) AS "Week Ending",
                CASE
                    WHEN ((y_1.name)::text ~* 'New Jersey|Paris|RTP|Shanghai|St Petersburg'::text) THEN y_1.name
                    WHEN ((x.name)::text ~* 'CEC'::text) THEN (((y_1.name)::text || ' CEC'::text))::character varying
                    WHEN ((y_1.name)::text ~* 'Durham|Hopkinton'::text) THEN ((((y_1.name)::text || ' '::text) || (x.name)::text))::character varying
                    ELSE 'Other'::character varying
                END AS host_category
           FROM ((((tbl_ibidinfo z
             LEFT JOIN ix_site y_1 ON ((y_1.id = z.ix_site_id)))
             LEFT JOIN ix_cloud x ON ((x.id = z.ix_cloud_id)))
             LEFT JOIN tbl_results w ON ((w.id = z.tbl_results_start_id)))
             LEFT JOIN usr_build_class w0 ON ((w0.id = w.usr_build_class_id)))
          WHERE ((w0.name)::text = 'Rel Eng'::text)
        ), b AS (
         SELECT a."Week Ending"
           FROM a
          GROUP BY a."Week Ending"
        ), c AS (
         SELECT a."Week Ending",
            count(*) AS "Durham CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Durham CEC'::text)
          GROUP BY a."Week Ending"
        ), d AS (
         SELECT a."Week Ending",
            count(*) AS "Durham EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Durham EOS2'::text)
          GROUP BY a."Week Ending"
        ), e AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton CEC"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton CEC'::text)
          GROUP BY a."Week Ending"
        ), f AS (
         SELECT a."Week Ending",
            count(*) AS "Hopkinton EOS2"
           FROM a
          WHERE ((a.host_category)::text = 'Hopkinton EOS2'::text)
          GROUP BY a."Week Ending"
        ), g AS (
         SELECT a."Week Ending",
            count(*) AS "New Jersey"
           FROM a
          WHERE ((a.host_category)::text = 'New Jersey'::text)
          GROUP BY a."Week Ending"
        ), h AS (
         SELECT a."Week Ending",
            count(*) AS "Paris"
           FROM a
          WHERE ((a.host_category)::text = 'Paris'::text)
          GROUP BY a."Week Ending"
        ), i AS (
         SELECT a."Week Ending",
            count(*) AS "RTP"
           FROM a
          WHERE ((a.host_category)::text = 'RTP'::text)
          GROUP BY a."Week Ending"
        ), j AS (
         SELECT a."Week Ending",
            count(*) AS "Shanghai"
           FROM a
          WHERE ((a.host_category)::text = 'Shanghai'::text)
          GROUP BY a."Week Ending"
        ), k AS (
         SELECT a."Week Ending",
            count(*) AS "St Petersburg"
           FROM a
          WHERE ((a.host_category)::text = 'St Petersburg'::text)
          GROUP BY a."Week Ending"
        ), l AS (
         SELECT a."Week Ending",
            count(*) AS "Other"
           FROM a
          WHERE ((a.host_category)::text = 'Other'::text)
          GROUP BY a."Week Ending"
        ), y AS (
         SELECT b."Week Ending",
            c."Durham CEC",
            d."Durham EOS2",
            e."Hopkinton CEC",
            f."Hopkinton EOS2",
            g."New Jersey",
            h."Paris",
            i."RTP",
            j."Shanghai",
            k."St Petersburg",
            l."Other"
           FROM ((((((((((b
             LEFT JOIN c USING ("Week Ending"))
             LEFT JOIN d USING ("Week Ending"))
             LEFT JOIN e USING ("Week Ending"))
             LEFT JOIN f USING ("Week Ending"))
             LEFT JOIN g USING ("Week Ending"))
             LEFT JOIN h USING ("Week Ending"))
             LEFT JOIN i USING ("Week Ending"))
             LEFT JOIN j USING ("Week Ending"))
             LEFT JOIN k USING ("Week Ending"))
             LEFT JOIN l USING ("Week Ending"))
        )
 SELECT y."Week Ending",
    y."Durham CEC",
    y."Durham EOS2",
    y."Hopkinton CEC",
    y."Hopkinton EOS2",
    y."New Jersey",
    y."Paris",
    y."RTP",
    y."Shanghai",
    y."St Petersburg",
    y."Other"
   FROM y
  ORDER BY y."Week Ending";


ALTER TABLE "Weekly counts - Host Types (RE)" OWNER TO postgres;

--
-- Name: VIEW "Weekly counts - Host Types (RE)"; Type: COMMENT; Schema: buildlog_new; Owner: postgres
--

COMMENT ON VIEW "Weekly counts - Host Types (RE)" IS 'Data to produce graph of ''Weekly counts - Host Types''';


--
-- Name: ix_cmdargs_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_cmdargs_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_cmdargs_id OWNER TO postgres;

--
-- Name: ix_cmdargs; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_cmdargs (
    id bigint DEFAULT nextval('ix_cmdargs_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_cmdargs OWNER TO postgres;

--
-- Name: ix_cmdvals_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_cmdvals_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_cmdvals_id OWNER TO postgres;

--
-- Name: ix_cmdvals; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_cmdvals (
    id bigint DEFAULT nextval('ix_cmdvals_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_cmdvals OWNER TO postgres;

--
-- Name: ix_env_type_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_env_type_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_env_type_id OWNER TO postgres;

--
-- Name: ix_env_type; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_env_type (
    id bigint DEFAULT nextval('ix_env_type_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_env_type OWNER TO postgres;

--
-- Name: ix_environment_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_environment_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_environment_id OWNER TO postgres;

--
-- Name: ix_environment; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_environment (
    id bigint DEFAULT nextval('ix_environment_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_environment OWNER TO postgres;

--
-- Name: ix_fault_detail_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_fault_detail_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_fault_detail_id OWNER TO postgres;

--
-- Name: ix_fault_detail; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_fault_detail (
    id bigint DEFAULT nextval('ix_fault_detail_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_fault_detail OWNER TO postgres;

--
-- Name: ix_fault_msg_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_fault_msg_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_fault_msg_id OWNER TO postgres;

--
-- Name: ix_fault_msg; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_fault_msg (
    id bigint DEFAULT nextval('ix_fault_msg_id'::regclass) NOT NULL,
    name character varying NOT NULL,
    hash character varying NOT NULL
);


ALTER TABLE ix_fault_msg OWNER TO postgres;

--
-- Name: ix_init_val_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_init_val_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_init_val_id OWNER TO postgres;

--
-- Name: ix_init_val; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_init_val (
    id bigint DEFAULT nextval('ix_init_val_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_init_val OWNER TO postgres;

--
-- Name: ix_stream_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE ix_stream_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_stream_id OWNER TO postgres;

--
-- Name: ix_stream; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE ix_stream (
    id bigint DEFAULT nextval('ix_stream_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_stream OWNER TO postgres;

--
-- Name: raw_baseresults; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE raw_baseresults (
    id bigint,
    tm timestamp without time zone,
    fault_class character varying,
    ibid character varying,
    "user" character varying,
    acuser character varying,
    host character varying,
    hostname character varying,
    ipaddr character varying,
    status integer,
    stream character varying,
    fault_component character varying,
    fault_msg character varying,
    fault_detail character varying,
    init_val character varying,
    pwd character varying,
    basis character varying,
    env_type character varying,
    native_env character varying,
    run_env character varying,
    workspace character varying,
    logerr character varying,
    logout character varying,
    log_subdir character varying,
    component character varying,
    component_outdir character varying
);


ALTER TABLE raw_baseresults OWNER TO postgres;

--
-- Name: raw_cmdargs; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE raw_cmdargs (
    id bigint,
    argument character varying,
    value character varying,
    "position" integer,
    orginalcommand character varying
);


ALTER TABLE raw_cmdargs OWNER TO postgres;

--
-- Name: raw_componentsbyoccurrence; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE raw_componentsbyoccurrence (
    id bigint,
    component character varying,
    duration integer,
    phase character varying
);


ALTER TABLE raw_componentsbyoccurrence OWNER TO postgres;

--
-- Name: raw_json_logs; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE raw_json_logs (
    log text NOT NULL
);


ALTER TABLE raw_json_logs OWNER TO postgres;

--
-- Name: tbl_cmdargs; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_cmdargs (
    tbl_results_id bigint,
    ix_cmdargs_id bigint,
    "position" integer,
    ix_cmdvals_id bigint
);


ALTER TABLE tbl_cmdargs OWNER TO postgres;

--
-- Name: tbl_fileinfo; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_fileinfo (
    tbl_results_id bigint NOT NULL,
    pwd text[],
    workspace text[],
    logerr text[],
    logout text[],
    log_subdir text[],
    component_outdir text[]
);


ALTER TABLE tbl_fileinfo OWNER TO postgres;

--
-- Name: tbl_json_logs; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tbl_json_logs (
    tm timestamp without time zone,
    log text NOT NULL
);


ALTER TABLE tbl_json_logs OWNER TO postgres;

--
-- Name: tmp_hosts_results; Type: TABLE; Schema: buildlog_new; Owner: c4dev
--

CREATE TABLE tmp_hosts_results (
    tbl_results_id bigint,
    tbl_hosts_id bigint,
    ix_host_id bigint,
    ix_hostname_id bigint,
    ix_ipaddress_ids bigint[]
);


ALTER TABLE tmp_hosts_results OWNER TO c4dev;

--
-- Name: tmp_ibid_results; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tmp_ibid_results (
    ix_ibid_id bigint,
    tbl_results_start_id bigint,
    tbl_results_end_id bigint,
    tm_bld_start timestamp without time zone,
    tm_bld_end timestamp without time zone,
    build_count integer,
    component_count integer,
    prep_phase_count integer,
    bld_phase_count integer,
    pkg_phase_count integer,
    components_mask bigint,
    build_duration interval,
    prep_phase_duration interval,
    bld_phase_duration interval,
    pkg_phase_duration interval,
    ix_site_id bigint,
    ix_cloud_id bigint,
    ix_director_ntlogin_id bigint
);


ALTER TABLE tmp_ibid_results OWNER TO postgres;

--
-- Name: tmp_ibids; Type: TABLE; Schema: buildlog_new; Owner: c4dev
--

CREATE TABLE tmp_ibids (
    tbl_results_id bigint,
    ix_ibid_id bigint,
    ibid character varying,
    build_class character varying,
    bld_ibid character varying,
    de_ibid character varying,
    ci_ibid character varying,
    re_ibid character varying
);


ALTER TABLE tmp_ibids OWNER TO c4dev;

--
-- Name: tmp_json_logs; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tmp_json_logs (
    id bigint NOT NULL,
    tm timestamp without time zone,
    log jsonb
);


ALTER TABLE tmp_json_logs OWNER TO postgres;

--
-- Name: tmp_usermatch_results; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE tmp_usermatch_results (
    tbl_results_id bigint,
    tbl_users_id bigint,
    usr_match_owner_to_log_id bigint,
    build_class character varying,
    host_class character varying,
    acuser character varying,
    "user" character varying,
    owner character varying
);


ALTER TABLE tmp_usermatch_results OWNER TO postgres;

--
-- Name: usr_host_category_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE usr_host_category_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_host_category_id OWNER TO postgres;

--
-- Name: usr_host_category; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_host_category (
    id bigint DEFAULT nextval('usr_host_category_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE usr_host_category OWNER TO postgres;

--
-- Name: usr_ipaddress_category_mapping; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_ipaddress_category_mapping (
    ix_ipaddress_id bigint NOT NULL,
    usr_locations_loc1_id bigint,
    usr_locations_loc2_id bigint
);


ALTER TABLE usr_ipaddress_category_mapping OWNER TO postgres;

--
-- Name: usr_locations_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE usr_locations_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_locations_id OWNER TO postgres;

--
-- Name: usr_locations; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_locations (
    id bigint DEFAULT nextval('usr_locations_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE usr_locations OWNER TO postgres;

--
-- Name: usr_logrange_info_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE usr_logrange_info_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_logrange_info_id OWNER TO postgres;

--
-- Name: usr_logrange_info; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_logrange_info (
    id bigint DEFAULT nextval('usr_logrange_info_id'::regclass) NOT NULL,
    tbl_results_start_id bigint,
    tbl_results_end_id bigint
);


ALTER TABLE usr_logrange_info OWNER TO postgres;

--
-- Name: usr_map_host_to_host_class_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE usr_map_host_to_host_class_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_map_host_to_host_class_id OWNER TO postgres;

--
-- Name: usr_map_host_to_host_class; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_map_host_to_host_class (
    id bigint DEFAULT nextval('usr_map_host_to_host_class_id'::regclass) NOT NULL,
    usr_host_class_id bigint DEFAULT 1 NOT NULL,
    usr_host_category_id bigint DEFAULT 1 NOT NULL,
    hostname_match character varying
);


ALTER TABLE usr_map_host_to_host_class OWNER TO postgres;

--
-- Name: usr_match_owner_to_log; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_match_owner_to_log (
    id integer NOT NULL,
    acuser_match character varying,
    user_match character varying,
    host_match character varying,
    workspace_match character varying,
    pwd_match character varying,
    ntid_match character varying,
    usr_build_class_id bigint
);


ALTER TABLE usr_match_owner_to_log OWNER TO postgres;

--
-- Name: usr_network_location_id; Type: SEQUENCE; Schema: buildlog_new; Owner: postgres
--

CREATE SEQUENCE usr_network_location_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_network_location_id OWNER TO postgres;

--
-- Name: usr_network_location; Type: TABLE; Schema: buildlog_new; Owner: postgres
--

CREATE TABLE usr_network_location (
    id bigint DEFAULT nextval('usr_network_location_id'::regclass) NOT NULL,
    name character varying NOT NULL,
    network_address cidr
);


ALTER TABLE usr_network_location OWNER TO postgres;

SET search_path = buildmetrics, pg_catalog;

--
-- Name: ix_buildall_version_id; Type: SEQUENCE; Schema: buildmetrics; Owner: postgres
--

CREATE SEQUENCE ix_buildall_version_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_buildall_version_id OWNER TO postgres;

--
-- Name: ix_buildall_version; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE ix_buildall_version (
    id bigint DEFAULT nextval('ix_buildall_version_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_buildall_version OWNER TO postgres;

--
-- Name: ix_components_id; Type: SEQUENCE; Schema: buildmetrics; Owner: postgres
--

CREATE SEQUENCE ix_components_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_components_id OWNER TO postgres;

--
-- Name: ix_components; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE ix_components (
    id bigint DEFAULT nextval('ix_components_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_components OWNER TO postgres;

--
-- Name: ix_flavor_id; Type: SEQUENCE; Schema: buildmetrics; Owner: postgres
--

CREATE SEQUENCE ix_flavor_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_flavor_id OWNER TO postgres;

--
-- Name: ix_flavor; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE ix_flavor (
    id bigint DEFAULT nextval('ix_flavor_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_flavor OWNER TO postgres;

--
-- Name: ix_host_ipaddress_id; Type: SEQUENCE; Schema: buildmetrics; Owner: postgres
--

CREATE SEQUENCE ix_host_ipaddress_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_host_ipaddress_id OWNER TO postgres;

--
-- Name: ix_host_ipaddress; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE ix_host_ipaddress (
    id bigint DEFAULT nextval('ix_host_ipaddress_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_host_ipaddress OWNER TO postgres;

--
-- Name: ix_stream_id; Type: SEQUENCE; Schema: buildmetrics; Owner: postgres
--

CREATE SEQUENCE ix_stream_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_stream_id OWNER TO postgres;

--
-- Name: ix_stream; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE ix_stream (
    id bigint DEFAULT nextval('ix_stream_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_stream OWNER TO postgres;

--
-- Name: ix_type_id; Type: SEQUENCE; Schema: buildmetrics; Owner: postgres
--

CREATE SEQUENCE ix_type_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_type_id OWNER TO postgres;

--
-- Name: ix_type; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE ix_type (
    id bigint DEFAULT nextval('ix_type_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_type OWNER TO postgres;

--
-- Name: tbl_build_summary; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE tbl_build_summary (
    tbl_buildmetadata_id bigint,
    ix_components_id bigint,
    prepare_phase_duration interval,
    build_phase_duration interval,
    package_phase_duration interval,
    setup_duration interval
);


ALTER TABLE tbl_build_summary OWNER TO postgres;

--
-- Name: tbl_buildmetadata; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE tbl_buildmetadata (
    id bigint NOT NULL,
    build_meta_time timestamp with time zone,
    ccache_enabled boolean,
    ix_host_ipaddress_id bigint,
    num_cpus integer,
    memory bigint,
    ix_stream_id bigint,
    ix_type_id bigint,
    ix_flavor_id bigint,
    ix_buildall_version_id bigint,
    buildid character varying,
    build_start_time timestamp without time zone,
    build_end_time timestamp without time zone,
    build_type character varying DEFAULT 'FULL_BUILD'::character varying
);


ALTER TABLE tbl_buildmetadata OWNER TO postgres;

--
-- Name: usr_host_location_mapping; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE usr_host_location_mapping (
    ix_host_ipaddress_id bigint,
    location text,
    vm_type text
);


ALTER TABLE usr_host_location_mapping OWNER TO postgres;

--
-- Name: TABLE usr_host_location_mapping; Type: COMMENT; Schema: buildmetrics; Owner: postgres
--

COMMENT ON TABLE usr_host_location_mapping IS 'This table contain mapping of host ipadress to its location';


--
-- Name: Build Summary; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "Build Summary" AS
 WITH a AS (
         SELECT y.id,
            y.build_start_time,
            y.buildid AS "Build ID",
            y.num_cpus AS cpus,
            y.memory,
            z3.name AS "ipAddress",
            z4.location AS "Location",
            z4.vm_type AS "VM Type",
            y2.name AS flavor,
            y1.name AS component,
            y.ccache_enabled AS cache,
            z.prepare_phase_duration AS prepare,
            z.build_phase_duration AS build,
            z.package_phase_duration AS package,
            (z.build_phase_duration + z.package_phase_duration) AS "Developer Time",
            ((z.prepare_phase_duration + z.build_phase_duration) + z.package_phase_duration) AS "Total Time",
            y3.name AS stream,
            y4.name AS type,
            ((('VM'::text || y.num_cpus) || 'x'::text) || (1 + (((y.memory / 1024) / 1024) / 1024))) AS "devVM",
            y5.name AS buildall_version
           FROM ((((((((tbl_build_summary z
             LEFT JOIN tbl_buildmetadata y ON ((y.id = z.tbl_buildmetadata_id)))
             LEFT JOIN ix_components y1 ON ((y1.id = z.ix_components_id)))
             LEFT JOIN ix_host_ipaddress z3 ON ((z3.id = y.ix_host_ipaddress_id)))
             LEFT JOIN usr_host_location_mapping z4 ON ((z4.ix_host_ipaddress_id = y.ix_host_ipaddress_id)))
             LEFT JOIN ix_flavor y2 ON ((y2.id = y.ix_flavor_id)))
             LEFT JOIN ix_stream y3 ON ((y3.id = y.ix_stream_id)))
             LEFT JOIN ix_type y4 ON ((y4.id = y.ix_type_id)))
             LEFT JOIN ix_buildall_version y5 ON ((y5.id = y.ix_buildall_version_id)))
          ORDER BY y.id
        )
 SELECT a.id,
    a.build_start_time,
    a."Build ID",
    a.cpus,
    a.memory,
    a."ipAddress",
    a."Location",
    a."VM Type",
    a.flavor,
    a.component,
    a.cache,
    a.prepare,
    a.build,
    a.package,
    a."Developer Time",
    a."Total Time",
    a.stream,
    a.type,
    a."devVM",
    a.buildall_version
   FROM a
  WHERE (a.component IS NOT NULL);


ALTER TABLE "Build Summary" OWNER TO postgres;

--
-- Name: Build Spread; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "Build Spread" AS
 WITH a AS (
         SELECT ("Build Summary".build_start_time)::date AS tm,
            "Build Summary"."devVM",
            "Build Summary"."VM Type",
            "Build Summary".flavor,
            "Build Summary".buildall_version,
            "Build Summary"."Location",
            count(*) AS components,
            sum(("Build Summary".build + "Build Summary".package)) AS "Developer Time",
            sum("Build Summary"."Total Time") AS "Total Time",
            "Build Summary"."ipAddress"
           FROM "Build Summary"
          GROUP BY "Build Summary".id, "Build Summary".build_start_time, "Build Summary"."devVM", "Build Summary"."VM Type", "Build Summary".flavor, "Build Summary".buildall_version, "Build Summary"."Location", "Build Summary"."ipAddress"
        ), b AS (
         SELECT a.tm,
            a."devVM",
            a."VM Type",
            a.flavor,
            a.buildall_version,
            a."Location",
            a."Developer Time",
            a."Total Time",
            a."ipAddress"
           FROM a
          WHERE (a.components > 40)
        )
 SELECT b.tm,
    b."devVM",
    b."VM Type",
    b.flavor,
    b.buildall_version,
    b."Location",
    b."Developer Time",
    b."Total Time",
    b."ipAddress"
   FROM b;


ALTER TABLE "Build Spread" OWNER TO postgres;

--
-- Name: Build Spread Summary; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "Build Spread Summary" AS
 WITH a AS (
         SELECT "Build Summary".id,
            public.endofweek("Build Summary".build_start_time) AS week,
            "Build Summary"."devVM",
            "Build Summary"."VM Type",
            "Build Summary".flavor,
            "Build Summary".buildall_version,
            "Build Summary"."Location",
            "Build Summary".build,
            "Build Summary".package,
            "Build Summary"."Total Time"
           FROM "Build Summary"
        ), b0 AS (
         SELECT a.week,
            a."devVM",
            a."VM Type",
            a.flavor,
            a.buildall_version,
            a."Location",
            count(*) AS components,
            date_part('epoch'::text, sum((a.build + a.package))) AS "Developer Time",
            date_part('epoch'::text, sum(a."Total Time")) AS "Total Time"
           FROM a
          GROUP BY a.id, a.week, a."devVM", a."VM Type", a.flavor, a.buildall_version, a."Location"
        ), b AS (
         SELECT b0.week,
            b0."devVM",
            b0."VM Type",
            b0.flavor,
            b0.buildall_version,
            b0."Location",
            b0.components,
            b0."Developer Time",
            b0."Total Time"
           FROM b0
          WHERE (b0.components > 40)
        ), c0 AS (
         SELECT DISTINCT b.week,
            b."devVM",
            b."VM Type",
            b.buildall_version
           FROM b
        ), c1 AS (
         SELECT b.week,
            b."devVM",
            b."VM Type",
            b.buildall_version,
            ((round(public.quantile(b."Developer Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "DV: Durham",
            ((round(public.quantile(b."Total Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "Tot: Durham"
           FROM b
          WHERE (b."Location" = 'Durham'::text)
          GROUP BY b.week, b."devVM", b."VM Type", b.flavor, b.buildall_version
        ), c2 AS (
         SELECT b.week,
            b."devVM",
            b."VM Type",
            b.buildall_version,
            ((round(public.quantile(b."Developer Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "DV: Hopkinton",
            ((round(public.quantile(b."Total Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "Tot: Hopkinton"
           FROM b
          WHERE (b."Location" = 'Hopkinton'::text)
          GROUP BY b.week, b."devVM", b."VM Type", b.flavor, b.buildall_version
        ), c3 AS (
         SELECT b.week,
            b."devVM",
            b."VM Type",
            b.buildall_version,
            ((round(public.quantile(b."Developer Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "DV: New Jersey",
            ((round(public.quantile(b."Total Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "Tot: New Jersey"
           FROM b
          WHERE (b."Location" = 'New Jersey'::text)
          GROUP BY b.week, b."devVM", b."VM Type", b.flavor, b.buildall_version
        ), c4 AS (
         SELECT b.week,
            b."devVM",
            b."VM Type",
            b.buildall_version,
            ((round(public.quantile(b."Developer Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "DV: Paris",
            ((round(public.quantile(b."Total Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "Tot: Paris"
           FROM b
          WHERE (b."Location" = 'Paris'::text)
          GROUP BY b.week, b."devVM", b."VM Type", b.flavor, b.buildall_version
        ), c5 AS (
         SELECT b.week,
            b."devVM",
            b."VM Type",
            b.buildall_version,
            ((round(public.quantile(b."Developer Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "DV: St Petersburg",
            ((round(public.quantile(b."Total Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "Tot: St Petersburg"
           FROM b
          WHERE (b."Location" = 'St Petersburg'::text)
          GROUP BY b.week, b."devVM", b."VM Type", b.flavor, b.buildall_version
        ), d AS (
         SELECT c0.week,
            c0."devVM",
            c0."VM Type",
            c0.buildall_version,
            c1."DV: Durham",
            c1."Tot: Durham",
            c2."DV: Hopkinton",
            c2."Tot: Hopkinton",
            c3."DV: New Jersey",
            c3."Tot: New Jersey",
            c4."DV: Paris",
            c4."Tot: Paris",
            c5."DV: St Petersburg",
            c5."Tot: St Petersburg"
           FROM (((((c0
             LEFT JOIN c1 USING (week, "devVM", "VM Type", buildall_version))
             LEFT JOIN c2 USING (week, "devVM", "VM Type", buildall_version))
             LEFT JOIN c3 USING (week, "devVM", "VM Type", buildall_version))
             LEFT JOIN c4 USING (week, "devVM", "VM Type", buildall_version))
             LEFT JOIN c5 USING (week, "devVM", "VM Type", buildall_version))
        )
 SELECT d.week,
    d."devVM",
    d."VM Type",
    d.buildall_version,
    d."DV: Durham",
    d."Tot: Durham",
    d."DV: Hopkinton",
    d."Tot: Hopkinton",
    d."DV: New Jersey",
    d."Tot: New Jersey",
    d."DV: Paris",
    d."Tot: Paris",
    d."DV: St Petersburg",
    d."Tot: St Petersburg"
   FROM d;


ALTER TABLE "Build Spread Summary" OWNER TO postgres;

--
-- Name: Build Summary2; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "Build Summary2" AS
 SELECT (((("Build Spread"."VM Type" || '_'::text) || "Build Spread"."devVM") || '_'::text) || "Build Spread"."Location") AS tag,
    date_part('epoch'::text, "Build Spread"."Total Time") AS "Total Time",
    "Build Spread".buildall_version,
    "Build Spread".tm,
    public.endofweek(("Build Spread".tm)::timestamp with time zone) AS week
   FROM "Build Spread";


ALTER TABLE "Build Summary2" OWNER TO postgres;

--
-- Name: Build Summary22; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "Build Summary22" AS
 WITH a AS (
         SELECT "Build Summary2".tag,
            "Build Summary2".week,
            count(*) AS "number of builds",
            ((round(public.quantile("Build Summary2"."Total Time", (0.5)::double precision)) || 'seconds'::text))::interval AS "median time",
            ((round(min("Build Summary2"."Total Time")) || 'seconds'::text))::interval AS "minimum time",
            ((round(max("Build Summary2"."Total Time")) || 'seconds'::text))::interval AS "maximum time",
            ((round(avg("Build Summary2"."Total Time")) || 'seconds'::text))::interval AS "average time",
            ((round(stddev_samp("Build Summary2"."Total Time")) || 'seconds'::text))::interval AS "stddev time",
            "Build Summary2".buildall_version
           FROM "Build Summary2"
          WHERE (("Build Summary2".buildall_version)::text = '2'::text)
          GROUP BY "Build Summary2".tag, "Build Summary2".week, "Build Summary2".buildall_version
          ORDER BY "Build Summary2".week DESC, "Build Summary2".tag
        )
 SELECT a.tag,
    a.week,
    a."number of builds",
    a."median time",
    a."minimum time",
    a."maximum time",
    a."average time",
    a."stddev time",
    a.buildall_version
   FROM a;


ALTER TABLE "Build Summary22" OWNER TO postgres;

--
-- Name: Build Summary3; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "Build Summary3" AS
 WITH a AS (
         SELECT y.id,
            y.build_start_time,
            y.num_cpus AS cpus,
            y.memory,
            z3.name AS "ipAddress",
            z4.location AS "Location",
            z4.vm_type AS "VM Type",
            y2.name AS flavor,
            y1.name AS component,
            z.prepare_phase_duration AS prepare,
            z.build_phase_duration AS build,
            z.package_phase_duration AS package,
            (z.build_phase_duration + z.package_phase_duration) AS "Developer Time",
            ((z.prepare_phase_duration + z.build_phase_duration) + z.package_phase_duration) AS "Total Time",
            y3.name AS stream,
            y4.name AS type,
            ((('VM'::text || y.num_cpus) || 'x'::text) || (1 + (((y.memory / 1024) / 1024) / 1024))) AS "devVM",
            y5.name AS buildall_version
           FROM ((((((((tbl_build_summary z
             LEFT JOIN tbl_buildmetadata y ON ((y.id = z.tbl_buildmetadata_id)))
             LEFT JOIN ix_components y1 ON ((y1.id = z.ix_components_id)))
             LEFT JOIN ix_host_ipaddress z3 ON ((z3.id = y.ix_host_ipaddress_id)))
             LEFT JOIN usr_host_location_mapping z4 ON ((z4.ix_host_ipaddress_id = y.ix_host_ipaddress_id)))
             LEFT JOIN ix_flavor y2 ON ((y2.id = y.ix_flavor_id)))
             LEFT JOIN ix_stream y3 ON ((y3.id = y.ix_stream_id)))
             LEFT JOIN ix_type y4 ON ((y4.id = y.ix_type_id)))
             LEFT JOIN ix_buildall_version y5 ON ((y5.id = y.ix_buildall_version_id)))
          WHERE (y1.name IS NOT NULL)
        ), b AS (
         SELECT (a.build_start_time)::date AS tm,
            a."devVM",
            a."VM Type",
            a.flavor,
            a.buildall_version,
            a."Location",
            a."ipAddress",
            count(*) AS components,
            sum((a.build + a.package)) AS "Developer Time",
            sum(a."Total Time") AS "Total Time"
           FROM a
          GROUP BY a.id, a.build_start_time, a."devVM", a."VM Type", a.flavor, a.buildall_version, a."Location", a."ipAddress"
        ), c AS (
         SELECT b.tm,
            b."devVM",
            b."VM Type",
            b.flavor,
            b.buildall_version,
            b."Location",
            b."ipAddress",
            b."Developer Time",
            b."Total Time"
           FROM b
          WHERE (b.components > 40)
        )
 SELECT c.tm,
    c."devVM",
    c."VM Type",
    c.flavor,
    c.buildall_version,
    c."Location",
    c."ipAddress",
    c."Developer Time",
    c."Total Time"
   FROM c;


ALTER TABLE "Build Summary3" OWNER TO postgres;

--
-- Name: BuildMetadataView; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "BuildMetadataView" AS
 WITH a AS (
         SELECT z.id,
            z1.name AS "Flavor",
            z2.name AS "Stream",
            z3.name AS "ipAddress",
            z5.name AS build_allversion,
            z4.name AS "Type",
            z.num_cpus AS "NumberofCPUs",
            z.build_meta_time AS "Time",
            z.ccache_enabled,
            z.memory AS "AllocatedMemory",
            z.buildid AS "Transaction",
            z.build_start_time,
            z.build_end_time,
            z.build_type
           FROM (((((tbl_buildmetadata z
             LEFT JOIN ix_flavor z1 ON ((z1.id = z.ix_flavor_id)))
             LEFT JOIN ix_stream z2 ON ((z2.id = z.ix_stream_id)))
             LEFT JOIN ix_host_ipaddress z3 ON ((z3.id = z.ix_host_ipaddress_id)))
             LEFT JOIN ix_type z4 ON ((z4.id = z.ix_type_id)))
             LEFT JOIN ix_buildall_version z5 ON ((z5.id = z.ix_buildall_version_id)))
        )
 SELECT a.id,
    a."Flavor",
    a."Stream",
    a."ipAddress",
    a.build_allversion,
    a."Type",
    a."NumberofCPUs",
    a."Time",
    a.ccache_enabled,
    a."AllocatedMemory",
    a."Transaction",
    a.build_start_time,
    a.build_end_time,
    a.build_type
   FROM a
  ORDER BY a.id;


ALTER TABLE "BuildMetadataView" OWNER TO postgres;

--
-- Name: BuildView; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "BuildView" AS
 WITH a AS (
         SELECT z1.id,
            z1.buildid AS "Build ID",
            z1.num_cpus AS core,
            z3.name AS flavor,
            z2.name AS "Component",
            z1.ccache_enabled AS cache,
            z.prepare_phase_duration AS prepare,
            z.build_phase_duration AS build,
            z.package_phase_duration AS package,
            ((z.prepare_phase_duration + z.build_phase_duration) + z.package_phase_duration) AS "Total Time"
           FROM (((tbl_build_summary z
             LEFT JOIN tbl_buildmetadata z1 ON ((z1.id = z.tbl_buildmetadata_id)))
             LEFT JOIN ix_components z2 ON ((z2.id = z.ix_components_id)))
             LEFT JOIN ix_flavor z3 ON ((z3.id = z1.ix_flavor_id)))
        )
 SELECT a.id,
    a."Build ID",
    a.flavor,
    a.core,
    a."Component",
    a.cache,
    a.prepare,
    a.build,
    a.package,
    a."Total Time"
   FROM a
  WHERE (a."Component" IS NOT NULL)
  ORDER BY a.id;


ALTER TABLE "BuildView" OWNER TO postgres;

--
-- Name: GeoPivot BuildCounts; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "GeoPivot BuildCounts" AS
 SELECT crosstab.tag,
    crosstab."2017-09-03",
    crosstab."2017-09-10",
    crosstab."2017-09-17",
    crosstab."2017-09-24",
    crosstab."2017-10-01",
    crosstab."2017-10-08",
    crosstab."2017-10-15",
    crosstab."2017-10-22",
    crosstab."2017-10-29",
    crosstab."2017-11-05"
   FROM public.crosstab('   
select tag
     , week::date
     , "number of builds"
  from buildmetrics."Build Summary22" 
 where week::date < public.startofweek(CURRENT_DATE)
   and week::date > public.endofweek(CURRENT_DATE - ''196 days''::interval)
   and buildall_version = ''2''
 order by tag
 '::text, '
select * from (values
        (''2017-09-03'')
      , (''2017-09-10'')
      , (''2017-09-17'')
      , (''2017-09-24'')
      , (''2017-10-01'')
      , (''2017-10-08'')
      , (''2017-10-15'')
      , (''2017-10-22'')
      , (''2017-10-29'')
      , (''2017-11-05'')
     ) x(week) order by week
 '::text) crosstab(tag character varying, "2017-09-03" bigint, "2017-09-10" bigint, "2017-09-17" bigint, "2017-09-24" bigint, "2017-10-01" bigint, "2017-10-08" bigint, "2017-10-15" bigint, "2017-10-22" bigint, "2017-10-29" bigint, "2017-11-05" bigint);


ALTER TABLE "GeoPivot BuildCounts" OWNER TO postgres;

--
-- Name: GeoPivot BuildTimes; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "GeoPivot BuildTimes" AS
 SELECT crosstab.week,
    crosstab."DevVm_VM12x12_Durham",
    crosstab."DevVm_VM12x12_Hopkinton",
    crosstab."DevVm_VM8x8_Durham",
    crosstab."DevVm_VM8x8_Hopkinton",
    crosstab."DevVm_VM8x8_New Jersey",
    crosstab."DevVm_VM8x8_Paris",
    crosstab."DevVm_VM8x8_St Petersburg",
    crosstab."Slave_VM16x16_Hopkinton",
    crosstab."Slave_VM32x32_Hopkinton",
    crosstab."Slave_VM8x8_Hopkinton"
   FROM public.crosstab('
select week
     , tag
     , extract(epoch from "median time")
  from buildmetrics."Build Summary22"
 where week::date < public.startofweek(CURRENT_DATE)
   and week::date > public.endofweek(CURRENT_DATE - ''196 days''::interval)
   and buildall_version = ''2''
 order by week
 '::text, '
select * from (values
        (''DevVm_VM12x12_Durham'')
      , (''DevVm_VM12x12_Hopkinton'')
      , (''DevVm_VM8x8_Durham'')
      , (''DevVm_VM8x8_Hopkinton'')
      , (''DevVm_VM8x8_New Jersey'')
      , (''DevVm_VM8x8_Paris'')
      , (''DevVm_VM8x8_St Petersburg'')
      , (''Slave_VM16x16_Hopkinton'')
      , (''Slave_VM32x32_Hopkinton'')
      , (''Slave_VM8x8_Hopkinton'')
     ) x(tag)
 '::text) crosstab(week date, "DevVm_VM12x12_Durham" bigint, "DevVm_VM12x12_Hopkinton" bigint, "DevVm_VM8x8_Durham" bigint, "DevVm_VM8x8_Hopkinton" bigint, "DevVm_VM8x8_New Jersey" bigint, "DevVm_VM8x8_Paris" bigint, "DevVm_VM8x8_St Petersburg" bigint, "Slave_VM16x16_Hopkinton" bigint, "Slave_VM32x32_Hopkinton" bigint, "Slave_VM8x8_Hopkinton" bigint);


ALTER TABLE "GeoPivot BuildTimes" OWNER TO postgres;

--
-- Name: Reference Builds; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "Reference Builds" AS
 SELECT "Build Summary".component,
    ((round(public.quantile(date_part('epoch'::text, "Build Summary".prepare), (0.5)::double precision)) || 'seconds'::text))::interval AS prepare,
    ((round(public.quantile(date_part('epoch'::text, "Build Summary".build), (0.5)::double precision)) || 'seconds'::text))::interval AS build,
    ((round(public.quantile(date_part('epoch'::text, "Build Summary".package), (0.5)::double precision)) || 'seconds'::text))::interval AS package,
    "Build Summary"."devVM",
    "Build Summary".flavor,
    "Build Summary"."Location"
   FROM "Build Summary"
  GROUP BY "Build Summary".component, "Build Summary"."devVM", "Build Summary".flavor, "Build Summary"."Location";


ALTER TABLE "Reference Builds" OWNER TO postgres;

SET search_path = vcenter, pg_catalog;

--
-- Name: ix_cloud_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE ix_cloud_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_cloud_id OWNER TO postgres;

--
-- Name: ix_cloud; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE ix_cloud (
    id bigint DEFAULT nextval('ix_cloud_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_cloud OWNER TO postgres;

--
-- Name: ix_cloud_info_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE ix_cloud_info_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_cloud_info_id OWNER TO postgres;

--
-- Name: ix_cloud_info; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE ix_cloud_info (
    id bigint DEFAULT nextval('ix_cloud_info_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_cloud_info OWNER TO postgres;

--
-- Name: ix_fld1_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE ix_fld1_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_fld1_id OWNER TO postgres;

--
-- Name: ix_fld1; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE ix_fld1 (
    id bigint DEFAULT nextval('ix_fld1_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_fld1 OWNER TO postgres;

--
-- Name: ix_fld2_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE ix_fld2_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_fld2_id OWNER TO postgres;

--
-- Name: ix_fld2; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE ix_fld2 (
    id bigint DEFAULT nextval('ix_fld2_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_fld2 OWNER TO postgres;

--
-- Name: ix_iptype_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE ix_iptype_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_iptype_id OWNER TO postgres;

--
-- Name: ix_iptype; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE ix_iptype (
    id bigint DEFAULT nextval('ix_iptype_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_iptype OWNER TO postgres;

--
-- Name: ix_site_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE ix_site_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_site_id OWNER TO postgres;

--
-- Name: ix_site; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE ix_site (
    id bigint DEFAULT nextval('ix_site_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_site OWNER TO postgres;

--
-- Name: ix_widget_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE ix_widget_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_widget_id OWNER TO postgres;

--
-- Name: ix_widget; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE ix_widget (
    id bigint DEFAULT nextval('ix_widget_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_widget OWNER TO postgres;

--
-- Name: locations_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE locations_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE locations_id OWNER TO postgres;

--
-- Name: locations; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE locations (
    id bigint DEFAULT nextval('locations_id'::regclass) NOT NULL,
    location character varying
);


ALTER TABLE locations OWNER TO postgres;

--
-- Name: usr_subnets_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE usr_subnets_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_subnets_id OWNER TO postgres;

--
-- Name: usr_subnets; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE usr_subnets (
    id bigint DEFAULT nextval('usr_subnets_id'::regclass) NOT NULL,
    subnet inet,
    ix_iptype_id bigint,
    ix_cloud_info_id bigint,
    ix_locations_id bigint,
    ix_site_id bigint,
    ix_cloud_id bigint,
    ix_widget_id bigint,
    ix_fld1_id bigint,
    ix_fld2_id bigint,
    source character varying
);


ALTER TABLE usr_subnets OWNER TO postgres;

--
-- Name: subnets; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW subnets AS
 WITH a AS (
         SELECT z.id,
            z.subnet,
            y.name AS iptype,
            x.location,
            w.name AS site,
            v.name AS cloud,
            u.name AS widget,
            t.name AS fld1,
            s.name AS fld2,
            r.name AS cloud_info,
            z.source,
                CASE
                    WHEN ((v.name)::text ~* 'CEC'::text) THEN true
                    WHEN (v.name IS NOT NULL) THEN false
                    WHEN ((w.name)::text ~* 'St Petersburg|RTP|Paris|New Jersey|Shanghai'::text) THEN false
                    ELSE NULL::boolean
                END AS iscec
           FROM ((((((((usr_subnets z
             LEFT JOIN ix_iptype y ON ((y.id = z.ix_iptype_id)))
             LEFT JOIN locations x ON ((x.id = z.ix_locations_id)))
             LEFT JOIN ix_site w ON ((w.id = z.ix_site_id)))
             LEFT JOIN ix_cloud v ON ((v.id = z.ix_cloud_id)))
             LEFT JOIN ix_widget u ON ((u.id = z.ix_widget_id)))
             LEFT JOIN ix_fld1 t ON ((t.id = z.ix_fld1_id)))
             LEFT JOIN ix_fld2 s ON ((s.id = z.ix_fld2_id)))
             LEFT JOIN ix_cloud_info r ON ((r.id = z.ix_cloud_info_id)))
        )
 SELECT a.id,
    a.subnet,
    a.iptype,
    a.location,
    a.site,
    a.cloud,
    a.widget,
    a.fld1,
    a.fld2,
    a.cloud_info,
    a.source,
    a.iscec
   FROM a;


ALTER TABLE subnets OWNER TO postgres;

SET search_path = buildmetrics, pg_catalog;

--
-- Name: VM Info; Type: VIEW; Schema: buildmetrics; Owner: postgres
--

CREATE VIEW "VM Info" AS
 WITH a AS (
         SELECT (y.name)::inet AS ip,
            ((('VM'::text || z.num_cpus) || 'x'::text) || (1 + (((z.memory / 1024) / 1024) / 1024))) AS "devVM"
           FROM (tbl_buildmetadata z
             LEFT JOIN ix_host_ipaddress y ON ((y.id = z.ix_host_ipaddress_id)))
        ), b AS (
         SELECT subnets.id,
            subnets.subnet,
            subnets.location,
            subnets.site,
            subnets.cloud
           FROM vcenter.subnets
          ORDER BY subnets.id
        ), c AS (
         SELECT DISTINCT ON (a.ip, a."devVM") a.ip,
            b.location,
            b.site,
            b.cloud,
            a."devVM"
           FROM (a
             LEFT JOIN b ON ((b.subnet >> a.ip)))
          WHERE ((a.ip << '10.0.0.0/8'::inet) OR (a.ip << '192.168.0.0/16'::inet))
        ), d AS (
         SELECT c.ip,
            c.location,
            c.site,
            c.cloud,
            c."devVM"
           FROM c
          ORDER BY c.site, c."devVM", c.ip, c.location
        )
 SELECT d.ip,
    d.location,
    d.site,
    d.cloud,
    d."devVM"
   FROM d;


ALTER TABLE "VM Info" OWNER TO postgres;

--
-- Name: ix_build_phase_id; Type: SEQUENCE; Schema: buildmetrics; Owner: postgres
--

CREATE SEQUENCE ix_build_phase_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_build_phase_id OWNER TO postgres;

--
-- Name: ix_build_phase; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE ix_build_phase (
    id bigint DEFAULT nextval('ix_build_phase_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_build_phase OWNER TO postgres;

--
-- Name: ix_build_type_id; Type: SEQUENCE; Schema: buildmetrics; Owner: postgres
--

CREATE SEQUENCE ix_build_type_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_build_type_id OWNER TO postgres;

--
-- Name: ix_build_type; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE ix_build_type (
    id bigint DEFAULT nextval('ix_build_type_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_build_type OWNER TO postgres;

--
-- Name: ix_product_id; Type: SEQUENCE; Schema: buildmetrics; Owner: postgres
--

CREATE SEQUENCE ix_product_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_product_id OWNER TO postgres;

--
-- Name: ix_product; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE ix_product (
    id bigint DEFAULT nextval('ix_product_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_product OWNER TO postgres;

--
-- Name: raw_buildmetadata; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE raw_buildmetadata (
    "Time" character varying,
    "Type" character varying,
    "Flavor" character varying,
    "build_all version" character varying,
    "Stream" character varying,
    "Transaction" character varying,
    ccache_enabled character varying,
    "ipAddress" character varying,
    "Number of CPUs" character varying,
    "Allocated Memory" character varying,
    "Build Type" character varying
);


ALTER TABLE raw_buildmetadata OWNER TO postgres;

--
-- Name: raw_component; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE raw_component (
    "Time" character varying,
    "Component" character varying
);


ALTER TABLE raw_component OWNER TO postgres;

--
-- Name: raw_cpu; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE raw_cpu (
    "CPU values" character varying
);


ALTER TABLE raw_cpu OWNER TO postgres;

--
-- Name: raw_disk; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE raw_disk (
    "Time" character varying,
    "BytesFree" character varying
);


ALTER TABLE raw_disk OWNER TO postgres;

--
-- Name: raw_disk2; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE raw_disk2 (
    data character varying
);


ALTER TABLE raw_disk2 OWNER TO postgres;

--
-- Name: raw_event; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE raw_event (
    "Time" character varying,
    "Event" character varying
);


ALTER TABLE raw_event OWNER TO postgres;

--
-- Name: raw_memory; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE raw_memory (
    "Time" character varying,
    "MemTotal" character varying,
    "MemFree" character varying,
    "Buffers" character varying,
    "Cached" character varying,
    "Slab" character varying,
    "SReclaimable" character varying,
    "SwapCached" character varying,
    "SwapTotal" character varying,
    "SwapFree" character varying,
    "Active" character varying,
    "Inactive" character varying,
    "Shmem" character varying
);


ALTER TABLE raw_memory OWNER TO postgres;

--
-- Name: raw_memory2; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE raw_memory2 (
    data character varying
);


ALTER TABLE raw_memory2 OWNER TO postgres;

--
-- Name: raw_warnings; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE raw_warnings (
    "Step" character varying,
    "Component" character varying,
    "Build Type" character varying,
    "Warning Count" character varying
);


ALTER TABLE raw_warnings OWNER TO postgres;

--
-- Name: tbl_buildmetadata_id; Type: SEQUENCE; Schema: buildmetrics; Owner: postgres
--

CREATE SEQUENCE tbl_buildmetadata_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tbl_buildmetadata_id OWNER TO postgres;

--
-- Name: tbl_component_data; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE tbl_component_data (
    tbl_buildmetadata_id bigint,
    sample_time timestamp without time zone,
    ix_components_id bigint,
    ix_flavor_id bigint,
    ix_product_id bigint
);


ALTER TABLE tbl_component_data OWNER TO postgres;

--
-- Name: tbl_cpu_data; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE tbl_cpu_data (
    tbl_buildmetadata_id bigint,
    sample_time timestamp without time zone,
    system_load real,
    cpu_load real[],
    busy_cpus integer
);


ALTER TABLE tbl_cpu_data OWNER TO postgres;

--
-- Name: tbl_disk_freespace; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE tbl_disk_freespace (
    tbl_buildmetadata_id bigint,
    sample_time timestamp without time zone,
    bytesfree bigint
);


ALTER TABLE tbl_disk_freespace OWNER TO postgres;

--
-- Name: tbl_event_data; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE tbl_event_data (
    tbl_buildmetadata_id bigint,
    sample_time timestamp without time zone,
    isactive boolean,
    ix_build_phase_id bigint,
    ix_components_id bigint,
    ix_flavor_id bigint,
    ix_product_id bigint
);


ALTER TABLE tbl_event_data OWNER TO postgres;

--
-- Name: tbl_memory_data; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE tbl_memory_data (
    tbl_buildmetadata_id bigint,
    sample_time timestamp without time zone,
    memtotal bigint,
    memfree bigint,
    buffers bigint,
    cached bigint,
    slab bigint,
    sreclaimable bigint,
    swapcached bigint,
    swaptotal bigint,
    swapfree bigint,
    active bigint,
    inactive bigint,
    shmem bigint
);


ALTER TABLE tbl_memory_data OWNER TO postgres;

--
-- Name: tbl_warnings; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE tbl_warnings (
    tbl_buildmetadata_id bigint,
    ix_build_phase_id bigint,
    ix_components_id bigint,
    ix_build_type_id bigint,
    warnings integer
);


ALTER TABLE tbl_warnings OWNER TO postgres;

--
-- Name: tmp_buildmetadata_id; Type: TABLE; Schema: buildmetrics; Owner: postgres
--

CREATE TABLE tmp_buildmetadata_id (
    id bigint NOT NULL
);


ALTER TABLE tmp_buildmetadata_id OWNER TO postgres;

SET search_path = cateams, pg_catalog;

--
-- Name: cateamleaders; Type: TABLE; Schema: cateams; Owner: postgres
--

CREATE TABLE cateamleaders (
    cateams_id bigint,
    name character varying
);


ALTER TABLE cateamleaders OWNER TO postgres;

--
-- Name: cateammembers; Type: TABLE; Schema: cateams; Owner: postgres
--

CREATE TABLE cateammembers (
    team_id bigint,
    rally_user character varying
);


ALTER TABLE cateammembers OWNER TO postgres;

--
-- Name: cateams; Type: TABLE; Schema: cateams; Owner: postgres
--

CREATE TABLE cateams (
    id bigint NOT NULL,
    name character varying
);


ALTER TABLE cateams OWNER TO postgres;

--
-- Name: rally_info_basic; Type: TABLE; Schema: cateams; Owner: postgres
--

CREATE TABLE rally_info_basic (
    ca character varying,
    rally_name character varying,
    email character varying,
    domain character varying
);


ALTER TABLE rally_info_basic OWNER TO postgres;

--
-- Name: scrumteams; Type: TABLE; Schema: cateams; Owner: postgres
--

CREATE TABLE scrumteams (
    emp_id bigint,
    lastknownscrum character varying,
    rlspreadsheet character varying
);


ALTER TABLE scrumteams OWNER TO postgres;

--
-- Name: team_info_id; Type: SEQUENCE; Schema: cateams; Owner: postgres
--

CREATE SEQUENCE team_info_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE team_info_id OWNER TO postgres;

--
-- Name: teamdata; Type: TABLE; Schema: cateams; Owner: postgres
--

CREATE TABLE teamdata (
    team character varying,
    stream character varying,
    stream_manager character varying,
    "CA_leaders" character varying
);


ALTER TABLE teamdata OWNER TO postgres;

--
-- Name: teaminfo; Type: TABLE; Schema: cateams; Owner: postgres
--

CREATE TABLE teaminfo (
    id bigint,
    team character varying,
    stream_manager character varying,
    "CA_leaders" character varying
);


ALTER TABLE teaminfo OWNER TO postgres;

SET search_path = cateams2, pg_catalog;

--
-- Name: ix_cateams_id; Type: SEQUENCE; Schema: cateams2; Owner: postgres
--

CREATE SEQUENCE ix_cateams_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_cateams_id OWNER TO postgres;

--
-- Name: ix_cateams; Type: TABLE; Schema: cateams2; Owner: postgres
--

CREATE TABLE ix_cateams (
    id bigint DEFAULT nextval('ix_cateams_id'::regclass) NOT NULL,
    name character varying,
    ix_domain_id bigint,
    ix_server_scans_id bigint
);


ALTER TABLE ix_cateams OWNER TO postgres;

--
-- Name: ix_domains_id; Type: SEQUENCE; Schema: cateams2; Owner: postgres
--

CREATE SEQUENCE ix_domains_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_domains_id OWNER TO postgres;

--
-- Name: ix_domains; Type: TABLE; Schema: cateams2; Owner: postgres
--

CREATE TABLE ix_domains (
    id bigint DEFAULT nextval('ix_domains_id'::regclass) NOT NULL,
    name character varying,
    ix_server_scans_id bigint
);


ALTER TABLE ix_domains OWNER TO postgres;

--
-- Name: ix_projects_id; Type: SEQUENCE; Schema: cateams2; Owner: postgres
--

CREATE SEQUENCE ix_projects_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_projects_id OWNER TO postgres;

--
-- Name: ix_projects; Type: TABLE; Schema: cateams2; Owner: postgres
--

CREATE TABLE ix_projects (
    id bigint DEFAULT nextval('ix_projects_id'::regclass) NOT NULL,
    name character varying,
    ix_cateams_id bigint,
    ix_server_scans_id bigint
);


ALTER TABLE ix_projects OWNER TO postgres;

--
-- Name: ix_server_scans_id; Type: SEQUENCE; Schema: cateams2; Owner: postgres
--

CREATE SEQUENCE ix_server_scans_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_server_scans_id OWNER TO postgres;

--
-- Name: ix_server_scans; Type: TABLE; Schema: cateams2; Owner: postgres
--

CREATE TABLE ix_server_scans (
    id bigint DEFAULT nextval('ix_server_scans_id'::regclass) NOT NULL,
    scan_time timestamp with time zone NOT NULL
);


ALTER TABLE ix_server_scans OWNER TO postgres;

--
-- Name: tbl_cateamleaders; Type: TABLE; Schema: cateams2; Owner: postgres
--

CREATE TABLE tbl_cateamleaders (
    name character varying NOT NULL,
    ix_cateams_id bigint,
    ix_server_scans_id bigint
);


ALTER TABLE tbl_cateamleaders OWNER TO postgres;

--
-- Name: COLUMN tbl_cateamleaders.name; Type: COMMENT; Schema: cateams2; Owner: postgres
--

COMMENT ON COLUMN tbl_cateamleaders.name IS 'ntlogin';


--
-- Name: tbl_cateammembers; Type: TABLE; Schema: cateams2; Owner: postgres
--

CREATE TABLE tbl_cateammembers (
    name character varying NOT NULL,
    ix_cateams_id bigint,
    ix_server_scans_id bigint NOT NULL
);


ALTER TABLE tbl_cateammembers OWNER TO postgres;

--
-- Name: COLUMN tbl_cateammembers.name; Type: COMMENT; Schema: cateams2; Owner: postgres
--

COMMENT ON COLUMN tbl_cateammembers.name IS 'ntlogin';


--
-- Name: tbl_rally_info; Type: TABLE; Schema: cateams2; Owner: postgres
--

CREATE TABLE tbl_rally_info (
    ix_project_id bigint,
    cateammember_name character varying,
    ix_server_scans_id bigint
);


ALTER TABLE tbl_rally_info OWNER TO postgres;

--
-- Name: tbl_teaminfo; Type: TABLE; Schema: cateams2; Owner: postgres
--

CREATE TABLE tbl_teaminfo (
    ix_cateams_id bigint NOT NULL,
    ix_server_scans_id bigint,
    stream character varying,
    stream_manager character varying
);


ALTER TABLE tbl_teaminfo OWNER TO postgres;

SET search_path = cyclone, pg_catalog;

--
-- Name: raw_pr_ar; Type: TABLE; Schema: cyclone; Owner: postgres
--

CREATE TABLE raw_pr_ar (
    entry_dt timestamp without time zone NOT NULL,
    org character varying(100) NOT NULL,
    repo character varying(100) NOT NULL,
    branch character varying(100) NOT NULL,
    commit_url character varying(1000),
    pr_url character varying(1000),
    ar character varying(20) NOT NULL,
    release_tag character varying(100)
);


ALTER TABLE raw_pr_ar OWNER TO postgres;

--
-- Name: tbl_pr_ar; Type: TABLE; Schema: cyclone; Owner: postgres
--

CREATE TABLE tbl_pr_ar (
    entry_dt timestamp without time zone NOT NULL,
    org character varying(100) NOT NULL,
    repo character varying(100) NOT NULL,
    branch character varying(100) NOT NULL,
    commit_url character varying(1000) NOT NULL,
    pr_url character varying(1000),
    ar character varying(20) NOT NULL,
    release_tag character varying(100)
);


ALTER TABLE tbl_pr_ar OWNER TO postgres;

SET search_path = demo_packaging, pg_catalog;

--
-- Name: demo_buildnumber; Type: TABLE; Schema: demo_packaging; Owner: postgres
--

CREATE TABLE demo_buildnumber (
    stream character varying(50) NOT NULL,
    uem_version character varying(50) NOT NULL,
    last_buildnumber bigint,
    source_control character varying(50)
);


ALTER TABLE demo_buildnumber OWNER TO postgres;

--
-- Name: COLUMN demo_buildnumber.stream; Type: COMMENT; Schema: demo_packaging; Owner: postgres
--

COMMENT ON COLUMN demo_buildnumber.stream IS 'Stream name.
Ex.  upc-Unity-int';


--
-- Name: COLUMN demo_buildnumber.last_buildnumber; Type: COMMENT; Schema: demo_packaging; Owner: postgres
--

COMMENT ON COLUMN demo_buildnumber.last_buildnumber IS 'Last build number.
Ex. 4.1.0.0-1';


--
-- Name: COLUMN demo_buildnumber.source_control; Type: COMMENT; Schema: demo_packaging; Owner: postgres
--

COMMENT ON COLUMN demo_buildnumber.source_control IS 'Source control name
Ex. GIT';


--
-- Name: demo_versions; Type: TABLE; Schema: demo_packaging; Owner: postgres
--

CREATE TABLE demo_versions (
    release character varying(50),
    program character varying(50) NOT NULL,
    uem_version character varying(50) NOT NULL
);


ALTER TABLE demo_versions OWNER TO postgres;

SET search_path = empdata, pg_catalog;

--
-- Name: current_employees; Type: VIEW; Schema: empdata; Owner: postgres
--

CREATE VIEW current_employees AS
 WITH a AS (
         SELECT max(ix_scans.scan_time) AS scan_time
           FROM ix_scans
        ), b AS (
         SELECT ix_scans.id AS ix_lastscan_id
           FROM (a
             LEFT JOIN ix_scans USING (scan_time))
          WHERE (ix_scans.id IS NOT NULL)
        ), d AS (
         SELECT z.tbl_employees_id,
            z.ix_manager_id,
            y.name AS phone,
            x.name AS city,
            w.name AS country
           FROM ((((tbl_employees_info z
             LEFT JOIN b USING (ix_lastscan_id))
             LEFT JOIN ix_phone y ON ((y.id = z.ix_phone_telephonenumber_id)))
             LEFT JOIN ix_citys x ON ((x.id = z.ix_citys_id)))
             LEFT JOIN ix_countrys w ON ((w.id = z.ix_countrys_id)))
          WHERE (z.ix_lastscan_id = b.ix_lastscan_id)
        ), e AS (
         SELECT d.tbl_employees_id,
            d.ix_manager_id,
            y.name AS badgeid,
            x.name AS ntlogin,
            w.name AS email,
            v.name,
            u.name AS surname,
            t.name AS givenname,
            d.phone,
            d.city,
            d.country,
            s.name AS distinguishedname
           FROM ((((((((d
             LEFT JOIN tbl_employees z ON ((z.id = d.tbl_employees_id)))
             LEFT JOIN ix_badgeid y ON ((y.id = z.ix_badgeid_id)))
             LEFT JOIN ix_ntlogin x ON ((x.id = z.ix_ntlogin_id)))
             LEFT JOIN ix_email w ON ((w.id = z.ix_email_id)))
             LEFT JOIN ix_fullname v ON ((v.id = z.ix_fullname_id)))
             LEFT JOIN ix_surname u ON ((u.id = z.ix_surname_id)))
             LEFT JOIN ix_givenname t ON ((t.id = z.ix_givenname_id)))
             LEFT JOIN ix_distinguishedname s ON ((s.id = z.ix_distinguishedname_id)))
          WHERE ((s.name)::text !~* 'OU=Terminations'::text)
        ), f AS (
         SELECT e.tbl_employees_id,
            e.badgeid,
            e.ntlogin,
            e.email,
            e.name,
            e.surname,
            e.givenname,
            e.phone,
            e.city,
            e.country,
            mgr.name AS mgr_name,
            mgr.badgeid AS mgr_badgeid,
            mgr.ntlogin AS mgr_ntlogin,
            mgr.email AS mgr_email,
            mgr.phone AS mgr_phone,
            e.distinguishedname
           FROM (e
             LEFT JOIN e mgr ON ((mgr.tbl_employees_id = e.ix_manager_id)))
        )
 SELECT f.tbl_employees_id,
    f.badgeid,
    f.ntlogin,
    f.email,
    f.name,
    f.surname,
    f.givenname,
    f.phone,
    f.city,
    f.country,
    f.mgr_name,
    f.mgr_badgeid,
    f.mgr_ntlogin,
    f.mgr_email,
    f.mgr_phone,
    f.distinguishedname
   FROM f;


ALTER TABLE current_employees OWNER TO postgres;

--
-- Name: ix_departments_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_departments_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_departments_id OWNER TO postgres;

--
-- Name: ix_departments; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_departments (
    id bigint DEFAULT nextval('ix_departments_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_departments OWNER TO postgres;

--
-- Name: ix_description_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_description_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_description_id OWNER TO postgres;

--
-- Name: ix_description; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_description (
    id bigint DEFAULT nextval('ix_description_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_description OWNER TO postgres;

--
-- Name: ix_displayname_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_displayname_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_displayname_id OWNER TO postgres;

--
-- Name: ix_displayname; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_displayname (
    id bigint DEFAULT nextval('ix_displayname_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_displayname OWNER TO postgres;

--
-- Name: ix_employee_name_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_employee_name_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_employee_name_id OWNER TO postgres;

--
-- Name: ix_employee_name; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_employee_name (
    id bigint DEFAULT nextval('ix_employee_name_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_employee_name OWNER TO postgres;

--
-- Name: ix_employeetypes_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_employeetypes_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_employeetypes_id OWNER TO postgres;

--
-- Name: ix_employeetypes; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_employeetypes (
    id bigint DEFAULT nextval('ix_employeetypes_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_employeetypes OWNER TO postgres;

--
-- Name: ix_officenames_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_officenames_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_officenames_id OWNER TO postgres;

--
-- Name: ix_officenames; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_officenames (
    id bigint DEFAULT nextval('ix_officenames_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_officenames OWNER TO postgres;

--
-- Name: ix_primarygroupids_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_primarygroupids_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_primarygroupids_id OWNER TO postgres;

--
-- Name: ix_primarygroupids; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_primarygroupids (
    id bigint DEFAULT nextval('ix_primarygroupids_id'::regclass) NOT NULL,
    name character varying
);


ALTER TABLE ix_primarygroupids OWNER TO postgres;

--
-- Name: ix_samaccounttypes_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_samaccounttypes_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_samaccounttypes_id OWNER TO postgres;

--
-- Name: ix_samaccounttypes; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_samaccounttypes (
    id bigint DEFAULT nextval('ix_samaccounttypes_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_samaccounttypes OWNER TO postgres;

--
-- Name: ix_states_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_states_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_states_id OWNER TO postgres;

--
-- Name: ix_states; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_states (
    id bigint DEFAULT nextval('ix_states_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_states OWNER TO postgres;

--
-- Name: ix_title_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_title_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_title_id OWNER TO postgres;

--
-- Name: ix_title; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_title (
    id bigint DEFAULT nextval('ix_title_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_title OWNER TO postgres;

--
-- Name: ix_useraccountcontrols_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_useraccountcontrols_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_useraccountcontrols_id OWNER TO postgres;

--
-- Name: ix_useraccountcontrols; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_useraccountcontrols (
    id bigint DEFAULT nextval('ix_useraccountcontrols_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_useraccountcontrols OWNER TO postgres;

--
-- Name: ix_zipcodes_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE ix_zipcodes_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_zipcodes_id OWNER TO postgres;

--
-- Name: ix_zipcodes; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE ix_zipcodes (
    id bigint DEFAULT nextval('ix_zipcodes_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_zipcodes OWNER TO postgres;

--
-- Name: raw_ldapdata; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE raw_ldapdata (
    city character varying,
    country character varying,
    department character varying,
    description character varying,
    displayname character varying,
    distinguishedname character varying,
    email character varying,
    employeetype character varying,
    employeeid character varying,
    givenname character varying,
    ipphone character varying,
    lastlogontimestamp character varying,
    manager character varying,
    name character varying,
    officename character varying,
    othertelephone character varying,
    primarygroupid character varying,
    pwdlastset character varying,
    samaccounttype character varying,
    samaccountname character varying,
    state character varying,
    surname character varying,
    telephonenumber character varying,
    title character varying,
    useraccountcontrol character varying,
    userprincipalname character varying,
    whenchanged character varying,
    whencreated character varying,
    zipcode character varying
);


ALTER TABLE raw_ldapdata OWNER TO postgres;

--
-- Name: tbl_employees_logins; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE tbl_employees_logins (
    tbl_employees_id bigint NOT NULL,
    ix_scans_id bigint,
    lastlogontimestamp character varying(20),
    pwdlastset character varying(20),
    whencreated timestamp with time zone,
    whenchanged timestamp with time zone
);


ALTER TABLE tbl_employees_logins OWNER TO postgres;

--
-- Name: tmp_scan_id; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE tmp_scan_id (
    id bigint,
    scan_time timestamp with time zone
);


ALTER TABLE tmp_scan_id OWNER TO postgres;

--
-- Name: usr_map_directors; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE usr_map_directors (
    tbl_employees_id bigint,
    ntlogin character varying,
    mgr_ntlogin character varying,
    director character varying,
    location character varying
);


ALTER TABLE usr_map_directors OWNER TO postgres;

--
-- Name: usr_top_mgrs_id; Type: SEQUENCE; Schema: empdata; Owner: postgres
--

CREATE SEQUENCE usr_top_mgrs_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_top_mgrs_id OWNER TO postgres;

--
-- Name: usr_top_mgrs; Type: TABLE; Schema: empdata; Owner: postgres
--

CREATE TABLE usr_top_mgrs (
    id bigint DEFAULT nextval('usr_top_mgrs_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE usr_top_mgrs OWNER TO postgres;

SET search_path = github, pg_catalog;

--
-- Name: cyclonecommon; Type: TABLE; Schema: github; Owner: c4dev
--

CREATE TABLE cyclonecommon (
    hook_event_ts timestamp with time zone NOT NULL,
    x_github_delivery uuid NOT NULL,
    x_github_event character varying NOT NULL,
    action character varying,
    repo_id integer NOT NULL,
    repo_name character varying NOT NULL,
    repo_full_name character varying NOT NULL,
    repo_html_url character varying NOT NULL,
    repo_forks integer,
    sender_id integer NOT NULL,
    sender_login character varying NOT NULL,
    sender_html_url character varying NOT NULL,
    payload jsonb NOT NULL
);


ALTER TABLE cyclonecommon OWNER TO c4dev;

--
-- Name: cyclonecommon_orig; Type: TABLE; Schema: github; Owner: c4dev
--

CREATE TABLE cyclonecommon_orig (
    hook_event_ts timestamp with time zone NOT NULL,
    x_github_delivery uuid NOT NULL,
    x_github_event character varying NOT NULL,
    action character varying,
    repo_id integer NOT NULL,
    repo_name character varying NOT NULL,
    repo_full_name character varying NOT NULL,
    repo_html_url character varying NOT NULL,
    repo_forks integer,
    sender_id integer NOT NULL,
    sender_login character varying NOT NULL,
    sender_html_url character varying NOT NULL,
    payload jsonb
);


ALTER TABLE cyclonecommon_orig OWNER TO c4dev;

SET search_path = jenkins, pg_catalog;

--
-- Name: bak_ciplugin_history; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE bak_ciplugin_history (
    ciplugins_id bigint,
    ciplugin_scan_id bigint,
    ciservers_id bigint
);


ALTER TABLE bak_ciplugin_history OWNER TO postgres;

--
-- Name: bak_ciplugins; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE bak_ciplugins (
    id bigint,
    name character varying,
    version character varying
);


ALTER TABLE bak_ciplugins OWNER TO postgres;

--
-- Name: bak_ciserver_info; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE bak_ciserver_info (
    ciplugin_scans_id bigint,
    ciservers_id bigint,
    server_versions_id bigint
);


ALTER TABLE bak_ciserver_info OWNER TO postgres;

--
-- Name: ciadmins_id; Type: SEQUENCE; Schema: jenkins; Owner: postgres
--

CREATE SEQUENCE ciadmins_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ciadmins_id OWNER TO postgres;

--
-- Name: ciadmins; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE ciadmins (
    id bigint DEFAULT nextval('ciadmins_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ciadmins OWNER TO postgres;

--
-- Name: cibuilds; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE cibuilds (
    job_id bigint,
    id character varying,
    result character varying,
    number integer,
    duration bigint,
    start_tm timestamp without time zone,
    slave_id bigint
);


ALTER TABLE cibuilds OWNER TO postgres;

--
-- Name: job_id; Type: SEQUENCE; Schema: jenkins; Owner: postgres
--

CREATE SEQUENCE job_id
    START WITH 4185
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE job_id OWNER TO postgres;

--
-- Name: cijobs; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE cijobs (
    job_id bigint DEFAULT nextval('job_id'::regclass) NOT NULL,
    server_id bigint,
    name character varying,
    tm timestamp without time zone,
    url character varying
);


ALTER TABLE cijobs OWNER TO postgres;

--
-- Name: ciplugin_history; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE ciplugin_history (
    ciplugins_id bigint NOT NULL,
    ciplugin_scan_id bigint NOT NULL,
    ciservers_id bigint NOT NULL
);


ALTER TABLE ciplugin_history OWNER TO postgres;

--
-- Name: ciplugin_scans; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE ciplugin_scans (
    id bigint NOT NULL,
    scan_timedate timestamp with time zone NOT NULL
);


ALTER TABLE ciplugin_scans OWNER TO postgres;

--
-- Name: ciplugin_scans_id; Type: SEQUENCE; Schema: jenkins; Owner: postgres
--

CREATE SEQUENCE ciplugin_scans_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ciplugin_scans_id OWNER TO postgres;

--
-- Name: ciplugins_id; Type: SEQUENCE; Schema: jenkins; Owner: postgres
--

CREATE SEQUENCE ciplugins_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ciplugins_id OWNER TO postgres;

--
-- Name: ciplugins; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE ciplugins (
    id bigint DEFAULT nextval('ciplugins_id'::regclass) NOT NULL,
    name character varying,
    version character varying
);


ALTER TABLE ciplugins OWNER TO postgres;

--
-- Name: ciservers_id; Type: SEQUENCE; Schema: jenkins; Owner: postgres
--

CREATE SEQUENCE ciservers_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ciservers_id OWNER TO postgres;

--
-- Name: ciservers; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE ciservers (
    id bigint DEFAULT nextval('ciservers_id'::regclass) NOT NULL,
    master character varying,
    master_url character varying,
    cluster character varying,
    team character varying,
    admin character varying,
    spo character varying,
    comments character varying,
    active boolean DEFAULT true
);


ALTER TABLE ciservers OWNER TO postgres;

--
-- Name: slave_id; Type: SEQUENCE; Schema: jenkins; Owner: postgres
--

CREATE SEQUENCE slave_id
    START WITH 444
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE slave_id OWNER TO postgres;

--
-- Name: cislaves; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE cislaves (
    slave_id bigint DEFAULT nextval('slave_id'::regclass) NOT NULL,
    server_id bigint NOT NULL,
    slave character varying,
    ostype character varying,
    architecture character varying,
    displayname character varying
);


ALTER TABLE cislaves OWNER TO postgres;

--
-- Name: ciserver overview; Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW "ciserver overview" AS
 WITH a AS (
         SELECT cibuilds.job_id,
            cibuilds.id,
            cibuilds.result,
            cibuilds.number,
            cibuilds.duration,
            cibuilds.start_tm,
            cibuilds.slave_id,
            cijobs.server_id,
            cijobs.name,
            cijobs.tm,
            cijobs.url
           FROM (cibuilds
             LEFT JOIN cijobs USING (job_id))
        ), b AS (
         SELECT a.server_id,
            count(*) AS "# builds",
            min(a.start_tm) AS earliest,
            max(a.start_tm) AS latest
           FROM a
          GROUP BY a.server_id
        ), c AS (
         SELECT cijobs.server_id,
            count(*) AS "# jobs"
           FROM cijobs
          GROUP BY cijobs.server_id
        ), d AS (
         SELECT cislaves.server_id,
            count(*) AS "# slaves"
           FROM cislaves
          GROUP BY cislaves.server_id
        ), e AS (
         SELECT z.master,
            z.active,
            d."# slaves",
            c."# jobs",
            b.earliest,
            b.latest,
            b."# builds"
           FROM (((b
             LEFT JOIN ciservers z ON ((z.id = b.server_id)))
             LEFT JOIN c USING (server_id))
             LEFT JOIN d USING (server_id))
          ORDER BY b.server_id
        )
 SELECT e.master,
    e.active,
    e."# slaves",
    e."# jobs",
    e.earliest,
    e.latest,
    e."# builds"
   FROM e;


ALTER TABLE "ciserver overview" OWNER TO postgres;

--
-- Name: ciserver-overview; Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW "ciserver-overview" AS
 WITH a AS (
         SELECT cibuilds.job_id,
            cibuilds.id,
            cibuilds.result,
            cibuilds.number,
            cibuilds.duration,
            cibuilds.start_tm,
            cibuilds.slave_id,
            cijobs.server_id,
            cijobs.name,
            cijobs.tm,
            cijobs.url
           FROM (cibuilds
             LEFT JOIN cijobs USING (job_id))
        ), b AS (
         SELECT a.server_id,
            count(*) AS "# builds",
            min(a.start_tm) AS start,
            max(a.start_tm) AS "end"
           FROM a
          GROUP BY a.server_id
        ), c AS (
         SELECT cijobs.server_id,
            count(*) AS "# jobs"
           FROM cijobs
          GROUP BY cijobs.server_id
        ), d AS (
         SELECT cislaves.server_id,
            count(*) AS "# slaves"
           FROM cislaves
          GROUP BY cislaves.server_id
        ), e AS (
         SELECT z.master,
            d."# slaves",
            c."# jobs",
            b.start,
            b."end",
            b."# builds",
            z.active
           FROM (((b
             LEFT JOIN ciservers z ON ((z.id = b.server_id)))
             LEFT JOIN c USING (server_id))
             LEFT JOIN d USING (server_id))
          ORDER BY b.server_id
        )
 SELECT e.master,
    e."# slaves",
    e."# jobs",
    e.start,
    e."end",
    e."# builds",
    e.active
   FROM e;


ALTER TABLE "ciserver-overview" OWNER TO postgres;

--
-- Name: ciserver_status; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE ciserver_status (
    server_id bigint NOT NULL,
    datetime timestamp with time zone,
    status boolean
);


ALTER TABLE ciserver_status OWNER TO postgres;

--
-- Name: ciserver-status; Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW "ciserver-status" AS
 WITH a0 AS (
         SELECT max(ciserver_status.datetime) AS datetime,
            ciserver_status.server_id
           FROM ciserver_status
          GROUP BY ciserver_status.server_id
        ), a1 AS (
         SELECT z.server_id,
            z.datetime,
            z.status
           FROM (a0
             LEFT JOIN ciserver_status z ON (((z.server_id = a0.server_id) AND (z.datetime = a0.datetime))))
        )
 SELECT a1.server_id,
    a1.datetime,
    a1.status
   FROM a1
  ORDER BY a1.server_id;


ALTER TABLE "ciserver-status" OWNER TO postgres;

--
-- Name: ciserver_info; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE ciserver_info (
    ciplugin_scans_id bigint,
    ciservers_id bigint,
    server_versions_id bigint NOT NULL
);


ALTER TABLE ciserver_info OWNER TO postgres;

--
-- Name: cislave-scans; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE "cislave-scans" (
    slave_id bigint,
    tm timestamp without time zone,
    availablephysicalmemory bigint,
    availableswapspace bigint,
    totalphysicalmemory bigint,
    totalswapspace bigint,
    architecturemonitor character varying,
    responsetimemonitoraverage bigint,
    temporaryspacemonitorpath character varying,
    temporaryspacemonitorsize bigint,
    diskspacemonitorpath character varying,
    diskspacemonitorsize bigint,
    numexecutors integer,
    offline boolean,
    offlinecausereason character varying
);


ALTER TABLE "cislave-scans" OWNER TO postgres;

--
-- Name: current_ciadmins; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE current_ciadmins (
    date date,
    ciservers_id bigint NOT NULL,
    ciadmins_id bigint NOT NULL
);


ALTER TABLE current_ciadmins OWNER TO postgres;

--
-- Name: jenkins-resources; Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW "jenkins-resources" AS
 SELECT DISTINCT y.master,
    z.slave,
    x.ipaddr,
    y.master_url,
    y.spo,
    y.admin
   FROM ((cislaves z
     LEFT JOIN ciservers y ON ((y.id = z.server_id)))
     LEFT JOIN buildlog.hosts x ON (((x.host)::text = (z.slave)::text)))
  WHERE ((((z.slave)::text ~~* 'CI-CPBE-%'::text) OR ((z.slave)::text ~~* 'CI-VNX-slave-%'::text) OR ((z.slave)::text ~~* 'CI-RHEL-slave-%'::text) OR ((z.slave)::text ~~* 'CI-SLES12-slave-%'::text)) AND ((y.master)::text ~~* 'ci-server-%'::text))
  ORDER BY y.master, z.slave;


ALTER TABLE "jenkins-resources" OWNER TO postgres;

--
-- Name: plugins-summary; Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW "plugins-summary" AS
 SELECT scan.scan_timedate,
    plugins.name,
    plugins.version,
    server.master,
    server.master_url,
    server.team,
    server.admin
   FROM (((ciplugin_scans scan
     JOIN ciplugin_history hist ON ((scan.id = hist.ciplugin_scan_id)))
     JOIN ciplugins plugins ON ((plugins.id = hist.ciplugins_id)))
     JOIN ciservers server ON ((server.id = hist.ciservers_id)))
  ORDER BY scan.scan_timedate DESC;


ALTER TABLE "plugins-summary" OWNER TO postgres;

--
-- Name: rawbuilds; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE rawbuilds (
    server_id bigint,
    tm timestamp without time zone,
    name character varying,
    id character varying,
    result character varying,
    number integer,
    duration bigint,
    run_tm character varying,
    builton character varying
);


ALTER TABLE rawbuilds OWNER TO postgres;

--
-- Name: rawjobs; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE rawjobs (
    server_id bigint,
    tm timestamp without time zone,
    name character varying,
    url character varying
);


ALTER TABLE rawjobs OWNER TO postgres;

--
-- Name: rawslaves; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE rawslaves (
    server_id bigint,
    tm timestamp without time zone,
    slave character varying,
    ostype character varying,
    architecture character varying,
    displayname character varying,
    availablephysicalmemory bigint,
    availableswapspace bigint,
    totalphysicalmemory bigint,
    totalswapspace bigint,
    architecturemonitor character varying,
    responsetimemonitoraverage bigint,
    temporaryspacemonitorpath character varying,
    temporaryspacemonitorsize bigint,
    diskspacemonitorpath character varying,
    diskspacemonitorsize bigint,
    numexecutors integer,
    offline boolean,
    offlinecausereason character varying
);


ALTER TABLE rawslaves OWNER TO postgres;

--
-- Name: results_overview; Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW results_overview AS
 WITH b2 AS (
         SELECT b_1.job_id,
            max(b_1.start_tm) AS latest_tm
           FROM cibuilds b_1
          GROUP BY b_1.job_id
        )
 SELECT j.job_id,
    j.name,
    s.team,
    j.url,
    b.result,
    b2.latest_tm
   FROM ciservers s,
    cijobs j,
    b2,
    cibuilds b
  WHERE ((b2.job_id = j.job_id) AND (((j.name)::text ~~ '%Test%'::text) OR ((j.name)::text ~~ '%TEST%'::text) OR ((j.name)::text ~~ '%test%'::text)) AND (j.server_id = s.id) AND (s.id <> 10) AND ((b.start_tm = b2.latest_tm) AND (b.job_id = b2.job_id)))
  ORDER BY b2.latest_tm DESC, b2.job_id DESC;


ALTER TABLE results_overview OWNER TO postgres;

--
-- Name: server build counts (xtab); Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW "server build counts (xtab)" AS
 SELECT crosstab.date,
    (crosstab."Virtualization")::bigint AS "Virtualization",
    (crosstab."Production Test Farm")::bigint AS "Production Test Farm",
    (crosstab."Platform Bring-up")::bigint AS "Platform Bring-up",
    (crosstab."Client Framework")::bigint AS "Client Framework",
    (crosstab."Dev Enablement")::bigint AS "Dev Enablement",
    (crosstab."Client Interop")::bigint AS "Client Interop",
    (crosstab."Serviceability")::bigint AS "Serviceability",
    (crosstab."Product Integration Engineering")::bigint AS "Product Integration Engineering",
    (crosstab."Unity CBE")::bigint AS "Unity CBE",
    (crosstab."CloudIQ")::bigint AS "CloudIQ",
    (crosstab."Data Mobility")::bigint AS "Data Mobility",
    (crosstab."CSX Development Cluster")::bigint AS "CSX Development Cluster",
    (crosstab."Cyclone")::bigint AS "Cyclone"
   FROM public.crosstab('
select "date"
     , team
     , "# builds"
  from jenkins."server utilization"
 order by "date"
 '::text, '
select * from (values
        (''Virtualization'')
      , (''Production Test Farm'')
      , (''Platform Bring-up'')
      , (''Client Framework'')
      , (''Dev Enablement'')
      , (''Client Interop'')
      , (''Serviceability'')
      , (''Product Integration Engineering'')
      , (''Unity CBE'')
      , (''CloudIQ'')
      , (''Data Mobility'')
      , (''CSX Development Cluster'')
      , (''Cyclone'')
     ) x(master)
 '::text) crosstab(date date, "Virtualization" character varying, "Production Test Farm" character varying, "Platform Bring-up" character varying, "Client Framework" character varying, "Dev Enablement" character varying, "Client Interop" character varying, "Serviceability" character varying, "Product Integration Engineering" character varying, "Unity CBE" character varying, "CloudIQ" character varying, "Data Mobility" character varying, "CSX Development Cluster" character varying, "Cyclone" character varying);


ALTER TABLE "server build counts (xtab)" OWNER TO postgres;

--
-- Name: server utilization; Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW "server utilization" AS
 WITH a AS (
         SELECT cijobs.server_id,
            cibuilds.result,
            cibuilds.duration,
                CASE
                    WHEN (cibuilds.start_tm IS NULL) THEN (now())::date
                    ELSE (cibuilds.start_tm)::date
                END AS date
           FROM (cibuilds
             LEFT JOIN cijobs USING (job_id))
        ), b AS (
         SELECT a.server_id,
            a.date,
            count(*) AS "# builds",
            (sum(a.duration))::bigint AS utilization
           FROM a
          WHERE ((a.result)::text = 'SUCCESS'::text)
          GROUP BY a.server_id, a.date
        ), e AS (
         SELECT b.date,
            z.master,
            z.team,
            b."# builds",
            b.utilization
           FROM (b
             LEFT JOIN ciservers z ON ((z.id = b.server_id)))
          WHERE (z.active = true)
          ORDER BY b.date, b.server_id
        )
 SELECT e.date,
    e.master,
    e.team,
    e."# builds",
    e.utilization
   FROM e;


ALTER TABLE "server utilization" OWNER TO postgres;

--
-- Name: server utilization (xtab); Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW "server utilization (xtab)" AS
 SELECT crosstab.date,
    crosstab."Virtualization",
    crosstab."Production Test Farm",
    crosstab."Platform Bring-up",
    crosstab."Client Framework",
    crosstab."Dev Enablement",
    crosstab."Client Interop",
    crosstab."Serviceability",
    crosstab."Product Integration Engineering",
    crosstab."Unity CBE",
    crosstab."CloudIQ",
    crosstab."Data Mobility",
    crosstab."CSX Development Cluster",
    crosstab."Cyclone"
   FROM public.crosstab('
select "date"
     , team
     , utilization
  from jenkins."server utilization"
 order by "date"
 '::text, '
select * from (values
        (''Virtualization'')
      , (''Production Test Farm'')
      , (''Platform Bring-up'')
      , (''Client Framework'')
      , (''Dev Enablement'')
      , (''Client Interop'')
      , (''Serviceability'')
      , (''Product Integration Engineering'')
      , (''Unity CBE'')
      , (''CloudIQ'')
      , (''Data Mobility'')
      , (''CSX Development Cluster'')
      , (''Cyclone'')
     ) x(master)
 '::text) crosstab(date date, "Virtualization" bigint, "Production Test Farm" bigint, "Platform Bring-up" bigint, "Client Framework" bigint, "Dev Enablement" bigint, "Client Interop" bigint, "Serviceability" bigint, "Product Integration Engineering" bigint, "Unity CBE" bigint, "CloudIQ" bigint, "Data Mobility" bigint, "CSX Development Cluster" bigint, "Cyclone" bigint);


ALTER TABLE "server utilization (xtab)" OWNER TO postgres;

--
-- Name: server_versions_id; Type: SEQUENCE; Schema: jenkins; Owner: postgres
--

CREATE SEQUENCE server_versions_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE server_versions_id OWNER TO postgres;

--
-- Name: server_versions; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE server_versions (
    id bigint DEFAULT nextval('server_versions_id'::regclass) NOT NULL,
    version character varying
);


ALTER TABLE server_versions OWNER TO postgres;

--
-- Name: tmp_plugins; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE tmp_plugins (
    ciservers_id bigint,
    name character varying,
    version character varying
);


ALTER TABLE tmp_plugins OWNER TO postgres;

--
-- Name: tmp_scan_timedate; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE tmp_scan_timedate (
    id bigint DEFAULT nextval('ciplugin_scans_id'::regclass) NOT NULL,
    scan_timedate timestamp with time zone
);


ALTER TABLE tmp_scan_timedate OWNER TO postgres;

--
-- Name: tmp_server_versions; Type: TABLE; Schema: jenkins; Owner: postgres
--

CREATE TABLE tmp_server_versions (
    ciservers_id bigint,
    version character varying
);


ALTER TABLE tmp_server_versions OWNER TO postgres;

--
-- Name: weekly-job-summary; Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW "weekly-job-summary" AS
 WITH a AS (
         SELECT x.master,
            y.name,
            public.startofweek(z.start_tm) AS startofweek,
            z.result,
            z.duration
           FROM ((cibuilds z
             LEFT JOIN cijobs y ON ((z.job_id = y.job_id)))
             LEFT JOIN ciservers x ON ((y.server_id = x.id)))
        ), b AS (
         SELECT a.master,
            a.name,
            count(*) AS pass,
            sum(a.duration) AS duration,
            a.startofweek AS week
           FROM a
          WHERE ((a.result)::text = 'SUCCESS'::text)
          GROUP BY a.master, a.name, a.startofweek
        ), c AS (
         SELECT a.master,
            a.name,
            count(*) AS fail,
            sum(a.duration) AS duration,
            a.startofweek AS week
           FROM a
          WHERE ((a.result)::text = 'FAILURE'::text)
          GROUP BY a.master, a.name, a.startofweek
        ), d AS (
         SELECT b.master,
            b.name,
            ((b.duration || ' seconds'::text))::interval AS duration,
            b.week,
            COALESCE(b.pass, (0)::bigint) AS pass,
            COALESCE(c.fail, (0)::bigint) AS fail,
            (COALESCE(b.pass, (0)::bigint) + COALESCE(c.fail, (0)::bigint)) AS builds
           FROM (b
             LEFT JOIN c ON ((((b.master)::text = (c.master)::text) AND ((b.name)::text = (c.name)::text) AND (b.week = c.week))))
        )
 SELECT d.master,
    d.name,
    d.duration,
    d.week,
    d.pass,
    d.fail,
    d.builds
   FROM d;


ALTER TABLE "weekly-job-summary" OWNER TO postgres;

--
-- Name: weekly-server-summary; Type: VIEW; Schema: jenkins; Owner: postgres
--

CREATE VIEW "weekly-server-summary" AS
 SELECT x.master,
    count(*) AS "# jobs",
    min(z.start_tm) AS earliest,
    max(z.start_tm) AS latest
   FROM ((cibuilds z
     LEFT JOIN cijobs y ON ((y.job_id = z.job_id)))
     LEFT JOIN ciservers x ON ((x.id = y.server_id)))
  GROUP BY x.master
  ORDER BY x.master;


ALTER TABLE "weekly-server-summary" OWNER TO postgres;

SET search_path = jenkinslogger, pg_catalog;

--
-- Name: baseresults_id; Type: SEQUENCE; Schema: jenkinslogger; Owner: postgres
--

CREATE SEQUENCE baseresults_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE baseresults_id OWNER TO postgres;

--
-- Name: baseresults; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE baseresults (
    id bigint DEFAULT nextval('baseresults_id'::regclass) NOT NULL,
    tm timestamp without time zone,
    name character varying,
    url character varying,
    full_url character varying,
    number integer,
    phase_time timestamp without time zone,
    phase character varying,
    build_url character varying,
    hostname character varying,
    job_name character varying,
    status character varying
);


ALTER TABLE baseresults OWNER TO postgres;

--
-- Name: etlresults; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE etlresults (
    start_id bigint,
    cmplt_id bigint,
    final_id bigint,
    duration interval,
    parameter_count integer,
    artifact_count integer
);


ALTER TABLE etlresults OWNER TO postgres;

--
-- Name: ExcelMetrics; Type: VIEW; Schema: jenkinslogger; Owner: postgres
--

CREATE VIEW "ExcelMetrics" AS
 WITH start AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.name,
            baseresults.url,
            baseresults.full_url,
            baseresults.number,
            baseresults.phase_time,
            baseresults.phase,
            baseresults.build_url,
            baseresults.hostname,
            baseresults.job_name,
            baseresults.status
           FROM baseresults
        ), cmplt AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.name,
            baseresults.url,
            baseresults.full_url,
            baseresults.number,
            baseresults.phase_time,
            baseresults.phase,
            baseresults.build_url,
            baseresults.hostname,
            baseresults.job_name,
            baseresults.status
           FROM baseresults
        ), final AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.name,
            baseresults.url,
            baseresults.full_url,
            baseresults.number,
            baseresults.phase_time,
            baseresults.phase,
            baseresults.build_url,
            baseresults.hostname,
            baseresults.job_name,
            baseresults.status
           FROM baseresults
        ), rslts AS (
         SELECT etlresults.start_id,
            etlresults.cmplt_id,
            etlresults.final_id,
            (((date_part('day'::text, etlresults.duration) + (date_part('hour'::text, etlresults.duration) / (24.0)::double precision)) + (date_part('min'::text, etlresults.duration) / (1440.0)::double precision)) + (date_part('sec'::text, etlresults.duration) / (86400.0)::double precision)) AS duration,
            etlresults.parameter_count,
            etlresults.artifact_count,
            start.tm AS start_tm,
            cmplt.tm AS cmplt_tm,
            final.tm AS final_tm,
            start.name,
            start.url,
            start.full_url,
            start.number,
            start.phase_time AS phase_start,
            cmplt.phase_time AS phase_cmplt,
            final.phase_time AS phase_final,
            start.build_url,
            start.hostname,
            start.job_name,
            final.status,
            date(start.tm) AS date,
            ((date(start.tm) - (date_part('dow'::text, start.tm) * '1 day'::interval)) + '6 days 23:59:59.99'::interval) AS week
           FROM (((etlresults
             LEFT JOIN start ON ((etlresults.start_id = start.id)))
             LEFT JOIN cmplt ON ((etlresults.cmplt_id = cmplt.id)))
             LEFT JOIN final ON ((etlresults.final_id = final.id)))
          ORDER BY start.id DESC
         LIMIT 1048574
        )
 SELECT rslts.start_id,
    rslts.cmplt_id,
    rslts.final_id,
    rslts.duration,
    rslts.parameter_count,
    rslts.artifact_count,
    rslts.start_tm,
    rslts.cmplt_tm,
    rslts.final_tm,
    rslts.name,
    rslts.url,
    rslts.full_url,
    rslts.number,
    rslts.phase_start,
    rslts.phase_cmplt,
    rslts.phase_final,
    rslts.build_url,
    rslts.hostname,
    rslts.job_name,
    rslts.status,
    rslts.date,
    rslts.week
   FROM rslts
  ORDER BY rslts.start_id;


ALTER TABLE "ExcelMetrics" OWNER TO postgres;

--
-- Name: artifacts; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE artifacts (
    id bigint,
    artifact character varying,
    url character varying
);


ALTER TABLE artifacts OWNER TO postgres;

--
-- Name: ExcelMetricsArtifacts; Type: VIEW; Schema: jenkinslogger; Owner: postgres
--

CREATE VIEW "ExcelMetricsArtifacts" AS
 WITH start AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.name,
            baseresults.url,
            baseresults.full_url,
            baseresults.number,
            baseresults.phase_time,
            baseresults.phase,
            baseresults.build_url,
            baseresults.hostname,
            baseresults.job_name,
            baseresults.status
           FROM baseresults
        ), cmplt AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.name,
            baseresults.url,
            baseresults.full_url,
            baseresults.number,
            baseresults.phase_time,
            baseresults.phase,
            baseresults.build_url,
            baseresults.hostname,
            baseresults.job_name,
            baseresults.status
           FROM baseresults
        ), final AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.name,
            baseresults.url,
            baseresults.full_url,
            baseresults.number,
            baseresults.phase_time,
            baseresults.phase,
            baseresults.build_url,
            baseresults.hostname,
            baseresults.job_name,
            baseresults.status
           FROM baseresults
        ), rslts AS (
         SELECT etlresults.start_id,
            etlresults.cmplt_id,
            etlresults.final_id,
            etlresults.duration,
            etlresults.parameter_count,
            etlresults.artifact_count,
            start.tm AS start_tm,
            cmplt.tm AS cmplt_tm,
            final.tm AS final_tm,
            start.name,
            start.url,
            start.full_url,
            start.number,
            start.phase_time AS phase_start,
            cmplt.phase_time AS phase_cmplt,
            final.phase_time AS phase_final,
            start.build_url,
            start.hostname,
            start.job_name,
            final.status,
            artifacts.artifact,
            artifacts.url AS artifacts_url,
            ((date(start.tm) - (date_part('dow'::text, start.tm) * '1 day'::interval)) + '6 days 23:59:59.99'::interval) AS week
           FROM ((((etlresults
             LEFT JOIN start ON ((etlresults.start_id = start.id)))
             LEFT JOIN cmplt ON ((etlresults.cmplt_id = cmplt.id)))
             LEFT JOIN final ON ((etlresults.final_id = final.id)))
             LEFT JOIN artifacts ON ((artifacts.id = final.id)))
          ORDER BY start.id DESC
         LIMIT 1048574
        )
 SELECT rslts.start_id,
    rslts.cmplt_id,
    rslts.final_id,
    rslts.duration,
    rslts.parameter_count,
    rslts.artifact_count,
    rslts.start_tm,
    rslts.cmplt_tm,
    rslts.final_tm,
    rslts.name,
    rslts.url,
    rslts.full_url,
    rslts.number,
    rslts.phase_start,
    rslts.phase_cmplt,
    rslts.phase_final,
    rslts.build_url,
    rslts.hostname,
    rslts.job_name,
    rslts.status,
    rslts.artifact,
    rslts.artifacts_url,
    rslts.week
   FROM rslts
  ORDER BY rslts.start_id;


ALTER TABLE "ExcelMetricsArtifacts" OWNER TO postgres;

--
-- Name: parameters; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE parameters (
    id bigint NOT NULL,
    param character varying,
    value character varying
);


ALTER TABLE parameters OWNER TO postgres;

--
-- Name: ExcelMetricsParameters; Type: VIEW; Schema: jenkinslogger; Owner: postgres
--

CREATE VIEW "ExcelMetricsParameters" AS
 WITH accurev_stream AS (
         SELECT parameters.id,
            parameters.value AS accurev_stream
           FROM parameters
          WHERE ((parameters.param)::text = 'ACCUREV_STREAM'::text)
        ), build_flavor AS (
         SELECT parameters.id,
            parameters.value AS build_flavor
           FROM parameters
          WHERE ((parameters.param)::text = 'BUILD_FLAVOR'::text)
        ), build_redhat AS (
         SELECT parameters.id,
            parameters.value AS build_redhat
           FROM parameters
          WHERE ((parameters.param)::text = 'BUILD_REDHAT'::text)
        ), build_suse AS (
         SELECT parameters.id,
            parameters.value AS build_suse
           FROM parameters
          WHERE ((parameters.param)::text = 'BUILD_SUSE'::text)
        ), build_windows AS (
         SELECT parameters.id,
            parameters.value AS build_windows
           FROM parameters
          WHERE ((parameters.param)::text = 'BUILD_WINDOWS'::text)
        ), testtype AS (
         SELECT parameters.id,
            parameters.value AS testtype
           FROM parameters
          WHERE ((parameters.param)::text = 'TESTTYPE'::text)
        ), framework AS (
         SELECT parameters.id,
            parameters.value AS framework
           FROM parameters
          WHERE ((parameters.param)::text = 'FRAMEWORK'::text)
        ), pool_type AS (
         SELECT parameters.id,
            parameters.value AS pool_type
           FROM parameters
          WHERE ((parameters.param)::text = 'POOL_TYPE'::text)
        ), autox_testbed AS (
         SELECT parameters.id,
            parameters.value AS autox_testbed
           FROM parameters
          WHERE ((parameters.param)::text = 'AUTOX_TESTBED'::text)
        ), asset_id AS (
         SELECT parameters.id,
            parameters.value AS asset_id
           FROM parameters
          WHERE ((parameters.param)::text = 'ASSET_ID'::text)
        ), autox_testset AS (
         SELECT parameters.id,
            parameters.value AS autox_testset
           FROM parameters
          WHERE ((parameters.param)::text = 'AUTOX_TESTSET'::text)
        ), autox_user AS (
         SELECT parameters.id,
            parameters.value AS autox_user
           FROM parameters
          WHERE ((parameters.param)::text = 'AUTOX_USER'::text)
        ), params AS (
         SELECT accurev_stream.id,
            accurev_stream.accurev_stream,
            build_flavor.build_flavor,
            build_redhat.build_redhat,
            build_suse.build_suse,
            build_windows.build_windows,
            testtype.testtype,
            framework.framework,
            pool_type.pool_type,
            autox_testbed.autox_testbed,
            asset_id.asset_id,
            autox_testset.autox_testset,
            autox_user.autox_user
           FROM (((((((((((accurev_stream
             LEFT JOIN build_flavor USING (id))
             LEFT JOIN build_redhat USING (id))
             LEFT JOIN build_suse USING (id))
             LEFT JOIN build_windows USING (id))
             LEFT JOIN testtype USING (id))
             LEFT JOIN framework USING (id))
             LEFT JOIN pool_type USING (id))
             LEFT JOIN autox_testbed USING (id))
             LEFT JOIN asset_id USING (id))
             LEFT JOIN autox_testset USING (id))
             LEFT JOIN autox_user USING (id))
        ), start AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.name,
            baseresults.url,
            baseresults.full_url,
            baseresults.number,
            baseresults.phase_time,
            baseresults.phase,
            baseresults.build_url,
            baseresults.hostname,
            baseresults.job_name,
            baseresults.status
           FROM baseresults
        ), cmplt AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.name,
            baseresults.url,
            baseresults.full_url,
            baseresults.number,
            baseresults.phase_time,
            baseresults.phase,
            baseresults.build_url,
            baseresults.hostname,
            baseresults.job_name,
            baseresults.status
           FROM baseresults
        ), final AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.name,
            baseresults.url,
            baseresults.full_url,
            baseresults.number,
            baseresults.phase_time,
            baseresults.phase,
            baseresults.build_url,
            baseresults.hostname,
            baseresults.job_name,
            baseresults.status
           FROM baseresults
        ), rslts AS (
         SELECT (((date_part('day'::text, z.duration) + (date_part('hour'::text, z.duration) / (24.0)::double precision)) + (date_part('min'::text, z.duration) / (1440.0)::double precision)) + (date_part('sec'::text, z.duration) / (86400.0)::double precision)) AS duration,
            date(start.tm) AS date,
            ((date(start.tm) - (date_part('dow'::text, start.tm) * '1 day'::interval)) + '6 days 23:59:59.99'::interval) AS week,
            z.start_id,
            z.cmplt_id,
            z.final_id,
            z.parameter_count,
            z.artifact_count,
            start.tm AS start_tm,
            cmplt.tm AS cmplt_tm,
            final.tm AS final_tm,
            start.name,
            start.url,
            start.full_url,
            start.number,
            start.phase_time AS phase_start,
            cmplt.phase_time AS phase_cmplt,
            final.phase_time AS phase_final,
            start.build_url,
            start.hostname,
            start.job_name,
            final.status,
            params.accurev_stream,
            params.build_flavor,
            params.build_redhat,
            params.build_suse,
            params.build_windows,
            params.testtype,
            params.framework,
            params.pool_type,
            params.autox_testbed,
            params.asset_id,
            params.autox_testset,
            params.autox_user
           FROM ((((etlresults z
             LEFT JOIN start ON ((start.id = z.start_id)))
             LEFT JOIN cmplt ON ((cmplt.id = z.cmplt_id)))
             LEFT JOIN final ON ((final.id = z.final_id)))
             LEFT JOIN params ON ((params.id = z.final_id)))
        ), rslts1 AS (
         SELECT rslts_1.duration,
            rslts_1.date,
            rslts_1.week,
            rslts_1.start_id,
            rslts_1.cmplt_id,
            rslts_1.final_id,
            rslts_1.parameter_count,
            rslts_1.artifact_count,
            rslts_1.start_tm,
            rslts_1.cmplt_tm,
            rslts_1.final_tm,
            rslts_1.name,
            rslts_1.url,
            rslts_1.full_url,
            rslts_1.number,
            rslts_1.phase_start,
            rslts_1.phase_cmplt,
            rslts_1.phase_final,
            rslts_1.build_url,
            rslts_1.hostname,
            rslts_1.job_name,
            rslts_1.status,
            rslts_1.accurev_stream,
            rslts_1.build_flavor,
            rslts_1.build_redhat,
            rslts_1.build_suse,
            rslts_1.build_windows,
            rslts_1.testtype,
            rslts_1.framework,
            rslts_1.pool_type,
            rslts_1.autox_testbed,
            rslts_1.asset_id,
            rslts_1.autox_testset,
            rslts_1.autox_user
           FROM rslts rslts_1
          ORDER BY rslts_1.start_id DESC
         LIMIT 1048574
        )
 SELECT rslts.duration,
    rslts.date,
    rslts.week,
    rslts.start_id,
    rslts.cmplt_id,
    rslts.final_id,
    rslts.parameter_count,
    rslts.artifact_count,
    rslts.start_tm,
    rslts.cmplt_tm,
    rslts.final_tm,
    rslts.name,
    rslts.url,
    rslts.full_url,
    rslts.number,
    rslts.phase_start,
    rslts.phase_cmplt,
    rslts.phase_final,
    rslts.build_url,
    rslts.hostname,
    rslts.job_name,
    rslts.status,
    rslts.accurev_stream,
    rslts.build_flavor,
    rslts.build_redhat,
    rslts.build_suse,
    rslts.build_windows,
    rslts.testtype,
    rslts.framework,
    rslts.pool_type,
    rslts.autox_testbed,
    rslts.asset_id,
    rslts.autox_testset,
    rslts.autox_user
   FROM rslts
  WHERE ((rslts.accurev_stream)::text = 'upc-PFDC-cs'::text)
  ORDER BY rslts.start_id;


ALTER TABLE "ExcelMetricsParameters" OWNER TO postgres;

--
-- Name: activityflow; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE activityflow (
    id bigint NOT NULL,
    job_id bigint NOT NULL,
    job_type character varying(8) NOT NULL,
    type_id bigint NOT NULL,
    cell_id bigint NOT NULL,
    equipment_id bigint NOT NULL,
    activity_scope text NOT NULL,
    activity_purpose text,
    external_id text,
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone NOT NULL,
    status character varying(16),
    created timestamp without time zone NOT NULL,
    updated timestamp without time zone NOT NULL
);


ALTER TABLE activityflow OWNER TO postgres;

--
-- Name: array_association; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE array_association (
    id bigint,
    jenkinscluster_id bigint,
    pool_id bigint,
    array_id bigint,
    testbed_id bigint
);


ALTER TABLE array_association OWNER TO postgres;

--
-- Name: arrays; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE arrays (
    id bigint,
    arrayname character varying,
    testbedpath character varying,
    reservedby character varying
);


ALTER TABLE arrays OWNER TO postgres;

--
-- Name: builddefinitions; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE builddefinitions (
    id bigint NOT NULL,
    parent_id bigint NOT NULL,
    name text NOT NULL,
    type character varying(8),
    target text,
    options text,
    srcpath text,
    logpath text,
    owner bigint NOT NULL,
    created timestamp without time zone NOT NULL,
    updated timestamp without time zone NOT NULL
);


ALTER TABLE builddefinitions OWNER TO postgres;

--
-- Name: celldefinition; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE celldefinition (
    id bigint NOT NULL,
    parent_id bigint NOT NULL,
    name text NOT NULL,
    description text,
    created timestamp without time zone NOT NULL,
    updated timestamp without time zone NOT NULL
);


ALTER TABLE celldefinition OWNER TO postgres;

--
-- Name: equipmentdefinition; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE equipmentdefinition (
    id bigint NOT NULL,
    parent_id bigint,
    class_name text NOT NULL,
    name text NOT NULL,
    description text,
    asset_id text,
    server_id text,
    created timestamp without time zone NOT NULL,
    updated timestamp without time zone NOT NULL
);


ALTER TABLE equipmentdefinition OWNER TO postgres;

--
-- Name: jenkinscluster; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE jenkinscluster (
    id bigint,
    master character varying,
    ca_name character varying,
    admin character varying
);


ALTER TABLE jenkinscluster OWNER TO postgres;

--
-- Name: jobdefinitions; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE jobdefinitions (
    id bigint NOT NULL,
    parent_id bigint NOT NULL,
    name text NOT NULL,
    description text,
    type character varying(8) NOT NULL,
    tsl bigint NOT NULL,
    tslname character varying(16) NOT NULL,
    owner bigint NOT NULL,
    created timestamp without time zone NOT NULL,
    updated timestamp without time zone NOT NULL
);


ALTER TABLE jobdefinitions OWNER TO postgres;

--
-- Name: pools; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE pools (
    id bigint,
    poolname character varying
);


ALTER TABLE pools OWNER TO postgres;

--
-- Name: testbeds; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE testbeds (
    id bigint,
    testbedpath character varying
);


ALTER TABLE testbeds OWNER TO postgres;

--
-- Name: testdefinitions; Type: TABLE; Schema: jenkinslogger; Owner: postgres
--

CREATE TABLE testdefinitions (
    id bigint NOT NULL,
    parent_id bigint NOT NULL,
    name text NOT NULL,
    utms_link text,
    utms_id text,
    owner bigint NOT NULL,
    created timestamp without time zone NOT NULL,
    updated timestamp without time zone NOT NULL
);


ALTER TABLE testdefinitions OWNER TO postgres;

SET search_path = jira, pg_catalog;

--
-- Name: jira_file_deletion; Type: TABLE; Schema: jira; Owner: hendrr2
--

CREATE TABLE jira_file_deletion (
    record_id uuid NOT NULL,
    name character varying NOT NULL,
    issue character varying NOT NULL,
    path character varying NOT NULL,
    owner character varying NOT NULL,
    mtime timestamp with time zone NOT NULL,
    ctime timestamp with time zone NOT NULL,
    type character varying NOT NULL,
    size bigint NOT NULL,
    rule character varying NOT NULL,
    log_time timestamp with time zone NOT NULL,
    event_time timestamp with time zone NOT NULL,
    initiator_id character varying NOT NULL,
    kafka_client_id character varying NOT NULL,
    kafka_consumer_group character varying NOT NULL,
    payload jsonb NOT NULL
);


ALTER TABLE jira_file_deletion OWNER TO hendrr2;

--
-- Name: jira_file_deletion_2018_jan_18__03_52_27_249; Type: TABLE; Schema: jira; Owner: hendrr2
--

CREATE TABLE jira_file_deletion_2018_jan_18__03_52_27_249 (
    record_id uuid NOT NULL,
    name character varying NOT NULL,
    issue character varying NOT NULL,
    path character varying NOT NULL,
    owner character varying NOT NULL,
    mtime timestamp with time zone NOT NULL,
    ctime timestamp with time zone NOT NULL,
    type character varying NOT NULL,
    rule character varying NOT NULL,
    log_time timestamp with time zone NOT NULL,
    event_time timestamp with time zone NOT NULL,
    initiator_id character varying NOT NULL,
    payload jsonb NOT NULL
);


ALTER TABLE jira_file_deletion_2018_jan_18__03_52_27_249 OWNER TO hendrr2;

--
-- Name: jira_file_deletion_2018_jan_18__15_29_37_071; Type: TABLE; Schema: jira; Owner: hendrr2
--

CREATE TABLE jira_file_deletion_2018_jan_18__15_29_37_071 (
    record_id uuid NOT NULL,
    name character varying NOT NULL,
    issue character varying NOT NULL,
    path character varying NOT NULL,
    owner character varying NOT NULL,
    mtime timestamp with time zone NOT NULL,
    ctime timestamp with time zone NOT NULL,
    type character varying NOT NULL,
    rule character varying NOT NULL,
    log_time timestamp with time zone NOT NULL,
    event_time timestamp with time zone NOT NULL,
    initiator_id character varying NOT NULL,
    payload jsonb NOT NULL
);


ALTER TABLE jira_file_deletion_2018_jan_18__15_29_37_071 OWNER TO hendrr2;

--
-- Name: jira_file_deletion_2018_jan_23__18_04_58_228; Type: TABLE; Schema: jira; Owner: hendrr2
--

CREATE TABLE jira_file_deletion_2018_jan_23__18_04_58_228 (
    record_id uuid NOT NULL,
    name character varying NOT NULL,
    issue character varying NOT NULL,
    path character varying NOT NULL,
    owner character varying NOT NULL,
    mtime timestamp with time zone NOT NULL,
    ctime timestamp with time zone NOT NULL,
    type character varying NOT NULL,
    rule character varying NOT NULL,
    log_time timestamp with time zone NOT NULL,
    event_time timestamp with time zone NOT NULL,
    initiator_id character varying NOT NULL,
    kafka_client_id character varying NOT NULL,
    kafka_consumer_group character varying NOT NULL,
    payload jsonb NOT NULL
);


ALTER TABLE jira_file_deletion_2018_jan_23__18_04_58_228 OWNER TO hendrr2;

SET search_path = netstat, pg_catalog;

--
-- Name: ix_address_id; Type: SEQUENCE; Schema: netstat; Owner: postgres
--

CREATE SEQUENCE ix_address_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_address_id OWNER TO postgres;

--
-- Name: ix_address; Type: TABLE; Schema: netstat; Owner: postgres
--

CREATE TABLE ix_address (
    id bigint DEFAULT nextval('ix_address_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_address OWNER TO postgres;

--
-- Name: ix_port_id; Type: SEQUENCE; Schema: netstat; Owner: postgres
--

CREATE SEQUENCE ix_port_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_port_id OWNER TO postgres;

--
-- Name: ix_port; Type: TABLE; Schema: netstat; Owner: postgres
--

CREATE TABLE ix_port (
    id bigint DEFAULT nextval('ix_port_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_port OWNER TO postgres;

--
-- Name: tbl_datamover_id; Type: SEQUENCE; Schema: netstat; Owner: postgres
--

CREATE SEQUENCE tbl_datamover_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tbl_datamover_id OWNER TO postgres;

--
-- Name: tbl_datamover; Type: TABLE; Schema: netstat; Owner: postgres
--

CREATE TABLE tbl_datamover (
    id bigint DEFAULT nextval('tbl_datamover_id'::regclass) NOT NULL,
    ix_proto_id bigint,
    ix_address_local_id bigint,
    ix_port_local_id bigint,
    ix_address_remote_id bigint,
    ix_port_remote_id bigint,
    ix_state_id bigint
);


ALTER TABLE tbl_datamover OWNER TO postgres;

--
-- Name: Busy DataMovers; Type: VIEW; Schema: netstat; Owner: postgres
--

CREATE VIEW "Busy DataMovers" AS
 WITH a AS (
         SELECT tbl_datamover.ix_address_local_id,
            tbl_datamover.ix_port_local_id,
            tbl_datamover.ix_address_remote_id,
            count(*) AS cnt
           FROM tbl_datamover
          GROUP BY tbl_datamover.ix_address_local_id, tbl_datamover.ix_port_local_id, tbl_datamover.ix_address_remote_id
        ), b AS (
         SELECT z1.name AS local_address,
            z2.name AS local_port,
            z3.name AS remote_address,
            a.cnt
           FROM (((a
             LEFT JOIN ix_address z1 ON ((z1.id = a.ix_address_local_id)))
             LEFT JOIN ix_port z2 ON ((z2.id = a.ix_port_local_id)))
             LEFT JOIN ix_address z3 ON ((z3.id = a.ix_address_remote_id)))
        )
 SELECT b.local_address,
    b.local_port,
    b.remote_address,
    b.cnt
   FROM b
  WHERE (b.cnt > 1)
  ORDER BY b.local_address, b.cnt DESC;


ALTER TABLE "Busy DataMovers" OWNER TO postgres;

--
-- Name: ix_proto_id; Type: SEQUENCE; Schema: netstat; Owner: postgres
--

CREATE SEQUENCE ix_proto_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_proto_id OWNER TO postgres;

--
-- Name: ix_proto; Type: TABLE; Schema: netstat; Owner: postgres
--

CREATE TABLE ix_proto (
    id bigint DEFAULT nextval('ix_proto_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_proto OWNER TO postgres;

--
-- Name: ix_state_id; Type: SEQUENCE; Schema: netstat; Owner: postgres
--

CREATE SEQUENCE ix_state_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_state_id OWNER TO postgres;

--
-- Name: ix_state; Type: TABLE; Schema: netstat; Owner: postgres
--

CREATE TABLE ix_state (
    id bigint DEFAULT nextval('ix_state_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_state OWNER TO postgres;

--
-- Name: DataMovers; Type: VIEW; Schema: netstat; Owner: postgres
--

CREATE VIEW "DataMovers" AS
 SELECT z0.name AS proto,
    z1.name AS local_address,
    z2.name AS local_port,
    z3.name AS remote_address,
    z4.name AS remote_port,
    z5.name AS state
   FROM ((((((tbl_datamover z
     LEFT JOIN ix_proto z0 ON ((z0.id = z.ix_proto_id)))
     LEFT JOIN ix_address z1 ON ((z1.id = z.ix_address_local_id)))
     LEFT JOIN ix_port z2 ON ((z2.id = z.ix_port_local_id)))
     LEFT JOIN ix_address z3 ON ((z3.id = z.ix_address_remote_id)))
     LEFT JOIN ix_port z4 ON ((z4.id = z.ix_port_remote_id)))
     LEFT JOIN ix_state z5 ON ((z5.id = z.ix_state_id)));


ALTER TABLE "DataMovers" OWNER TO postgres;

--
-- Name: rawdata; Type: TABLE; Schema: netstat; Owner: postgres
--

CREATE TABLE rawdata (
    data character varying
);


ALTER TABLE rawdata OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: Build Record Comparison; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW "Build Record Comparison" AS
 SELECT y.id,
    y.cnt
   FROM ( SELECT count(*) AS cnt,
            'tbl_ibidinfo'::text AS id
           FROM buildlog_new.tbl_ibidinfo
        UNION
         SELECT count(*) AS cnt,
            'ix_ibid'::text AS id
           FROM buildlog_new.ix_ibid
        UNION
         SELECT count(*) AS cnt,
            'tbl_results'::text AS id
           FROM ( SELECT DISTINCT tbl_results.ix_ibid_id
                   FROM buildlog_new.tbl_results) z
        UNION
         SELECT count(*) AS cnt,
            'ibidresults'::text AS id
           FROM buildlog.ibidresults
        UNION
         SELECT count(*) AS cnt,
            'ibidmaskresults'::text AS id
           FROM buildlog.ibidmaskresults
        UNION
         SELECT count(*) AS cnt,
            'ibidextended'::text AS id
           FROM buildlog.ibidextended
        UNION
         SELECT count(*) AS cnt,
            'etlresults'::text AS id
           FROM ( SELECT DISTINCT etlresults.ibid_calc
                   FROM buildlog.etlresults) y_1) y
  ORDER BY y.cnt;


ALTER TABLE "Build Record Comparison" OWNER TO postgres;

SET search_path = vcenter, pg_catalog;

--
-- Name: esxservers_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE esxservers_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE esxservers_id OWNER TO postgres;

--
-- Name: esxservers; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE esxservers (
    id integer DEFAULT nextval('esxservers_id'::regclass) NOT NULL,
    address character varying NOT NULL,
    locations_id bigint NOT NULL,
    name character varying,
    colmap integer,
    widget character varying
);


ALTER TABLE esxservers OWNER TO postgres;

--
-- Name: folders_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE folders_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE folders_id OWNER TO postgres;

--
-- Name: folders; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE folders (
    id bigint DEFAULT nextval('folders_id'::regclass) NOT NULL,
    folderid character varying NOT NULL,
    folderparentid character varying,
    name character varying NOT NULL,
    parent_id bigint,
    esxservers_id bigint NOT NULL,
    type character varying
);


ALTER TABLE folders OWNER TO postgres;

--
-- Name: guestid_types_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE guestid_types_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE guestid_types_id OWNER TO postgres;

--
-- Name: guestid_types; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE guestid_types (
    id bigint DEFAULT nextval('guestid_types_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE guestid_types OWNER TO postgres;

--
-- Name: guestos_types_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE guestos_types_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE guestos_types_id OWNER TO postgres;

--
-- Name: guestos_types; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE guestos_types (
    id bigint DEFAULT nextval('guestos_types_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE guestos_types OWNER TO postgres;

--
-- Name: server_scans_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE server_scans_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE server_scans_id OWNER TO postgres;

--
-- Name: server_scans; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE server_scans (
    id bigint DEFAULT nextval('server_scans_id'::regclass) NOT NULL,
    scan_time timestamp with time zone
);


ALTER TABLE server_scans OWNER TO postgres;

--
-- Name: vminfo_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE vminfo_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vminfo_id OWNER TO postgres;

--
-- Name: vminfo; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE vminfo (
    id bigint DEFAULT nextval('vminfo_id'::regclass) NOT NULL,
    vms_id bigint,
    server_scans_id bigint,
    folders_id bigint,
    guestos_types_id bigint,
    guestid_types_id bigint,
    hostname character varying,
    ipaddress character varying,
    notes character varying
);


ALTER TABLE vminfo OWNER TO postgres;

--
-- Name: vminfo_history; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE vminfo_history (
    vminfo_id bigint,
    server_scans_id bigint,
    powered_on boolean,
    connected boolean,
    usedspacegb real,
    freespacegb real,
    capacitygb real,
    numcpus integer,
    numnics integer,
    memory_size bigint,
    virtual_disks integer,
    tools_version character varying,
    tools_status_id integer,
    tools_cfg_version bigint,
    tools_version_status_id integer,
    tools_version_id bigint
);


ALTER TABLE vminfo_history OWNER TO postgres;

--
-- Name: vms_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE vms_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vms_id OWNER TO postgres;

--
-- Name: vms; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE vms (
    id bigint DEFAULT nextval('vms_id'::regclass) NOT NULL,
    esxservers_id bigint NOT NULL,
    name character varying,
    vmid character varying NOT NULL,
    vmpathname character varying
);


ALTER TABLE vms OWNER TO postgres;

--
-- Name: current_vms; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW current_vms AS
 WITH a0 AS (
         SELECT max(server_scans.id) AS server_scans_id
           FROM server_scans
        ), a1 AS (
         SELECT y.scan_time,
            x.vms_id,
            v.address AS esxserver,
            w.name,
            w.vmid,
            x.hostname,
            x.ipaddress,
            s.name AS folder,
            z.numcpus,
            z.numnics,
            z.memory_size,
            z.virtual_disks,
            z.capacitygb,
            u.name AS guestos,
            t.name AS guestid,
            z.powered_on
           FROM ((((((((vminfo_history z
             LEFT JOIN a0 ON ((a0.server_scans_id = z.server_scans_id)))
             LEFT JOIN server_scans y ON ((y.id = z.server_scans_id)))
             LEFT JOIN vminfo x ON ((x.id = z.vminfo_id)))
             LEFT JOIN vms w ON ((w.id = x.vms_id)))
             LEFT JOIN esxservers v ON ((v.id = w.esxservers_id)))
             LEFT JOIN guestos_types u ON ((u.id = x.guestos_types_id)))
             LEFT JOIN guestid_types t ON ((t.id = x.guestid_types_id)))
             LEFT JOIN folders s ON ((s.id = x.folders_id)))
          WHERE (z.server_scans_id = a0.server_scans_id)
        )
 SELECT a1.scan_time,
    a1.vms_id,
    a1.esxserver,
    a1.name,
    a1.vmid,
    a1.hostname,
    a1.ipaddress,
    a1.folder,
    a1.numcpus,
    a1.numnics,
    a1.memory_size,
    a1.virtual_disks,
    a1.capacitygb,
    a1.guestos,
    a1.guestid,
    a1.powered_on
   FROM a1;


ALTER TABLE current_vms OWNER TO postgres;

--
-- Name: Jenkins Servers; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW "Jenkins Servers" AS
 WITH a AS (
         SELECT public.fromraw(lower((current_vms.hostname)::text)) AS name
           FROM current_vms
          WHERE ((current_vms.hostname)::text ~* '^ci-server'::text)
        ), b AS (
         SELECT lower(a.name) AS name
           FROM a
          WHERE ((a.name IS NOT NULL) AND (a.name !~* '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'::text) AND (a.name !~* '-tmp'::text))
        ), c AS (
         SELECT split_part(b.name, '.'::text, 1) AS name
           FROM b
          WHERE (b.name IS NOT NULL)
        ), d AS (
         SELECT DISTINCT c.name
           FROM c
          WHERE (c.name IS NOT NULL)
        ), e AS (
         SELECT z.esxserver,
            d.name,
            unnest(regexp_split_to_array((z.ipaddress)::text, ','::text)) AS ipaddress,
            z1.location
           FROM (((d
             LEFT JOIN current_vms z ON (((z.hostname)::text ~* (d.name || '(\..+)*$'::text))))
             LEFT JOIN esxservers z0 ON (((z0.address)::text = (z.esxserver)::text)))
             LEFT JOIN locations z1 ON ((z1.id = z0.locations_id)))
        ), f AS (
         SELECT e.esxserver,
            e.name,
            e.ipaddress,
                CASE
                    WHEN (e.ipaddress ~* '^128.222.'::text) THEN (e.name || '.rtp.lab.emc.com'::text)
                    WHEN (e.ipaddress ~* '^10.((103)|(108)|(109)|(111)).'::text) THEN (e.name || '.drm.lab.emc.com'::text)
                    WHEN (e.ipaddress ~* '^10.244.'::text) THEN (e.name || '.usd.lab.emc.com'::text)
                    ELSE e.name
                END AS hostname,
            e.location
           FROM e
          WHERE ((e.name !~* 'Decomm'::text) AND (e.ipaddress ~* '10\.'::text))
        )
 SELECT f.esxserver,
    f.name,
    f.ipaddress,
    f.hostname,
    f.location
   FROM f
  ORDER BY f.name;


ALTER TABLE "Jenkins Servers" OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: ciservers; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW ciservers AS
 SELECT y.id,
    z.name AS master,
        CASE
            WHEN (y.id IS NULL) THEN (regexp_replace(z.name, '^.*-(\d+)\w*'::text, 'CI-Cluster-\1'::text))::character varying
            ELSE y.cluster
        END AS cluster,
    z.ipaddress,
        CASE
            WHEN (y.id IS NULL) THEN ((('http://'::text || z.hostname) || ':8080/'::text))::character varying
            ELSE y.master_url
        END AS master_url,
    true AS active
   FROM (vcenter."Jenkins Servers" z
     LEFT JOIN jenkins.ciservers y ON (((y.master)::text = z.name)));


ALTER TABLE ciservers OWNER TO postgres;

--
-- Name: daily_promotions; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW daily_promotions AS
 SELECT z.filter_id,
    z.t_id AS transaction,
    to_timestamp((z.t_time)::double precision) AS "time",
    z.ntlogin,
    w.name,
    v.rally_name,
    w.email,
    w.badgeid,
    v.ca,
    v.project,
    z.stream,
    z.domain_stream,
    z.path,
    z.vvers AS version,
    z.comments
   FROM ((accurev.promotions_daily z
     LEFT JOIN empdata.employee_data w ON ((lower((w.ntlogin)::text) = lower((z.ntlogin)::text))))
     LEFT JOIN cateams.rally_info v ON ((lower((v.email)::text) = lower((w.email)::text))))
  ORDER BY z.t_id;


ALTER TABLE daily_promotions OWNER TO postgres;

SET search_path = rally, pg_catalog;

--
-- Name: ix_domains_id; Type: SEQUENCE; Schema: rally; Owner: postgres
--

CREATE SEQUENCE ix_domains_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_domains_id OWNER TO postgres;

--
-- Name: ix_domains; Type: TABLE; Schema: rally; Owner: postgres
--

CREATE TABLE ix_domains (
    id bigint DEFAULT nextval('ix_domains_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_domains OWNER TO postgres;

--
-- Name: ix_rally_users_id; Type: SEQUENCE; Schema: rally; Owner: postgres
--

CREATE SEQUENCE ix_rally_users_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_rally_users_id OWNER TO postgres;

--
-- Name: tbl_rally_users; Type: TABLE; Schema: rally; Owner: postgres
--

CREATE TABLE tbl_rally_users (
    id bigint DEFAULT nextval('ix_rally_users_id'::regclass) NOT NULL,
    email character varying NOT NULL,
    disabled boolean,
    ix_costcenters_id bigint,
    ix_domains_id bigint,
    ix_permissions_id bigint,
    ix_projects_id bigint,
    ix_roles_id bigint
);


ALTER TABLE tbl_rally_users OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- Name: domain_info; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW domain_info AS
 WITH a AS (
         SELECT z.stream,
            z.owner,
            z.url,
            z.build_infra,
            z.comment,
            z.ntlogin,
            y.email
           FROM (accurev.domain_streams z
             LEFT JOIN empdata.employee_data y ON (((y.ntlogin)::text = (z.ntlogin)::text)))
          WHERE ((z.stream)::text ~* 'next'::text)
        ), b AS (
         SELECT DISTINCT tbl_rally_users.email,
            tbl_rally_users.ix_domains_id
           FROM rally.tbl_rally_users
          WHERE ((tbl_rally_users.email)::text IN ( SELECT a.email
                   FROM a))
        ), c AS (
         SELECT w.name AS domain,
            a.stream,
            a.owner,
            a.url,
            a.build_infra,
            a.comment,
            a.ntlogin,
            a.email
           FROM ((a
             LEFT JOIN b USING (email))
             LEFT JOIN rally.ix_domains w ON ((w.id = b.ix_domains_id)))
        )
 SELECT c.domain,
    c.stream,
    c.owner,
    c.url,
    c.build_infra,
    c.comment,
    c.ntlogin,
    c.email
   FROM c;


ALTER TABLE domain_info OWNER TO postgres;

--
-- Name: list_schema; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW list_schema AS
 SELECT n.nspname AS "Name"
   FROM pg_namespace n
  WHERE ((n.nspname !~ '^pg_'::text) AND (n.nspname <> 'information_schema'::name))
  ORDER BY n.nspname;


ALTER TABLE list_schema OWNER TO postgres;

--
-- Name: ws-adoption; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW "ws-adoption" AS
 WITH RECURSIVE a0 AS (
         SELECT z.accurev_user,
            y.week
           FROM (wscommands.baseresults z
             LEFT JOIN wscommands.etlresults y ON ((y.id = z.id)))
          WHERE ((z.accurev_user IS NOT NULL) AND ((z.accurev_user)::text <> '(not logged in)'::text))
        ), b0 AS (
         SELECT min(etlresults.week) AS begin
           FROM wscommands.etlresults
        ), c1(wk, bldusers, wsusers, delta) AS (
         SELECT b0.begin AS wk,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM buildlog.etlresults,
                            b0 b0_1
                          WHERE (etlresults.week <= b0_1.begin)) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT a0.accurev_user
                           FROM a0,
                            b0 b0_1
                          WHERE (a0.week <= b0_1.begin)) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM buildlog.etlresults,
                            b0 b0_1
                          WHERE ((etlresults.week <= b0_1.begin) AND (NOT ((etlresults.ntid)::text IN ( SELECT DISTINCT a0.accurev_user
                                   FROM a0,
                                    b0 b0_2
                                  WHERE (a0.week <= b0_2.begin)))))) z(ntid)) AS count
           FROM b0
        UNION ALL
         SELECT (c1_1.wk + '7 days'::interval) AS wk,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM buildlog.etlresults
                          WHERE (etlresults.week <= c1_1.wk)) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT a0.accurev_user
                           FROM a0
                          WHERE (a0.week <= c1_1.wk)) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM buildlog.etlresults
                          WHERE ((etlresults.week <= c1_1.wk) AND (NOT ((etlresults.ntid)::text IN ( SELECT DISTINCT a0.accurev_user
                                   FROM a0
                                  WHERE (a0.week <= c1_1.wk)))))) z(ntid)) AS count
           FROM c1 c1_1
          WHERE ((c1_1.wk)::date < startofweek((('now'::text)::date)::timestamp with time zone))
        )
 SELECT c1.wk AS "Week",
    c1.bldusers AS "Build Users",
    c1.wsusers AS "Ws Command Users",
    c1.delta AS "Delta"
   FROM c1;


ALTER TABLE "ws-adoption" OWNER TO postgres;

--
-- Name: ws-adoption2; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW "ws-adoption2" AS
 WITH RECURSIVE a0 AS (
         SELECT z.accurev_user,
            y.week
           FROM (wscommands.baseresults z
             LEFT JOIN wscommands.etlresults y ON ((y.id = z.id)))
          WHERE ((z.accurev_user IS NOT NULL) AND ((z.accurev_user)::text <> '(not logged in)'::text))
        ), b0 AS (
         SELECT min(etlresults.week) AS begin
           FROM wscommands.etlresults
        ), c1(wk, bldusers, wsusers, delta) AS (
         SELECT b0.begin AS wk,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM buildlog.etlresults,
                            b0 b0_1
                          WHERE (etlresults.week <= b0_1.begin)) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT a0.accurev_user
                           FROM a0,
                            b0 b0_1
                          WHERE (a0.week <= b0_1.begin)) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM buildlog.etlresults,
                            b0 b0_1
                          WHERE ((etlresults.week <= b0_1.begin) AND (NOT ((etlresults.ntid)::text IN ( SELECT DISTINCT a0.accurev_user
                                   FROM a0,
                                    b0 b0_2
                                  WHERE (a0.week <= b0_2.begin)))))) z(ntid)) AS count
           FROM b0
        UNION ALL
         SELECT (c1_1.wk + '7 days'::interval) AS wk,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM buildlog.etlresults
                          WHERE ((etlresults.week >= c1_1.wk) AND (etlresults.week < (c1_1.wk + '7 days'::interval)))) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT a0.accurev_user
                           FROM a0
                          WHERE ((a0.week >= c1_1.wk) AND (a0.week < (c1_1.wk + '7 days'::interval)))) z(ntid)) AS count,
            ( SELECT count(*) AS count
                   FROM ( SELECT DISTINCT etlresults.ntid
                           FROM buildlog.etlresults
                          WHERE ((etlresults.week >= c1_1.wk) AND (etlresults.week < (c1_1.wk + '7 days'::interval)) AND (NOT ((etlresults.ntid)::text IN ( SELECT DISTINCT a0.accurev_user
                                   FROM a0
                                  WHERE ((a0.week >= c1_1.wk) AND (a0.week < (c1_1.wk + '7 days'::interval)))))))) z(ntid)) AS count
           FROM c1 c1_1
          WHERE ((c1_1.wk)::date < startofweek((('now'::text)::date)::timestamp with time zone))
        )
 SELECT c1.wk AS "Week",
    c1.bldusers AS "Build Users",
    c1.wsusers AS "Ws Command Users",
    c1.delta AS "Delta"
   FROM c1;


ALTER TABLE "ws-adoption2" OWNER TO postgres;

SET search_path = rally, pg_catalog;

--
-- Name: ix_roles_id; Type: SEQUENCE; Schema: rally; Owner: postgres
--

CREATE SEQUENCE ix_roles_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_roles_id OWNER TO postgres;

--
-- Name: ix_roles; Type: TABLE; Schema: rally; Owner: postgres
--

CREATE TABLE ix_roles (
    id bigint DEFAULT nextval('ix_roles_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_roles OWNER TO postgres;

--
-- Name: Domain Product Owners; Type: VIEW; Schema: rally; Owner: postgres
--

CREATE VIEW "Domain Product Owners" AS
 SELECT z.name AS domain,
    w.name,
    w.ntlogin,
    y.email
   FROM (((ix_domains z
     LEFT JOIN tbl_rally_users y ON ((y.ix_domains_id = z.id)))
     LEFT JOIN ix_roles x ON ((y.ix_roles_id = x.id)))
     LEFT JOIN empdata.employee_data w ON ((lower((w.email)::text) = lower((y.email)::text))))
  WHERE ((x.name)::text = 'Chief Product Owner'::text)
  ORDER BY z.name;


ALTER TABLE "Domain Product Owners" OWNER TO postgres;

--
-- Name: ix_costcenters_id; Type: SEQUENCE; Schema: rally; Owner: postgres
--

CREATE SEQUENCE ix_costcenters_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_costcenters_id OWNER TO postgres;

--
-- Name: ix_costcenters; Type: TABLE; Schema: rally; Owner: postgres
--

CREATE TABLE ix_costcenters (
    id bigint DEFAULT nextval('ix_costcenters_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_costcenters OWNER TO postgres;

--
-- Name: ix_permissions_id; Type: SEQUENCE; Schema: rally; Owner: postgres
--

CREATE SEQUENCE ix_permissions_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_permissions_id OWNER TO postgres;

--
-- Name: ix_permissions; Type: TABLE; Schema: rally; Owner: postgres
--

CREATE TABLE ix_permissions (
    id bigint DEFAULT nextval('ix_permissions_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_permissions OWNER TO postgres;

--
-- Name: ix_projects_id; Type: SEQUENCE; Schema: rally; Owner: postgres
--

CREATE SEQUENCE ix_projects_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_projects_id OWNER TO postgres;

--
-- Name: ix_projects; Type: TABLE; Schema: rally; Owner: postgres
--

CREATE TABLE ix_projects (
    id bigint DEFAULT nextval('ix_projects_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_projects OWNER TO postgres;

--
-- Name: raw_rally; Type: TABLE; Schema: rally; Owner: postgres
--

CREATE TABLE raw_rally (
    domain character varying,
    project character varying,
    email character varying,
    displayname character varying,
    costcenter character varying,
    role character varying,
    subscriptionpermission character varying,
    disabled character varying
);


ALTER TABLE raw_rally OWNER TO postgres;

--
-- Name: tbl_psi_timeboxes; Type: TABLE; Schema: rally; Owner: postgres
--

CREATE TABLE tbl_psi_timeboxes (
    iteration character(6) NOT NULL,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    psi character(6)
);


ALTER TABLE tbl_psi_timeboxes OWNER TO postgres;

SET search_path = remedy, pg_catalog;

--
-- Name: ix_major_area_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_major_area_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_major_area_id OWNER TO postgres;

--
-- Name: ix_major_area; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_major_area (
    id bigint DEFAULT nextval('ix_major_area_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_major_area OWNER TO postgres;

--
-- Name: ix_ntlogin_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_ntlogin_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_ntlogin_id OWNER TO postgres;

--
-- Name: ix_ntlogin; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_ntlogin (
    id bigint DEFAULT nextval('ix_ntlogin_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_ntlogin OWNER TO postgres;

--
-- Name: ix_priority_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_priority_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_priority_id OWNER TO postgres;

--
-- Name: ix_priority; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_priority (
    id bigint DEFAULT nextval('ix_priority_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_priority OWNER TO postgres;

--
-- Name: ix_product_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_product_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_product_id OWNER TO postgres;

--
-- Name: ix_product; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_product (
    id bigint DEFAULT nextval('ix_product_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_product OWNER TO postgres;

--
-- Name: ix_product_area_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_product_area_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_product_area_id OWNER TO postgres;

--
-- Name: ix_product_area; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_product_area (
    id bigint DEFAULT nextval('ix_product_area_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_product_area OWNER TO postgres;

--
-- Name: ix_product_family_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_product_family_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_product_family_id OWNER TO postgres;

--
-- Name: ix_product_family; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_product_family (
    id bigint DEFAULT nextval('ix_product_family_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_product_family OWNER TO postgres;

--
-- Name: ix_product_release_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_product_release_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_product_release_id OWNER TO postgres;

--
-- Name: ix_product_release; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_product_release (
    id bigint DEFAULT nextval('ix_product_release_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_product_release OWNER TO postgres;

--
-- Name: ix_status_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_status_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_status_id OWNER TO postgres;

--
-- Name: ix_status; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_status (
    id bigint DEFAULT nextval('ix_status_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_status OWNER TO postgres;

--
-- Name: ix_status_details_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_status_details_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_status_details_id OWNER TO postgres;

--
-- Name: ix_status_details; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_status_details (
    id bigint DEFAULT nextval('ix_status_details_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_status_details OWNER TO postgres;

--
-- Name: ix_type_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_type_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_type_id OWNER TO postgres;

--
-- Name: ix_type; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_type (
    id bigint DEFAULT nextval('ix_type_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_type OWNER TO postgres;

--
-- Name: Current Issues; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "Current Issues" AS
 SELECT z.entryid,
    z.create_date,
    z.modified_date,
    z0.name AS "Assigned to",
    z1.name AS "Major area",
    z9.name AS priority,
    z2.name AS "Product",
    z3.name AS "Product Area",
    z4.name AS "Product Family",
    z5.name AS "Product Release",
    z6.name AS "Status",
    z7.name AS "Status Details",
    z8.name AS "Type"
   FROM ((((((((((current_issues() z(entryid, create_date, modified_date, ix_major_area_id, ix_ntlogin_assigned_to_id, ix_priority_id, ix_product_id, ix_product_area_id, ix_product_family_id, ix_product_release_id, ix_status_id, ix_status_details_id, ix_type_id)
     LEFT JOIN ix_ntlogin z0 ON ((z0.id = z.ix_ntlogin_assigned_to_id)))
     LEFT JOIN ix_major_area z1 ON ((z1.id = z.ix_major_area_id)))
     LEFT JOIN ix_product z2 ON ((z2.id = z.ix_product_id)))
     LEFT JOIN ix_product_area z3 ON ((z3.id = z.ix_product_area_id)))
     LEFT JOIN ix_product_family z4 ON ((z4.id = z.ix_product_family_id)))
     LEFT JOIN ix_product_release z5 ON ((z5.id = z.ix_product_release_id)))
     LEFT JOIN ix_status z6 ON ((z6.id = z.ix_status_id)))
     LEFT JOIN ix_status_details z7 ON ((z7.id = z.ix_status_details_id)))
     LEFT JOIN ix_type z8 ON ((z8.id = z.ix_type_id)))
     LEFT JOIN ix_priority z9 ON ((z9.id = z.ix_priority_id)))
  ORDER BY z.entryid, z.modified_date;


ALTER TABLE "Current Issues" OWNER TO postgres;

--
-- Name: ix_classification_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_classification_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_classification_id OWNER TO postgres;

--
-- Name: ix_classification; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_classification (
    id bigint DEFAULT nextval('ix_classification_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_classification OWNER TO postgres;

--
-- Name: ix_customer_impact_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_customer_impact_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_customer_impact_id OWNER TO postgres;

--
-- Name: ix_customer_impact; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_customer_impact (
    id bigint DEFAULT nextval('ix_customer_impact_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_customer_impact OWNER TO postgres;

--
-- Name: ix_employee_names_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_employee_names_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_employee_names_id OWNER TO postgres;

--
-- Name: ix_employee_names; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_employee_names (
    id bigint DEFAULT nextval('ix_employee_names_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_employee_names OWNER TO postgres;

--
-- Name: ix_escalate_reason_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_escalate_reason_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_escalate_reason_id OWNER TO postgres;

--
-- Name: ix_escalate_reason; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_escalate_reason (
    id bigint DEFAULT nextval('ix_escalate_reason_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_escalate_reason OWNER TO postgres;

--
-- Name: ix_function_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_function_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_function_id OWNER TO postgres;

--
-- Name: ix_function; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_function (
    id bigint DEFAULT nextval('ix_function_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_function OWNER TO postgres;

--
-- Name: ix_group_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_group_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_group_id OWNER TO postgres;

--
-- Name: ix_group; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_group (
    id bigint DEFAULT nextval('ix_group_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_group OWNER TO postgres;

--
-- Name: ix_how_found_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_how_found_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_how_found_id OWNER TO postgres;

--
-- Name: ix_how_found; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_how_found (
    id bigint DEFAULT nextval('ix_how_found_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_how_found OWNER TO postgres;

--
-- Name: ix_primus_needed_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_primus_needed_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_primus_needed_id OWNER TO postgres;

--
-- Name: ix_primus_needed; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_primus_needed (
    id bigint DEFAULT nextval('ix_primus_needed_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_primus_needed OWNER TO postgres;

--
-- Name: ix_release_note_needed_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_release_note_needed_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_release_note_needed_id OWNER TO postgres;

--
-- Name: ix_release_note_needed; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_release_note_needed (
    id bigint DEFAULT nextval('ix_release_note_needed_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_release_note_needed OWNER TO postgres;

--
-- Name: ix_releases_built_in_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_releases_built_in_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_releases_built_in_id OWNER TO postgres;

--
-- Name: ix_releases_built_in; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_releases_built_in (
    id bigint DEFAULT nextval('ix_releases_built_in_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_releases_built_in OWNER TO postgres;

--
-- Name: ix_script_name_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_script_name_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_script_name_id OWNER TO postgres;

--
-- Name: ix_script_name; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_script_name (
    id bigint DEFAULT nextval('ix_script_name_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_script_name OWNER TO postgres;

--
-- Name: tbl_issue_tracking; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_issue_tracking (
    entryid bigint NOT NULL,
    num_duplicates integer,
    num_regressions_caused integer,
    array_serial_number character varying,
    ix_assigned_to_function_id bigint,
    ix_assigned_to_group_id bigint,
    blocking boolean,
    clarifyid character varying,
    ix_classification_id bigint,
    create_date timestamp without time zone,
    ix_customer_impact_id bigint,
    customer_issue boolean,
    customer_name character varying,
    deferred_issue boolean,
    earliest_dup_bugid bigint,
    escalate boolean,
    ix_escalate_reason_id bigint,
    ix_how_found_id bigint,
    keywords character varying,
    long_term_enhancements character varying,
    ix_major_area_id bigint,
    modified_date timestamp without time zone,
    num_escalations integer,
    ix_primus_needed_id bigint,
    priority integer,
    ix_product_id bigint,
    ix_product_area_id bigint,
    ix_product_family_id bigint,
    ix_product_release_id bigint,
    ix_release_note_needed_id bigint,
    release_when_first_introduced character varying,
    ix_releases_built_in_id bigint,
    regression boolean,
    regression_bugid bigint,
    ix_reported_by_id bigint,
    ix_reported_by_function_id bigint,
    ix_reported_by_group_id bigint,
    root_cause character varying,
    ix_script_name_id bigint,
    short_problem_description character varying,
    ix_status_id bigint,
    ix_status_details_id bigint,
    summary character varying,
    ix_type_id bigint,
    version_found character varying,
    version_when_first_introduced character varying,
    ix_ntlogin_assigned_to_id bigint,
    ix_ntlogin_last_modified_by_id bigint,
    prime_bug_entryid bigint,
    ix_priority_id bigint,
    additional_references character varying,
    notify_list character varying,
    support_materials character varying
);


ALTER TABLE tbl_issue_tracking OWNER TO postgres;

--
-- Name: tbl_share_audit; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_share_audit (
    requestid bigint NOT NULL,
    entryid bigint,
    ix_audit_attribute_id bigint,
    ix_audit_attribute_label_id bigint,
    create_date timestamp without time zone,
    ix_from_value_id bigint,
    modified_date timestamp without time zone,
    ix_to_value_id bigint,
    ix_ntlogin_submitter_id bigint
);


ALTER TABLE tbl_share_audit OWNER TO postgres;

--
-- Name: Cyclone ARs; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "Cyclone ARs" AS
 WITH aa AS (
         SELECT entryid(z.entryid) AS "Entry-Id",
            z.num_duplicates AS "# of Duplicates",
            z.num_regressions_caused AS "# of Regressions Caused",
            z21.name AS "Assigned to",
            z00.name AS "Assigned to Function",
            z01.name AS "Assigned to Group",
            z.array_serial_number AS "Array Serial Number",
            z.blocking AS "Blocking",
            z.clarifyid AS "Clarify ID",
            z02.name AS "Classification",
            z.create_date AS "Create date",
            z03.name AS "Customer Impact",
            z.customer_issue AS "Customer Issue",
            z.customer_name AS "Customer Name",
            z.deferred_issue AS "Deferred Issue",
            entryid(z.earliest_dup_bugid) AS "Earliest Dup Bug #",
            z.escalate AS "Escalate",
            z04.name AS "Escalate Reason",
            z05.name AS "How Found",
            z.keywords AS "Keywords",
            z22.name AS "Last modified by",
            z.long_term_enhancements AS "Long Term Enhancements",
            z06.name AS "Major Area",
            z.modified_date AS "Modified date",
            z.num_escalations AS "Num Escalations",
            z07.name AS "Primus Needed",
            z23.name AS "Priority",
            z20.name AS "Product",
            z08.name AS "Product Area",
            z09.name AS "Product Family",
            z10.name AS "Product Release",
            z11.name AS "Release Note Needed",
            z.release_when_first_introduced AS "Release When First Introduced",
            z12.name AS "Releases Built-in",
            z.regression AS "Regression",
            entryid(z.regression_bugid) AS "Regression Bug #",
            z13.name AS "Reported by",
            z14.name AS "Reported by Function",
            z15.name AS "Reported by Group",
            z.root_cause AS "Root Cause",
            z16.name AS "Script Name",
            z.short_problem_description AS "Short Problem Description",
            z17.name AS "Status",
            z18.name AS "Status Details",
            z.summary AS "Summary",
            z19.name AS "Type",
            z.version_found AS "Version Found",
            z.version_when_first_introduced AS "Version When First Introduced",
            ax.modified_date AS "Modified-date"
           FROM (((((((((((((((((((((((((tbl_issue_tracking z
             LEFT JOIN tbl_share_audit ax USING (entryid))
             LEFT JOIN ix_function z00 ON ((z00.id = z.ix_assigned_to_function_id)))
             LEFT JOIN ix_group z01 ON ((z01.id = z.ix_assigned_to_group_id)))
             LEFT JOIN ix_classification z02 ON ((z02.id = z.ix_classification_id)))
             LEFT JOIN ix_customer_impact z03 ON ((z03.id = z.ix_customer_impact_id)))
             LEFT JOIN ix_escalate_reason z04 ON ((z04.id = z.ix_escalate_reason_id)))
             LEFT JOIN ix_how_found z05 ON ((z05.id = z.ix_how_found_id)))
             LEFT JOIN ix_major_area z06 ON ((z06.id = z.ix_major_area_id)))
             LEFT JOIN ix_primus_needed z07 ON ((z07.id = z.ix_primus_needed_id)))
             LEFT JOIN ix_product_area z08 ON ((z08.id = z.ix_product_area_id)))
             LEFT JOIN ix_product_family z09 ON ((z09.id = z.ix_product_family_id)))
             LEFT JOIN ix_product_release z10 ON ((z10.id = z.ix_product_release_id)))
             LEFT JOIN ix_release_note_needed z11 ON ((z11.id = z.ix_release_note_needed_id)))
             LEFT JOIN ix_releases_built_in z12 ON ((z12.id = z.ix_releases_built_in_id)))
             LEFT JOIN ix_employee_names z13 ON ((z13.id = z.ix_reported_by_id)))
             LEFT JOIN ix_function z14 ON ((z14.id = z.ix_reported_by_function_id)))
             LEFT JOIN ix_group z15 ON ((z15.id = z.ix_reported_by_group_id)))
             LEFT JOIN ix_script_name z16 ON ((z16.id = z.ix_script_name_id)))
             LEFT JOIN ix_status z17 ON ((z17.id = ax.ix_to_value_id)))
             LEFT JOIN ix_status_details z18 ON ((z18.id = z.ix_status_details_id)))
             LEFT JOIN ix_type z19 ON ((z19.id = z.ix_type_id)))
             LEFT JOIN ix_product z20 ON ((z20.id = z.ix_product_id)))
             LEFT JOIN ix_ntlogin z21 ON ((z21.id = z.ix_ntlogin_assigned_to_id)))
             LEFT JOIN ix_ntlogin z22 ON ((z22.id = z.ix_ntlogin_last_modified_by_id)))
             LEFT JOIN ix_priority z23 ON ((z23.id = z.ix_priority_id)))
          WHERE ((z20.name)::text = 'Cyclone'::text)
        ), bb AS (
         SELECT aa."Entry-Id" AS "Issue id",
            aa."Modified date",
            aa."Assigned to" AS "Assignee",
            aa."Blocking",
            aa."Product Area" AS "Component",
            aa."Create date" AS "Created",
            aa."Version Found" AS "Found Version",
            aa."Type" AS "Issue Type",
            aa."Keywords" AS "Labels",
            aa."# of Duplicates" AS "Number of duplicates",
            aa."Priority",
            aa."Product",
            aa."Major Area" AS "Product Area",
            aa."Product Family",
            aa."Product Release" AS "Release",
            aa."Releases Built-in",
            aa."Reported by" AS "Reporter",
            aa."Script Name",
            aa."Status",
            aa."Status Details",
            aa."Summary" AS "Description",
            aa."Modified-date" AS "Updated",
            aa."Reported by" AS "Validator",
            aa."How Found",
            aa."Classification"
           FROM aa
          ORDER BY aa."Entry-Id", aa."Modified date"
        )
 SELECT bb."Issue id",
    bb."Modified date",
    bb."Assignee",
    bb."Blocking",
    bb."Component",
    bb."Created",
    bb."Found Version",
    bb."Issue Type",
    bb."Labels",
    bb."Number of duplicates",
    bb."Priority",
    bb."Product",
    bb."Product Area",
    bb."Product Family",
    bb."Release",
    bb."Releases Built-in",
    bb."Reporter",
    bb."Script Name",
    bb."Status",
    bb."Status Details",
    bb."Description",
    bb."Updated",
    bb."Validator",
    bb."How Found",
    bb."Classification"
   FROM bb;


ALTER TABLE "Cyclone ARs" OWNER TO postgres;

--
-- Name: DevEcosystem ARs; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "DevEcosystem ARs" AS
 WITH a AS (
         SELECT z.manager_name,
            z."Period End",
            z.status,
            z.isnew,
            z.entryid,
            z.priority
           FROM devecosystem_ars(NULL::timestamp without time zone, NULL::timestamp without time zone) z(manager_name, "Period End", status, isnew, entryid, priority)
        ), a0 AS (
         SELECT a.manager_name,
            a."Period End",
            a.status,
            a.isnew,
            a.entryid,
            a.priority
           FROM a
          WHERE (a.isnew = true)
        ), b0 AS (
         SELECT DISTINCT a.manager_name
           FROM a
          WHERE (a.manager_name IS NOT NULL)
        ), b1 AS (
         SELECT DISTINCT a."Period End"
           FROM a
          WHERE (a."Period End" IS NOT NULL)
        ), b AS (
         SELECT b0.manager_name,
            b1."Period End"
           FROM (b0
             CROSS JOIN b1)
        ), c0 AS (
         SELECT a0.manager_name,
            a0."Period End",
            count(*) AS "P00-New"
           FROM a0
          WHERE (a0.priority = 'P00'::text)
          GROUP BY a0."Period End", a0.manager_name
        ), c1 AS (
         SELECT a0.manager_name,
            a0."Period End",
            count(*) AS "P01-New"
           FROM a0
          WHERE (a0.priority = 'P01'::text)
          GROUP BY a0."Period End", a0.manager_name
        ), c2 AS (
         SELECT a0.manager_name,
            a0."Period End",
            count(*) AS "P02-New"
           FROM a0
          WHERE (a0.priority = 'P02'::text)
          GROUP BY a0."Period End", a0.manager_name
        ), c3 AS (
         SELECT a0.manager_name,
            a0."Period End",
            count(*) AS "P03-New"
           FROM a0
          WHERE (a0.priority = 'P03'::text)
          GROUP BY a0."Period End", a0.manager_name
        ), k0 AS (
         SELECT a.manager_name,
            a."Period End",
            a.status,
            count(*) AS pcnt
           FROM a
          WHERE (a.priority = 'P00'::text)
          GROUP BY a."Period End", a.manager_name, a.status
        ), k1 AS (
         SELECT a.manager_name,
            a."Period End",
            a.status,
            count(*) AS pcnt
           FROM a
          WHERE (a.priority = 'P01'::text)
          GROUP BY a."Period End", a.manager_name, a.status
        ), k2 AS (
         SELECT a.manager_name,
            a."Period End",
            a.status,
            count(*) AS pcnt
           FROM a
          WHERE (a.priority = 'P02'::text)
          GROUP BY a."Period End", a.manager_name, a.status
        ), k3 AS (
         SELECT a.manager_name,
            a."Period End",
            a.status,
            count(*) AS pcnt
           FROM a
          WHERE (a.priority = 'P03'::text)
          GROUP BY a."Period End", a.manager_name, a.status
        ), l0 AS (
         SELECT k0.manager_name,
            k0."Period End",
            k0.pcnt AS "P00-Open"
           FROM k0
          WHERE (k0.status = 'Open'::text)
        ), l1 AS (
         SELECT k1.manager_name,
            k1."Period End",
            k1.pcnt AS "P01-Open"
           FROM k1
          WHERE (k1.status = 'Open'::text)
        ), l2 AS (
         SELECT k2.manager_name,
            k2."Period End",
            k2.pcnt AS "P02-Open"
           FROM k2
          WHERE (k2.status = 'Open'::text)
        ), l3 AS (
         SELECT k3.manager_name,
            k3."Period End",
            k3.pcnt AS "P03-Open"
           FROM k3
          WHERE (k3.status = 'Open'::text)
        ), m0 AS (
         SELECT k0.manager_name,
            k0."Period End",
            k0.pcnt AS "P00-In-progress"
           FROM k0
          WHERE (k0.status = 'In-progress'::text)
        ), m1 AS (
         SELECT k1.manager_name,
            k1."Period End",
            k1.pcnt AS "P01-In-progress"
           FROM k1
          WHERE (k1.status = 'In-progress'::text)
        ), m2 AS (
         SELECT k2.manager_name,
            k2."Period End",
            k2.pcnt AS "P02-In-progress"
           FROM k2
          WHERE (k2.status = 'In-progress'::text)
        ), m3 AS (
         SELECT k3.manager_name,
            k3."Period End",
            k3.pcnt AS "P03-In-progress"
           FROM k3
          WHERE (k3.status = 'In-progress'::text)
        ), n0 AS (
         SELECT k0.manager_name,
            k0."Period End",
            k0.pcnt AS "P00-Waiting on Originator"
           FROM k0
          WHERE (k0.status = 'Waiting on Originator'::text)
        ), n1 AS (
         SELECT k1.manager_name,
            k1."Period End",
            k1.pcnt AS "P01-Waiting on Originator"
           FROM k1
          WHERE (k1.status = 'Waiting on Originator'::text)
        ), n2 AS (
         SELECT k2.manager_name,
            k2."Period End",
            k2.pcnt AS "P02-Waiting on Originator"
           FROM k2
          WHERE (k2.status = 'Waiting on Originator'::text)
        ), n3 AS (
         SELECT k3.manager_name,
            k3."Period End",
            k3.pcnt AS "P03-Waiting on Originator"
           FROM k3
          WHERE (k3.status = 'Waiting on Originator'::text)
        ), o0 AS (
         SELECT k0.manager_name,
            k0."Period End",
            k0.pcnt AS "P00-Fixed"
           FROM k0
          WHERE (k0.status = 'Fixed'::text)
        ), o1 AS (
         SELECT k1.manager_name,
            k1."Period End",
            k1.pcnt AS "P01-Fixed"
           FROM k1
          WHERE (k1.status = 'Fixed'::text)
        ), o2 AS (
         SELECT k2.manager_name,
            k2."Period End",
            k2.pcnt AS "P02-Fixed"
           FROM k2
          WHERE (k2.status = 'Fixed'::text)
        ), o3 AS (
         SELECT k3.manager_name,
            k3."Period End",
            k3.pcnt AS "P03-Fixed"
           FROM k3
          WHERE (k3.status = 'Fixed'::text)
        ), p0 AS (
         SELECT k0.manager_name,
            k0."Period End",
            k0.pcnt AS "P00-Dismissed"
           FROM k0
          WHERE (k0.status = 'Dismissed'::text)
        ), p1 AS (
         SELECT k1.manager_name,
            k1."Period End",
            k1.pcnt AS "P01-Dismissed"
           FROM k1
          WHERE (k1.status = 'Dismissed'::text)
        ), p2 AS (
         SELECT k2.manager_name,
            k2."Period End",
            k2.pcnt AS "P02-Dismissed"
           FROM k2
          WHERE (k2.status = 'Dismissed'::text)
        ), p3 AS (
         SELECT k3.manager_name,
            k3."Period End",
            k3.pcnt AS "P03-Dismissed"
           FROM k3
          WHERE (k3.status = 'Dismissed'::text)
        ), q AS (
         SELECT b.manager_name,
            b."Period End",
            c0."P00-New",
            l0."P00-Open",
            m0."P00-In-progress",
            n0."P00-Waiting on Originator",
            o0."P00-Fixed",
            p0."P00-Dismissed",
            c1."P01-New",
            l1."P01-Open",
            m1."P01-In-progress",
            n1."P01-Waiting on Originator",
            o1."P01-Fixed",
            p1."P01-Dismissed",
            c2."P02-New",
            l2."P02-Open",
            m2."P02-In-progress",
            n2."P02-Waiting on Originator",
            o2."P02-Fixed",
            p2."P02-Dismissed",
            c3."P03-New",
            l3."P03-Open",
            m3."P03-In-progress",
            n3."P03-Waiting on Originator",
            o3."P03-Fixed",
            p3."P03-Dismissed",
            ((COALESCE(c0."P00-New", (0)::bigint) - COALESCE(o0."P00-Fixed", (0)::bigint)) - COALESCE(p0."P00-Dismissed", (0)::bigint)) AS "P00-Net",
            ((COALESCE(c1."P01-New", (0)::bigint) - COALESCE(o1."P01-Fixed", (0)::bigint)) - COALESCE(p1."P01-Dismissed", (0)::bigint)) AS "P01-Net",
            ((COALESCE(c2."P02-New", (0)::bigint) - COALESCE(o2."P02-Fixed", (0)::bigint)) - COALESCE(p2."P02-Dismissed", (0)::bigint)) AS "P02-Net",
            ((COALESCE(c3."P03-New", (0)::bigint) - COALESCE(o3."P03-Fixed", (0)::bigint)) - COALESCE(p3."P03-Dismissed", (0)::bigint)) AS "P03-Net"
           FROM ((((((((((((((((((((((((b
             LEFT JOIN c0 USING (manager_name, "Period End"))
             LEFT JOIN l0 USING (manager_name, "Period End"))
             LEFT JOIN m0 USING (manager_name, "Period End"))
             LEFT JOIN n0 USING (manager_name, "Period End"))
             LEFT JOIN o0 USING (manager_name, "Period End"))
             LEFT JOIN p0 USING (manager_name, "Period End"))
             LEFT JOIN c1 USING (manager_name, "Period End"))
             LEFT JOIN l1 USING (manager_name, "Period End"))
             LEFT JOIN m1 USING (manager_name, "Period End"))
             LEFT JOIN n1 USING (manager_name, "Period End"))
             LEFT JOIN o1 USING (manager_name, "Period End"))
             LEFT JOIN p1 USING (manager_name, "Period End"))
             LEFT JOIN c2 USING (manager_name, "Period End"))
             LEFT JOIN l2 USING (manager_name, "Period End"))
             LEFT JOIN m2 USING (manager_name, "Period End"))
             LEFT JOIN n2 USING (manager_name, "Period End"))
             LEFT JOIN o2 USING (manager_name, "Period End"))
             LEFT JOIN p2 USING (manager_name, "Period End"))
             LEFT JOIN c3 USING (manager_name, "Period End"))
             LEFT JOIN l3 USING (manager_name, "Period End"))
             LEFT JOIN m3 USING (manager_name, "Period End"))
             LEFT JOIN n3 USING (manager_name, "Period End"))
             LEFT JOIN o3 USING (manager_name, "Period End"))
             LEFT JOIN p3 USING (manager_name, "Period End"))
        ), r AS (
         SELECT q.manager_name,
            q."Period End",
            q."P00-New",
            q."P00-Open",
            q."P00-In-progress",
            q."P00-Waiting on Originator",
            q."P00-Fixed",
            q."P00-Dismissed",
            q."P00-Net",
            sum(q."P00-Net") OVER ar_changes AS "P00-Outstanding",
            q."P01-New",
            q."P01-Open",
            q."P01-In-progress",
            q."P01-Waiting on Originator",
            q."P01-Fixed",
            q."P01-Dismissed",
            q."P01-Net",
            sum(q."P01-Net") OVER ar_changes AS "P01-Outstanding",
            q."P02-New",
            q."P02-Open",
            q."P02-In-progress",
            q."P02-Waiting on Originator",
            q."P02-Fixed",
            q."P02-Dismissed",
            q."P02-Net",
            sum(q."P02-Net") OVER ar_changes AS "P02-Outstanding",
            q."P03-New",
            q."P03-Open",
            q."P03-In-progress",
            q."P03-Waiting on Originator",
            q."P03-Fixed",
            q."P03-Dismissed",
            q."P03-Net",
            sum(q."P03-Net") OVER ar_changes AS "P03-Outstanding"
           FROM q
          WINDOW ar_changes AS (PARTITION BY q.manager_name ORDER BY q."Period End")
        ), s AS (
         SELECT r.manager_name,
            r."Period End",
            r."P00-New",
            r."P00-Open",
            r."P00-In-progress",
            r."P00-Waiting on Originator",
            r."P00-Fixed",
            r."P00-Dismissed",
            r."P00-Net",
            r."P00-Outstanding",
            r."P01-New",
            r."P01-Open",
            r."P01-In-progress",
            r."P01-Waiting on Originator",
            r."P01-Fixed",
            r."P01-Dismissed",
            r."P01-Net",
            r."P01-Outstanding",
            r."P02-New",
            r."P02-Open",
            r."P02-In-progress",
            r."P02-Waiting on Originator",
            r."P02-Fixed",
            r."P02-Dismissed",
            r."P02-Net",
            r."P02-Outstanding",
            r."P03-New",
            r."P03-Open",
            r."P03-In-progress",
            r."P03-Waiting on Originator",
            r."P03-Fixed",
            r."P03-Dismissed",
            r."P03-Net",
            r."P03-Outstanding"
           FROM r
          WHERE (r.manager_name IS NOT NULL)
          ORDER BY r.manager_name, r."Period End"
        )
 SELECT s.manager_name,
    s."Period End",
    s."P00-New",
    s."P00-Open",
    s."P00-In-progress",
    s."P00-Waiting on Originator",
    s."P00-Fixed",
    s."P00-Dismissed",
    s."P00-Net",
    s."P00-Outstanding",
    s."P01-New",
    s."P01-Open",
    s."P01-In-progress",
    s."P01-Waiting on Originator",
    s."P01-Fixed",
    s."P01-Dismissed",
    s."P01-Net",
    s."P01-Outstanding",
    s."P02-New",
    s."P02-Open",
    s."P02-In-progress",
    s."P02-Waiting on Originator",
    s."P02-Fixed",
    s."P02-Dismissed",
    s."P02-Net",
    s."P02-Outstanding",
    s."P03-New",
    s."P03-Open",
    s."P03-In-progress",
    s."P03-Waiting on Originator",
    s."P03-Fixed",
    s."P03-Dismissed",
    s."P03-Net",
    s."P03-Outstanding"
   FROM s;


ALTER TABLE "DevEcosystem ARs" OWNER TO postgres;

--
-- Name: Development Enablement; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "Development Enablement" AS
 SELECT z.entryid,
    z.num_duplicates,
    z.num_regressions_caused,
    z.array_serial_number,
    z.ix_assigned_to_function_id,
    z.ix_assigned_to_group_id,
    z.blocking,
    z.clarifyid,
    z.ix_classification_id,
    z.create_date,
    z.ix_customer_impact_id,
    z.customer_issue,
    z.customer_name,
    z.deferred_issue,
    z.earliest_dup_bugid,
    z.escalate,
    z.ix_escalate_reason_id,
    z.ix_how_found_id,
    z.keywords,
    z.long_term_enhancements,
    z.ix_major_area_id,
    z.modified_date,
    z.num_escalations,
    z.ix_primus_needed_id,
    z.priority,
    z.ix_product_id,
    z.ix_product_area_id,
    z.ix_product_family_id,
    z.ix_product_release_id,
    z.ix_release_note_needed_id,
    z.release_when_first_introduced,
    z.ix_releases_built_in_id,
    z.regression,
    z.regression_bugid,
    z.ix_reported_by_id,
    z.ix_reported_by_function_id,
    z.ix_reported_by_group_id,
    z.root_cause,
    z.ix_script_name_id,
    z.short_problem_description,
    z.ix_status_id,
    z.ix_status_details_id,
    z.summary,
    z.ix_type_id,
    z.version_found,
    z.version_when_first_introduced,
    z.ix_ntlogin_assigned_to_id,
    z.ix_ntlogin_last_modified_by_id,
    z.prime_bug_entryid,
    z.ix_priority_id
   FROM ((tbl_issue_tracking z
     LEFT JOIN ix_product_family y ON ((y.id = z.ix_product_family_id)))
     LEFT JOIN ix_product x ON ((x.id = z.ix_product_id)))
  WHERE (((y.name)::text = 'Common Tools'::text) AND (((x.name)::text = 'Development Enablement'::text) OR ((x.name)::text = 'Dev Ecosystem'::text)));


ALTER TABLE "Development Enablement" OWNER TO postgres;

--
-- Name: ix_candidate_status_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_candidate_status_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_candidate_status_id OWNER TO postgres;

--
-- Name: ix_candidate_status; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_candidate_status (
    id bigint DEFAULT nextval('ix_candidate_status_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_candidate_status OWNER TO postgres;

--
-- Name: ix_sp_target_release_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_sp_target_release_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_sp_target_release_id OWNER TO postgres;

--
-- Name: ix_sp_target_release; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_sp_target_release (
    id bigint DEFAULT nextval('ix_sp_target_release_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_sp_target_release OWNER TO postgres;

--
-- Name: tbl_issue_escalation_join; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_issue_escalation_join (
    entryid bigint NOT NULL,
    ix_candidate_status_id bigint,
    ix_escalate_by_id bigint,
    ix_escalate_reason_id bigint,
    sp_create_date timestamp without time zone,
    sp_modified_date timestamp without time zone,
    ix_sp_last_modified_by_id bigint,
    ix_sp_target_release_id bigint
);


ALTER TABLE tbl_issue_escalation_join OWNER TO postgres;

--
-- Name: EMC:Issue Escalation Join; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:Issue Escalation Join" AS
 WITH a AS (
         SELECT entryid(z.entryid) AS "Entry ID",
            y.name AS "Candidate Status",
            x.name AS "Escalate by",
            w.name AS "Escalate Reason",
            z.sp_create_date AS "SP Create Date",
            z.sp_modified_date AS "SP Modified Date",
            v.name AS "SP Last Modified by",
            u.name AS "SP Target Release"
           FROM (((((tbl_issue_escalation_join z
             LEFT JOIN ix_candidate_status y ON ((y.id = z.ix_candidate_status_id)))
             LEFT JOIN ix_employee_names x ON ((x.id = z.ix_escalate_by_id)))
             LEFT JOIN ix_escalate_reason w ON ((w.id = z.ix_escalate_reason_id)))
             LEFT JOIN ix_employee_names v ON ((v.id = z.ix_sp_last_modified_by_id)))
             LEFT JOIN ix_sp_target_release u ON ((u.id = z.ix_sp_target_release_id)))
        )
 SELECT a."Entry ID",
    a."Candidate Status",
    a."Escalate by",
    a."Escalate Reason",
    a."SP Create Date",
    a."SP Modified Date",
    a."SP Last Modified by",
    a."SP Target Release"
   FROM a;


ALTER TABLE "EMC:Issue Escalation Join" OWNER TO postgres;

--
-- Name: tbl_issue_reported_by_manager_join; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_issue_reported_by_manager_join (
    entryid bigint NOT NULL,
    ix_direct_manager_id bigint,
    ix_senior_manager_id bigint,
    status_history_dismissed timestamp without time zone,
    status_history_fixed timestamp without time zone,
    status_history_in_progress timestamp without time zone,
    status_history_open timestamp without time zone,
    status_history_waiting_on_originator timestamp without time zone,
    version_verified character varying
);


ALTER TABLE tbl_issue_reported_by_manager_join OWNER TO postgres;

--
-- Name: EMC:Issue Reported by Manager Join; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:Issue Reported by Manager Join" AS
 WITH a AS (
         SELECT entryid(z.entryid) AS "Entry-Id",
            y.name AS "Direct Manager",
            x.name AS "Senior Manager",
            z.status_history_dismissed AS "Status History Dismissed TIME",
            z.status_history_fixed AS "Status History Fixed TIME",
            z.status_history_in_progress AS "Status History In-progress TIME",
            z.status_history_open AS "Status History Open TIME",
            z.status_history_waiting_on_originator AS "Status History Waiting on Originator TIME",
            z.version_verified AS "Version Verified"
           FROM ((tbl_issue_reported_by_manager_join z
             LEFT JOIN ix_employee_names y ON ((y.id = z.ix_direct_manager_id)))
             LEFT JOIN ix_employee_names x ON ((x.id = z.ix_senior_manager_id)))
        )
 SELECT a."Entry-Id",
    a."Direct Manager",
    a."Senior Manager",
    a."Status History Dismissed TIME",
    a."Status History Fixed TIME",
    a."Status History In-progress TIME",
    a."Status History Open TIME",
    a."Status History Waiting on Originator TIME",
    a."Version Verified"
   FROM a;


ALTER TABLE "EMC:Issue Reported by Manager Join" OWNER TO postgres;

--
-- Name: tbl_issue_descriptions; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_issue_descriptions (
    entryid bigint NOT NULL,
    modified_date timestamp without time zone,
    full_details character varying
);


ALTER TABLE tbl_issue_descriptions OWNER TO postgres;

--
-- Name: EMC:Issue Tracking; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:Issue Tracking" AS
 WITH aa AS (
         SELECT tbl_share_audit.entryid,
            max(tbl_share_audit.requestid) AS requestid
           FROM tbl_share_audit
          GROUP BY tbl_share_audit.entryid
        ), ab AS (
         SELECT z.requestid,
            z.entryid,
            z.ix_audit_attribute_id,
            z.ix_audit_attribute_label_id,
            z.create_date,
            z.ix_from_value_id,
            z.modified_date,
            z.ix_to_value_id,
            z.ix_ntlogin_submitter_id
           FROM (aa
             LEFT JOIN tbl_share_audit z USING (requestid))
        ), ac AS (
         SELECT entryid(z.entryid) AS "Entry-Id",
            z.num_duplicates AS "# of Duplicates",
            z.num_regressions_caused AS "# of Regressions Caused",
            z21.name AS "Assigned to",
            z00.name AS "Assigned to Function",
            z01.name AS "Assigned to Group",
            z.array_serial_number AS "Array Serial Number",
            z.blocking AS "Blocking",
            z.clarifyid AS "Clarify ID",
            z02.name AS "Classification",
            z.create_date AS "Create date",
            z03.name AS "Customer Impact",
            z.customer_issue AS "Customer Issue",
            z.customer_name AS "Customer Name",
            z.deferred_issue AS "Deferred Issue",
            entryid(z.earliest_dup_bugid) AS "Earliest Dup Bug #",
            z.escalate AS "Escalate",
            z04.name AS "Escalate Reason",
            z05.name AS "How Found",
            z.keywords AS "Keywords",
            z22.name AS "Last modified by",
            z.long_term_enhancements AS "Long Term Enhancements",
            z06.name AS "Major Area",
            z.modified_date AS "Modified date",
            z.num_escalations AS "Num Escalations",
            z07.name AS "Primus Needed",
            z23.name AS "Priority",
            z20.name AS "Product",
            z08.name AS "Product Area",
            z09.name AS "Product Family",
            z10.name AS "Product Release",
            z11.name AS "Release Note Needed",
            z.release_when_first_introduced AS "Release When First Introduced",
            z12.name AS "Releases Built-in",
            z.regression AS "Regression",
            entryid(z.regression_bugid) AS "Regression Bug #",
            z13.name AS "Reported by",
            z14.name AS "Reported by Function",
            z15.name AS "Reported by Group",
            z.root_cause AS "Root Cause",
            z16.name AS "Script Name",
            z.short_problem_description AS "Short Problem Description",
            z17.name AS "Status",
            z18.name AS "Status Details",
            z.summary AS "Summary",
            z19.name AS "Type",
            z.version_found AS "Version Found",
            z.version_when_first_introduced AS "Version When First Introduced",
            z.additional_references AS "Additional references",
            z.notify_list AS "Notify List",
            z.support_materials AS "Support Materials",
            z24.full_details AS "Full Details"
           FROM ((((((((((((((((((((((((((tbl_issue_tracking z
             LEFT JOIN ab USING (entryid))
             LEFT JOIN ix_function z00 ON ((z00.id = z.ix_assigned_to_function_id)))
             LEFT JOIN ix_group z01 ON ((z01.id = z.ix_assigned_to_group_id)))
             LEFT JOIN ix_classification z02 ON ((z02.id = z.ix_classification_id)))
             LEFT JOIN ix_customer_impact z03 ON ((z03.id = z.ix_customer_impact_id)))
             LEFT JOIN ix_escalate_reason z04 ON ((z04.id = z.ix_escalate_reason_id)))
             LEFT JOIN ix_how_found z05 ON ((z05.id = z.ix_how_found_id)))
             LEFT JOIN ix_major_area z06 ON ((z06.id = z.ix_major_area_id)))
             LEFT JOIN ix_primus_needed z07 ON ((z07.id = z.ix_primus_needed_id)))
             LEFT JOIN ix_product_area z08 ON ((z08.id = z.ix_product_area_id)))
             LEFT JOIN ix_product_family z09 ON ((z09.id = z.ix_product_family_id)))
             LEFT JOIN ix_product_release z10 ON ((z10.id = z.ix_product_release_id)))
             LEFT JOIN ix_release_note_needed z11 ON ((z11.id = z.ix_release_note_needed_id)))
             LEFT JOIN ix_releases_built_in z12 ON ((z12.id = z.ix_releases_built_in_id)))
             LEFT JOIN ix_employee_names z13 ON ((z13.id = z.ix_reported_by_id)))
             LEFT JOIN ix_function z14 ON ((z14.id = z.ix_reported_by_function_id)))
             LEFT JOIN ix_group z15 ON ((z15.id = z.ix_reported_by_group_id)))
             LEFT JOIN ix_script_name z16 ON ((z16.id = z.ix_script_name_id)))
             LEFT JOIN ix_status z17 ON ((z17.id = ab.ix_to_value_id)))
             LEFT JOIN ix_status_details z18 ON ((z18.id = z.ix_status_details_id)))
             LEFT JOIN ix_type z19 ON ((z19.id = z.ix_type_id)))
             LEFT JOIN ix_product z20 ON ((z20.id = z.ix_product_id)))
             LEFT JOIN ix_ntlogin z21 ON ((z21.id = z.ix_ntlogin_assigned_to_id)))
             LEFT JOIN ix_ntlogin z22 ON ((z22.id = z.ix_ntlogin_last_modified_by_id)))
             LEFT JOIN ix_priority z23 ON ((z23.id = z.ix_priority_id)))
             LEFT JOIN tbl_issue_descriptions z24 USING (entryid))
          ORDER BY z.entryid
        )
 SELECT ac."Entry-Id",
    ac."# of Duplicates",
    ac."# of Regressions Caused",
    ac."Assigned to",
    ac."Assigned to Function",
    ac."Assigned to Group",
    ac."Array Serial Number",
    ac."Blocking",
    ac."Clarify ID",
    ac."Classification",
    ac."Create date",
    ac."Customer Impact",
    ac."Customer Issue",
    ac."Customer Name",
    ac."Deferred Issue",
    ac."Earliest Dup Bug #",
    ac."Escalate",
    ac."Escalate Reason",
    ac."How Found",
    ac."Keywords",
    ac."Last modified by",
    ac."Long Term Enhancements",
    ac."Major Area",
    ac."Modified date",
    ac."Num Escalations",
    ac."Primus Needed",
    ac."Priority",
    ac."Product",
    ac."Product Area",
    ac."Product Family",
    ac."Product Release",
    ac."Release Note Needed",
    ac."Release When First Introduced",
    ac."Releases Built-in",
    ac."Regression",
    ac."Regression Bug #",
    ac."Reported by",
    ac."Reported by Function",
    ac."Reported by Group",
    ac."Root Cause",
    ac."Script Name",
    ac."Short Problem Description",
    ac."Status",
    ac."Status Details",
    ac."Summary",
    ac."Type",
    ac."Version Found",
    ac."Version When First Introduced",
    ac."Additional references",
    ac."Notify List",
    ac."Support Materials",
    ac."Full Details"
   FROM ac;


ALTER TABLE "EMC:Issue Tracking" OWNER TO postgres;

--
-- Name: ix_functional_area_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_functional_area_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_functional_area_id OWNER TO postgres;

--
-- Name: ix_functional_area; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_functional_area (
    id bigint DEFAULT nextval('ix_functional_area_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_functional_area OWNER TO postgres;

--
-- Name: ix_request_type_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_request_type_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_request_type_id OWNER TO postgres;

--
-- Name: ix_request_type; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_request_type (
    id bigint DEFAULT nextval('ix_request_type_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_request_type OWNER TO postgres;

--
-- Name: tbl_release_engineering_tracker; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_release_engineering_tracker (
    entryid bigint NOT NULL,
    ix_assigned_to_id bigint,
    create_date timestamp without time zone,
    ix_functional_area_id bigint,
    modified_date timestamp without time zone,
    priority integer,
    ix_reported_by_id bigint,
    ix_request_type_id bigint,
    ix_status_id bigint,
    summary character varying,
    ix_ntlogin_last_modified_by_id bigint,
    ix_ntlogin_submitter_id bigint
);


ALTER TABLE tbl_release_engineering_tracker OWNER TO postgres;

--
-- Name: EMC:Release Engineering Tracker; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:Release Engineering Tracker" AS
 WITH a AS (
         SELECT ('RET'::text || "right"((entryid(z.entryid))::text, 12)) AS "Entry ID",
            v.name AS "Assigned to",
            z.create_date AS "Create Date",
            y.name AS "Functional Area",
            t.name AS "Last Modified By",
            z.modified_date AS "Modified Date",
            ('P0'::text || z.priority) AS "Priority",
            u.name AS "Reported by",
            x.name AS "Request Type",
            w.name AS "Status",
            s.name AS "Submitter_Login_ID_hdn",
            z.summary AS "Summary"
           FROM (((((((tbl_release_engineering_tracker z
             LEFT JOIN ix_functional_area y ON ((y.id = z.ix_functional_area_id)))
             LEFT JOIN ix_request_type x ON ((x.id = z.ix_request_type_id)))
             LEFT JOIN ix_status w ON ((w.id = z.ix_status_id)))
             LEFT JOIN ix_employee_names v ON ((v.id = z.ix_assigned_to_id)))
             LEFT JOIN ix_employee_names u ON ((u.id = z.ix_reported_by_id)))
             LEFT JOIN ix_ntlogin t ON ((t.id = z.ix_ntlogin_last_modified_by_id)))
             LEFT JOIN ix_ntlogin s ON ((s.id = z.ix_ntlogin_submitter_id)))
        )
 SELECT a."Entry ID",
    a."Assigned to",
    a."Create Date",
    a."Functional Area",
    a."Last Modified By",
    a."Modified Date",
    a."Priority",
    a."Reported by",
    a."Request Type",
    a."Status",
    a."Submitter_Login_ID_hdn",
    a."Summary"
   FROM a;


ALTER TABLE "EMC:Release Engineering Tracker" OWNER TO postgres;

--
-- Name: tbl_releases; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_releases (
    requestid bigint NOT NULL,
    create_date timestamp without time zone,
    email_users character varying,
    enabled boolean,
    modified_date timestamp without time zone,
    ix_product_family_id bigint,
    ix_product_release_id bigint,
    ix_ntlogin_last_modified_by_id bigint
);


ALTER TABLE tbl_releases OWNER TO postgres;

--
-- Name: EMC:Releases; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:Releases" AS
 WITH a AS (
         SELECT entryid(z.requestid) AS "Request ID",
            z.create_date AS "Create Date",
            z.email_users AS "Email Users",
            z.enabled AS "Enabled",
            w.name AS "Last Modified By",
            z.modified_date AS "Modified Date",
            y.name AS "Product Family",
            y.name AS "Product Release"
           FROM (((tbl_releases z
             LEFT JOIN ix_employee_names y ON ((y.id = z.ix_product_family_id)))
             LEFT JOIN ix_employee_names x ON ((x.id = z.ix_product_release_id)))
             LEFT JOIN ix_ntlogin w ON ((w.id = z.ix_ntlogin_last_modified_by_id)))
        )
 SELECT a."Request ID",
    a."Create Date",
    a."Email Users",
    a."Enabled",
    a."Last Modified By",
    a."Modified Date",
    a."Product Family",
    a."Product Release"
   FROM a;


ALTER TABLE "EMC:Releases" OWNER TO postgres;

--
-- Name: ix_relationship_type_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_relationship_type_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_relationship_type_id OWNER TO postgres;

--
-- Name: ix_relationship_type; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_relationship_type (
    id bigint DEFAULT nextval('ix_relationship_type_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_relationship_type OWNER TO postgres;

--
-- Name: tbl_share_association; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_share_association (
    requestid bigint NOT NULL,
    modified_date timestamp without time zone,
    ix_relationship_type_id bigint,
    requestid1 bigint,
    requestid2 bigint,
    ix_status_id bigint,
    ix_ntlogin_last_modified_by_id bigint
);


ALTER TABLE tbl_share_association OWNER TO postgres;

--
-- Name: EMC:SHARE Association; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:SHARE Association" AS
 WITH a AS (
         SELECT entryid(z.requestid) AS "Request ID",
            w.name AS "Last Modified By",
            z.modified_date AS "Modified Date",
            y.name AS "Relationship Type",
            z.requestid1 AS "Request ID 1",
            z.requestid2 AS "Request ID 2",
            x.name AS "Status"
           FROM (((tbl_share_association z
             LEFT JOIN ix_relationship_type y ON ((y.id = z.ix_relationship_type_id)))
             LEFT JOIN ix_status x ON ((x.id = z.ix_status_id)))
             LEFT JOIN ix_ntlogin w ON ((w.id = z.ix_ntlogin_last_modified_by_id)))
        )
 SELECT a."Request ID",
    a."Last Modified By",
    a."Modified Date",
    a."Relationship Type",
    a."Request ID 1",
    a."Request ID 2",
    a."Status"
   FROM a;


ALTER TABLE "EMC:SHARE Association" OWNER TO postgres;

--
-- Name: ix_audit_attribute_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_audit_attribute_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_audit_attribute_id OWNER TO postgres;

--
-- Name: ix_audit_attribute; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_audit_attribute (
    id bigint DEFAULT nextval('ix_audit_attribute_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_audit_attribute OWNER TO postgres;

--
-- Name: EMC:SHARE Audit; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:SHARE Audit" AS
 WITH a AS (
         SELECT entryid(z.requestid) AS "Request ID",
            entryid(z.entryid) AS "Object Entry ID",
            y.name AS "Attribute",
            x.name AS "Attribute Label",
            z.create_date AS "Create Date",
            t.name AS "From Value",
            z.modified_date AS "Modified Date",
            s.name AS "Submitter",
            l.name AS "To Value"
           FROM (((((tbl_share_audit z
             LEFT JOIN ix_audit_attribute y ON ((y.id = z.ix_audit_attribute_id)))
             LEFT JOIN ix_audit_attribute x ON ((x.id = z.ix_audit_attribute_label_id)))
             LEFT JOIN ix_status_details t ON ((t.id = z.ix_from_value_id)))
             LEFT JOIN ix_status_details l ON ((l.id = z.ix_to_value_id)))
             LEFT JOIN ix_ntlogin s ON ((s.id = z.ix_ntlogin_submitter_id)))
          ORDER BY z.requestid, z.entryid
        )
 SELECT a."Request ID",
    a."Object Entry ID",
    a."Attribute",
    a."Attribute Label",
    a."Create Date",
    a."From Value",
    a."Modified Date",
    a."Submitter",
    a."To Value"
   FROM a;


ALTER TABLE "EMC:SHARE Audit" OWNER TO postgres;

--
-- Name: ix_badgeid_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_badgeid_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_badgeid_id OWNER TO postgres;

--
-- Name: ix_badgeid; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_badgeid (
    id bigint DEFAULT nextval('ix_badgeid_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_badgeid OWNER TO postgres;

--
-- Name: ix_email_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_email_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_email_id OWNER TO postgres;

--
-- Name: ix_email; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_email (
    id bigint DEFAULT nextval('ix_email_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_email OWNER TO postgres;

--
-- Name: ix_givenname_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_givenname_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_givenname_id OWNER TO postgres;

--
-- Name: ix_givenname; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_givenname (
    id bigint DEFAULT nextval('ix_givenname_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_givenname OWNER TO postgres;

--
-- Name: ix_surname_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_surname_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_surname_id OWNER TO postgres;

--
-- Name: ix_surname; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_surname (
    id bigint DEFAULT nextval('ix_surname_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_surname OWNER TO postgres;

--
-- Name: tbl_share_employee; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_share_employee (
    requestid bigint NOT NULL,
    ix_group_name_id bigint,
    ix_full_name_id bigint,
    ix_status_id bigint,
    system_modified_date timestamp without time zone,
    ix_ntlogin_id bigint,
    ix_email_id bigint,
    ix_badgeid_id bigint,
    ix_givenname_id bigint,
    ix_surname_id bigint,
    ix_function_name_id bigint
);


ALTER TABLE tbl_share_employee OWNER TO postgres;

--
-- Name: EMC:SHARE Employee; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:SHARE Employee" AS
 WITH a AS (
         SELECT entryid(z.requestid) AS "Request ID",
            z.system_modified_date AS "System Modified Date",
            v.name AS "Login",
            u.name AS "Email Address",
            t.name AS "Employee ID",
            s.name AS "First Name",
            x.name AS "Full Name",
            r.name AS "Last Name",
            w.name AS "Status",
            y.name AS "Function Name",
            y.name AS "Group Name"
           FROM (((((((((tbl_share_employee z
             LEFT JOIN ix_group y ON ((y.id = z.ix_group_name_id)))
             LEFT JOIN ix_employee_names x ON ((x.id = z.ix_full_name_id)))
             LEFT JOIN ix_status w ON ((w.id = z.ix_status_id)))
             LEFT JOIN ix_ntlogin v ON ((v.id = z.ix_ntlogin_id)))
             LEFT JOIN ix_email u ON ((u.id = z.ix_email_id)))
             LEFT JOIN ix_badgeid t ON ((t.id = z.ix_badgeid_id)))
             LEFT JOIN ix_givenname s ON ((s.id = z.ix_givenname_id)))
             LEFT JOIN ix_surname r ON ((r.id = z.ix_surname_id)))
             LEFT JOIN ix_group q ON ((q.id = z.ix_function_name_id)))
          ORDER BY z.requestid
        )
 SELECT a."Request ID",
    a."System Modified Date",
    a."Login",
    a."Email Address",
    a."Employee ID",
    a."First Name",
    a."Full Name",
    a."Last Name",
    a."Status",
    a."Function Name",
    a."Group Name"
   FROM a;


ALTER TABLE "EMC:SHARE Employee" OWNER TO postgres;

--
-- Name: tbl_share_notes; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_share_notes (
    requestid bigint NOT NULL,
    entryid bigint,
    ix_full_name_id bigint,
    modified_date timestamp without time zone,
    short_desc character varying,
    note_details character varying,
    ix_ntlogin_last_modified_by_id bigint
);


ALTER TABLE tbl_share_notes OWNER TO postgres;

--
-- Name: EMC:SHARE Notes; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:SHARE Notes" AS
 WITH a AS (
         SELECT entryid(z.requestid) AS "Request ID",
            entryid(z.entryid) AS "Entry ID",
            y.name AS "Full Name",
            x.name AS "Last Modified By",
            z.modified_date AS "Modified Date",
            z.short_desc AS "Short Desc",
            z.note_details AS "Note Details"
           FROM ((tbl_share_notes z
             LEFT JOIN ix_employee_names y ON ((y.id = z.ix_full_name_id)))
             LEFT JOIN ix_ntlogin x ON ((x.id = z.ix_ntlogin_last_modified_by_id)))
          ORDER BY z.entryid
        )
 SELECT a."Request ID",
    a."Entry ID",
    a."Full Name",
    a."Last Modified By",
    a."Modified Date",
    a."Short Desc",
    a."Note Details"
   FROM a;


ALTER TABLE "EMC:SHARE Notes" OWNER TO postgres;

--
-- Name: ix_release_name_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_release_name_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_release_name_id OWNER TO postgres;

--
-- Name: ix_release_name; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_release_name (
    id bigint DEFAULT nextval('ix_release_name_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_release_name OWNER TO postgres;

--
-- Name: tbl_share_release_association; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_share_release_association (
    requestid bigint NOT NULL,
    issue_entryid bigint,
    ix_release_name_id bigint,
    modified_date timestamp without time zone
);


ALTER TABLE tbl_share_release_association OWNER TO postgres;

--
-- Name: EMC:SHARE Release Association; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:SHARE Release Association" AS
 WITH a AS (
         SELECT entryid(z.requestid) AS "Request ID",
            entryid(z.issue_entryid) AS "Issue Entry ID",
            y.name AS "Release Name",
            z.modified_date AS "Modified Date"
           FROM (tbl_share_release_association z
             LEFT JOIN ix_release_name y ON ((y.id = z.ix_release_name_id)))
          ORDER BY z.requestid
        )
 SELECT a."Request ID",
    a."Issue Entry ID",
    a."Release Name",
    a."Modified Date"
   FROM a;


ALTER TABLE "EMC:SHARE Release Association" OWNER TO postgres;

--
-- Name: tbl_share_user_notification; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_share_user_notification (
    requestid bigint NOT NULL,
    nsg_issue_tracking_entryid bigint,
    ix_name_id bigint,
    ix_ntlogin_id bigint
);


ALTER TABLE tbl_share_user_notification OWNER TO postgres;

--
-- Name: EMC:SHARE User Notification; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "EMC:SHARE User Notification" AS
 WITH a AS (
         SELECT entryid(z.requestid) AS "Request ID",
            entryid(z.nsg_issue_tracking_entryid) AS "NSG Issue Tracking Id",
            x.name AS "Login",
            y.name AS "Name"
           FROM ((tbl_share_user_notification z
             LEFT JOIN ix_employee_names y ON ((y.id = z.ix_name_id)))
             LEFT JOIN ix_ntlogin x ON ((x.id = z.ix_ntlogin_id)))
          ORDER BY z.requestid
        )
 SELECT a."Request ID",
    a."NSG Issue Tracking Id",
    a."Login",
    a."Name"
   FROM a;


ALTER TABLE "EMC:SHARE User Notification" OWNER TO postgres;

--
-- Name: ix_how_found_main_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_how_found_main_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_how_found_main_id OWNER TO postgres;

--
-- Name: ix_how_found_main; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_how_found_main (
    id bigint DEFAULT nextval('ix_how_found_main_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_how_found_main OWNER TO postgres;

--
-- Name: tbl_how_found; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_how_found (
    ix_how_found_id bigint,
    ix_how_found_main_id bigint
);


ALTER TABLE tbl_how_found OWNER TO postgres;

--
-- Name: How Found; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "How Found" AS
 WITH a AS (
         SELECT x.name AS how_found_main,
            y.name AS how_found_sub
           FROM ((tbl_how_found z
             LEFT JOIN ix_how_found y ON ((y.id = z.ix_how_found_id)))
             LEFT JOIN ix_how_found_main x ON ((x.id = z.ix_how_found_main_id)))
          ORDER BY x.name, y.name
        )
 SELECT a.how_found_main,
    a.how_found_sub
   FROM a;


ALTER TABLE "How Found" OWNER TO postgres;

--
-- Name: NON-AR audit records; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "NON-AR audit records" AS
 SELECT z.requestid,
    z.entryid,
    z.modified_date,
    x.name AS "Modified by",
    y.name AS attribute,
    w.name AS "From",
    v.name AS "To"
   FROM ((((tbl_share_audit z
     LEFT JOIN ix_audit_attribute y ON ((y.id = z.ix_audit_attribute_id)))
     LEFT JOIN ix_ntlogin x ON ((x.id = z.ix_ntlogin_submitter_id)))
     LEFT JOIN ix_status_details w ON ((w.id = z.ix_from_value_id)))
     LEFT JOIN ix_status_details v ON ((v.id = z.ix_to_value_id)))
  WHERE (z.entryid IS NULL)
  ORDER BY z.requestid;


ALTER TABLE "NON-AR audit records" OWNER TO postgres;

--
-- Name: tbl_ret_overview; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_ret_overview (
    tm timestamp with time zone,
    "Average age" numeric,
    "Average days since last modification" numeric,
    "RETs: non orphaned" numeric,
    "RETs: orphaned 'Assigned To'" numeric,
    "RETs: orphaned 'Last Modified by'" numeric,
    "RETs: orphaned 'Assigned To' & 'Last Modified by'" numeric,
    "Total number of RETs" numeric
);


ALTER TABLE tbl_ret_overview OWNER TO postgres;

--
-- Name: RETs Overview; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "RETs Overview" AS
 SELECT (tbl_ret_overview.tm)::date AS tm,
    tbl_ret_overview."Average age",
    tbl_ret_overview."Average days since last modification",
    tbl_ret_overview."RETs: non orphaned",
    tbl_ret_overview."RETs: orphaned 'Assigned To'",
    tbl_ret_overview."RETs: orphaned 'Last Modified by'",
    tbl_ret_overview."RETs: orphaned 'Assigned To' & 'Last Modified by'",
    tbl_ret_overview."Total number of RETs"
   FROM tbl_ret_overview;


ALTER TABLE "RETs Overview" OWNER TO postgres;

--
-- Name: Release Engineering: Activity all; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "Release Engineering: Activity all" AS
 WITH a AS (
         SELECT tbl_release_engineering_tracker.entryid,
            max(tbl_release_engineering_tracker.modified_date) AS modified_date
           FROM tbl_release_engineering_tracker
          GROUP BY tbl_release_engineering_tracker.entryid
        ), b AS (
         SELECT z.entryid,
            z.ix_assigned_to_id,
            z.create_date,
            z.ix_functional_area_id,
            z.modified_date,
            z.priority,
            z.ix_reported_by_id,
            z.ix_request_type_id,
            z.ix_status_id,
            z.summary,
            z.ix_ntlogin_last_modified_by_id,
            z.ix_ntlogin_submitter_id
           FROM (a
             LEFT JOIN tbl_release_engineering_tracker z USING (entryid, modified_date))
        ), c AS (
         SELECT b.entryid,
            y.name AS assigned_to,
            x.name AS status
           FROM ((b
             LEFT JOIN ix_employee_names y ON ((y.id = b.ix_assigned_to_id)))
             LEFT JOIN ix_status x ON ((x.id = b.ix_status_id)))
        ), d AS (
         SELECT c.assigned_to,
            count(*) AS "Total"
           FROM c
          GROUP BY c.assigned_to
        ), e AS (
         SELECT c.assigned_to,
            count(*) AS "Open & New"
           FROM c
          WHERE ((c.status)::text = ANY (ARRAY[('New'::character varying)::text, ('Open'::character varying)::text]))
          GROUP BY c.assigned_to
        ), f AS (
         SELECT c.assigned_to,
            count(*) AS "WOO"
           FROM c
          WHERE ((c.status)::text ~* '^Waiting'::text)
          GROUP BY c.assigned_to
        ), g AS (
         SELECT c.assigned_to,
            count(*) AS "Closed"
           FROM c
          WHERE ((c.status)::text = ANY (ARRAY[('Closed'::character varying)::text, ('Dismissed'::character varying)::text]))
          GROUP BY c.assigned_to
        ), h AS (
         SELECT c.assigned_to,
            count(*) AS "Backlog"
           FROM c
          WHERE ((c.status)::text ~* '^Backlog'::text)
          GROUP BY c.assigned_to
        ), i AS (
         SELECT d.assigned_to,
            e."Open & New",
            f."WOO",
            h."Backlog",
            g."Closed",
            d."Total"
           FROM ((((d
             LEFT JOIN e USING (assigned_to))
             LEFT JOIN f USING (assigned_to))
             LEFT JOIN g USING (assigned_to))
             LEFT JOIN h USING (assigned_to))
          ORDER BY d.assigned_to
        )
 SELECT i.assigned_to,
    i."Open & New",
    i."WOO",
    i."Backlog",
    i."Closed",
    i."Total"
   FROM i;


ALTER TABLE "Release Engineering: Activity all" OWNER TO postgres;

--
-- Name: Release Engineering: Activity last week; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "Release Engineering: Activity last week" AS
 WITH week AS (
         SELECT public.endofweek((('now'::text)::date - '7 days'::interval)) AS endof,
            public.startofweek((('now'::text)::date - '7 days'::interval)) AS startof
        ), a AS (
         SELECT tbl_release_engineering_tracker.entryid,
            max(tbl_release_engineering_tracker.modified_date) AS modified_date
           FROM tbl_release_engineering_tracker
          GROUP BY tbl_release_engineering_tracker.entryid
        ), b AS (
         SELECT z.entryid,
            z.ix_assigned_to_id,
            z.create_date,
            z.ix_functional_area_id,
            z.modified_date,
            z.priority,
            z.ix_reported_by_id,
            z.ix_request_type_id,
            z.ix_status_id,
            z.summary,
            z.ix_ntlogin_last_modified_by_id,
            z.ix_ntlogin_submitter_id
           FROM (a
             LEFT JOIN tbl_release_engineering_tracker z USING (entryid, modified_date))
        ), c AS (
         SELECT z.entryid,
            y.name AS assigned_to,
            x.name AS status
           FROM (((tbl_release_engineering_tracker z
             CROSS JOIN week)
             LEFT JOIN ix_employee_names y ON ((y.id = z.ix_assigned_to_id)))
             LEFT JOIN ix_status x ON ((x.id = z.ix_status_id)))
          WHERE (((z.create_date > week.startof) AND (z.create_date < week.endof)) OR ((z.modified_date > week.startof) AND (z.modified_date < week.endof)))
        ), d AS (
         SELECT c.assigned_to,
            count(*) AS "Total"
           FROM c
          GROUP BY c.assigned_to
        ), e AS (
         SELECT c.assigned_to,
            count(*) AS "Open & New"
           FROM c
          WHERE ((c.status)::text = ANY (ARRAY[('New'::character varying)::text, ('Open'::character varying)::text]))
          GROUP BY c.assigned_to
        ), f AS (
         SELECT c.assigned_to,
            count(*) AS "WOO"
           FROM c
          WHERE ((c.status)::text ~* '^Waiting'::text)
          GROUP BY c.assigned_to
        ), g AS (
         SELECT c.assigned_to,
            count(*) AS "Closed"
           FROM c
          WHERE ((c.status)::text = ANY (ARRAY[('Closed'::character varying)::text, ('Dismissed'::character varying)::text]))
          GROUP BY c.assigned_to
        ), h AS (
         SELECT c.assigned_to,
            count(*) AS "Backlog"
           FROM c
          WHERE ((c.status)::text ~* '^Backlog'::text)
          GROUP BY c.assigned_to
        ), i AS (
         SELECT d.assigned_to,
            e."Open & New",
            f."WOO",
            h."Backlog",
            g."Closed",
            d."Total"
           FROM ((((d
             LEFT JOIN e USING (assigned_to))
             LEFT JOIN f USING (assigned_to))
             LEFT JOIN g USING (assigned_to))
             LEFT JOIN h USING (assigned_to))
          ORDER BY d.assigned_to
        )
 SELECT i.assigned_to,
    i."Open & New",
    i."WOO",
    i."Backlog",
    i."Closed",
    i."Total"
   FROM i;


ALTER TABLE "Release Engineering: Activity last week" OWNER TO postgres;

--
-- Name: Release Engineering: Open RET Aging; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "Release Engineering: Open RET Aging" AS
 SELECT rets."Entry ID",
    rets."Age",
    rets."Days since last modification",
    rets."Assigned To",
    rets."Assigned To: login",
    rets."Last Modified By",
    rets."Last Modified By: login",
    rets.status,
    rets."Orphaned status"
   FROM rets(now()) rets("Entry ID", "Age", "Days since last modification", "Assigned To", "Assigned To: login", "Last Modified By", "Last Modified By: login", status, "Orphaned status");


ALTER TABLE "Release Engineering: Open RET Aging" OWNER TO postgres;

--
-- Name: Release Engineering: Overview; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "Release Engineering: Overview" AS
 WITH aa AS (
         SELECT 0 AS id,
            'Average age'::text AS "desc"
        ), ab AS (
         SELECT 1 AS id,
            'Average days since last modification'::text AS "desc"
        ), ac AS (
         SELECT 2 AS id,
            'RETs: non orphaned'::text AS "desc"
        ), ad AS (
         SELECT 3 AS id,
            ('RETs: orphaned '::text || quote_literal('Assigned To'::text)) AS "desc"
        ), ae AS (
         SELECT 4 AS id,
            ('RETs: orphaned '::text || quote_literal('Last Modified by'::text)) AS "desc"
        ), af AS (
         SELECT 5 AS id,
            ((('RETs: orphaned '::text || quote_literal('Assigned To'::text)) || ' & '::text) || quote_literal('Last Modified by'::text)) AS "desc"
        ), ag AS (
         SELECT 6 AS id,
            'Total number of RETs'::text AS "desc"
        ), b0 AS (
         SELECT rets."Entry ID",
            rets."Age",
            rets."Days since last modification",
            rets."Assigned To",
            rets."Assigned To: login",
            rets."Last Modified By",
            rets."Last Modified By: login",
            rets.status,
            rets."Orphaned status"
           FROM rets(now()) rets("Entry ID", "Age", "Days since last modification", "Assigned To", "Assigned To: login", "Last Modified By", "Last Modified By: login", status, "Orphaned status")
        ), ba AS (
         SELECT 0 AS id,
            round(avg(b0."Age"), 2) AS val
           FROM b0
        ), bb AS (
         SELECT 1 AS id,
            round(avg(b0."Days since last modification"), 2) AS val
           FROM b0
        ), bc AS (
         SELECT 2 AS id,
            count(*) AS val
           FROM b0
          WHERE (b0."Orphaned status" IS NULL)
        ), bd AS (
         SELECT 3 AS id,
            count(*) AS val
           FROM b0
          WHERE ((length(b0."Orphaned status"[1]) > 0) AND (length(b0."Orphaned status"[2]) = 0))
        ), be AS (
         SELECT 4 AS id,
            count(*) AS val
           FROM b0
          WHERE ((length(b0."Orphaned status"[1]) = 0) AND (length(b0."Orphaned status"[2]) > 0))
        ), bf AS (
         SELECT 5 AS id,
            count(*) AS val
           FROM b0
          WHERE ((length(b0."Orphaned status"[1]) > 0) AND (length(b0."Orphaned status"[2]) > 0))
        ), bg AS (
         SELECT 6 AS id,
            count(*) AS val
           FROM b0
        ), c0 AS (
         SELECT b0."Entry ID",
            b0."Age",
            b0."Days since last modification",
            b0."Assigned To",
            b0."Assigned To: login",
            b0."Last Modified By",
            b0."Last Modified By: login",
            b0.status,
            b0."Orphaned status"
           FROM b0
          WHERE ((b0.status)::text <> 'Backlog'::text)
        ), ca AS (
         SELECT 0 AS id,
            round(avg(c0."Age"), 2) AS nob_val
           FROM c0
        ), cb AS (
         SELECT 1 AS id,
            round(avg(c0."Days since last modification"), 2) AS nob_val
           FROM c0
        ), cc AS (
         SELECT 2 AS id,
            count(*) AS nob_val
           FROM c0
          WHERE (c0."Orphaned status" IS NULL)
        ), cd AS (
         SELECT 3 AS id,
            count(*) AS nob_val
           FROM c0
          WHERE ((length(c0."Orphaned status"[1]) > 0) AND (length(c0."Orphaned status"[2]) = 0))
        ), ce AS (
         SELECT 4 AS id,
            count(*) AS nob_val
           FROM c0
          WHERE ((length(c0."Orphaned status"[1]) = 0) AND (length(c0."Orphaned status"[2]) > 0))
        ), cf AS (
         SELECT 5 AS id,
            count(*) AS nob_val
           FROM c0
          WHERE ((length(c0."Orphaned status"[1]) > 0) AND (length(c0."Orphaned status"[2]) > 0))
        ), cg AS (
         SELECT 6 AS id,
            count(*) AS nob_val
           FROM c0
        ), a AS (
         SELECT aa.id,
            aa."desc",
            ba.val,
            ca.nob_val
           FROM ((aa
             LEFT JOIN ba USING (id))
             LEFT JOIN ca USING (id))
        ), b AS (
         SELECT ab.id,
            ab."desc",
            bb.val,
            cb.nob_val
           FROM ((ab
             LEFT JOIN bb USING (id))
             LEFT JOIN cb USING (id))
        ), c AS (
         SELECT ac.id,
            ac."desc",
            bc.val,
            cc.nob_val
           FROM ((ac
             LEFT JOIN bc USING (id))
             LEFT JOIN cc USING (id))
        ), d AS (
         SELECT ad.id,
            ad."desc",
            bd.val,
            cd.nob_val
           FROM ((ad
             LEFT JOIN bd USING (id))
             LEFT JOIN cd USING (id))
        ), e AS (
         SELECT ae.id,
            ae."desc",
            be.val,
            ce.nob_val
           FROM ((ae
             LEFT JOIN be USING (id))
             LEFT JOIN ce USING (id))
        ), f AS (
         SELECT af.id,
            af."desc",
            bf.val,
            cf.nob_val
           FROM ((af
             LEFT JOIN bf USING (id))
             LEFT JOIN cf USING (id))
        ), g AS (
         SELECT ag.id,
            ag."desc",
            bg.val,
            cg.nob_val
           FROM ((ag
             LEFT JOIN bg USING (id))
             LEFT JOIN cg USING (id))
        ), h AS (
         SELECT a.id,
            a."desc",
            a.val,
            a.nob_val
           FROM a
        UNION
         SELECT b.id,
            b."desc",
            b.val,
            b.nob_val
           FROM b
        UNION
         SELECT c.id,
            c."desc",
            c.val,
            c.nob_val
           FROM c
        UNION
         SELECT d.id,
            d."desc",
            d.val,
            d.nob_val
           FROM d
        UNION
         SELECT e.id,
            e."desc",
            e.val,
            e.nob_val
           FROM e
        UNION
         SELECT f.id,
            f."desc",
            f.val,
            f.nob_val
           FROM f
        UNION
         SELECT g.id,
            g."desc",
            g.val,
            g.nob_val
           FROM g
  ORDER BY 1
        )
 SELECT h."desc",
    h.val,
    h.nob_val
   FROM h;


ALTER TABLE "Release Engineering: Overview" OWNER TO postgres;

--
-- Name: usr_report_definitions_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE usr_report_definitions_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_report_definitions_id OWNER TO postgres;

--
-- Name: usr_report_definitions; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE usr_report_definitions (
    id bigint DEFAULT nextval('usr_report_definitions_id'::regclass) NOT NULL,
    tbl_share_employee_managerspo_id bigint,
    tbl_share_employee_managerabove_id bigint,
    ix_product_family_id bigint,
    ix_product_id bigint,
    ix_product_area_id bigint
);


ALTER TABLE usr_report_definitions OWNER TO postgres;

--
-- Name: User Report Definitions; Type: VIEW; Schema: remedy; Owner: postgres
--

CREATE VIEW "User Report Definitions" AS
 WITH a AS (
         SELECT z.id AS "ID",
            z.tbl_share_employee_managerspo_id,
            x.name AS "Manager SPO",
            z.tbl_share_employee_managerabove_id,
            w.name AS "Manager Above",
            z.ix_product_family_id,
            u.name AS "Product Family",
            z.ix_product_id,
            t.name AS "Product",
            z.ix_product_area_id,
            s.name AS "Product Area"
           FROM (((((((usr_report_definitions z
             LEFT JOIN tbl_share_employee y ON ((y.requestid = z.tbl_share_employee_managerspo_id)))
             LEFT JOIN ix_employee_names x ON ((x.id = y.ix_full_name_id)))
             LEFT JOIN tbl_share_employee v ON ((v.requestid = z.tbl_share_employee_managerabove_id)))
             LEFT JOIN ix_employee_names w ON ((w.id = v.ix_full_name_id)))
             LEFT JOIN ix_product_family u ON ((u.id = z.ix_product_family_id)))
             LEFT JOIN ix_product t ON ((t.id = z.ix_product_id)))
             LEFT JOIN ix_product_area s ON ((s.id = z.ix_product_area_id)))
        )
 SELECT a."ID",
    a.tbl_share_employee_managerspo_id,
    a."Manager SPO",
    a.tbl_share_employee_managerabove_id,
    a."Manager Above",
    a.ix_product_family_id,
    a."Product Family",
    a.ix_product_id,
    a."Product",
    a.ix_product_area_id,
    a."Product Area"
   FROM a;


ALTER TABLE "User Report Definitions" OWNER TO postgres;

--
-- Name: history_issue_weekly; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE history_issue_weekly (
    ix_history_id bigint NOT NULL,
    entryid bigint,
    create_date timestamp without time zone,
    modified_date timestamp without time zone,
    ix_major_area_id bigint,
    ix_ntlogin_assigned_to_id bigint,
    ix_priority_id bigint,
    ix_product_id bigint,
    ix_product_area_id bigint,
    ix_product_family_id bigint,
    ix_product_release_id bigint,
    ix_status_id bigint,
    ix_status_details_id bigint,
    ix_type_id bigint
);


ALTER TABLE history_issue_weekly OWNER TO postgres;

--
-- Name: ix_audit_fields_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE ix_audit_fields_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_audit_fields_id OWNER TO postgres;

--
-- Name: ix_audit_fields; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_audit_fields (
    id bigint DEFAULT nextval('ix_audit_fields_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_audit_fields OWNER TO postgres;

--
-- Name: ix_history; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE ix_history (
    id bigint NOT NULL,
    end_tm timestamp without time zone
);


ALTER TABLE ix_history OWNER TO postgres;

--
-- Name: raw_how_found; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_how_found (
    how_found_main text,
    how_found_sub text
);


ALTER TABLE raw_how_found OWNER TO postgres;

--
-- Name: raw_issue_descriptions; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_issue_descriptions (
    "Entry-Id" character varying,
    "Modified Date" character varying,
    "Full Details" character varying
);


ALTER TABLE raw_issue_descriptions OWNER TO postgres;

--
-- Name: raw_issue_escalation_join; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_issue_escalation_join (
    "Entry ID" character varying,
    "Candidate Status" character varying,
    "Escalate by" character varying,
    "Escalate Reason" character varying,
    "SP Create Date" character varying,
    "SP Modified Date" character varying,
    "SP Last Modified by" character varying,
    "SP Target Release" character varying
);


ALTER TABLE raw_issue_escalation_join OWNER TO postgres;

--
-- Name: raw_issue_notify_list; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_issue_notify_list (
    "Entry-Id" character varying,
    "Modified Date" character varying,
    "Notify Email List" character varying
);


ALTER TABLE raw_issue_notify_list OWNER TO postgres;

--
-- Name: raw_issue_reported_by_manager_join; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_issue_reported_by_manager_join (
    "Entry-Id" character varying,
    "Direct Manager" character varying,
    "Senior Manager" character varying,
    "Status History Dismissed TIME" character varying,
    "Status History Fixed TIME" character varying,
    "Status History In-progress TIME" character varying,
    "Status History Open TIME" character varying,
    "Status History Waiting on Originator TIME" character varying,
    "Version Verified" character varying
);


ALTER TABLE raw_issue_reported_by_manager_join OWNER TO postgres;

--
-- Name: raw_issue_tracking; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_issue_tracking (
    "Entry-Id" character varying,
    "# of Duplicates" character varying,
    "# of Regressions Caused" character varying,
    "Assigned-to Full Name" character varying,
    "Assigned-to Function" character varying,
    "Assigned-to Group" character varying,
    "Array Serial Number" character varying,
    "Blocking" character varying,
    "Clarify ID" character varying,
    "Classification" character varying,
    "Create Date" character varying,
    "Customer Impact" character varying,
    "Customer Issue" character varying,
    "Customer Name" character varying,
    "Deferred Issue" character varying,
    "Earliest Dup Bug #" character varying,
    "Escalate" character varying,
    "Escalate Reason" character varying,
    "How Found" character varying,
    "Keywords" character varying,
    "Last modified by" character varying,
    "Long Term Enhancements" character varying,
    "Major Area" character varying,
    "Modified Date" character varying,
    "Num Escalations" character varying,
    "Prime Bug #" character varying,
    "Primus Needed" character varying,
    "Priority" character varying,
    "Product" character varying,
    "Product Area" character varying,
    "Product Family" character varying,
    "Product Release" character varying,
    "Release Note Needed" character varying,
    "Release When First Introduced" character varying,
    "Releases Built-in" character varying,
    "Regression" character varying,
    "Regression Bug #" character varying,
    "Reported by" character varying,
    "Reported by Function" character varying,
    "Reported by Group" character varying,
    "Root Cause" character varying,
    "Script Name" character varying,
    "Short Problem Description" character varying,
    "Status" character varying,
    "Status Details" character varying,
    "Summary" character varying,
    "Type" character varying,
    "Version Found" character varying,
    "Version When First Introduced" character varying,
    "Additional references" character varying,
    "Notify List" character varying,
    "Support Materials" character varying
);


ALTER TABLE raw_issue_tracking OWNER TO postgres;

--
-- Name: raw_jira_ars; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_jira_ars (
    entryid character varying
);


ALTER TABLE raw_jira_ars OWNER TO postgres;

--
-- Name: raw_other; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_other (
    "Entry-Id" character varying,
    "Modified Date" character varying,
    "Additional references" character varying,
    "Notify List" character varying,
    "Support Materials" character varying
);


ALTER TABLE raw_other OWNER TO postgres;

--
-- Name: raw_release_engineering_tracker; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_release_engineering_tracker (
    "Entry ID" character varying,
    "Assigned to" character varying,
    "Create Date" character varying,
    "Functional Area" character varying,
    "Last Modified By" character varying,
    "Modified Date" character varying,
    "Priority" character varying,
    "Reported by" character varying,
    "Request Type" character varying,
    "Status" character varying,
    "Submitter_Login_ID_hdn" character varying,
    "Summary" character varying
);


ALTER TABLE raw_release_engineering_tracker OWNER TO postgres;

--
-- Name: raw_releases; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_releases (
    "Request ID" character varying,
    "Create Date" character varying,
    "Email Users" character varying,
    "Enabled" character varying,
    "Last Modified By" character varying,
    "Modified Date" character varying,
    "Product Family" character varying,
    "Product Release" character varying
);


ALTER TABLE raw_releases OWNER TO postgres;

--
-- Name: raw_report_definitions; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_report_definitions (
    "Manager SPO" character varying,
    "Manager Above" character varying,
    "Product Family" character varying,
    "Product" character varying,
    "Product Area" character varying
);


ALTER TABLE raw_report_definitions OWNER TO postgres;

--
-- Name: raw_share_association; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_share_association (
    "Request ID" character varying,
    "Last Modified By" character varying,
    "Modified Date" character varying,
    "Relationship Type" character varying,
    "Request ID 1" character varying,
    "Request ID 2" character varying,
    "Status" character varying
);


ALTER TABLE raw_share_association OWNER TO postgres;

--
-- Name: raw_share_audit; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_share_audit (
    "Request ID" character varying,
    "Object Entry ID" character varying,
    "Attribute" character varying,
    "Attribute Label" character varying,
    "Create Date" character varying,
    "From Value" character varying,
    "Modified Date" character varying,
    "Submitter" character varying,
    "To Value" character varying
);


ALTER TABLE raw_share_audit OWNER TO postgres;

--
-- Name: raw_share_employee; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_share_employee (
    "Request ID" character varying,
    "Login" character varying,
    "Group Name" character varying,
    "Email Address" character varying,
    "Employee ID" character varying,
    "First Name" character varying,
    "Full Name" character varying,
    "Last Name" character varying,
    "Status" character varying,
    "System Modified Date" character varying,
    "Function Name" character varying
);


ALTER TABLE raw_share_employee OWNER TO postgres;

--
-- Name: raw_share_notes; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_share_notes (
    "Request ID" character varying,
    "Entry ID" character varying,
    "Full Name" character varying,
    "Last Modified By" character varying,
    "Modified Date" character varying,
    "Short Desc" character varying,
    "Note Details" character varying
);


ALTER TABLE raw_share_notes OWNER TO postgres;

--
-- Name: raw_share_release_association; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_share_release_association (
    "Request ID" character varying,
    "Issue Entry ID" character varying,
    "Release Name" character varying,
    "Modified Date" character varying
);


ALTER TABLE raw_share_release_association OWNER TO postgres;

--
-- Name: raw_share_user_notification; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE raw_share_user_notification (
    "Request ID" character varying,
    "NSG Issue Tracking Id" character varying,
    "Login" character varying,
    "Name" character varying
);


ALTER TABLE raw_share_user_notification OWNER TO postgres;

--
-- Name: tbl_issue_status; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_issue_status (
    entryid bigint NOT NULL,
    ix_status_id bigint,
    ix_ntlogin_assigned_to_id bigint,
    ix_ntlogin_reported_by_id bigint,
    ix_ntlogin_last_modified_by_id bigint,
    last_modified_date timestamp without time zone,
    status_history_dismissed timestamp without time zone,
    status_history_fixed timestamp without time zone,
    status_history_verified timestamp without time zone,
    version_verified character varying
);


ALTER TABLE tbl_issue_status OWNER TO postgres;

--
-- Name: tbl_issuetracking_products; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_issuetracking_products (
    entryid bigint,
    ix_product_id bigint
);


ALTER TABLE tbl_issuetracking_products OWNER TO postgres;

--
-- Name: tbl_other; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tbl_other (
    entryid bigint NOT NULL,
    modified_date timestamp without time zone,
    additional_references character varying,
    notify_list character varying,
    support_materials character varying
);


ALTER TABLE tbl_other OWNER TO postgres;

--
-- Name: tmp_ars_for_jira; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_ars_for_jira (
    entryid bigint,
    "Entry-Id" character varying,
    "# of Duplicates" integer,
    "# of Regressions Caused" integer,
    "Additional References" character varying,
    "Array Serial Number" character varying,
    "Assigned to" character varying,
    "Assigned to Function" character varying,
    "Assigned to Group" character varying,
    "Blocking" boolean,
    changes public.change[],
    "Clarify ID" character varying,
    "Classification" character varying,
    "Create date" timestamp without time zone,
    "Customer Impact" character varying,
    "Customer Issue" boolean,
    "Customer Name" character varying,
    "Deferred Issue" boolean,
    "Earliest Dup Bug #" character varying,
    "Escalate" boolean,
    "Escalate Reason" character varying,
    "How Found" character varying,
    "Keywords" character varying,
    "Last modified by" character varying,
    "Long Term Enhancements" character varying,
    "Major Area" character varying,
    "Modified date" timestamp without time zone,
    notes public.note[],
    "Notify List" text[],
    "Num Escalations" integer,
    "Primus Needed" character varying,
    "Priority" character varying,
    "Product" character varying,
    "Product Area" character varying,
    "Product Family" character varying,
    "Product Release" character varying,
    "Release Note Needed" character varying,
    "Release When First Introduced" character varying,
    "Releases Built-in" text[],
    "Regression" boolean,
    "Regression Bug #" character varying,
    "Reported by" character varying,
    "Reported by Function" character varying,
    "Reported by Group" character varying,
    "Root Cause" character varying,
    "Resolution" text,
    "Resolutiondate" timestamp without time zone,
    "Script Name" character varying,
    "Short Problem Description" character varying,
    "Status" text,
    "Status Details" text,
    "Summary" character varying,
    "Support Materials" character varying,
    "Type" character varying,
    "Version Found" character varying,
    "Version When First Introduced" character varying,
    "Version Verified" character varying,
    "Full Details" character varying,
    "JIRA Create date" text,
    "JIRA Modified date" text
);


ALTER TABLE tmp_ars_for_jira OWNER TO postgres;

--
-- Name: tmp_entryid_20170927; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_entryid_20170927 (
    entryid bigint
);


ALTER TABLE tmp_entryid_20170927 OWNER TO postgres;

--
-- Name: tmp_entryid_20170928; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_entryid_20170928 (
    entryid bigint
);


ALTER TABLE tmp_entryid_20170928 OWNER TO postgres;

--
-- Name: tmp_entryid_20171009; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_entryid_20171009 (
    entryid bigint
);


ALTER TABLE tmp_entryid_20171009 OWNER TO postgres;

--
-- Name: tmp_ix_history; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_ix_history (
    id bigint,
    end_tm timestamp without time zone,
    start_tm timestamp without time zone
);


ALTER TABLE tmp_ix_history OWNER TO postgres;

--
-- Name: tmp_jiracomments; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jiracomments (
    "externalId" bigint,
    comments public.jira_comment[]
);


ALTER TABLE tmp_jiracomments OWNER TO postgres;

--
-- Name: tmp_jiracomponents; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jiracomponents (
    component character varying
);


ALTER TABLE tmp_jiracomponents OWNER TO postgres;

--
-- Name: tmp_jiracustomfieldvalues_array; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jiracustomfieldvalues_array (
    "externalId" bigint,
    "customFieldValues_array" public.jira_customfield_array[]
);


ALTER TABLE tmp_jiracustomfieldvalues_array OWNER TO postgres;

--
-- Name: tmp_jiracustomfieldvalues_hash; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jiracustomfieldvalues_hash (
    "externalId" bigint,
    "customFieldValues_hash" public.jira_customfield_hash[]
);


ALTER TABLE tmp_jiracustomfieldvalues_hash OWNER TO postgres;

--
-- Name: tmp_jiracustomfieldvalues_text; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jiracustomfieldvalues_text (
    "externalId" bigint,
    "customFieldValues_text" public.jira_customfield_text[]
);


ALTER TABLE tmp_jiracustomfieldvalues_text OWNER TO postgres;

--
-- Name: tmp_jirahistory; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jirahistory (
    "externalId" bigint,
    history public.jira_history[]
);


ALTER TABLE tmp_jirahistory OWNER TO postgres;

--
-- Name: tmp_jiraissues; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jiraissues (
    issue public.jira_issue
);


ALTER TABLE tmp_jiraissues OWNER TO postgres;

--
-- Name: tmp_jirajson; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jirajson (
    users public.jira_user[],
    links public.jira_link[],
    projects public.jira_project[]
);


ALTER TABLE tmp_jirajson OWNER TO postgres;

--
-- Name: tmp_jiralinks; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jiralinks (
    link public.jira_link
);


ALTER TABLE tmp_jiralinks OWNER TO postgres;

--
-- Name: tmp_jiraprojects; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jiraprojects (
    project public.jira_project
);


ALTER TABLE tmp_jiraprojects OWNER TO postgres;

--
-- Name: tmp_jirausers; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jirausers (
    ntlogin character varying,
    "displayName" character varying,
    email text,
    "groupBy" character varying,
    "functionBy" character varying,
    "isActive" boolean
);


ALTER TABLE tmp_jirausers OWNER TO postgres;

--
-- Name: tmp_jiraversions; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE tmp_jiraversions (
    version public.jira_version
);


ALTER TABLE tmp_jiraversions OWNER TO postgres;

--
-- Name: usr_closed_status_detail_id; Type: SEQUENCE; Schema: remedy; Owner: postgres
--

CREATE SEQUENCE usr_closed_status_detail_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE usr_closed_status_detail_id OWNER TO postgres;

--
-- Name: usr_closed_status_detail; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE usr_closed_status_detail (
    id bigint DEFAULT nextval('usr_closed_status_detail_id'::regclass) NOT NULL,
    name character varying NOT NULL,
    ix_status_details_id bigint
);


ALTER TABLE usr_closed_status_detail OWNER TO postgres;

--
-- Name: usr_issue_tracking_attributes; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE usr_issue_tracking_attributes (
    ix_audit_attribute_id bigint,
    is_relevant_to_backlog boolean DEFAULT false NOT NULL,
    tbl_issue_tracking_column character varying
);


ALTER TABLE usr_issue_tracking_attributes OWNER TO postgres;

--
-- Name: usr_managerspo_priority_offsets; Type: TABLE; Schema: remedy; Owner: postgres
--

CREATE TABLE usr_managerspo_priority_offsets (
    tbl_share_employee_managerspo_id bigint,
    "P00" integer,
    "P01" integer,
    "P02" integer,
    "P03" integer,
    tm timestamp without time zone
);


ALTER TABLE usr_managerspo_priority_offsets OWNER TO postgres;

SET search_path = shares, pg_catalog;

--
-- Name: rpmdir; Type: SEQUENCE; Schema: shares; Owner: postgres
--

CREATE SEQUENCE rpmdir
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rpmdir OWNER TO postgres;

--
-- Name: buildsharedirs; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE buildsharedirs (
    id bigint DEFAULT nextval('rpmdir'::regclass) NOT NULL,
    dir character varying NOT NULL
);


ALTER TABLE buildsharedirs OWNER TO postgres;

--
-- Name: current_buildshare; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE current_buildshare (
    name character varying,
    inode integer,
    dir_id bigint NOT NULL,
    type character varying,
    permission integer,
    owner character varying,
    "group" character varying,
    size bigint,
    lastmodified timestamp with time zone,
    target_dirid bigint
);


ALTER TABLE current_buildshare OWNER TO postgres;

--
-- Name: builddirs; Type: VIEW; Schema: shares; Owner: postgres
--

CREATE VIEW builddirs AS
 WITH a0 AS (
         SELECT x.name
           FROM ( VALUES ('.min_builds'::text,'.max_builds'::text,'.usepct'::text,'INDEX'::text)) x(name, column2, column3, column4)
        ), a1 AS (
         SELECT DISTINCT current_buildshare.dir_id
           FROM current_buildshare
          WHERE ((current_buildshare.name)::text IN ( SELECT a0.name
                   FROM a0))
        ), a2 AS (
         SELECT current_buildshare.dir_id,
            count(*) AS cnt
           FROM current_buildshare
          WHERE ((current_buildshare.dir_id IN ( SELECT a1.dir_id
                   FROM a1)) AND ((current_buildshare.type)::text = 'directory'::text))
          GROUP BY current_buildshare.dir_id
        ), a3 AS (
         SELECT a2.dir_id,
            z.dir
           FROM (a2
             LEFT JOIN buildsharedirs z ON ((z.id = a2.dir_id)))
          WHERE (a2.cnt > 0)
          ORDER BY z.dir
        )
 SELECT a3.dir_id,
    a3.dir
   FROM a3;


ALTER TABLE builddirs OWNER TO postgres;

--
-- Name: stream_id; Type: SEQUENCE; Schema: shares; Owner: postgres
--

CREATE SEQUENCE stream_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE stream_id OWNER TO postgres;

--
-- Name: cistreams; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE cistreams (
    id bigint DEFAULT nextval('stream_id'::regclass) NOT NULL,
    name character varying
);


ALTER TABLE cistreams OWNER TO postgres;

--
-- Name: current_rpmjobs; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE current_rpmjobs (
    job_id bigint NOT NULL,
    org_id integer,
    transaction bigint,
    trans_date timestamp without time zone,
    lastbld integer,
    builds integer,
    size bigint
);


ALTER TABLE current_rpmjobs OWNER TO postgres;

--
-- Name: rpmbuilds; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE rpmbuilds (
    job_id bigint,
    build integer,
    build_txn bigint,
    trans_date timestamp without time zone,
    promote_updates boolean,
    last_attempt bigint,
    last_built bigint,
    last_marker bigint,
    last_success bigint,
    last_cs_dirid bigint,
    last_dart_dirid bigint,
    last_rockies_dirid bigint
);


ALTER TABLE rpmbuilds OWNER TO postgres;

--
-- Name: rpmjob; Type: SEQUENCE; Schema: shares; Owner: postgres
--

CREATE SEQUENCE rpmjob
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rpmjob OWNER TO postgres;

--
-- Name: rpmjobs; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE rpmjobs (
    id bigint DEFAULT nextval('rpmjob'::regclass) NOT NULL,
    dir_id bigint,
    stream_id bigint,
    min_builds integer,
    max_builds integer,
    usepct integer
);


ALTER TABLE rpmjobs OWNER TO postgres;

--
-- Name: rpmlocations; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE rpmlocations (
    location character varying,
    team character varying,
    capacity bigint,
    mount character varying,
    scanner_id bigint
);


ALTER TABLE rpmlocations OWNER TO postgres;

--
-- Name: builds info; Type: VIEW; Schema: shares; Owner: postgres
--

CREATE VIEW "builds info" AS
 WITH a9 AS (
         SELECT z.server_id,
            z.job_id,
            count(y.id) AS builds
           FROM (jenkins.cijobs z
             LEFT JOIN jenkins.cibuilds y ON ((y.job_id = z.job_id)))
          WHERE (z.job_id IN ( SELECT DISTINCT current_rpmjobs.job_id
                   FROM current_rpmjobs))
          GROUP BY z.server_id, z.job_id
        ), b9 AS (
         SELECT y.master,
            z.name AS job,
            max(z.tm) AS tm
           FROM (jenkins.cijobs z
             LEFT JOIN jenkins.ciservers y ON ((y.id = z.server_id)))
          GROUP BY y.master, z.name
        ), a8 AS (
         SELECT z.dir_id
           FROM current_buildshare z
          WHERE (((z.name)::text ~ '^build-\d'::text) OR ((z.name)::text ~ '^.min_builds$'::text) OR ((z.name)::text ~ '^.max_builds$'::text) OR ((z.name)::text ~ '^.usepct$'::text))
          GROUP BY z.dir_id
        ), b8 AS (
         SELECT z.id,
            z.dir,
            regexp_replace((z.dir)::text, ((y.location)::text || '/'::text), ''::text) AS job,
            regexp_replace((z.dir)::text, '(/[^/]+)$'::text, ''::text) AS parentdir,
            regexp_replace((z.dir)::text, '^.*/([^/]+)$'::text, '\1'::text) AS name,
            y.team AS location
           FROM (buildsharedirs z
             LEFT JOIN rpmlocations y ON ((strpos((z.dir)::text, ((y.location)::text || '/'::text)) = 1)))
          WHERE ((z.id IN ( SELECT a8.dir_id
                   FROM a8)) AND ((z.dir)::text !~ '/build-\d'::text))
        ), c8 AS (
         SELECT b8.id,
            b8.job,
            b8.dir,
            b8.location,
            z.id AS p_id,
            y.name,
            y.inode,
            y.dir_id,
            y.type,
            y.permission,
            y.owner,
            y."group",
            y.size,
            y.lastmodified,
            y.target_dirid
           FROM ((b8
             LEFT JOIN buildsharedirs z ON (((z.dir)::text = b8.parentdir)))
             LEFT JOIN current_buildshare y ON (((y.dir_id = z.id) AND ((y.name)::text = b8.name))))
        ), d8 AS (
         SELECT rpmbuilds.job_id,
            min(rpmbuilds.build) AS minbuild,
            max(rpmbuilds.build) AS maxbuild,
            min(rpmbuilds.build_txn) AS min_txn,
            max(rpmbuilds.build_txn) AS max_txn,
            min(rpmbuilds.trans_date) AS min_date,
            max(rpmbuilds.trans_date) AS max_date,
                CASE
                    WHEN every((rpmbuilds.promote_updates = true)) THEN true
                    ELSE false
                END AS promote_updates,
            count(*) AS bld_dirs
           FROM rpmbuilds
          WHERE (rpmbuilds.job_id IN ( SELECT DISTINCT current_rpmjobs.job_id
                   FROM current_rpmjobs))
          GROUP BY rpmbuilds.job_id
        ), e8 AS (
         SELECT current_rpmjobs.job_id,
            current_rpmjobs.org_id,
            max(current_rpmjobs.transaction) AS transaction
           FROM current_rpmjobs
          GROUP BY current_rpmjobs.job_id, current_rpmjobs.org_id
        ), f8 AS (
         SELECT z.job_id,
            z.org_id,
            z.transaction,
            z.trans_date,
            z.lastbld,
            z.builds,
            z.size
           FROM (current_rpmjobs z
             LEFT JOIN e8 ON (((e8.job_id = z.job_id) AND (e8.org_id = z.org_id) AND (e8.transaction = z.transaction))))
        ), b7 AS (
         SELECT z.id AS job_id,
            z.min_builds,
            z.max_builds,
            z.usepct,
            c8.id,
            c8.job,
            c8.dir,
            c8.location,
            c8.p_id,
            c8.name,
            c8.inode,
            c8.dir_id,
            c8.type,
            c8.permission,
            c8.owner,
            c8."group",
            c8.size,
            c8.lastmodified,
            c8.target_dirid,
                CASE
                    WHEN (y.name IS NOT NULL) THEN (y.name)::text
                    WHEN (regexp_replace((c8.dir)::text, '^.*(upc-.*-((m?cs)|(usr))).*$'::text, '\1'::text, 'i'::text) = (c8.dir)::text) THEN NULL::text
                    ELSE regexp_replace((c8.dir)::text, '^.*(upc-.*-((m?cs)|(usr))).*$'::text, '\1'::text, 'i'::text)
                END AS stream,
            y.id AS stream_id
           FROM ((rpmjobs z
             LEFT JOIN c8 ON ((c8.id = z.dir_id)))
             LEFT JOIN cistreams y ON ((y.id = z.stream_id)))
        ), c7 AS (
         SELECT b7.stream,
            b7.size,
            d8.min_date,
            f8.trans_date AS "last transaction",
            d8.max_date,
            f8.builds,
            d8.minbuild,
            d8.maxbuild,
            d8.bld_dirs,
            d8.min_txn,
            f8.transaction,
            d8.max_txn,
            b7.min_builds,
            b7.max_builds,
            b7.usepct,
            d8.promote_updates,
            b7.dir,
            b7.location,
            b7.job,
            f8.org_id,
            f8.job_id
           FROM ((f8
             LEFT JOIN d8 ON ((d8.job_id = f8.job_id)))
             LEFT JOIN b7 ON ((b7.job_id = f8.job_id)))
        ), a6 AS (
         SELECT b9.master,
            c7.stream,
            c7.size,
            c7.min_date,
            c7."last transaction",
            c7.max_date,
            c7.builds,
            c7.minbuild,
            c7.maxbuild,
            c7.bld_dirs,
            c7.min_txn,
            c7.transaction,
            c7.max_txn,
            c7.min_builds,
            c7.max_builds,
            c7.usepct,
            c7.promote_updates,
            c7.dir,
            c7.location,
            c7.job,
            c7.org_id,
            c7.job_id
           FROM (c7
             LEFT JOIN b9 ON (((b9.job)::text = c7.job)))
          ORDER BY (lower((b9.master)::text)), (lower(c7.stream))
        )
 SELECT a6.master,
    a6.stream,
    a6.size,
    a6.min_date,
    a6."last transaction",
    a6.max_date,
    a6.builds,
    a6.minbuild,
    a6.maxbuild,
    a6.bld_dirs,
    a6.min_txn,
    a6.transaction,
    a6.max_txn,
    a6.min_builds,
    a6.max_builds,
    a6.usepct,
    a6.promote_updates,
    a6.dir,
    a6.location,
    a6.job,
    a6.org_id,
    a6.job_id
   FROM a6;


ALTER TABLE "builds info" OWNER TO postgres;

--
-- Name: builds overview; Type: VIEW; Schema: shares; Owner: postgres
--

CREATE VIEW "builds overview" AS
 WITH cibld AS (
         SELECT "builds info".master,
            "builds info".location,
            round(((sum("builds info".size) / (1024)::numeric) / (1024)::numeric), 2) AS "space used (MB)",
            round(((((100)::numeric * sum("builds info".size)) / ('12688293872'::bigint)::numeric) / (1024)::numeric), 2) AS "space used (%)",
            count(*) AS jobs,
            sum("builds info".builds) AS "total builds",
                CASE
                    WHEN (max("builds info"."last transaction") > max("builds info".max_date)) THEN max("builds info"."last transaction")
                    ELSE max("builds info".max_date)
                END AS "last update"
           FROM "builds info"
          WHERE (("builds info".location)::text = 'CI-build'::text)
          GROUP BY "builds info".master, "builds info".location
        ), stbld AS (
         SELECT "builds info".master,
            "builds info".location,
            round(((sum("builds info".size) / (1024)::numeric) / (1024)::numeric), 2) AS "space used (MB)",
            round(((((100)::numeric * sum("builds info".size)) / ('4229431280'::bigint)::numeric) / (1024)::numeric), 2) AS "space used (%)",
            count(*) AS jobs,
            sum("builds info".builds) AS "total builds",
                CASE
                    WHEN (max("builds info"."last transaction") > max("builds info".max_date)) THEN max("builds info"."last transaction")
                    ELSE max("builds info".max_date)
                END AS "last update"
           FROM "builds info"
          WHERE (("builds info".location)::text = 'ST-build'::text)
          GROUP BY "builds info".master, "builds info".location
        ), xll AS (
         SELECT cibld.master,
            cibld.location,
            cibld."space used (MB)",
            cibld."space used (%)",
            cibld.jobs,
            cibld."total builds",
            cibld."last update"
           FROM cibld
        UNION
         SELECT stbld.master,
            stbld.location,
            stbld."space used (MB)",
            stbld."space used (%)",
            stbld.jobs,
            stbld."total builds",
            stbld."last update"
           FROM stbld
  ORDER BY 2, 3 DESC, 1
        )
 SELECT xll.master,
    xll.location,
    xll."space used (MB)",
    xll."space used (%)",
    xll.jobs,
    xll."total builds",
    xll."last update"
   FROM xll;


ALTER TABLE "builds overview" OWNER TO postgres;

--
-- Name: builds_info; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE builds_info (
    master character varying,
    stream text,
    size bigint,
    min_date timestamp without time zone,
    "last transaction" timestamp without time zone,
    max_date timestamp without time zone,
    builds integer,
    minbuild integer,
    maxbuild integer,
    bld_dirs bigint,
    min_txn bigint,
    transaction bigint,
    max_txn bigint,
    min_builds integer,
    max_builds integer,
    usepct integer,
    promote_updates boolean,
    dir character varying,
    location character varying,
    job text,
    org_id integer,
    job_id bigint,
    tm timestamp with time zone
);


ALTER TABLE builds_info OWNER TO postgres;

--
-- Name: builds_overview; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE builds_overview (
    master character varying,
    location character varying,
    "space used (MB)" numeric,
    "space used (%)" numeric,
    jobs bigint,
    "total builds" bigint,
    "last update" timestamp without time zone,
    tm timestamp with time zone
);


ALTER TABLE builds_overview OWNER TO postgres;

--
-- Name: rpmscans; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE rpmscans (
    id bigint,
    tm timestamp without time zone,
    dirs integer,
    jobs integer,
    builds integer,
    links integer,
    emptyfiles integer,
    regfiles bigint,
    total bigint,
    duration integer,
    size bigint
);


ALTER TABLE rpmscans OWNER TO postgres;

--
-- Name: filescan.csv; Type: VIEW; Schema: shares; Owner: postgres
--

CREATE VIEW "filescan.csv" AS
 WITH a AS (
         SELECT z.name,
            z.inode,
            y.dir,
            z.type,
            z.permission,
            z.owner,
            z."group",
            z.size,
            z.lastmodified,
            x.dir AS target
           FROM ((current_buildshare z
             LEFT JOIN buildsharedirs y ON ((y.id = z.dir_id)))
             LEFT JOIN buildsharedirs x ON ((x.id = z.target_dirid)))
        ), b AS (
         SELECT max(rpmscans.tm) AS tm
           FROM rpmscans
        )
 SELECT b.tm,
    a.name,
    a.inode,
    a.dir,
    a.type,
    a.permission,
    a.owner,
    a."group",
    a.size,
    a.lastmodified,
    a.target
   FROM a,
    b;


ALTER TABLE "filescan.csv" OWNER TO postgres;

--
-- Name: history_buildshare; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE history_buildshare (
    start timestamp without time zone,
    "end" timestamp without time zone,
    name character varying,
    inode integer,
    dir_id bigint NOT NULL,
    type character varying,
    permission integer,
    owner character varying,
    "group" character varying,
    size bigint,
    lastmodified timestamp with time zone,
    target_dirid bigint
);


ALTER TABLE history_buildshare OWNER TO postgres;

--
-- Name: history_rpmjobs; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE history_rpmjobs (
    job_id bigint NOT NULL,
    tm timestamp without time zone,
    transaction bigint,
    trans_date timestamp without time zone,
    lastbld integer,
    builds integer,
    size bigint
);


ALTER TABLE history_rpmjobs OWNER TO postgres;

--
-- Name: rpmbuild.csv; Type: VIEW; Schema: shares; Owner: postgres
--

CREATE VIEW "rpmbuild.csv" AS
 SELECT a.job_id,
    a.last_attempt,
    a.last_built,
    b.dir AS last_cs,
    c.dir AS last_dart,
    a.last_marker,
    d.dir AS last_rockies,
    a.last_success,
    a.build,
    a.build_txn,
    a.trans_date,
    a.promote_updates
   FROM (((rpmbuilds a
     LEFT JOIN buildsharedirs b ON ((b.id = a.last_cs_dirid)))
     LEFT JOIN buildsharedirs c ON ((c.id = a.last_dart_dirid)))
     LEFT JOIN buildsharedirs d ON ((d.id = a.last_rockies_dirid)))
  ORDER BY a.job_id;


ALTER TABLE "rpmbuild.csv" OWNER TO postgres;

--
-- Name: rpmjob.csv; Type: VIEW; Schema: shares; Owner: postgres
--

CREATE VIEW "rpmjob.csv" AS
 WITH a AS (
         SELECT max(rpmscans.tm) AS tm
           FROM rpmscans
        ), c AS (
         SELECT concat(z.dir, '/', y.name) AS dir,
            y.name,
            y.inode,
            y.dir_id,
            y.type,
            y.permission,
            y.owner,
            y."group",
            y.size,
            y.lastmodified,
            y.target_dirid
           FROM (current_buildshare y
             LEFT JOIN buildsharedirs z ON ((z.id = y.dir_id)))
          WHERE ((y.type)::text = 'directory'::text)
        ), d AS (
         SELECT z.id,
            z.dir_id,
            z.stream_id,
            z.min_builds,
            z.max_builds,
            z.usepct,
            y.dir,
            x.name AS stream,
            c.size
           FROM (((rpmjobs z
             LEFT JOIN buildsharedirs y ON ((y.id = z.dir_id)))
             LEFT JOIN cistreams x ON ((x.id = z.stream_id)))
             LEFT JOIN c ON (((y.dir)::text = c.dir)))
        ), e AS (
         SELECT z.org_id,
            d.id,
            a.tm,
            d.dir,
            d.min_builds,
            d.max_builds,
            d.usepct,
            z.builds,
            z.transaction,
            d.stream,
            z.trans_date,
            z.lastbld,
            z.size
           FROM a,
            (d
             LEFT JOIN current_rpmjobs z ON ((d.id = z.job_id)))
        )
 SELECT e.org_id,
    e.id,
    e.tm,
    e.dir,
    e.min_builds,
    e.max_builds,
    e.usepct,
    e.builds,
    e.transaction,
    e.stream,
    e.trans_date,
    e.lastbld,
    e.size
   FROM e;


ALTER TABLE "rpmjob.csv" OWNER TO postgres;

--
-- Name: rpmscan; Type: SEQUENCE; Schema: shares; Owner: postgres
--

CREATE SEQUENCE rpmscan
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rpmscan OWNER TO postgres;

--
-- Name: rpmscan.csv; Type: VIEW; Schema: shares; Owner: postgres
--

CREATE VIEW "rpmscan.csv" AS
 SELECT rpmscans.id,
    rpmscans.tm,
    rpmscans.dirs,
    rpmscans.jobs,
    rpmscans.builds,
    rpmscans.links,
    rpmscans.emptyfiles,
    rpmscans.regfiles,
    rpmscans.total,
    rpmscans.duration,
    rpmscans.size
   FROM rpmscans;


ALTER TABLE "rpmscan.csv" OWNER TO postgres;

--
-- Name: sharedirs overview; Type: VIEW; Schema: shares; Owner: postgres
--

CREATE VIEW "sharedirs overview" AS
 SELECT y.location,
    count(z.*) AS count
   FROM (buildsharedirs z
     LEFT JOIN rpmlocations y ON (((z.dir)::text ~* ('^'::text || (y.location)::text))))
  GROUP BY y.location;


ALTER TABLE "sharedirs overview" OWNER TO postgres;

--
-- Name: validfiles; Type: TABLE; Schema: shares; Owner: postgres
--

CREATE TABLE validfiles (
    key character varying,
    path character varying,
    match character varying
);


ALTER TABLE validfiles OWNER TO postgres;

SET search_path = vcenter, pg_catalog;

--
-- Name: 2015-12-14.Poweroff; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "2015-12-14.Poweroff" (
    esxserver character varying,
    name character varying,
    vmpathname character varying
);


ALTER TABLE "2015-12-14.Poweroff" OWNER TO postgres;

--
-- Name: 2016-01-29.VMs for deletion; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "2016-01-29.VMs for deletion" (
    server character varying,
    name character varying,
    numcpus integer,
    memory_size integer,
    category character varying
);


ALTER TABLE "2016-01-29.VMs for deletion" OWNER TO postgres;

--
-- Name: 2016-02-14.VMs for deletion; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "2016-02-14.VMs for deletion" (
    server character varying,
    name character varying,
    folder character varying,
    numcpus integer,
    memory_size integer
);


ALTER TABLE "2016-02-14.VMs for deletion" OWNER TO postgres;

--
-- Name: 2016-02-29.Categories; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "2016-02-29.Categories" (
    name character varying,
    esxserver character varying,
    vmid character varying,
    category character varying
);


ALTER TABLE "2016-02-29.Categories" OWNER TO postgres;

--
-- Name: 2016-04-18.ip reassignments; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "2016-04-18.ip reassignments" (
    "Scan Time" timestamp with time zone,
    "System Name" character varying,
    "IP Address" character varying,
    "Physical Location" character varying,
    "Virtual or Physical" text,
    "Vcenter/Hardware" character varying,
    "Operating System" character varying,
    "Number of Processors" integer,
    "CPU Memory" bigint,
    " Used Disk Space" real,
    "Free Disk Space" real,
    "Total Capacity" real,
    "Number of Disks" integer,
    "Powered On" boolean,
    "vCenter Folder" text,
    "Category" character varying,
    "vCenter ID" character varying
);


ALTER TABLE "2016-04-18.ip reassignments" OWNER TO postgres;

--
-- Name: 2016-10-06.usd_cloud powered-off vms; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "2016-10-06.usd_cloud powered-off vms" (
    "Name" character varying,
    "State" character varying,
    "Status" character varying,
    "Host" character varying,
    "Provisioned Space" character varying,
    "Used Space" character varying,
    "Host CPU - MHz" character varying,
    "Host Mem - MB" character varying,
    "Guest Mem - %" character varying,
    "IP Address" character varying,
    "Notes" character varying,
    "Alarm Actions" character varying,
    "Owner" character varying,
    inc character varying
);


ALTER TABLE "2016-10-06.usd_cloud powered-off vms" OWNER TO postgres;

--
-- Name: 2017-11-06.usd_cloud_master; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "2017-11-06.usd_cloud_master" (
    server character varying,
    "Cloud Location" character varying,
    "VM Type" character varying,
    "Name" character varying,
    ntlogin character varying,
    "Owner" character varying,
    "Column2" character varying,
    "Manager" character varying,
    "Active" character varying,
    "Notes" character varying,
    "Keep/Remove" character varying,
    "Level 4" character varying,
    "Level 5" character varying,
    "Level 6" character varying,
    "Level 7" character varying,
    "VmPathName" character varying,
    "Notes2" character varying,
    "PowerState" character varying,
    "NumCpu" character varying,
    "MemoryGB" character varying,
    "UsedSpaceGB" character varying,
    "guestId" character varying,
    "folderName" character varying,
    "folderId" character varying,
    "folderParentId" character varying,
    vmid character varying,
    hostname character varying,
    "ipAddress" character varying,
    "guestOS" character varying,
    "Connected" character varying,
    "NumNics" character varying,
    "CapacityGB" character varying,
    "FreeSpaceGB" character varying,
    "virtualDisks" character varying,
    "toolsVersion" character varying,
    "ToolsStatus" character varying,
    "ToolsCfgVersion" character varying,
    "ToolsVersionStatus" character varying,
    "Column1" character varying
);


ALTER TABLE "2017-11-06.usd_cloud_master" OWNER TO postgres;

--
-- Name: tools_status_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE tools_status_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tools_status_id OWNER TO postgres;

--
-- Name: tools_status; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE tools_status (
    id integer DEFAULT nextval('tools_status_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE tools_status OWNER TO postgres;

--
-- Name: tools_version_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE tools_version_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tools_version_id OWNER TO postgres;

--
-- Name: tools_version; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE tools_version (
    id bigint DEFAULT nextval('tools_version_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE tools_version OWNER TO postgres;

--
-- Name: tools_version_status_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE tools_version_status_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tools_version_status_id OWNER TO postgres;

--
-- Name: tools_version_status; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE tools_version_status (
    id integer DEFAULT nextval('tools_version_status_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE tools_version_status OWNER TO postgres;

--
-- Name: vmcategory; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE vmcategory (
    vms_id bigint NOT NULL,
    vmcategory_types_id bigint NOT NULL
);


ALTER TABLE vmcategory OWNER TO postgres;

--
-- Name: vmcategory_types_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE vmcategory_types_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vmcategory_types_id OWNER TO postgres;

--
-- Name: vmcategory_types; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE vmcategory_types (
    id bigint DEFAULT nextval('vmcategory_types_id'::regclass) NOT NULL,
    name character varying NOT NULL,
    match character varying
);


ALTER TABLE vmcategory_types OWNER TO postgres;

--
-- Name: All VMs; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW "All VMs" AS
 WITH a AS (
         SELECT max(server_scans.id) AS id
           FROM server_scans
        ), b AS (
         SELECT z.vminfo_id,
            z.powered_on,
            getfolder(y.folders_id) AS folder,
            y.hostname,
            y.ipaddress,
            x.name,
            x.vmid,
            u.name AS category,
            q.name AS tools_version,
            s.name AS tools_status,
            z.tools_cfg_version,
            r.name AS tools_version_status
           FROM ((((((((((vminfo_history z
             LEFT JOIN a ON ((a.id = z.server_scans_id)))
             LEFT JOIN vminfo y ON ((y.id = z.vminfo_id)))
             LEFT JOIN vms x ON ((x.id = y.vms_id)))
             LEFT JOIN esxservers w ON ((w.id = x.esxservers_id)))
             LEFT JOIN vmcategory v ON ((v.vms_id = x.id)))
             LEFT JOIN vmcategory_types u ON ((u.id = v.vmcategory_types_id)))
             LEFT JOIN locations t ON ((t.id = w.locations_id)))
             LEFT JOIN tools_status s ON ((s.id = z.tools_status_id)))
             LEFT JOIN tools_version_status r ON ((r.id = z.tools_version_status_id)))
             LEFT JOIN tools_version q ON ((q.id = z.tools_version_id)))
          WHERE (z.server_scans_id = a.id)
        )
 SELECT b.vminfo_id,
    b.powered_on,
    b.folder,
    b.hostname,
    b.ipaddress,
    b.name,
    b.vmid,
    b.category,
    b.tools_version,
    b.tools_status,
    b.tools_cfg_version,
    b.tools_version_status
   FROM b;


ALTER TABLE "All VMs" OWNER TO postgres;

--
-- Name: Current Categorized VMs; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW "Current Categorized VMs" AS
 WITH a1 AS (
         SELECT t.scan_time AS "Scan Time",
                CASE
                    WHEN ((z.hostname IS NOT NULL) AND ((z.hostname)::text <> 'Booting...'::text)) THEN z.hostname
                    WHEN (z.name IS NOT NULL) THEN z.name
                    ELSE NULL::character varying
                END AS "System Name",
            z.ipaddress AS "IP Address",
            r.location AS "Physical Location",
            'virtual'::text AS "Virtual or Physical",
            z.esxserver AS "Vcenter/Hardware",
            z.guestos AS "Operating System",
            z.numcpus AS "Number of Processors",
            z.memory_size AS "CPU Memory",
            z.usedspacegb AS " Used Disk Space",
            z.freespacegb AS "Free Disk Space",
            z.capacitygb AS "Total Capacity",
            z.virtual_disks AS "Number of Disks",
            z.powered_on AS "Powered On",
            getfolder(z.folders_id) AS "vCenter Folder",
            z.category AS "Category",
            z.vmid AS "vCenter ID"
           FROM (((categories() z(vminfo_id, folders_id, server_scans_id, esxserver, name, vmid, hostname, ipaddress, folder, guestos, guestid, numcpus, numnics, memory_size, virtual_disks, usedspacegb, freespacegb, capacitygb, powered_on, category, catmode, tools_version, tools_status, tools_cfg_version, tools_version_status)
             LEFT JOIN esxservers v ON (((v.address)::text = (z.esxserver)::text)))
             LEFT JOIN server_scans t ON ((t.id = z.server_scans_id)))
             LEFT JOIN locations r ON ((r.id = v.locations_id)))
        )
 SELECT a1."Scan Time",
    a1."System Name",
    a1."IP Address",
    a1."Physical Location",
    a1."Virtual or Physical",
    a1."Vcenter/Hardware",
    a1."Operating System",
    a1."Number of Processors",
    a1."CPU Memory",
    a1." Used Disk Space",
    a1."Free Disk Space",
    a1."Total Capacity",
    a1."Number of Disks",
    a1."Powered On",
    a1."vCenter Folder",
    a1."Category",
    a1."vCenter ID"
   FROM a1;


ALTER TABLE "Current Categorized VMs" OWNER TO postgres;

--
-- Name: RE physical assets; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "RE physical assets" (
    system_name character varying,
    nagios_class character varying,
    ipaddress character varying,
    username character varying,
    purpose character varying,
    rack_location character varying,
    hardware character varying,
    operating_system character varying,
    rel_eng_process character varying,
    monitor_options character varying,
    needs_backups character varying,
    dependencies character varying,
    switch character varying,
    number_of_processors character varying,
    cpu character varying,
    memory character varying,
    disk_space_a character varying,
    disk_space_b character varying,
    pruned character varying
);


ALTER TABLE "RE physical assets" OWNER TO postgres;

--
-- Name: Hopkinton All VMs; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW "Hopkinton All VMs" AS
 WITH a AS (
         SELECT NULL::integer AS vminfo_id,
            NULL::boolean AS powered_on,
            "RE physical assets".system_name,
            "RE physical assets".ipaddress,
            NULL::text AS address,
            "RE physical assets".nagios_class,
            "RE physical assets".operating_system,
            "RE physical assets".rack_location AS location,
            "RE physical assets".username,
            NULL::text AS tools_status,
            NULL::integer AS tools_cfg_version,
            NULL::text AS tools_version_status,
            'RE: physical assets'::text AS category
           FROM "RE physical assets"
        ), b AS (
         SELECT z.vminfo_id,
            z.powered_on,
            z.name AS system_name,
            z.ipaddress,
            w.address,
            NULL::text AS nagios_class,
            v.name AS operating_system,
            NULL::text AS location,
            NULL::text AS username,
            z.tools_status,
            z.tools_cfg_version,
            z.tools_version_status,
            z.category
           FROM (((("All VMs" z
             LEFT JOIN vminfo y ON ((y.id = z.vminfo_id)))
             LEFT JOIN vms x ON ((x.id = y.vms_id)))
             LEFT JOIN esxservers w ON ((w.id = x.esxservers_id)))
             LEFT JOIN guestos_types v ON ((v.id = y.guestos_types_id)))
        ), c AS (
         SELECT a.vminfo_id,
            a.powered_on,
            a.system_name,
            a.ipaddress,
            a.address,
            a.nagios_class,
            a.operating_system,
            a.location,
            a.username,
            a.tools_status,
            a.tools_cfg_version,
            a.tools_version_status,
            a.category
           FROM a
        UNION
         SELECT b.vminfo_id,
            b.powered_on,
            b.system_name,
            b.ipaddress,
            b.address,
            b.nagios_class,
            b.operating_system,
            b.location,
            b.username,
            b.tools_status,
            b.tools_cfg_version,
            b.tools_version_status,
            b.category
           FROM b
        )
 SELECT c.vminfo_id,
    c.powered_on,
    c.system_name,
    c.ipaddress,
    c.address,
    c.nagios_class,
    c.operating_system,
    c.location,
    c.username,
    c.tools_status,
    c.tools_cfg_version,
    c.tools_version_status,
    c.category
   FROM c;


ALTER TABLE "Hopkinton All VMs" OWNER TO postgres;

--
-- Name: IP address ranges; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW "IP address ranges" AS
 WITH a AS (
         SELECT max(server_scans.id) AS id
           FROM server_scans
        ), b AS (
         SELECT regexp_split_to_array((y.ipaddress)::text, ',\s+'::text) AS ipaddress,
            w.name AS vcenter
           FROM ((((vminfo_history z
             LEFT JOIN a ON ((a.id = z.server_scans_id)))
             LEFT JOIN vminfo y ON ((y.id = z.vminfo_id)))
             LEFT JOIN vms x ON ((x.id = y.vms_id)))
             LEFT JOIN esxservers w ON ((w.id = x.esxservers_id)))
          WHERE ((z.server_scans_id = a.id) AND ((y.hostname)::text !~* 'tmp'::text) AND (y.ipaddress IS NOT NULL))
        ), bw AS (
         SELECT b.vcenter,
            unnest(b.ipaddress) AS ipaddress
           FROM b
        ), bx AS (
         SELECT bw.vcenter,
            bw.ipaddress
           FROM bw
          WHERE (bw.ipaddress ~* '^\d+\.\d+\.\d+\.\d+$'::text)
        ), c AS (
         SELECT bx.vcenter,
            network(((bx.ipaddress || '/16'::text))::inet) AS network_16,
            "substring"(bx.ipaddress, '^\d+\.\d+'::text) AS ip_16s,
            network(((bx.ipaddress || '/24'::text))::inet) AS network_24,
            "substring"(bx.ipaddress, '^\d+\.\d+\.\d+'::text) AS ip_24s
           FROM bx
        ), d AS (
         SELECT c.vcenter,
            c.network_16,
            c.ip_16s,
            c.network_24,
            c.ip_24s,
            count(*) AS host_count
           FROM c
          WHERE ((c.ip_16s <> '10.0'::text) AND (c.ip_16s <> '1.1'::text) AND (c.ip_16s <> '192.168'::text) AND (c.ip_16s <> '127.0'::text) AND (c.ip_16s !~* '^0\.'::text) AND (c.ip_16s !~* '^128'::text) AND (c.ip_16s !~* '^172'::text))
          GROUP BY c.vcenter, c.network_16, c.ip_16s, c.network_24, c.ip_24s
          ORDER BY c.network_24
        )
 SELECT d.vcenter,
    d.network_16,
    d.ip_16s,
    d.network_24,
    d.ip_24s,
    d.host_count
   FROM d;


ALTER TABLE "IP address ranges" OWNER TO postgres;

--
-- Name: Name Lookup; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW "Name Lookup" AS
 WITH a AS (
         SELECT max(server_scans.id) AS id
           FROM server_scans
        ), b AS (
         SELECT regexp_split_to_array((y.ipaddress)::text, ',\s+'::text) AS ipaddress,
            y.hostname,
            y.folders_id,
            w.name AS vcenter_name,
            w.address AS vcenter
           FROM ((((vminfo_history z
             LEFT JOIN a ON ((a.id = z.server_scans_id)))
             LEFT JOIN vminfo y ON ((y.id = z.vminfo_id)))
             LEFT JOIN vms x ON ((x.id = y.vms_id)))
             LEFT JOIN esxservers w ON ((w.id = x.esxservers_id)))
          WHERE ((z.server_scans_id = a.id) AND ((y.hostname)::text !~* 'tmp'::text) AND (y.ipaddress IS NOT NULL))
        ), bw AS (
         SELECT b.vcenter_name,
            b.hostname,
            b.folders_id,
            b.vcenter,
            unnest(b.ipaddress) AS ipaddress
           FROM b
        ), bx AS (
         SELECT bw.vcenter_name,
            bw.hostname,
            bw.folders_id,
            bw.vcenter,
            bw.ipaddress
           FROM bw
          WHERE (bw.ipaddress ~* '^\d+\.\d+\.\d+\.\d+$'::text)
        ), c AS (
         SELECT bx.vcenter_name,
            bx.hostname,
            bx.ipaddress,
            bx.folders_id,
            bx.vcenter,
            network(((bx.ipaddress || '/16'::text))::inet) AS network_16,
            "substring"(bx.ipaddress, '^\d+\.\d+'::text) AS ip_16s,
            network(((bx.ipaddress || '/24'::text))::inet) AS network_24,
            "substring"(bx.ipaddress, '^\d+\.\d+\.\d+'::text) AS ip_24s
           FROM bx
        ), d AS (
         SELECT c.hostname,
            c.ipaddress,
            c.vcenter_name,
            c.vcenter,
            c.folders_id
           FROM c
          WHERE ((c.ip_16s !~* '^0\.'::text) AND (c.ip_16s <> '1.1'::text) AND (c.ip_16s <> '10.0'::text) AND (c.ip_16s <> '127.0'::text) AND (c.ip_16s !~* '^128'::text) AND (c.ip_16s !~* '^172'::text) AND (c.ip_16s <> '192.168'::text))
          ORDER BY c.network_24
        )
 SELECT d.hostname,
    d.ipaddress,
    d.vcenter_name,
    d.vcenter,
    d.folders_id
   FROM d;


ALTER TABLE "Name Lookup" OWNER TO postgres;

--
-- Name: SLES12 Migration; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "SLES12 Migration" (
    devvm character varying,
    ntlogin character varying,
    developer character varying,
    vm character varying,
    domain character varying,
    id bigint
);


ALTER TABLE "SLES12 Migration" OWNER TO postgres;

--
-- Name: SLES12 Migration Info; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "SLES12 Migration Info" (
    "SLES12 Migration id" bigint,
    isvalid boolean,
    ipaddress character varying,
    fqname character varying
);


ALTER TABLE "SLES12 Migration Info" OWNER TO postgres;

--
-- Name: Powered-On SELS11; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW "Powered-On SELS11" AS
 SELECT z.developer,
    z.ntlogin,
    z.domain,
    z.vm,
    y.fqname,
    x.powered_on
   FROM (("SLES12 Migration" z
     LEFT JOIN "SLES12 Migration Info" y ON ((y."SLES12 Migration id" = z.id)))
     LEFT JOIN current_vms x ON (((x.ipaddress)::text = (y.ipaddress)::text)))
  WHERE (x.powered_on = true)
  ORDER BY z.developer, z.domain;


ALTER TABLE "Powered-On SELS11" OWNER TO postgres;

--
-- Name: RE phys 2; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "RE phys 2" (
    system_name character varying,
    nagios_class character varying,
    ipaddress character varying,
    username character varying,
    purpose character varying,
    rack_location character varying,
    hardware character varying,
    operating_system character varying,
    rel_eng_process character varying,
    monitor_options character varying,
    needs_backups character varying,
    dependencies character varying,
    switch character varying,
    number_of_processors character varying,
    cpu character varying,
    memory character varying,
    disk_space_a character varying,
    disk_space_b character varying,
    pruned character varying
);


ALTER TABLE "RE phys 2" OWNER TO postgres;

--
-- Name: SLES12 SignUp; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE "SLES12 SignUp" (
    ntlogin character varying,
    developer character varying,
    vmx character varying,
    vm character varying
);


ALTER TABLE "SLES12 SignUp" OWNER TO postgres;

--
-- Name: SLES12 trade ins; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW "SLES12 trade ins" AS
 WITH a AS (
         SELECT max(server_scans.id) AS id
           FROM server_scans
        ), b AS (
         SELECT z.vminfo_id,
            z.powered_on,
            w.address AS esxserver,
            y.hostname
           FROM ((((vminfo_history z
             LEFT JOIN a ON ((a.id = z.server_scans_id)))
             LEFT JOIN vminfo y ON ((y.id = z.vminfo_id)))
             LEFT JOIN vms x ON ((x.id = y.vms_id)))
             LEFT JOIN esxservers w ON ((w.id = x.esxservers_id)))
          WHERE (a.id = z.server_scans_id)
        ), c AS (
         SELECT z.developer,
            z.ntlogin,
            z.domain,
            z.vm,
            y.fqname
           FROM ("SLES12 Migration" z
             LEFT JOIN "SLES12 Migration Info" y ON ((y."SLES12 Migration id" = z.id)))
        ), d AS (
         SELECT c.developer,
            c.ntlogin,
            c.domain,
            c.vm,
            c.fqname,
            max(b.vminfo_id) AS vminfo_id
           FROM (c
             LEFT JOIN b ON ((((c.domain)::text = (b.esxserver)::text) AND ((c.vm)::text = (b.hostname)::text))))
          GROUP BY c.developer, c.ntlogin, c.domain, c.vm, c.fqname
        ), e AS (
         SELECT d.developer,
            d.ntlogin,
            d.domain,
            d.vm,
            d.fqname,
            d.vminfo_id
           FROM ((d
             LEFT JOIN b ON ((((d.domain)::text = (b.esxserver)::text) AND ((d.vm)::text = (b.hostname)::text) AND (d.vminfo_id = b.vminfo_id))))
             LEFT JOIN empdata.employee_data z USING (ntlogin))
          WHERE ((b.powered_on = true) AND (z.badgeid IS NOT NULL) AND ((d.developer)::text !~ '^zzz'::text))
        )
 SELECT e.developer,
    e.ntlogin,
    e.domain,
    e.vm,
    e.fqname,
    e.vminfo_id
   FROM e
  ORDER BY e.vm, e.ntlogin;


ALTER TABLE "SLES12 trade ins" OWNER TO postgres;

--
-- Name: adminuser_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE adminuser_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE adminuser_id OWNER TO postgres;

--
-- Name: adminuser; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE adminuser (
    id bigint DEFAULT nextval('adminuser_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE adminuser OWNER TO postgres;

--
-- Name: hardware_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE hardware_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE hardware_id OWNER TO postgres;

--
-- Name: hardware; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE hardware (
    id bigint DEFAULT nextval('hardware_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE hardware OWNER TO postgres;

--
-- Name: historical_overview; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE historical_overview (
    server_scans_id bigint,
    esxservers_id bigint NOT NULL,
    vmcategory_types_id bigint,
    "OFF" bigint,
    "ON" bigint,
    "OFF_cpus" bigint,
    "ON_cpus" bigint,
    "OFF_nics" bigint,
    "ON_nics" bigint,
    "OFF_mem" bigint,
    "ON_mem" bigint,
    "OFF_disks" bigint,
    "ON_disks" bigint,
    "OFF_space" bigint,
    "ON_space" bigint
);


ALTER TABLE historical_overview OWNER TO postgres;

--
-- Name: ipaddresses; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW ipaddresses AS
 WITH a AS (
         SELECT max(server_scans.id) AS id
           FROM server_scans
        ), b AS (
         SELECT z.vminfo_id,
            y.vms_id,
            y.hostname,
            regexp_split_to_table((y.ipaddress)::text, ',\s+'::text) AS ipaddress
           FROM (((vminfo_history z
             LEFT JOIN a ON ((a.id = z.server_scans_id)))
             LEFT JOIN vminfo y ON ((y.id = z.vminfo_id)))
             LEFT JOIN vms x ON ((x.id = y.vms_id)))
          WHERE ((z.server_scans_id = a.id) AND ((y.hostname)::text !~* 'tmp'::text) AND (y.ipaddress IS NOT NULL))
        ), c AS (
         SELECT b.vminfo_id,
            b.vms_id,
            btrim(b.ipaddress) AS ipaddress
           FROM b
          WHERE ((btrim(b.ipaddress) ~* '^(\d{1,3}\.){3}\d{1,3}'::text) OR (btrim(b.ipaddress) ~* '^[:0-9]+'::text))
        )
 SELECT c.vminfo_id,
    c.vms_id,
    c.ipaddress
   FROM c;


ALTER TABLE ipaddresses OWNER TO postgres;

--
-- Name: ix_vcenter_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE ix_vcenter_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE ix_vcenter_id OWNER TO postgres;

--
-- Name: ix_vcenter; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE ix_vcenter (
    id bigint DEFAULT nextval('ix_vcenter_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE ix_vcenter OWNER TO postgres;

--
-- Name: nagios_class_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE nagios_class_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE nagios_class_id OWNER TO postgres;

--
-- Name: nagios_class; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE nagios_class (
    id bigint DEFAULT nextval('nagios_class_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE nagios_class OWNER TO postgres;

--
-- Name: normalized_re_phys2; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE normalized_re_phys2 (
    system_name character varying,
    nagios_class_id bigint,
    ipaddress character varying,
    adminuser_id bigint,
    purpose_id bigint,
    rack_location_id bigint,
    switch_id bigint,
    guestos_type_id bigint,
    hardware_id bigint
);


ALTER TABLE normalized_re_phys2 OWNER TO postgres;

--
-- Name: normalized_re_physical_assets; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE normalized_re_physical_assets (
    system_name character varying,
    nagios_class_id bigint,
    ipaddress character varying,
    adminuser_id bigint,
    purpose_id bigint,
    rack_location_id bigint,
    switch_id bigint,
    guestos_type_id bigint,
    hardware_id bigint
);


ALTER TABLE normalized_re_physical_assets OWNER TO postgres;

--
-- Name: raw_data; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE raw_data (
    server character varying,
    name character varying,
    vmpathname character varying,
    notes character varying,
    powerstate character varying,
    numcpu character varying,
    memorygb character varying,
    usedspacegb character varying,
    guestid character varying,
    foldername character varying,
    folderid character varying,
    folderparentid character varying,
    vmid character varying,
    hostname character varying,
    ipaddress character varying,
    guestos character varying,
    connected character varying,
    numnics character varying,
    capacitygb character varying,
    freespacegb character varying,
    virtualdisks character varying,
    tools_version character varying,
    tools_status character varying,
    tools_cfg_version character varying,
    tools_version_status character varying
);


ALTER TABLE raw_data OWNER TO postgres;

--
-- Name: vmexists; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE vmexists (
    vminfo_id bigint NOT NULL,
    exist_status boolean,
    last_change bigint
);


ALTER TABLE vmexists OWNER TO postgres;

--
-- Name: overview; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW overview AS
 WITH c2 AS (
         SELECT 'vcenter.vms'::text AS type,
            count(*) AS count
           FROM vms
        ), a1 AS (
         SELECT current_vms.esxserver,
            current_vms.name,
            current_vms.vmid,
            count(*) AS cnt
           FROM current_vms
          GROUP BY current_vms.esxserver, current_vms.name, current_vms.vmid
        ), c3 AS (
         SELECT 'UNIQUE vcenter.vms'::text AS type,
            count(*) AS count
           FROM a1
        ), c4 AS (
         SELECT 'vcenter.vminfo'::text AS type,
            count(*) AS count
           FROM vminfo
        ), a2 AS (
         SELECT current_vms.esxserver,
            current_vms.name,
            current_vms.vmid,
            count(*) AS cnt
           FROM current_vms
          GROUP BY current_vms.esxserver, current_vms.name, current_vms.vmid
        ), c5 AS (
         SELECT 'UNIQUE vcenter.vminfo'::text AS type,
            count(*) AS count
           FROM a2
        ), c6 AS (
         SELECT 'vcenter.raw_data'::text AS type,
            count(*) AS count
           FROM raw_data
        ), a3 AS (
         SELECT current_vms.esxserver,
            current_vms.name,
            current_vms.vmid,
            count(*) AS cnt
           FROM current_vms
          GROUP BY current_vms.esxserver, current_vms.name, current_vms.vmid
        ), c7 AS (
         SELECT 'UNIQUE vcenter.raw_data'::text AS type,
            count(*) AS count
           FROM a3
        ), c8 AS (
         SELECT 'vcenter.vminfo_history'::text AS type,
            count(*) AS count
           FROM vminfo_history
        ), a4 AS (
         SELECT current_vms.esxserver,
            current_vms.name,
            current_vms.vmid,
            count(*) AS cnt
           FROM current_vms
          GROUP BY current_vms.esxserver, current_vms.name, current_vms.vmid
        ), c9 AS (
         SELECT 'UNIQUE vcenter.vminfo_history'::text AS type,
            count(*) AS count
           FROM a4
        ), c10 AS (
         SELECT 'vcenter.current_vms'::text AS type,
            count(*) AS count
           FROM current_vms
        ), a5 AS (
         SELECT current_vms.esxserver,
            current_vms.name,
            current_vms.vmid,
            count(*) AS cnt
           FROM current_vms
          GROUP BY current_vms.esxserver, current_vms.name, current_vms.vmid
        ), c11 AS (
         SELECT 'UNIQUE vcenter.current_vms'::text AS type,
            count(*) AS count
           FROM a5
        ), c12 AS (
         SELECT 'vcenter.categories'::text AS type,
            count(*) AS count
           FROM categories() categories(vminfo_id, folders_id, server_scans_id, esxserver, name, vmid, hostname, ipaddress, folder, guestos, guestid, numcpus, numnics, memory_size, virtual_disks, usedspacegb, freespacegb, capacitygb, powered_on, category, catmode, tools_version, tools_status, tools_cfg_version, tools_version_status)
        ), a6 AS (
         SELECT categories.esxserver,
            categories.name,
            categories.vmid,
            count(*) AS cnt
           FROM categories() categories(vminfo_id, folders_id, server_scans_id, esxserver, name, vmid, hostname, ipaddress, folder, guestos, guestid, numcpus, numnics, memory_size, virtual_disks, usedspacegb, freespacegb, capacitygb, powered_on, category, catmode, tools_version, tools_status, tools_cfg_version, tools_version_status)
          GROUP BY categories.esxserver, categories.name, categories.vmid
        ), c13 AS (
         SELECT 'UNIQUE vcenter.categories'::text AS type,
            count(*) AS count
           FROM a6
        ), a7 AS (
         SELECT z.vminfo_id,
            max(z.last_change) AS last_change
           FROM vmexists z
          WHERE (z.exist_status = true)
          GROUP BY z.vminfo_id
        ), c14 AS (
         SELECT 'UNIQUE vms'::text AS type,
            count(*) AS count
           FROM a7
        ), a8 AS (
         SELECT "Current Categorized VMs"."IP Address",
            "Current Categorized VMs"."Vcenter/Hardware"
           FROM "Current Categorized VMs"
          GROUP BY "Current Categorized VMs"."IP Address", "Current Categorized VMs"."Vcenter/Hardware"
        ), c15 AS (
         SELECT 'UNIQUE Current Categorized VMs'::text AS type,
            count(*) AS count
           FROM a8
        ), c16 AS (
         SELECT 'Current Categorized VMs'::text AS type,
            count(*) AS count
           FROM "Current Categorized VMs"
        )
 SELECT c2.type,
    c2.count
   FROM c2
UNION
 SELECT c3.type,
    c3.count
   FROM c3
UNION
 SELECT c4.type,
    c4.count
   FROM c4
UNION
 SELECT c5.type,
    c5.count
   FROM c5
UNION
 SELECT c6.type,
    c6.count
   FROM c6
UNION
 SELECT c7.type,
    c7.count
   FROM c7
UNION
 SELECT c8.type,
    c8.count
   FROM c8
UNION
 SELECT c9.type,
    c9.count
   FROM c9
UNION
 SELECT c10.type,
    c10.count
   FROM c10
UNION
 SELECT c11.type,
    c11.count
   FROM c11
UNION
 SELECT c12.type,
    c12.count
   FROM c12
UNION
 SELECT c13.type,
    c13.count
   FROM c13
UNION
 SELECT c14.type,
    c14.count
   FROM c14
UNION
 SELECT c15.type,
    c15.count
   FROM c15
UNION
 SELECT c16.type,
    c16.count
   FROM c16
  ORDER BY 1;


ALTER TABLE overview OWNER TO postgres;

--
-- Name: purpose_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE purpose_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE purpose_id OWNER TO postgres;

--
-- Name: purpose; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE purpose (
    id bigint DEFAULT nextval('purpose_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE purpose OWNER TO postgres;

--
-- Name: rack_location_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE rack_location_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE rack_location_id OWNER TO postgres;

--
-- Name: rack_location; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE rack_location (
    id bigint DEFAULT nextval('rack_location_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE rack_location OWNER TO postgres;

--
-- Name: raw_data_normalized; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE raw_data_normalized (
    vms_id bigint,
    vminfo_id bigint,
    folders_id bigint,
    guestos_types_id bigint,
    guestid_types_id bigint,
    name character varying,
    hostname character varying,
    ipaddress character varying,
    numcpus integer,
    memory_size bigint,
    numnics integer,
    virtual_disks integer,
    powered_on boolean,
    connected boolean,
    usedspacegb real,
    freespacegb real,
    capacitygb real,
    notes character varying,
    tools_status_id integer,
    tools_cfg_version bigint,
    tools_version_status_id integer,
    tools_version_id bigint
);


ALTER TABLE raw_data_normalized OWNER TO postgres;

--
-- Name: raw_folders; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE raw_folders (
    name character varying,
    folderid character varying,
    folderparentid character varying,
    type character varying
);


ALTER TABLE raw_folders OWNER TO postgres;

--
-- Name: raw_subnets; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE raw_subnets (
    subnet character varying,
    type character varying,
    location character varying,
    site character varying,
    cloud character varying,
    widget character varying,
    comment1 character varying,
    comment2 character varying,
    comment3 character varying,
    source character varying
);


ALTER TABLE raw_subnets OWNER TO postgres;

--
-- Name: releng_vminfo; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE releng_vminfo (
    name character varying,
    category character varying
);


ALTER TABLE releng_vminfo OWNER TO postgres;

--
-- Name: summary; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW summary AS
 WITH vms AS (
         SELECT z.scan_time,
            z.vms_id,
            z.esxserver,
            z.name,
            z.vmid,
            z.hostname,
            z.ipaddress,
            z.folder,
            z.numcpus,
            z.numnics,
            z.memory_size,
            z.virtual_disks,
            z.capacitygb,
            z.guestos,
            z.guestid,
            z.powered_on
           FROM current_vms z
        ), vm_off AS (
         SELECT vms.scan_time,
            vms.vms_id,
            vms.esxserver,
            vms.name,
            vms.vmid,
            vms.hostname,
            vms.ipaddress,
            vms.folder,
            vms.numcpus,
            vms.numnics,
            vms.memory_size,
            vms.virtual_disks,
            vms.capacitygb,
            vms.guestos,
            vms.guestid,
            vms.powered_on
           FROM vms
          WHERE (vms.powered_on = false)
        ), vm_on AS (
         SELECT vms.scan_time,
            vms.vms_id,
            vms.esxserver,
            vms.name,
            vms.vmid,
            vms.hostname,
            vms.ipaddress,
            vms.folder,
            vms.numcpus,
            vms.numnics,
            vms.memory_size,
            vms.virtual_disks,
            vms.capacitygb,
            vms.guestos,
            vms.guestid,
            vms.powered_on
           FROM vms
          WHERE (vms.powered_on = true)
        ), vm_types AS (
         SELECT vmcategory_types.id,
            vmcategory_types.name,
            vmcategory_types.match
           FROM vmcategory_types
        ), v_off AS (
         SELECT z.esxserver,
            y.name,
            count(*) AS "OFF"
           FROM (vm_off z
             LEFT JOIN vm_types y ON (((z.name)::text ~* (y.match)::text)))
          GROUP BY z.esxserver, y.name
        ), v_on AS (
         SELECT z.esxserver,
            y.name,
            count(*) AS "ON"
           FROM (vm_off z
             LEFT JOIN vm_types y ON (((z.name)::text ~* (y.match)::text)))
          GROUP BY z.esxserver, y.name
        ), v_all AS (
         SELECT z.esxserver,
            z.name,
            z."ON",
            y."OFF"
           FROM (v_on z
             LEFT JOIN v_off y ON ((((z.esxserver)::text = (y.esxserver)::text) AND ((z.name)::text = (y.name)::text))))
        )
 SELECT v_all.esxserver,
    v_all.name,
    v_all."ON",
    v_all."OFF"
   FROM v_all
  WHERE (v_all.name IS NOT NULL)
  ORDER BY v_all.esxserver, v_all.name;


ALTER TABLE summary OWNER TO postgres;

--
-- Name: summary2; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW summary2 AS
 WITH vm_types AS (
         SELECT vmcategory_types.id,
            vmcategory_types.name,
            vmcategory_types.match
           FROM vmcategory_types
        ), ls AS (
         SELECT max(server_scans.scan_time) AS last_scan
           FROM server_scans
        ), v1_all AS (
         SELECT
                CASE
                    WHEN (x.id IS NULL) THEN ('8.Unknown'::character varying)::text
                    ELSE ('0.'::text || (x.name)::text)
                END AS category,
            ARRAY[z."ON", z."OFF", z."ON_cpus", z."OFF_cpus", z."ON_mem", z."OFF_mem", z."ON_nics", z."OFF_nics", z."ON_disks", z."OFF_disks", z."ON_space", z."OFF_space"] AS vals,
            w.address AS esxserver,
            w.colmap,
            y.scan_time
           FROM (((historical_overview z
             LEFT JOIN server_scans y ON ((y.id = z.server_scans_id)))
             LEFT JOIN vmcategory_types x ON ((x.id = z.vmcategory_types_id)))
             LEFT JOIN esxservers w ON ((w.id = z.esxservers_id)))
        ), v2_all AS (
         SELECT z.category,
            z.vals,
            z.esxserver,
            z.colmap
           FROM v1_all z,
            ls
          WHERE (z.scan_time = ls.last_scan)
        ), a1 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 1)
          GROUP BY v2_all.category
        ), b1 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a1.vals[1]), sum(a1.vals[2]), sum(a1.vals[3]), sum(a1.vals[4]), sum(a1.vals[5]), sum(a1.vals[6]), sum(a1.vals[7]), sum(a1.vals[8]), sum(a1.vals[9]), sum(a1.vals[10]), sum(a1.vals[11]), sum(a1.vals[12])] AS vals
           FROM a1
        ), c1 AS (
         SELECT a1.category,
            a1.vals
           FROM a1
        UNION
         SELECT b1.category,
            b1.vals
           FROM b1
        ), a2 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 2)
          GROUP BY v2_all.category
        ), b2 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a2.vals[1]), sum(a2.vals[2]), sum(a2.vals[3]), sum(a2.vals[4]), sum(a2.vals[5]), sum(a2.vals[6]), sum(a2.vals[7]), sum(a2.vals[8]), sum(a2.vals[9]), sum(a2.vals[10]), sum(a2.vals[11]), sum(a2.vals[12])] AS vals
           FROM a2
        ), c2 AS (
         SELECT a2.category,
            a2.vals
           FROM a2
        UNION
         SELECT b2.category,
            b2.vals
           FROM b2
        ), a3 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 3)
          GROUP BY v2_all.category
        ), b3 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a3.vals[1]), sum(a3.vals[2]), sum(a3.vals[3]), sum(a3.vals[4]), sum(a3.vals[5]), sum(a3.vals[6]), sum(a3.vals[7]), sum(a3.vals[8]), sum(a3.vals[9]), sum(a3.vals[10]), sum(a3.vals[11]), sum(a3.vals[12])] AS vals
           FROM a3
        ), c3 AS (
         SELECT a3.category,
            a3.vals
           FROM a3
        UNION
         SELECT b3.category,
            b3.vals
           FROM b3
        ), a4 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 4)
          GROUP BY v2_all.category
        ), b4 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a4.vals[1]), sum(a4.vals[2]), sum(a4.vals[3]), sum(a4.vals[4]), sum(a4.vals[5]), sum(a4.vals[6]), sum(a4.vals[7]), sum(a4.vals[8]), sum(a4.vals[9]), sum(a4.vals[10]), sum(a4.vals[11]), sum(a4.vals[12])] AS vals
           FROM a4
        ), c4 AS (
         SELECT a4.category,
            a4.vals
           FROM a4
        UNION
         SELECT b4.category,
            b4.vals
           FROM b4
        ), a5 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 5)
          GROUP BY v2_all.category
        ), b5 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a5.vals[1]), sum(a5.vals[2]), sum(a5.vals[3]), sum(a5.vals[4]), sum(a5.vals[5]), sum(a5.vals[6]), sum(a5.vals[7]), sum(a5.vals[8]), sum(a5.vals[9]), sum(a5.vals[10]), sum(a5.vals[11]), sum(a5.vals[12])] AS vals
           FROM a5
        ), c5 AS (
         SELECT a5.category,
            a5.vals
           FROM a5
        UNION
         SELECT b5.category,
            b5.vals
           FROM b5
        ), a6 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 6)
          GROUP BY v2_all.category
        ), b6 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a6.vals[1]), sum(a6.vals[2]), sum(a6.vals[3]), sum(a6.vals[4]), sum(a6.vals[5]), sum(a6.vals[6]), sum(a6.vals[7]), sum(a6.vals[8]), sum(a6.vals[9]), sum(a6.vals[10]), sum(a6.vals[11]), sum(a6.vals[12])] AS vals
           FROM a6
        ), c6 AS (
         SELECT a6.category,
            a6.vals
           FROM a6
        UNION
         SELECT b6.category,
            b6.vals
           FROM b6
        ), a7 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 7)
          GROUP BY v2_all.category
        ), b7 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a7.vals[1]), sum(a7.vals[2]), sum(a7.vals[3]), sum(a7.vals[4]), sum(a7.vals[5]), sum(a7.vals[6]), sum(a7.vals[7]), sum(a7.vals[8]), sum(a7.vals[9]), sum(a7.vals[10]), sum(a7.vals[11]), sum(a7.vals[12])] AS vals
           FROM a7
        ), c7 AS (
         SELECT a7.category,
            a7.vals
           FROM a7
        UNION
         SELECT b7.category,
            b7.vals
           FROM b7
        ), a8 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 8)
          GROUP BY v2_all.category
        ), b8 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a8.vals[1]), sum(a8.vals[2]), sum(a8.vals[3]), sum(a8.vals[4]), sum(a8.vals[5]), sum(a8.vals[6]), sum(a8.vals[7]), sum(a8.vals[8]), sum(a8.vals[9]), sum(a8.vals[10]), sum(a8.vals[11]), sum(a8.vals[12])] AS vals
           FROM a8
        ), c8 AS (
         SELECT a8.category,
            a8.vals
           FROM a8
        UNION
         SELECT b8.category,
            b8.vals
           FROM b8
        ), a9 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 9)
          GROUP BY v2_all.category
        ), b9 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a9.vals[1]), sum(a9.vals[2]), sum(a9.vals[3]), sum(a9.vals[4]), sum(a9.vals[5]), sum(a9.vals[6]), sum(a9.vals[7]), sum(a9.vals[8]), sum(a9.vals[9]), sum(a9.vals[10]), sum(a9.vals[11]), sum(a9.vals[12])] AS vals
           FROM a9
        ), c9 AS (
         SELECT a9.category,
            a9.vals
           FROM a9
        UNION
         SELECT b9.category,
            b9.vals
           FROM b9
        ), a10 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 10)
          GROUP BY v2_all.category
        ), b10 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a10.vals[1]), sum(a10.vals[2]), sum(a10.vals[3]), sum(a10.vals[4]), sum(a10.vals[5]), sum(a10.vals[6]), sum(a10.vals[7]), sum(a10.vals[8]), sum(a10.vals[9]), sum(a10.vals[10]), sum(a10.vals[11]), sum(a10.vals[12])] AS vals
           FROM a10
        ), c10 AS (
         SELECT a10.category,
            a10.vals
           FROM a10
        UNION
         SELECT b10.category,
            b10.vals
           FROM b10
        ), a11 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 11)
          GROUP BY v2_all.category
        ), b11 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a11.vals[1]), sum(a11.vals[2]), sum(a11.vals[3]), sum(a11.vals[4]), sum(a11.vals[5]), sum(a11.vals[6]), sum(a11.vals[7]), sum(a11.vals[8]), sum(a11.vals[9]), sum(a11.vals[10]), sum(a11.vals[11]), sum(a11.vals[12])] AS vals
           FROM a11
        ), c11 AS (
         SELECT a11.category,
            a11.vals
           FROM a11
        UNION
         SELECT b11.category,
            b11.vals
           FROM b11
        ), a12 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 12)
          GROUP BY v2_all.category
        ), b12 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a12.vals[1]), sum(a12.vals[2]), sum(a12.vals[3]), sum(a12.vals[4]), sum(a12.vals[5]), sum(a12.vals[6]), sum(a12.vals[7]), sum(a12.vals[8]), sum(a12.vals[9]), sum(a12.vals[10]), sum(a12.vals[11]), sum(a12.vals[12])] AS vals
           FROM a12
        ), c12 AS (
         SELECT a12.category,
            a12.vals
           FROM a12
        UNION
         SELECT b12.category,
            b12.vals
           FROM b12
        ), a13 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 13)
          GROUP BY v2_all.category
        ), b13 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a13.vals[1]), sum(a13.vals[2]), sum(a13.vals[3]), sum(a13.vals[4]), sum(a13.vals[5]), sum(a13.vals[6]), sum(a13.vals[7]), sum(a13.vals[8]), sum(a13.vals[9]), sum(a13.vals[10]), sum(a13.vals[11]), sum(a13.vals[12])] AS vals
           FROM a13
        ), c13 AS (
         SELECT a13.category,
            a13.vals
           FROM a13
        UNION
         SELECT b13.category,
            b13.vals
           FROM b13
        ), a14 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 14)
          GROUP BY v2_all.category
        ), b14 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a14.vals[1]), sum(a14.vals[2]), sum(a14.vals[3]), sum(a14.vals[4]), sum(a14.vals[5]), sum(a14.vals[6]), sum(a14.vals[7]), sum(a14.vals[8]), sum(a14.vals[9]), sum(a14.vals[10]), sum(a14.vals[11]), sum(a14.vals[12])] AS vals
           FROM a14
        ), c14 AS (
         SELECT a14.category,
            a14.vals
           FROM a14
        UNION
         SELECT b14.category,
            b14.vals
           FROM b14
        ), a15 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 15)
          GROUP BY v2_all.category
        ), b15 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a15.vals[1]), sum(a15.vals[2]), sum(a15.vals[3]), sum(a15.vals[4]), sum(a15.vals[5]), sum(a15.vals[6]), sum(a15.vals[7]), sum(a15.vals[8]), sum(a15.vals[9]), sum(a15.vals[10]), sum(a15.vals[11]), sum(a15.vals[12])] AS vals
           FROM a15
        ), c15 AS (
         SELECT a15.category,
            a15.vals
           FROM a15
        UNION
         SELECT b15.category,
            b15.vals
           FROM b15
        ), a16 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 16)
          GROUP BY v2_all.category
        ), b16 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a16.vals[1]), sum(a16.vals[2]), sum(a16.vals[3]), sum(a16.vals[4]), sum(a16.vals[5]), sum(a16.vals[6]), sum(a16.vals[7]), sum(a16.vals[8]), sum(a16.vals[9]), sum(a16.vals[10]), sum(a16.vals[11]), sum(a16.vals[12])] AS vals
           FROM a16
        ), c16 AS (
         SELECT a16.category,
            a16.vals
           FROM a16
        UNION
         SELECT b16.category,
            b16.vals
           FROM b16
        ), a0 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all.vals[1]), sum(v2_all.vals[2]), sum(v2_all.vals[3]), sum(v2_all.vals[4]), sum(v2_all.vals[5]), sum(v2_all.vals[6]), sum(v2_all.vals[7]), sum(v2_all.vals[8]), sum(v2_all.vals[9]), sum(v2_all.vals[10]), sum(v2_all.vals[11]), sum(v2_all.vals[12])] AS vals
           FROM v2_all
          GROUP BY v2_all.category
        ), b0 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a0.vals[1]), sum(a0.vals[2]), sum(a0.vals[3]), sum(a0.vals[4]), sum(a0.vals[5]), sum(a0.vals[6]), sum(a0.vals[7]), sum(a0.vals[8]), sum(a0.vals[9]), sum(a0.vals[10]), sum(a0.vals[11]), sum(a0.vals[12])] AS vals
           FROM a0
        ), c0 AS (
         SELECT a0.category,
            a0.vals
           FROM a0
        UNION
         SELECT b0.category,
            b0.vals
           FROM b0
        ), d0 AS (
         SELECT c0.category
           FROM c0
        UNION
         SELECT c1.category
           FROM c1
        UNION
         SELECT c2.category
           FROM c2
        UNION
         SELECT c3.category
           FROM c3
        UNION
         SELECT c4.category
           FROM c4
        UNION
         SELECT c5.category
           FROM c5
        UNION
         SELECT c6.category
           FROM c6
        UNION
         SELECT c7.category
           FROM c7
        UNION
         SELECT c8.category
           FROM c8
        UNION
         SELECT c9.category
           FROM c9
        UNION
         SELECT c10.category
           FROM c10
        UNION
         SELECT c11.category
           FROM c11
        UNION
         SELECT c12.category
           FROM c12
        UNION
         SELECT c13.category
           FROM c13
        UNION
         SELECT c14.category
           FROM c14
        UNION
         SELECT c15.category
           FROM c15
        UNION
         SELECT c16.category
           FROM c16
        ), d1 AS (
         SELECT DISTINCT d0.category
           FROM d0
        ), v_all AS (
         SELECT z.category AS name,
            y.vals AS "Hopkinton EOS2",
            l.vals AS "Hopkinton RelEng",
            k.vals AS "Hopkinton Prod",
            x.vals AS "Hopkinton CEC-1",
            w.vals AS "Hopkinton CEC-2",
            v.vals AS "Hopkinton CEC-3",
            u.vals AS "Hopkinton CEC-4",
            t.vals AS "Durham EOS2",
            s.vals AS "Durham CEC-1",
            r.vals AS "Durham CEC-2",
            q.vals AS "Durham CEC-3",
            p.vals AS "Durham CEC-4",
            j.vals AS "Durham CEC-D",
            o.vals AS "RTP",
            n.vals AS "New Jersey",
            m.vals AS "Shanghai",
            a.vals AS "Total"
           FROM (((((((((((((((((d1 z
             LEFT JOIN c1 y USING (category))
             LEFT JOIN c2 x USING (category))
             LEFT JOIN c3 w USING (category))
             LEFT JOIN c4 v USING (category))
             LEFT JOIN c5 u USING (category))
             LEFT JOIN c6 t USING (category))
             LEFT JOIN c7 s USING (category))
             LEFT JOIN c8 r USING (category))
             LEFT JOIN c9 q USING (category))
             LEFT JOIN c10 p USING (category))
             LEFT JOIN c11 o USING (category))
             LEFT JOIN c12 n USING (category))
             LEFT JOIN c13 m USING (category))
             LEFT JOIN c14 l USING (category))
             LEFT JOIN c15 k USING (category))
             LEFT JOIN c16 j USING (category))
             LEFT JOIN c0 a USING (category))
          ORDER BY z.category
        )
 SELECT v_all.name,
    v_all."Hopkinton EOS2",
    v_all."Hopkinton RelEng",
    v_all."Hopkinton Prod",
    v_all."Hopkinton CEC-1",
    v_all."Hopkinton CEC-2",
    v_all."Hopkinton CEC-3",
    v_all."Hopkinton CEC-4",
    v_all."Durham EOS2",
    v_all."Durham CEC-1",
    v_all."Durham CEC-2",
    v_all."Durham CEC-3",
    v_all."Durham CEC-4",
    v_all."Durham CEC-D",
    v_all."RTP",
    v_all."New Jersey",
    v_all."Shanghai",
    v_all."Total"
   FROM v_all;


ALTER TABLE summary2 OWNER TO postgres;

--
-- Name: switch_id; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE switch_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE switch_id OWNER TO postgres;

--
-- Name: switch; Type: TABLE; Schema: vcenter; Owner: postgres
--

CREATE TABLE switch (
    id bigint DEFAULT nextval('switch_id'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE switch OWNER TO postgres;

--
-- Name: vminfo_history_distribution; Type: VIEW; Schema: vcenter; Owner: postgres
--

CREATE VIEW vminfo_history_distribution AS
 WITH a AS (
         SELECT ARRAY[vminfo_history.vminfo_id, vminfo_history.server_scans_id] AS ids,
            ARRAY[vminfo_history.powered_on, vminfo_history.connected] AS bools,
            ARRAY[vminfo_history.usedspacegb, vminfo_history.freespacegb, vminfo_history.capacitygb] AS reals,
            ARRAY[vminfo_history.numcpus, vminfo_history.numnics, vminfo_history.virtual_disks, vminfo_history.tools_status_id, vminfo_history.tools_version_status_id] AS integers,
            ARRAY[vminfo_history.memory_size, vminfo_history.tools_cfg_version, vminfo_history.tools_version_id] AS bigints
           FROM vminfo_history
        ), b AS (
         SELECT count(*) AS cnt,
            a.bools,
            a.reals,
            a.integers,
            a.bigints
           FROM a
          GROUP BY a.bools, a.reals, a.integers, a.bigints
        )
 SELECT b.cnt,
    b.bools,
    b.reals,
    b.integers,
    b.bigints
   FROM b
  ORDER BY b.cnt DESC;


ALTER TABLE vminfo_history_distribution OWNER TO postgres;

--
-- Name: xxx; Type: SEQUENCE; Schema: vcenter; Owner: postgres
--

CREATE SEQUENCE xxx
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE xxx OWNER TO postgres;

SET search_path = vdiscover, pg_catalog;

--
-- Name: poweroff_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE poweroff_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE poweroff_id OWNER TO postgres;

--
-- Name: 2015-12-14.Poweroff; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE "2015-12-14.Poweroff" (
    id bigint DEFAULT nextval('poweroff_id'::regclass) NOT NULL,
    vm_id bigint NOT NULL
);


ALTER TABLE "2015-12-14.Poweroff" OWNER TO postgres;

--
-- Name: 2016-01-29.VMs for deletion; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE "2016-01-29.VMs for deletion" (
    server character varying,
    name character varying,
    numcpus integer,
    memory_size integer,
    category character varying
);


ALTER TABLE "2016-01-29.VMs for deletion" OWNER TO postgres;

--
-- Name: err_errors_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE err_errors_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE err_errors_id OWNER TO postgres;

--
-- Name: err_errors; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE err_errors (
    id bigint DEFAULT nextval('err_errors_id'::regclass) NOT NULL,
    error character varying
);


ALTER TABLE err_errors OWNER TO postgres;

--
-- Name: err_files_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE err_files_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE err_files_id OWNER TO postgres;

--
-- Name: err_files; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE err_files (
    id bigint DEFAULT nextval('err_files_id'::regclass) NOT NULL,
    file character varying
);


ALTER TABLE err_files OWNER TO postgres;

--
-- Name: err_names_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE err_names_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE err_names_id OWNER TO postgres;

--
-- Name: err_names; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE err_names (
    id bigint DEFAULT nextval('err_names_id'::regclass) NOT NULL,
    name character varying
);


ALTER TABLE err_names OWNER TO postgres;

--
-- Name: esx-servers; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE "esx-servers" (
    id integer NOT NULL,
    address character varying NOT NULL,
    location_id bigint NOT NULL,
    name character varying,
    colmap integer
);


ALTER TABLE "esx-servers" OWNER TO postgres;

--
-- Name: server_scans_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE server_scans_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE server_scans_id OWNER TO postgres;

--
-- Name: server_scans; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE server_scans (
    id bigint DEFAULT nextval('server_scans_id'::regclass) NOT NULL,
    scan_time timestamp with time zone NOT NULL
);


ALTER TABLE server_scans OWNER TO postgres;

--
-- Name: vmerror; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vmerror (
    server_scans_id bigint,
    server_id bigint,
    name_id bigint,
    file_id bigint,
    error_id bigint
);


ALTER TABLE vmerror OWNER TO postgres;

--
-- Name: allerrors; Type: VIEW; Schema: vdiscover; Owner: postgres
--

CREATE VIEW allerrors AS
 SELECT y.scan_time,
    x.address AS server,
    w.name,
    u.file,
    t.error
   FROM (((((vmerror z
     LEFT JOIN server_scans y ON ((y.id = z.server_scans_id)))
     LEFT JOIN "esx-servers" x ON ((x.id = z.server_id)))
     LEFT JOIN err_names w ON ((w.id = z.name_id)))
     LEFT JOIN err_files u ON ((u.id = z.file_id)))
     LEFT JOIN err_errors t ON ((t.id = z.error_id)));


ALTER TABLE allerrors OWNER TO postgres;

--
-- Name: guestid_types_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE guestid_types_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE guestid_types_id OWNER TO postgres;

--
-- Name: guestid_types; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE guestid_types (
    id bigint DEFAULT nextval('guestid_types_id'::regclass) NOT NULL,
    name character varying
);


ALTER TABLE guestid_types OWNER TO postgres;

--
-- Name: guestos_types_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE guestos_types_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE guestos_types_id OWNER TO postgres;

--
-- Name: guestos_types; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE guestos_types (
    id bigint DEFAULT nextval('guestos_types_id'::regclass) NOT NULL,
    name character varying
);


ALTER TABLE guestos_types OWNER TO postgres;

--
-- Name: vmexists; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vmexists (
    vminfo_id bigint NOT NULL,
    last_change timestamp with time zone DEFAULT now(),
    exist_status boolean
);


ALTER TABLE vmexists OWNER TO postgres;

--
-- Name: vminfo_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE vminfo_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vminfo_id OWNER TO postgres;

--
-- Name: vminfo; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vminfo (
    id bigint DEFAULT nextval('vminfo_id'::regclass) NOT NULL,
    vm_id bigint,
    hostname character varying,
    ipaddress character varying,
    numcpus integer,
    memory_size bigint,
    virtual_disks integer,
    template integer,
    guestos_id bigint,
    guestid_id bigint,
    vmwaretools_id bigint
);


ALTER TABLE vminfo OWNER TO postgres;

--
-- Name: vms_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE vms_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vms_id OWNER TO postgres;

--
-- Name: vms; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vms (
    id bigint DEFAULT nextval('vms_id'::regclass) NOT NULL,
    server_id bigint NOT NULL,
    name character varying,
    vmpathname character varying
);


ALTER TABLE vms OWNER TO postgres;

--
-- Name: vmwaretools_types_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE vmwaretools_types_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vmwaretools_types_id OWNER TO postgres;

--
-- Name: vmwaretools_types; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vmwaretools_types (
    id bigint DEFAULT nextval('vmwaretools_types_id'::regclass) NOT NULL,
    name character varying
);


ALTER TABLE vmwaretools_types OWNER TO postgres;

--
-- Name: current_vms; Type: VIEW; Schema: vdiscover; Owner: postgres
--

CREATE VIEW current_vms AS
 WITH a0 AS (
         SELECT y.vm_id,
            z.vminfo_id,
            z.last_change,
            z.exist_status
           FROM (vmexists z
             LEFT JOIN vminfo y ON ((y.id = z.vminfo_id)))
        ), a1 AS (
         SELECT a0.vm_id,
            max(a0.last_change) AS last_change
           FROM a0
          GROUP BY a0.vm_id
        ), a2 AS (
         SELECT y.vminfo_id,
            y.last_change,
            y.exist_status,
            x.id,
            x.vm_id,
            x.hostname,
            x.ipaddress,
            x.numcpus,
            x.memory_size,
            x.virtual_disks,
            x.template,
            x.guestos_id,
            x.guestid_id,
            x.vmwaretools_id
           FROM ((a1 z
             LEFT JOIN vmexists y ON ((y.last_change = z.last_change)))
             LEFT JOIN vminfo x ON ((x.id = y.vminfo_id)))
          WHERE ((y.exist_status = true) AND (x.vm_id = z.vm_id))
        ), a3 AS (
         SELECT z.last_change,
            z.vm_id,
            w.address AS server,
            x.name,
            x.vmpathname,
            z.hostname,
            z.ipaddress,
            z.numcpus,
            z.memory_size,
            z.virtual_disks,
            z.template,
            v.name AS guestos,
            u.name AS guestid,
            t.name AS vmwaretools,
                CASE
                    WHEN ((v.name IS NULL) AND (u.name IS NULL)) THEN false
                    ELSE true
                END AS powered_on
           FROM (((((a2 z
             LEFT JOIN vms x ON ((x.id = z.vm_id)))
             LEFT JOIN "esx-servers" w ON ((w.id = x.server_id)))
             LEFT JOIN guestos_types v ON ((v.id = z.guestos_id)))
             LEFT JOIN guestid_types u ON ((u.id = z.guestid_id)))
             LEFT JOIN vmwaretools_types t ON ((t.id = z.vmwaretools_id)))
        )
 SELECT a3.last_change,
    a3.vm_id,
    a3.server,
    a3.name,
    a3.vmpathname,
    a3.hostname,
    a3.ipaddress,
    a3.numcpus,
    a3.memory_size,
    a3.virtual_disks,
    a3.template,
    a3.guestos,
    a3.guestid,
    a3.vmwaretools,
    a3.powered_on
   FROM a3;


ALTER TABLE current_vms OWNER TO postgres;

--
-- Name: vmcategory; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vmcategory (
    vm_id bigint NOT NULL,
    vmcategory_type_id bigint NOT NULL
);


ALTER TABLE vmcategory OWNER TO postgres;

--
-- Name: vmcategory_types_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE vmcategory_types_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vmcategory_types_id OWNER TO postgres;

--
-- Name: vmcategory_types; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vmcategory_types (
    id bigint DEFAULT nextval('vmcategory_types_id'::regclass) NOT NULL,
    name character varying,
    match character varying
);


ALTER TABLE vmcategory_types OWNER TO postgres;

--
-- Name: current_vms2; Type: VIEW; Schema: vdiscover; Owner: postgres
--

CREATE VIEW current_vms2 AS
 WITH a1 AS (
         SELECT current_vms.last_change,
            current_vms.vm_id,
            current_vms.server,
            current_vms.name,
            current_vms.vmpathname,
            current_vms.hostname,
            current_vms.ipaddress,
            current_vms.numcpus,
            current_vms.memory_size,
            current_vms.virtual_disks,
            current_vms.template,
            current_vms.guestos,
            current_vms.guestid,
            current_vms.vmwaretools,
            current_vms.powered_on
           FROM current_vms
        ), u0 AS (
         SELECT z.last_change,
            z.vm_id,
            z.server,
            z.name,
            z.vmpathname,
            z.hostname,
            z.ipaddress,
            z.numcpus,
            z.memory_size,
            z.virtual_disks,
            z.template,
            z.guestos,
            z.guestid,
            z.vmwaretools,
            z.powered_on,
            q.name AS category,
            'assigned'::text AS catmode
           FROM ((a1 z
             LEFT JOIN vmcategory r ON ((r.vm_id = z.vm_id)))
             LEFT JOIN vmcategory_types q ON ((q.id = r.vmcategory_type_id)))
          WHERE (q.name IS NOT NULL)
        ), u1 AS (
         SELECT z.last_change,
            z.vm_id,
            z.server,
            z.name,
            z.vmpathname,
            z.hostname,
            z.ipaddress,
            z.numcpus,
            z.memory_size,
            z.virtual_disks,
            z.template,
            z.guestos,
            z.guestid,
            z.vmwaretools,
            z.powered_on,
            y.name AS category,
            'name'::text AS catmode
           FROM (a1 z
             LEFT JOIN vmcategory_types y ON (((y.match IS NOT NULL) AND ((z.name)::text ~* (y.match)::text))))
          WHERE ((y.name IS NOT NULL) AND (NOT (ARRAY[z.server, z.name, z.vmpathname] IN ( SELECT ARRAY[u0.server, u0.name, u0.vmpathname] AS "array"
                   FROM u0))))
        ), u2 AS (
         SELECT u0.last_change,
            u0.vm_id,
            u0.server,
            u0.name,
            u0.vmpathname,
            u0.hostname,
            u0.ipaddress,
            u0.numcpus,
            u0.memory_size,
            u0.virtual_disks,
            u0.template,
            u0.guestos,
            u0.guestid,
            u0.vmwaretools,
            u0.powered_on,
            u0.category,
            u0.catmode
           FROM u0
        UNION
         SELECT u1.last_change,
            u1.vm_id,
            u1.server,
            u1.name,
            u1.vmpathname,
            u1.hostname,
            u1.ipaddress,
            u1.numcpus,
            u1.memory_size,
            u1.virtual_disks,
            u1.template,
            u1.guestos,
            u1.guestid,
            u1.vmwaretools,
            u1.powered_on,
            u1.category,
            u1.catmode
           FROM u1
        ), s3 AS (
         SELECT z.last_change,
            z.vm_id,
            z.server,
            z.name,
            z.vmpathname,
            z.hostname,
            z.ipaddress,
            z.numcpus,
            z.memory_size,
            z.virtual_disks,
            z.template,
            z.guestos,
            z.guestid,
            z.vmwaretools,
            z.powered_on,
            y.name AS category,
            'hostname'::text AS catmode
           FROM (a1 z
             LEFT JOIN vmcategory_types y ON (((y.match IS NOT NULL) AND ((z.hostname)::text ~* (y.match)::text))))
          WHERE ((y.name IS NOT NULL) AND (NOT (ARRAY[z.server, z.name, z.vmpathname] IN ( SELECT ARRAY[u2.server, u2.name, u2.vmpathname] AS "array"
                   FROM u2))))
        ), t3 AS (
         SELECT DISTINCT s3.vm_id
           FROM s3
        ), u3 AS (
         SELECT s3.last_change,
            s3.vm_id,
            s3.server,
            s3.name,
            s3.vmpathname,
            s3.hostname,
            s3.ipaddress,
            s3.numcpus,
            s3.memory_size,
            s3.virtual_disks,
            s3.template,
            s3.guestos,
            s3.guestid,
            s3.vmwaretools,
            s3.powered_on,
            s3.category,
            s3.catmode
           FROM (t3
             LEFT JOIN s3 ON ((s3.vm_id = t3.vm_id)))
        ), u4 AS (
         SELECT u2.last_change,
            u2.vm_id,
            u2.server,
            u2.name,
            u2.vmpathname,
            u2.hostname,
            u2.ipaddress,
            u2.numcpus,
            u2.memory_size,
            u2.virtual_disks,
            u2.template,
            u2.guestos,
            u2.guestid,
            u2.vmwaretools,
            u2.powered_on,
            u2.category,
            u2.catmode
           FROM u2
        UNION
         SELECT u3.last_change,
            u3.vm_id,
            u3.server,
            u3.name,
            u3.vmpathname,
            u3.hostname,
            u3.ipaddress,
            u3.numcpus,
            u3.memory_size,
            u3.virtual_disks,
            u3.template,
            u3.guestos,
            u3.guestid,
            u3.vmwaretools,
            u3.powered_on,
            u3.category,
            u3.catmode
           FROM u3
        ), s5 AS (
         SELECT z.last_change,
            z.vm_id,
            z.server,
            z.name,
            z.vmpathname,
            z.hostname,
            z.ipaddress,
            z.numcpus,
            z.memory_size,
            z.virtual_disks,
            z.template,
            z.guestos,
            z.guestid,
            z.vmwaretools,
            z.powered_on,
            NULL::text AS category,
            NULL::text AS catmode
           FROM a1 z
          WHERE (NOT (ARRAY[z.server, z.name, z.vmpathname] IN ( SELECT ARRAY[u4.server, u4.name, u4.vmpathname] AS "array"
                   FROM u4)))
        ), t5 AS (
         SELECT DISTINCT s5.vm_id
           FROM s5
        ), u5 AS (
         SELECT s5.last_change,
            s5.vm_id,
            s5.server,
            s5.name,
            s5.vmpathname,
            s5.hostname,
            s5.ipaddress,
            s5.numcpus,
            s5.memory_size,
            s5.virtual_disks,
            s5.template,
            s5.guestos,
            s5.guestid,
            s5.vmwaretools,
            s5.powered_on,
            s5.category,
            s5.catmode
           FROM (t5
             LEFT JOIN s5 ON ((s5.vm_id = t5.vm_id)))
        ), u6 AS (
         SELECT u4.last_change,
            u4.vm_id,
            u4.server,
            u4.name,
            u4.vmpathname,
            u4.hostname,
            u4.ipaddress,
            u4.numcpus,
            u4.memory_size,
            u4.virtual_disks,
            u4.template,
            u4.guestos,
            u4.guestid,
            u4.vmwaretools,
            u4.powered_on,
            u4.category,
            u4.catmode
           FROM u4
        UNION
         SELECT u5.last_change,
            u5.vm_id,
            u5.server,
            u5.name,
            u5.vmpathname,
            u5.hostname,
            u5.ipaddress,
            u5.numcpus,
            u5.memory_size,
            u5.virtual_disks,
            u5.template,
            u5.guestos,
            u5.guestid,
            u5.vmwaretools,
            u5.powered_on,
            u5.category,
            u5.catmode
           FROM u5
        )
 SELECT u6.last_change,
    u6.vm_id,
    u6.server,
    u6.name,
    u6.vmpathname,
    u6.hostname,
    u6.ipaddress,
    u6.numcpus,
    u6.memory_size,
    u6.virtual_disks,
    u6.template,
    u6.guestos,
    u6.guestid,
    u6.vmwaretools,
    u6.powered_on,
    u6.category,
    u6.catmode
   FROM u6;


ALTER TABLE current_vms2 OWNER TO postgres;

--
-- Name: entities; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE entities (
    id bigint NOT NULL,
    entityname character varying,
    server_id bigint,
    entitytype_id bigint
);


ALTER TABLE entities OWNER TO postgres;

--
-- Name: entities_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE entities_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE entities_id OWNER TO postgres;

--
-- Name: entity-types_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE "entity-types_id"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "entity-types_id" OWNER TO postgres;

--
-- Name: entity-types; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE "entity-types" (
    id bigint DEFAULT nextval('"entity-types_id"'::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE "entity-types" OWNER TO postgres;

--
-- Name: esx-servers_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE "esx-servers_id"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "esx-servers_id" OWNER TO postgres;

--
-- Name: historical_overview; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE historical_overview (
    server_scan_id bigint,
    vmcategory_type_id bigint,
    "OFF" bigint,
    "ON" bigint,
    "OFF_cpus" bigint,
    "ON_cpus" bigint,
    "OFF_mem" bigint,
    "ON_mem" bigint,
    server_id bigint NOT NULL
);


ALTER TABLE historical_overview OWNER TO postgres;

--
-- Name: locations; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE locations (
    id bigint NOT NULL,
    location character varying
);


ALTER TABLE locations OWNER TO postgres;

--
-- Name: locations_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE locations_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE locations_id OWNER TO postgres;

--
-- Name: overallstatus_types_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE overallstatus_types_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE overallstatus_types_id OWNER TO postgres;

--
-- Name: overallstatus_types; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE overallstatus_types (
    id bigint DEFAULT nextval('overallstatus_types_id'::regclass) NOT NULL,
    name character varying
);


ALTER TABLE overallstatus_types OWNER TO postgres;

--
-- Name: vminfo_raw; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vminfo_raw (
    server character varying,
    name character varying,
    numcpus character varying,
    memory_size character varying,
    virtual_disks character varying,
    template character varying,
    vmpathname character varying,
    guestos character varying,
    guestid character varying,
    hostname character varying,
    ipaddress character varying,
    vmwaretools character varying,
    cpuusage character varying,
    hostmemoryusage character varying,
    guestmemoryusage character varying,
    overallstatus character varying
);


ALTER TABLE vminfo_raw OWNER TO postgres;

--
-- Name: overview; Type: VIEW; Schema: vdiscover; Owner: postgres
--

CREATE VIEW overview AS
 WITH c2 AS (
         SELECT 'vdiscover.vms'::text AS type,
            count(*) AS count
           FROM vms
        ), a1 AS (
         SELECT current_vms.server,
            current_vms.name,
            count(*) AS cnt
           FROM current_vms
          GROUP BY current_vms.server, current_vms.name
        ), c3 AS (
         SELECT 'UNIQUE vdiscover.vms'::text AS type,
            count(*) AS count
           FROM a1
        ), c4 AS (
         SELECT 'vdiscover.vminfo'::text AS type,
            count(*) AS count
           FROM vminfo
        ), a2 AS (
         SELECT current_vms.server,
            current_vms.name,
            count(*) AS cnt
           FROM current_vms
          GROUP BY current_vms.server, current_vms.name
        ), c5 AS (
         SELECT 'UNIQUE vdiscover.vminfo'::text AS type,
            count(*) AS count
           FROM a2
        ), c6 AS (
         SELECT 'vdiscover.raw_data'::text AS type,
            count(*) AS count
           FROM vminfo_raw
        ), a3 AS (
         SELECT current_vms.server,
            current_vms.name,
            count(*) AS cnt
           FROM current_vms
          GROUP BY current_vms.server, current_vms.name
        ), c7 AS (
         SELECT 'UNIQUE vdiscover.raw_data'::text AS type,
            count(*) AS count
           FROM a3
        ), c8 AS (
         SELECT 'vdiscover.vminfo_history'::text AS type,
            count(*) AS count
           FROM historical_overview
        ), a4 AS (
         SELECT current_vms.server,
            current_vms.name,
            count(*) AS cnt
           FROM current_vms
          GROUP BY current_vms.server, current_vms.name
        ), c9 AS (
         SELECT 'UNIQUE vdiscover.vminfo_history'::text AS type,
            count(*) AS count
           FROM a4
        ), c10 AS (
         SELECT 'vdiscover.current_vms'::text AS type,
            count(*) AS count
           FROM current_vms
        ), a5 AS (
         SELECT current_vms.server,
            current_vms.name,
            count(*) AS cnt
           FROM current_vms
          GROUP BY current_vms.server, current_vms.name
        ), c11 AS (
         SELECT 'UNIQUE vdiscover.current_vms'::text AS type,
            count(*) AS count
           FROM a5
        ), c12 AS (
         SELECT 'vdiscover.categories'::text AS type,
            count(*) AS count
           FROM categories() categories(category, server, name, vmpathname, hostname, numcpus, memory_size, powered_on)
        ), a6 AS (
         SELECT categories.server,
            categories.name,
            count(*) AS cnt
           FROM categories() categories(category, server, name, vmpathname, hostname, numcpus, memory_size, powered_on)
          GROUP BY categories.server, categories.name
        ), c13 AS (
         SELECT 'UNIQUE vdiscover.categories'::text AS type,
            count(*) AS count
           FROM a6
        ), a7 AS (
         SELECT z.vminfo_id,
            max(z.last_change) AS last_change
           FROM vmexists z
          WHERE (z.exist_status = true)
          GROUP BY z.vminfo_id
        ), c14 AS (
         SELECT 'UNIQUE vms'::text AS type,
            count(*) AS count
           FROM a7
        )
 SELECT c2.type,
    c2.count
   FROM c2
UNION
 SELECT c3.type,
    c3.count
   FROM c3
UNION
 SELECT c4.type,
    c4.count
   FROM c4
UNION
 SELECT c5.type,
    c5.count
   FROM c5
UNION
 SELECT c6.type,
    c6.count
   FROM c6
UNION
 SELECT c7.type,
    c7.count
   FROM c7
UNION
 SELECT c8.type,
    c8.count
   FROM c8
UNION
 SELECT c9.type,
    c9.count
   FROM c9
UNION
 SELECT c10.type,
    c10.count
   FROM c10
UNION
 SELECT c11.type,
    c11.count
   FROM c11
UNION
 SELECT c12.type,
    c12.count
   FROM c12
UNION
 SELECT c13.type,
    c13.count
   FROM c13
UNION
 SELECT c14.type,
    c14.count
   FROM c14
  ORDER BY 1;


ALTER TABLE overview OWNER TO postgres;

--
-- Name: summary; Type: VIEW; Schema: vdiscover; Owner: postgres
--

CREATE VIEW summary AS
 WITH vms AS (
         SELECT z.last_change,
            z.vm_id,
            z.server,
            z.name,
            z.vmpathname,
            z.hostname,
            z.ipaddress,
            z.numcpus,
            z.memory_size,
            z.virtual_disks,
            z.template,
            z.guestos,
            z.guestid,
            z.vmwaretools,
            z.powered_on
           FROM current_vms z
        ), vm_off AS (
         SELECT vms.last_change,
            vms.vm_id,
            vms.server,
            vms.name,
            vms.vmpathname,
            vms.hostname,
            vms.ipaddress,
            vms.numcpus,
            vms.memory_size,
            vms.virtual_disks,
            vms.template,
            vms.guestos,
            vms.guestid,
            vms.vmwaretools,
            vms.powered_on
           FROM vms
          WHERE (vms.powered_on = false)
        ), vm_on AS (
         SELECT vms.last_change,
            vms.vm_id,
            vms.server,
            vms.name,
            vms.vmpathname,
            vms.hostname,
            vms.ipaddress,
            vms.numcpus,
            vms.memory_size,
            vms.virtual_disks,
            vms.template,
            vms.guestos,
            vms.guestid,
            vms.vmwaretools,
            vms.powered_on
           FROM vms
          WHERE (vms.powered_on = true)
        ), vm_types AS (
         SELECT vmcategory_types.id,
            vmcategory_types.name,
            vmcategory_types.match
           FROM vmcategory_types
        ), v_off AS (
         SELECT z.server,
            y.name,
            count(*) AS "OFF"
           FROM (vm_off z
             LEFT JOIN vm_types y ON (((z.name)::text ~* (y.match)::text)))
          GROUP BY z.server, y.name
        ), v_on AS (
         SELECT z.server,
            y.name,
            count(*) AS "ON"
           FROM (vm_off z
             LEFT JOIN vm_types y ON (((z.name)::text ~* (y.match)::text)))
          GROUP BY z.server, y.name
        ), v_all AS (
         SELECT z.server,
            z.name,
            z."ON",
            y."OFF"
           FROM (v_on z
             LEFT JOIN v_off y ON ((((z.server)::text = (y.server)::text) AND ((z.name)::text = (y.name)::text))))
        )
 SELECT v_all.server,
    v_all.name,
    v_all."ON",
    v_all."OFF"
   FROM v_all
  WHERE (v_all.name IS NOT NULL)
  ORDER BY v_all.server, v_all.name;


ALTER TABLE summary OWNER TO postgres;

--
-- Name: summary2; Type: VIEW; Schema: vdiscover; Owner: postgres
--

CREATE VIEW summary2 AS
 WITH vm_types AS (
         SELECT vmcategory_types.id,
            vmcategory_types.name,
            vmcategory_types.match
           FROM vmcategory_types
        ), ls AS (
         SELECT max(server_scans.scan_time) AS last_scan
           FROM server_scans
        ), v1_all AS (
         SELECT
                CASE
                    WHEN (x.id IS NULL) THEN ('8.Unknown'::character varying)::text
                    ELSE ('0.'::text || (x.name)::text)
                END AS category,
            z."OFF",
            z."ON",
            z."OFF_cpus",
            z."ON_cpus",
            z."OFF_mem",
            z."ON_mem",
            w.address AS esxserver,
            w.colmap,
            y.scan_time
           FROM (((historical_overview z
             LEFT JOIN server_scans y ON ((y.id = z.server_scan_id)))
             LEFT JOIN vmcategory_types x ON ((x.id = z.vmcategory_type_id)))
             LEFT JOIN "esx-servers" w ON ((w.id = z.server_id)))
        ), v2_all AS (
         SELECT z.category,
            z."OFF",
            z."ON",
            z."OFF_cpus",
            z."ON_cpus",
            z."OFF_mem",
            z."ON_mem",
            z.esxserver,
            z.colmap
           FROM v1_all z,
            ls
          WHERE (z.scan_time = ls.last_scan)
        ), a1 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all."ON"), sum(v2_all."OFF"), sum(v2_all."ON_cpus"), sum(v2_all."OFF_cpus"), sum(v2_all."ON_mem"), sum(v2_all."OFF_mem")] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 1)
          GROUP BY v2_all.category
        ), b1 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a1.vals[1]), sum(a1.vals[2]), sum(a1.vals[3]), sum(a1.vals[4]), sum(a1.vals[5]), sum(a1.vals[6])] AS vals
           FROM a1
        ), c1 AS (
         SELECT a1.category,
            a1.vals
           FROM a1
        UNION
         SELECT b1.category,
            b1.vals
           FROM b1
        ), a2 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all."ON"), sum(v2_all."OFF"), sum(v2_all."ON_cpus"), sum(v2_all."OFF_cpus"), sum(v2_all."ON_mem"), sum(v2_all."OFF_mem")] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 2)
          GROUP BY v2_all.category
        ), b2 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a2.vals[1]), sum(a2.vals[2]), sum(a2.vals[3]), sum(a2.vals[4]), sum(a2.vals[5]), sum(a2.vals[6])] AS vals
           FROM a2
        ), c2 AS (
         SELECT a2.category,
            a2.vals
           FROM a2
        UNION
         SELECT b2.category,
            b2.vals
           FROM b2
        ), a3 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all."ON"), sum(v2_all."OFF"), sum(v2_all."ON_cpus"), sum(v2_all."OFF_cpus"), sum(v2_all."ON_mem"), sum(v2_all."OFF_mem")] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 3)
          GROUP BY v2_all.category
        ), b3 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a3.vals[1]), sum(a3.vals[2]), sum(a3.vals[3]), sum(a3.vals[4]), sum(a3.vals[5]), sum(a3.vals[6])] AS vals
           FROM a3
        ), c3 AS (
         SELECT a3.category,
            a3.vals
           FROM a3
        UNION
         SELECT b3.category,
            b3.vals
           FROM b3
        ), a4 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all."ON"), sum(v2_all."OFF"), sum(v2_all."ON_cpus"), sum(v2_all."OFF_cpus"), sum(v2_all."ON_mem"), sum(v2_all."OFF_mem")] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 4)
          GROUP BY v2_all.category
        ), b4 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a4.vals[1]), sum(a4.vals[2]), sum(a4.vals[3]), sum(a4.vals[4]), sum(a4.vals[5]), sum(a4.vals[6])] AS vals
           FROM a4
        ), c4 AS (
         SELECT a4.category,
            a4.vals
           FROM a4
        UNION
         SELECT b4.category,
            b4.vals
           FROM b4
        ), a5 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all."ON"), sum(v2_all."OFF"), sum(v2_all."ON_cpus"), sum(v2_all."OFF_cpus"), sum(v2_all."ON_mem"), sum(v2_all."OFF_mem")] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 5)
          GROUP BY v2_all.category
        ), b5 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a5.vals[1]), sum(a5.vals[2]), sum(a5.vals[3]), sum(a5.vals[4]), sum(a5.vals[5]), sum(a5.vals[6])] AS vals
           FROM a5
        ), c5 AS (
         SELECT a5.category,
            a5.vals
           FROM a5
        UNION
         SELECT b5.category,
            b5.vals
           FROM b5
        ), a6 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all."ON"), sum(v2_all."OFF"), sum(v2_all."ON_cpus"), sum(v2_all."OFF_cpus"), sum(v2_all."ON_mem"), sum(v2_all."OFF_mem")] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 6)
          GROUP BY v2_all.category
        ), b6 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a6.vals[1]), sum(a6.vals[2]), sum(a6.vals[3]), sum(a6.vals[4]), sum(a6.vals[5]), sum(a6.vals[6])] AS vals
           FROM a6
        ), c6 AS (
         SELECT a6.category,
            a6.vals
           FROM a6
        UNION
         SELECT b6.category,
            b6.vals
           FROM b6
        ), a7 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all."ON"), sum(v2_all."OFF"), sum(v2_all."ON_cpus"), sum(v2_all."OFF_cpus"), sum(v2_all."ON_mem"), sum(v2_all."OFF_mem")] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 7)
          GROUP BY v2_all.category
        ), b7 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a7.vals[1]), sum(a7.vals[2]), sum(a7.vals[3]), sum(a7.vals[4]), sum(a7.vals[5]), sum(a7.vals[6])] AS vals
           FROM a7
        ), c7 AS (
         SELECT a7.category,
            a7.vals
           FROM a7
        UNION
         SELECT b7.category,
            b7.vals
           FROM b7
        ), a8 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all."ON"), sum(v2_all."OFF"), sum(v2_all."ON_cpus"), sum(v2_all."OFF_cpus"), sum(v2_all."ON_mem"), sum(v2_all."OFF_mem")] AS vals
           FROM v2_all
          WHERE (v2_all.colmap = 8)
          GROUP BY v2_all.category
        ), b8 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a8.vals[1]), sum(a8.vals[2]), sum(a8.vals[3]), sum(a8.vals[4]), sum(a8.vals[5]), sum(a8.vals[6])] AS vals
           FROM a8
        ), c8 AS (
         SELECT a8.category,
            a8.vals
           FROM a8
        UNION
         SELECT b8.category,
            b8.vals
           FROM b8
        ), a9 AS (
         SELECT v2_all.category,
            ARRAY[sum(v2_all."ON"), sum(v2_all."OFF"), sum(v2_all."ON_cpus"), sum(v2_all."OFF_cpus"), sum(v2_all."ON_mem"), sum(v2_all."OFF_mem")] AS vals
           FROM v2_all
          GROUP BY v2_all.category
        ), b9 AS (
         SELECT '9.Total'::character varying AS category,
            ARRAY[sum(a9.vals[1]), sum(a9.vals[2]), sum(a9.vals[3]), sum(a9.vals[4]), sum(a9.vals[5]), sum(a9.vals[6])] AS vals
           FROM a9
        ), c9 AS (
         SELECT a9.category,
            a9.vals
           FROM a9
        UNION
         SELECT b9.category,
            b9.vals
           FROM b9
        ), d0 AS (
         SELECT c1.category
           FROM c1
        UNION
         SELECT c2.category
           FROM c2
        UNION
         SELECT c3.category
           FROM c3
        UNION
         SELECT c4.category
           FROM c4
        UNION
         SELECT c5.category
           FROM c5
        UNION
         SELECT c6.category
           FROM c6
        UNION
         SELECT c7.category
           FROM c7
        UNION
         SELECT c8.category
           FROM c8
        UNION
         SELECT c9.category
           FROM c9
        ), d1 AS (
         SELECT DISTINCT d0.category
           FROM d0
        ), v_all AS (
         SELECT z.category AS name,
            y.vals AS "Hopkinton EOS2",
            x.vals AS "Hopkinton CEC-1",
            q.vals AS "Hopkinton CEC-2",
            w.vals AS "Durham EOS2",
            v.vals AS "Durham CEC",
            u.vals AS "RTP",
            t.vals AS "New Jersey",
            s.vals AS "Shanghai",
            r.vals AS "Total"
           FROM (((((((((d1 z
             LEFT JOIN c1 y ON ((y.category = z.category)))
             LEFT JOIN c2 x ON ((x.category = z.category)))
             LEFT JOIN c3 w ON ((w.category = z.category)))
             LEFT JOIN c4 v ON ((v.category = z.category)))
             LEFT JOIN c5 u ON ((u.category = z.category)))
             LEFT JOIN c6 t ON ((t.category = z.category)))
             LEFT JOIN c7 s ON ((s.category = z.category)))
             LEFT JOIN c8 r ON ((r.category = z.category)))
             LEFT JOIN c9 q ON ((q.category = z.category)))
          ORDER BY z.category
        )
 SELECT v_all.name,
    v_all."Hopkinton EOS2",
    v_all."Hopkinton CEC-1",
    v_all."Hopkinton CEC-2",
    v_all."Durham EOS2",
    v_all."Durham CEC",
    v_all."RTP",
    v_all."New Jersey",
    v_all."Shanghai",
    v_all."Total"
   FROM v_all;


ALTER TABLE summary2 OWNER TO postgres;

--
-- Name: vdiscovery; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vdiscovery (
    id bigint NOT NULL,
    parent_id bigint,
    vobject_type_id bigint,
    name character varying,
    tree_depth integer,
    server_id bigint
);


ALTER TABLE vdiscovery OWNER TO postgres;

--
-- Name: vobject_types_id; Type: SEQUENCE; Schema: vdiscover; Owner: postgres
--

CREATE SEQUENCE vobject_types_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE vobject_types_id OWNER TO postgres;

--
-- Name: vobject_types; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vobject_types (
    id bigint DEFAULT nextval('vobject_types_id'::regclass) NOT NULL,
    name character varying
);


ALTER TABLE vobject_types OWNER TO postgres;

--
-- Name: vdiscover_tree; Type: VIEW; Schema: vdiscover; Owner: postgres
--

CREATE VIEW vdiscover_tree AS
 SELECT z.id,
    z.parent_id,
    y.name AS type,
    z.name,
    x.address AS server
   FROM ((vdiscovery z
     LEFT JOIN vobject_types y ON ((y.id = z.vobject_type_id)))
     LEFT JOIN "esx-servers" x ON ((x.id = z.server_id)))
  ORDER BY z.*, z.id, z.parent_id;


ALTER TABLE vdiscover_tree OWNER TO postgres;

--
-- Name: vdiscovery_raw; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vdiscovery_raw (
    id bigint,
    parent_id bigint,
    type character varying,
    name character varying,
    indent integer,
    server character varying
);


ALTER TABLE vdiscovery_raw OWNER TO postgres;

--
-- Name: vmerror_raw; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vmerror_raw (
    server character varying,
    name character varying,
    file character varying,
    error character varying
);


ALTER TABLE vmerror_raw OWNER TO postgres;

--
-- Name: vminfo_data; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vminfo_data (
    vm_id bigint,
    server_scans_id bigint,
    cpuusage integer,
    hostmemoryusage integer,
    guestmemoryusage integer,
    overallstatus_id bigint,
    powered_on boolean
);


ALTER TABLE vminfo_data OWNER TO postgres;

--
-- Name: vmowner; Type: TABLE; Schema: vdiscover; Owner: postgres
--

CREATE TABLE vmowner (
    vm_id bigint,
    owner character varying,
    owner_in_ldap boolean
);


ALTER TABLE vmowner OWNER TO postgres;

SET search_path = wscommands, pg_catalog;

--
-- Name: suspectresults; Type: TABLE; Schema: wscommands; Owner: postgres
--

CREATE TABLE suspectresults (
    id bigint NOT NULL,
    comment character varying
);


ALTER TABLE suspectresults OWNER TO postgres;

--
-- Name: ExcelMetrics-Current; Type: VIEW; Schema: wscommands; Owner: postgres
--

CREATE VIEW "ExcelMetrics-Current" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.workspace,
            baseresults.workingdir,
            baseresults.version,
            baseresults.stream,
            baseresults.duration,
            baseresults."user",
            baseresults.command,
            baseresults.code,
            baseresults.host,
            baseresults.accurev_user,
            baseresults.accurev_topdir
           FROM baseresults
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), rslts AS (
         SELECT z.id,
            z.tm,
            z.workspace,
            z.workingdir,
            z.version,
            z.stream,
            z.duration,
            z."user",
            z.command,
            z.code,
            z.host,
            z.accurev_user,
            z.accurev_topdir,
                CASE
                    WHEN (z.code = 0) THEN 'pass'::text
                    ELSE 'fail'::text
                END AS ok,
            x.ca,
            x.project,
            y.arg_count,
            y.line_count,
            y.hour,
            y.date,
            y.week
           FROM ((base z
             LEFT JOIN etlresults y ON ((y.id = z.id)))
             LEFT JOIN cateams.rally_info x ON (((x.ntlogin)::text = (z.accurev_user)::text)))
          ORDER BY z.id DESC
         LIMIT 1048574
        )
 SELECT rslts.id,
    rslts.tm,
    rslts.workspace,
    rslts.workingdir,
    rslts.version,
    rslts.stream,
    rslts.duration,
    rslts."user",
    rslts.command,
    rslts.code,
    rslts.host,
    rslts.accurev_user,
    rslts.accurev_topdir,
    rslts.ok,
    rslts.ca,
    rslts.project,
    rslts.arg_count,
    rslts.line_count,
    rslts.hour,
    rslts.date,
    rslts.week
   FROM rslts
  ORDER BY rslts.id;


ALTER TABLE "ExcelMetrics-Current" OWNER TO postgres;

--
-- Name: ExcelMetrics1; Type: VIEW; Schema: wscommands; Owner: postgres
--

CREATE VIEW "ExcelMetrics1" AS
 WITH base AS (
         SELECT baseresults.id,
            baseresults.tm,
            baseresults.workspace,
            baseresults.workingdir,
            baseresults.version,
            baseresults.stream,
            baseresults.duration,
            baseresults."user",
            baseresults.command,
            baseresults.code,
            baseresults.host,
            baseresults.accurev_user,
            baseresults.accurev_topdir
           FROM baseresults
          WHERE (NOT (baseresults.id IN ( SELECT suspectresults.id
                   FROM suspectresults)))
        ), rslts AS (
         SELECT z.id,
            z.tm,
            z.workspace,
            z.workingdir,
            z.version,
            z.stream,
            z.duration,
            z."user",
            z.command,
            z.code,
            z.host,
            z.accurev_user,
            z.accurev_topdir,
            y.arg_count,
            y.line_count,
            y.hour,
            y.date,
            y.week
           FROM base z,
            etlresults y
          WHERE ((y.id = z.id) AND ((y.week)::date < public.startofweek((('now'::text)::date)::timestamp with time zone)))
          ORDER BY z.id DESC
         LIMIT 1048574
        )
 SELECT rslts.id,
    rslts.tm,
    rslts.workspace,
    rslts.workingdir,
    rslts.version,
    rslts.stream,
    rslts.duration,
    rslts."user",
    rslts.command,
    rslts.code,
    rslts.host,
    rslts.accurev_user,
    rslts.accurev_topdir,
    rslts.arg_count,
    rslts.line_count,
    rslts.hour,
    rslts.date,
    rslts.week
   FROM rslts
  ORDER BY rslts.id;


ALTER TABLE "ExcelMetrics1" OWNER TO postgres;

--
-- Name: Reliable_Build_Users; Type: VIEW; Schema: wscommands; Owner: postgres
--

CREATE VIEW "Reliable_Build_Users" AS
 SELECT z.accurev_user AS ntlogin,
    min(z.tm) AS start_tm,
    count(*) AS cnt
   FROM baseresults z
  WHERE ((z.accurev_user IS NOT NULL) AND ((z.accurev_user)::text <> '(not logged in)'::text))
  GROUP BY z.accurev_user
  ORDER BY z.accurev_user;


ALTER TABLE "Reliable_Build_Users" OWNER TO postgres;

--
-- Name: cmdargs; Type: TABLE; Schema: wscommands; Owner: postgres
--

CREATE TABLE cmdargs (
    id bigint NOT NULL,
    command character varying,
    argument character varying,
    value character varying,
    "position" integer,
    orginalcommand character varying
);


ALTER TABLE cmdargs OWNER TO postgres;

--
-- Name: host_class; Type: TABLE; Schema: wscommands; Owner: postgres
--

CREATE TABLE host_class (
    type character varying,
    match character varying,
    id bigint NOT NULL
);


ALTER TABLE host_class OWNER TO postgres;

--
-- Name: hosts; Type: TABLE; Schema: wscommands; Owner: postgres
--

CREATE TABLE hosts (
    host character varying NOT NULL,
    type character varying
);


ALTER TABLE hosts OWNER TO postgres;

--
-- Name: messages; Type: TABLE; Schema: wscommands; Owner: postgres
--

CREATE TABLE messages (
    id bigint NOT NULL,
    line_num integer,
    line character varying
);


ALTER TABLE messages OWNER TO postgres;

--
-- Name: raw_baseresults; Type: TABLE; Schema: wscommands; Owner: postgres
--

CREATE TABLE raw_baseresults (
    id bigint,
    tm timestamp without time zone,
    workspace character varying,
    workingdir character varying,
    version real,
    stream character varying,
    duration bigint,
    "user" character varying,
    command character varying,
    code integer,
    host character varying,
    accurev_user character varying,
    accurev_topdir character varying
);


ALTER TABLE raw_baseresults OWNER TO postgres;

--
-- Name: raw_cmdargs; Type: TABLE; Schema: wscommands; Owner: postgres
--

CREATE TABLE raw_cmdargs (
    id bigint,
    command character varying,
    argument character varying,
    value character varying,
    "position" integer,
    orginalcommand character varying
);


ALTER TABLE raw_cmdargs OWNER TO postgres;

--
-- Name: raw_messages; Type: TABLE; Schema: wscommands; Owner: postgres
--

CREATE TABLE raw_messages (
    id bigint,
    line_num integer,
    line character varying
);


ALTER TABLE raw_messages OWNER TO postgres;

SET search_path = "PIE", pg_catalog;

--
-- Name: promo_req promo_req_pkey; Type: CONSTRAINT; Schema: PIE; Owner: postgres
--

ALTER TABLE ONLY promo_req
    ADD CONSTRAINT promo_req_pkey PRIMARY KEY (id);


SET search_path = accurev, pg_catalog;

--
-- Name: depots depots_depotname_key; Type: CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY depots
    ADD CONSTRAINT depots_depotname_key UNIQUE (depotname);


--
-- Name: depots depots_pkey; Type: CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY depots
    ADD CONSTRAINT depots_pkey PRIMARY KEY (id);


--
-- Name: elem_types elem_types_pkey; Type: CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY elem_types
    ADD CONSTRAINT elem_types_pkey PRIMARY KEY (id);


--
-- Name: elem_types elem_types_type_name_key; Type: CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY elem_types
    ADD CONSTRAINT elem_types_type_name_key UNIQUE (type_name);


--
-- Name: filter_comments filter_comments_pkey; Type: CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY filter_comments
    ADD CONSTRAINT filter_comments_pkey PRIMARY KEY (id);


--
-- Name: stream_daily stream_daily_pkey; Type: CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY stream_daily
    ADD CONSTRAINT stream_daily_pkey PRIMARY KEY (depotname, streamnumber);


--
-- Name: transactions transactions_pkey; Type: CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY transactions
    ADD CONSTRAINT transactions_pkey PRIMARY KEY (t_id);


SET search_path = audit_control, pg_catalog;

--
-- Name: distro_lists distro_lists_manager_key; Type: CONSTRAINT; Schema: audit_control; Owner: postgres
--

ALTER TABLE ONLY distro_lists
    ADD CONSTRAINT distro_lists_manager_key UNIQUE (ldap_list);


--
-- Name: distro_lists distro_lists_pkey; Type: CONSTRAINT; Schema: audit_control; Owner: postgres
--

ALTER TABLE ONLY distro_lists
    ADD CONSTRAINT distro_lists_pkey PRIMARY KEY (id);


SET search_path = buildlog, pg_catalog;

--
-- Name: baseresults baseresults_pkey; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY baseresults
    ADD CONSTRAINT baseresults_pkey PRIMARY KEY (id);


--
-- Name: componentmeta componentmeta_pkey; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY componentmeta
    ADD CONSTRAINT componentmeta_pkey PRIMARY KEY (component);


--
-- Name: etlresults etlresults_id_key; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY etlresults
    ADD CONSTRAINT etlresults_id_key UNIQUE (id);


--
-- Name: fault_class fault_class_fault_class_key; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY fault_class
    ADD CONSTRAINT fault_class_fault_class_key UNIQUE (fault_class);


--
-- Name: fault_class fault_class_pkey; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY fault_class
    ADD CONSTRAINT fault_class_pkey PRIMARY KEY (fault_class);


--
-- Name: host_class host_class_pkey; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY host_class
    ADD CONSTRAINT host_class_pkey PRIMARY KEY (id);


--
-- Name: hosts hosts_pkey; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY hosts
    ADD CONSTRAINT hosts_pkey PRIMARY KEY (host);


--
-- Name: ibidresults ibidresults_ibid_key; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY ibidresults
    ADD CONSTRAINT ibidresults_ibid_key UNIQUE (ibid);


--
-- Name: ibidresults ibidresults_id_key; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY ibidresults
    ADD CONSTRAINT ibidresults_id_key UNIQUE (id);


--
-- Name: usermatch usermatch_pkey; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY usermatch
    ADD CONSTRAINT usermatch_pkey PRIMARY KEY (m_id);


--
-- Name: weekly weekly_pkey; Type: CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY weekly
    ADD CONSTRAINT weekly_pkey PRIMARY KEY (week, component, host_class);


SET search_path = buildlog_new, pg_catalog;

--
-- Name: usr_build_class ix_build_class_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_build_class
    ADD CONSTRAINT ix_build_class_name_key UNIQUE (name);


--
-- Name: usr_build_class ix_build_class_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_build_class
    ADD CONSTRAINT ix_build_class_pkey PRIMARY KEY (id);


--
-- Name: ix_cloud ix_cloud_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_cloud
    ADD CONSTRAINT ix_cloud_name_key UNIQUE (name);


--
-- Name: ix_cloud ix_cloud_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_cloud
    ADD CONSTRAINT ix_cloud_pkey PRIMARY KEY (id);


--
-- Name: ix_cmdargs ix_cmdargs_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_cmdargs
    ADD CONSTRAINT ix_cmdargs_name_key UNIQUE (name);


--
-- Name: ix_cmdargs ix_cmdargs_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_cmdargs
    ADD CONSTRAINT ix_cmdargs_pkey PRIMARY KEY (id);


--
-- Name: ix_cmdvals ix_cmdvals_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_cmdvals
    ADD CONSTRAINT ix_cmdvals_name_key UNIQUE (name);


--
-- Name: ix_cmdvals ix_cmdvals_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_cmdvals
    ADD CONSTRAINT ix_cmdvals_pkey PRIMARY KEY (id);


--
-- Name: usr_component_class ix_component_class_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_component_class
    ADD CONSTRAINT ix_component_class_name_key UNIQUE (name);


--
-- Name: usr_component_class ix_component_class_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_component_class
    ADD CONSTRAINT ix_component_class_pkey PRIMARY KEY (id);


--
-- Name: ix_component ix_component_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_component
    ADD CONSTRAINT ix_component_name_key UNIQUE (name);


--
-- Name: ix_component ix_component_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_component
    ADD CONSTRAINT ix_component_pkey PRIMARY KEY (id);


--
-- Name: ix_env_type ix_env_type_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_env_type
    ADD CONSTRAINT ix_env_type_name_key UNIQUE (name);


--
-- Name: ix_env_type ix_env_type_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_env_type
    ADD CONSTRAINT ix_env_type_pkey PRIMARY KEY (id);


--
-- Name: ix_environment ix_environment_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_environment
    ADD CONSTRAINT ix_environment_name_key UNIQUE (name);


--
-- Name: ix_environment ix_environment_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_environment
    ADD CONSTRAINT ix_environment_pkey PRIMARY KEY (id);


--
-- Name: usr_fault_category ix_fault_category_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_fault_category
    ADD CONSTRAINT ix_fault_category_name_key UNIQUE (name);


--
-- Name: usr_fault_category ix_fault_category_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_fault_category
    ADD CONSTRAINT ix_fault_category_pkey PRIMARY KEY (id);


--
-- Name: usr_fault_class ix_fault_class_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_fault_class
    ADD CONSTRAINT ix_fault_class_name_key UNIQUE (name);


--
-- Name: usr_fault_class ix_fault_class_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_fault_class
    ADD CONSTRAINT ix_fault_class_pkey PRIMARY KEY (id);


--
-- Name: ix_fault_detail ix_fault_detail_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_fault_detail
    ADD CONSTRAINT ix_fault_detail_pkey PRIMARY KEY (id);


--
-- Name: ix_fault_msg ix_fault_msg_hash_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_fault_msg
    ADD CONSTRAINT ix_fault_msg_hash_key UNIQUE (hash);


--
-- Name: ix_fault_msg ix_fault_msg_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_fault_msg
    ADD CONSTRAINT ix_fault_msg_pkey PRIMARY KEY (id);


--
-- Name: usr_host_category ix_host_category_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_host_category
    ADD CONSTRAINT ix_host_category_name_key UNIQUE (name);


--
-- Name: usr_host_category ix_host_category_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_host_category
    ADD CONSTRAINT ix_host_category_pkey PRIMARY KEY (id);


--
-- Name: usr_host_class ix_host_class_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_host_class
    ADD CONSTRAINT ix_host_class_name_key UNIQUE (name);


--
-- Name: usr_host_class ix_host_class_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_host_class
    ADD CONSTRAINT ix_host_class_pkey PRIMARY KEY (id);


--
-- Name: ix_host ix_host_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_host
    ADD CONSTRAINT ix_host_name_key UNIQUE (name);


--
-- Name: ix_host ix_host_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_host
    ADD CONSTRAINT ix_host_pkey PRIMARY KEY (id);


--
-- Name: ix_ibid ix_ibid_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_ibid
    ADD CONSTRAINT ix_ibid_name_key UNIQUE (name);


--
-- Name: ix_ibid ix_ibid_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_ibid
    ADD CONSTRAINT ix_ibid_pkey PRIMARY KEY (id);


--
-- Name: ix_init_val ix_init_val_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_init_val
    ADD CONSTRAINT ix_init_val_name_key UNIQUE (name);


--
-- Name: ix_init_val ix_init_val_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_init_val
    ADD CONSTRAINT ix_init_val_pkey PRIMARY KEY (id);


--
-- Name: ix_ipaddress ix_ipaddress_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_ipaddress
    ADD CONSTRAINT ix_ipaddress_name_key UNIQUE (name);


--
-- Name: ix_ipaddress ix_ipaddress_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_ipaddress
    ADD CONSTRAINT ix_ipaddress_pkey PRIMARY KEY (id);


--
-- Name: ix_ntlogin ix_ntlogin_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_ntlogin
    ADD CONSTRAINT ix_ntlogin_name_key UNIQUE (name);


--
-- Name: ix_ntlogin ix_ntlogin_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_ntlogin
    ADD CONSTRAINT ix_ntlogin_pkey PRIMARY KEY (id);


--
-- Name: ix_phase ix_phase_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_phase
    ADD CONSTRAINT ix_phase_name_key UNIQUE (name);


--
-- Name: ix_phase ix_phase_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_phase
    ADD CONSTRAINT ix_phase_pkey PRIMARY KEY (id);


--
-- Name: ix_site ix_site_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_site
    ADD CONSTRAINT ix_site_name_key UNIQUE (name);


--
-- Name: ix_site ix_site_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_site
    ADD CONSTRAINT ix_site_pkey PRIMARY KEY (id);


--
-- Name: ix_stream ix_stream_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_stream
    ADD CONSTRAINT ix_stream_name_key UNIQUE (name);


--
-- Name: ix_stream ix_stream_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY ix_stream
    ADD CONSTRAINT ix_stream_pkey PRIMARY KEY (id);


--
-- Name: usr_map_host_to_host_class map_host_class_to_host_category_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_map_host_to_host_class
    ADD CONSTRAINT map_host_class_to_host_category_pkey PRIMARY KEY (id);


--
-- Name: tbl_faults tbl_fault_details_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_faults
    ADD CONSTRAINT tbl_fault_details_pkey PRIMARY KEY (tbl_results_id);


--
-- Name: tbl_fileinfo tbl_fileinfo_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_fileinfo
    ADD CONSTRAINT tbl_fileinfo_pkey PRIMARY KEY (tbl_results_id);


--
-- Name: tbl_hosts tbl_hosts_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_hosts
    ADD CONSTRAINT tbl_hosts_pkey PRIMARY KEY (id);


--
-- Name: tbl_ibidinfo tbl_ibidinfo_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_ibidinfo
    ADD CONSTRAINT tbl_ibidinfo_pkey PRIMARY KEY (ix_ibid_id);


--
-- Name: usr_logrange_info tbl_logrange_info_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_logrange_info
    ADD CONSTRAINT tbl_logrange_info_pkey PRIMARY KEY (id);


--
-- Name: tbl_results tbl_results_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_pkey PRIMARY KEY (id);


--
-- Name: tbl_timeslots tbl_timeslots_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_timeslots
    ADD CONSTRAINT tbl_timeslots_pkey PRIMARY KEY (tbl_results_id);


--
-- Name: tbl_users tbl_users_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_users
    ADD CONSTRAINT tbl_users_pkey PRIMARY KEY (id);


--
-- Name: usr_match_owner_to_log usermatch_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_match_owner_to_log
    ADD CONSTRAINT usermatch_pkey PRIMARY KEY (id);


--
-- Name: usr_ipaddress_category_mapping usr_ipaddress_category_mapping_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_ipaddress_category_mapping
    ADD CONSTRAINT usr_ipaddress_category_mapping_pkey PRIMARY KEY (ix_ipaddress_id);


--
-- Name: usr_locations usr_locations_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_locations
    ADD CONSTRAINT usr_locations_name_key UNIQUE (name);


--
-- Name: usr_locations usr_locations_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_locations
    ADD CONSTRAINT usr_locations_pkey PRIMARY KEY (id);


--
-- Name: usr_network_location usr_network_location_name_key; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_network_location
    ADD CONSTRAINT usr_network_location_name_key UNIQUE (name);


--
-- Name: usr_network_location usr_network_location_pkey; Type: CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_network_location
    ADD CONSTRAINT usr_network_location_pkey PRIMARY KEY (id);


SET search_path = buildmetrics, pg_catalog;

--
-- Name: ix_build_phase ix_build_phase_name_key; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_build_phase
    ADD CONSTRAINT ix_build_phase_name_key UNIQUE (name);


--
-- Name: ix_build_phase ix_build_phase_pkey; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_build_phase
    ADD CONSTRAINT ix_build_phase_pkey PRIMARY KEY (id);


--
-- Name: ix_build_type ix_build_type_name_key; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_build_type
    ADD CONSTRAINT ix_build_type_name_key UNIQUE (name);


--
-- Name: ix_build_type ix_build_type_pkey; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_build_type
    ADD CONSTRAINT ix_build_type_pkey PRIMARY KEY (id);


--
-- Name: ix_buildall_version ix_buildall_version_name_key; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_buildall_version
    ADD CONSTRAINT ix_buildall_version_name_key UNIQUE (name);


--
-- Name: ix_buildall_version ix_buildall_version_pkey; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_buildall_version
    ADD CONSTRAINT ix_buildall_version_pkey PRIMARY KEY (id);


--
-- Name: ix_components ix_components_name_key; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_components
    ADD CONSTRAINT ix_components_name_key UNIQUE (name);


--
-- Name: ix_components ix_components_pkey; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_components
    ADD CONSTRAINT ix_components_pkey PRIMARY KEY (id);


--
-- Name: ix_flavor ix_flavor_name_key; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_flavor
    ADD CONSTRAINT ix_flavor_name_key UNIQUE (name);


--
-- Name: ix_flavor ix_flavor_pkey; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_flavor
    ADD CONSTRAINT ix_flavor_pkey PRIMARY KEY (id);


--
-- Name: ix_host_ipaddress ix_host_ipaddress_name_key; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_host_ipaddress
    ADD CONSTRAINT ix_host_ipaddress_name_key UNIQUE (name);


--
-- Name: ix_host_ipaddress ix_host_ipaddress_pkey; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_host_ipaddress
    ADD CONSTRAINT ix_host_ipaddress_pkey PRIMARY KEY (id);


--
-- Name: ix_product ix_product_name_key; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_product
    ADD CONSTRAINT ix_product_name_key UNIQUE (name);


--
-- Name: ix_product ix_product_pkey; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_product
    ADD CONSTRAINT ix_product_pkey PRIMARY KEY (id);


--
-- Name: ix_stream ix_stream_name_key; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_stream
    ADD CONSTRAINT ix_stream_name_key UNIQUE (name);


--
-- Name: ix_stream ix_stream_pkey; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_stream
    ADD CONSTRAINT ix_stream_pkey PRIMARY KEY (id);


--
-- Name: ix_type ix_type_name_key; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_type
    ADD CONSTRAINT ix_type_name_key UNIQUE (name);


--
-- Name: ix_type ix_type_pkey; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY ix_type
    ADD CONSTRAINT ix_type_pkey PRIMARY KEY (id);


--
-- Name: tbl_buildmetadata tbl_buildmetadata_pkey; Type: CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_buildmetadata
    ADD CONSTRAINT tbl_buildmetadata_pkey PRIMARY KEY (id);


SET search_path = cateams, pg_catalog;

--
-- Name: cateams cateams_name_key; Type: CONSTRAINT; Schema: cateams; Owner: postgres
--

ALTER TABLE ONLY cateams
    ADD CONSTRAINT cateams_name_key UNIQUE (name);


--
-- Name: cateams cateams_pkey; Type: CONSTRAINT; Schema: cateams; Owner: postgres
--

ALTER TABLE ONLY cateams
    ADD CONSTRAINT cateams_pkey PRIMARY KEY (id);


--
-- Name: rally_info rally_info_email_key; Type: CONSTRAINT; Schema: cateams; Owner: postgres
--

ALTER TABLE ONLY rally_info
    ADD CONSTRAINT rally_info_email_key UNIQUE (email);


--
-- Name: rally_info rally_info_employee_id_key; Type: CONSTRAINT; Schema: cateams; Owner: postgres
--

ALTER TABLE ONLY rally_info
    ADD CONSTRAINT rally_info_employee_id_key UNIQUE (employee_id);


--
-- Name: rally_info rally_info_ntlogin_key; Type: CONSTRAINT; Schema: cateams; Owner: postgres
--

ALTER TABLE ONLY rally_info
    ADD CONSTRAINT rally_info_ntlogin_key UNIQUE (ntlogin);


SET search_path = cateams2, pg_catalog;

--
-- Name: tbl_cateamleaders cateamleaders_pkey; Type: CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_cateamleaders
    ADD CONSTRAINT cateamleaders_pkey PRIMARY KEY (name);


--
-- Name: tbl_cateammembers cateammembers_pkey; Type: CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_cateammembers
    ADD CONSTRAINT cateammembers_pkey PRIMARY KEY (name, ix_server_scans_id);


--
-- Name: ix_cateams cateams_pkey; Type: CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY ix_cateams
    ADD CONSTRAINT cateams_pkey PRIMARY KEY (id);


--
-- Name: ix_domains domains_pkey; Type: CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY ix_domains
    ADD CONSTRAINT domains_pkey PRIMARY KEY (id);


--
-- Name: ix_projects projects_pkey; Type: CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY ix_projects
    ADD CONSTRAINT projects_pkey PRIMARY KEY (id);


--
-- Name: ix_server_scans server_scans_pkey; Type: CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY ix_server_scans
    ADD CONSTRAINT server_scans_pkey PRIMARY KEY (id);


--
-- Name: ix_server_scans server_scans_scan_time_key; Type: CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY ix_server_scans
    ADD CONSTRAINT server_scans_scan_time_key UNIQUE (scan_time);


SET search_path = cyclone, pg_catalog;

--
-- Name: tbl_pr_ar pk_tbl_pr_ar; Type: CONSTRAINT; Schema: cyclone; Owner: postgres
--

ALTER TABLE ONLY tbl_pr_ar
    ADD CONSTRAINT pk_tbl_pr_ar PRIMARY KEY (entry_dt, repo, branch, commit_url, ar);


SET search_path = demo_packaging, pg_catalog;

--
-- Name: demo_versions PK; Type: CONSTRAINT; Schema: demo_packaging; Owner: postgres
--

ALTER TABLE ONLY demo_versions
    ADD CONSTRAINT "PK" PRIMARY KEY (uem_version);


--
-- Name: demo_buildnumber Primary_key; Type: CONSTRAINT; Schema: demo_packaging; Owner: postgres
--

ALTER TABLE ONLY demo_buildnumber
    ADD CONSTRAINT "Primary_key" PRIMARY KEY (stream, uem_version);


SET search_path = empdata, pg_catalog;

--
-- Name: ix_badgeid ix_badgeid_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_badgeid
    ADD CONSTRAINT ix_badgeid_name_key UNIQUE (name);


--
-- Name: ix_badgeid ix_badgeid_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_badgeid
    ADD CONSTRAINT ix_badgeid_pkey PRIMARY KEY (id);


--
-- Name: ix_citys ix_citys_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_citys
    ADD CONSTRAINT ix_citys_name_key UNIQUE (name);


--
-- Name: ix_citys ix_citys_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_citys
    ADD CONSTRAINT ix_citys_pkey PRIMARY KEY (id);


--
-- Name: ix_countrys ix_countrys_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_countrys
    ADD CONSTRAINT ix_countrys_name_key UNIQUE (name);


--
-- Name: ix_countrys ix_countrys_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_countrys
    ADD CONSTRAINT ix_countrys_pkey PRIMARY KEY (id);


--
-- Name: ix_departments ix_departments_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_departments
    ADD CONSTRAINT ix_departments_name_key UNIQUE (name);


--
-- Name: ix_departments ix_departments_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_departments
    ADD CONSTRAINT ix_departments_pkey PRIMARY KEY (id);


--
-- Name: ix_description ix_description_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_description
    ADD CONSTRAINT ix_description_name_key UNIQUE (name);


--
-- Name: ix_description ix_description_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_description
    ADD CONSTRAINT ix_description_pkey PRIMARY KEY (id);


--
-- Name: ix_displayname ix_displayname_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_displayname
    ADD CONSTRAINT ix_displayname_name_key UNIQUE (name);


--
-- Name: ix_displayname ix_displayname_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_displayname
    ADD CONSTRAINT ix_displayname_pkey PRIMARY KEY (id);


--
-- Name: ix_distinguishedname ix_distinguishedname_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_distinguishedname
    ADD CONSTRAINT ix_distinguishedname_name_key UNIQUE (name);


--
-- Name: ix_distinguishedname ix_distinguishedname_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_distinguishedname
    ADD CONSTRAINT ix_distinguishedname_pkey PRIMARY KEY (id);


--
-- Name: ix_email ix_email_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_email
    ADD CONSTRAINT ix_email_name_key UNIQUE (name);


--
-- Name: ix_email ix_email_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_email
    ADD CONSTRAINT ix_email_pkey PRIMARY KEY (id);


--
-- Name: ix_employee_name ix_employee_name_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_employee_name
    ADD CONSTRAINT ix_employee_name_name_key UNIQUE (name);


--
-- Name: ix_employee_name ix_employee_name_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_employee_name
    ADD CONSTRAINT ix_employee_name_pkey PRIMARY KEY (id);


--
-- Name: ix_employeetypes ix_employeetypes_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_employeetypes
    ADD CONSTRAINT ix_employeetypes_name_key UNIQUE (name);


--
-- Name: ix_employeetypes ix_employeetypes_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_employeetypes
    ADD CONSTRAINT ix_employeetypes_pkey PRIMARY KEY (id);


--
-- Name: ix_givenname ix_givenname_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_givenname
    ADD CONSTRAINT ix_givenname_name_key UNIQUE (name);


--
-- Name: ix_givenname ix_givenname_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_givenname
    ADD CONSTRAINT ix_givenname_pkey PRIMARY KEY (id);


--
-- Name: ix_fullname ix_name_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_fullname
    ADD CONSTRAINT ix_name_name_key UNIQUE (name);


--
-- Name: ix_fullname ix_name_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_fullname
    ADD CONSTRAINT ix_name_pkey PRIMARY KEY (id);


--
-- Name: ix_ntlogin ix_ntlogin_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_ntlogin
    ADD CONSTRAINT ix_ntlogin_name_key UNIQUE (name);


--
-- Name: ix_ntlogin ix_ntlogin_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_ntlogin
    ADD CONSTRAINT ix_ntlogin_pkey PRIMARY KEY (id);


--
-- Name: ix_officenames ix_officenames_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_officenames
    ADD CONSTRAINT ix_officenames_name_key UNIQUE (name);


--
-- Name: ix_officenames ix_officenames_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_officenames
    ADD CONSTRAINT ix_officenames_pkey PRIMARY KEY (id);


--
-- Name: ix_phone ix_phone_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_phone
    ADD CONSTRAINT ix_phone_name_key UNIQUE (name);


--
-- Name: ix_phone ix_phone_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_phone
    ADD CONSTRAINT ix_phone_pkey PRIMARY KEY (id);


--
-- Name: ix_primarygroupids ix_primarygroupids_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_primarygroupids
    ADD CONSTRAINT ix_primarygroupids_name_key UNIQUE (name);


--
-- Name: ix_primarygroupids ix_primarygroupids_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_primarygroupids
    ADD CONSTRAINT ix_primarygroupids_pkey PRIMARY KEY (id);


--
-- Name: ix_samaccounttypes ix_samaccounttypes_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_samaccounttypes
    ADD CONSTRAINT ix_samaccounttypes_name_key UNIQUE (name);


--
-- Name: ix_samaccounttypes ix_samaccounttypes_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_samaccounttypes
    ADD CONSTRAINT ix_samaccounttypes_pkey PRIMARY KEY (id);


--
-- Name: ix_scans ix_scans_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_scans
    ADD CONSTRAINT ix_scans_name_key UNIQUE (scan_time);


--
-- Name: ix_scans ix_scans_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_scans
    ADD CONSTRAINT ix_scans_pkey PRIMARY KEY (id);


--
-- Name: ix_states ix_states_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_states
    ADD CONSTRAINT ix_states_name_key UNIQUE (name);


--
-- Name: ix_states ix_states_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_states
    ADD CONSTRAINT ix_states_pkey PRIMARY KEY (id);


--
-- Name: ix_surname ix_surname_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_surname
    ADD CONSTRAINT ix_surname_name_key UNIQUE (name);


--
-- Name: ix_surname ix_surname_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_surname
    ADD CONSTRAINT ix_surname_pkey PRIMARY KEY (id);


--
-- Name: ix_title ix_title_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_title
    ADD CONSTRAINT ix_title_name_key UNIQUE (name);


--
-- Name: ix_title ix_title_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_title
    ADD CONSTRAINT ix_title_pkey PRIMARY KEY (id);


--
-- Name: ix_useraccountcontrols ix_useraccountcontrols_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_useraccountcontrols
    ADD CONSTRAINT ix_useraccountcontrols_name_key UNIQUE (name);


--
-- Name: ix_useraccountcontrols ix_useraccountcontrols_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_useraccountcontrols
    ADD CONSTRAINT ix_useraccountcontrols_pkey PRIMARY KEY (id);


--
-- Name: ix_zipcodes ix_zipcodes_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_zipcodes
    ADD CONSTRAINT ix_zipcodes_name_key UNIQUE (name);


--
-- Name: ix_zipcodes ix_zipcodes_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY ix_zipcodes
    ADD CONSTRAINT ix_zipcodes_pkey PRIMARY KEY (id);


--
-- Name: usr_top_mgrs usr_top_mgrs_name_key; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY usr_top_mgrs
    ADD CONSTRAINT usr_top_mgrs_name_key UNIQUE (name);


--
-- Name: usr_top_mgrs usr_top_mgrs_pkey; Type: CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY usr_top_mgrs
    ADD CONSTRAINT usr_top_mgrs_pkey PRIMARY KEY (id);


SET search_path = jenkins, pg_catalog;

--
-- Name: ciadmins ciadmins_name_key; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciadmins
    ADD CONSTRAINT ciadmins_name_key UNIQUE (name);


--
-- Name: ciadmins ciadmins_pkey; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciadmins
    ADD CONSTRAINT ciadmins_pkey PRIMARY KEY (id);


--
-- Name: cijobs cijobs_pkey; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY cijobs
    ADD CONSTRAINT cijobs_pkey PRIMARY KEY (job_id);


--
-- Name: cijobs cijobs_server_id_name_key; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY cijobs
    ADD CONSTRAINT cijobs_server_id_name_key UNIQUE (server_id, name);


--
-- Name: ciplugin_scans ciplugin_scans_pkey; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciplugin_scans
    ADD CONSTRAINT ciplugin_scans_pkey PRIMARY KEY (id);


--
-- Name: ciplugin_scans ciplugin_scans_scan_timedate_key; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciplugin_scans
    ADD CONSTRAINT ciplugin_scans_scan_timedate_key UNIQUE (scan_timedate);


--
-- Name: ciplugins ciplugins_name_version_key; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciplugins
    ADD CONSTRAINT ciplugins_name_version_key UNIQUE (name, version);


--
-- Name: ciplugins ciplugins_pkey; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciplugins
    ADD CONSTRAINT ciplugins_pkey PRIMARY KEY (id);


--
-- Name: ciservers ciservers_pkey; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciservers
    ADD CONSTRAINT ciservers_pkey PRIMARY KEY (id);


--
-- Name: cislaves cislaves_slave_id_key; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY cislaves
    ADD CONSTRAINT cislaves_slave_id_key UNIQUE (slave_id);


--
-- Name: server_versions server_versions_pkey; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY server_versions
    ADD CONSTRAINT server_versions_pkey PRIMARY KEY (id);


--
-- Name: server_versions server_versions_version_key; Type: CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY server_versions
    ADD CONSTRAINT server_versions_version_key UNIQUE (version);


SET search_path = jenkinslogger, pg_catalog;

--
-- Name: baseresults baseresults_pkey; Type: CONSTRAINT; Schema: jenkinslogger; Owner: postgres
--

ALTER TABLE ONLY baseresults
    ADD CONSTRAINT baseresults_pkey PRIMARY KEY (id);


SET search_path = netstat, pg_catalog;

--
-- Name: ix_address ix_address_name_key; Type: CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY ix_address
    ADD CONSTRAINT ix_address_name_key UNIQUE (name);


--
-- Name: ix_address ix_address_pkey; Type: CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY ix_address
    ADD CONSTRAINT ix_address_pkey PRIMARY KEY (id);


--
-- Name: ix_port ix_port_name_key; Type: CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY ix_port
    ADD CONSTRAINT ix_port_name_key UNIQUE (name);


--
-- Name: ix_port ix_port_pkey; Type: CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY ix_port
    ADD CONSTRAINT ix_port_pkey PRIMARY KEY (id);


--
-- Name: ix_proto ix_proto_name_key; Type: CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY ix_proto
    ADD CONSTRAINT ix_proto_name_key UNIQUE (name);


--
-- Name: ix_proto ix_proto_pkey; Type: CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY ix_proto
    ADD CONSTRAINT ix_proto_pkey PRIMARY KEY (id);


--
-- Name: ix_state ix_state_name_key; Type: CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY ix_state
    ADD CONSTRAINT ix_state_name_key UNIQUE (name);


--
-- Name: ix_state ix_state_pkey; Type: CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY ix_state
    ADD CONSTRAINT ix_state_pkey PRIMARY KEY (id);


--
-- Name: tbl_datamover tbl_datamover_pkey; Type: CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY tbl_datamover
    ADD CONSTRAINT tbl_datamover_pkey PRIMARY KEY (id);


SET search_path = rally, pg_catalog;

--
-- Name: ix_costcenters costcenters_name_key; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY ix_costcenters
    ADD CONSTRAINT costcenters_name_key UNIQUE (name);


--
-- Name: ix_costcenters costcenters_pkey; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY ix_costcenters
    ADD CONSTRAINT costcenters_pkey PRIMARY KEY (id);


--
-- Name: ix_domains domains_name_key; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY ix_domains
    ADD CONSTRAINT domains_name_key UNIQUE (name);


--
-- Name: ix_domains domains_pkey; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY ix_domains
    ADD CONSTRAINT domains_pkey PRIMARY KEY (id);


--
-- Name: ix_permissions permissions_name_key; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY ix_permissions
    ADD CONSTRAINT permissions_name_key UNIQUE (name);


--
-- Name: ix_permissions permissions_pkey; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY ix_permissions
    ADD CONSTRAINT permissions_pkey PRIMARY KEY (id);


--
-- Name: ix_projects projects_name_key; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY ix_projects
    ADD CONSTRAINT projects_name_key UNIQUE (name);


--
-- Name: ix_projects projects_pkey; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY ix_projects
    ADD CONSTRAINT projects_pkey PRIMARY KEY (id);


--
-- Name: tbl_rally_users rally_users_pkey; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY tbl_rally_users
    ADD CONSTRAINT rally_users_pkey PRIMARY KEY (id);


--
-- Name: ix_roles roles_name_key; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY ix_roles
    ADD CONSTRAINT roles_name_key UNIQUE (name);


--
-- Name: ix_roles roles_pkey; Type: CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY ix_roles
    ADD CONSTRAINT roles_pkey PRIMARY KEY (id);


SET search_path = remedy, pg_catalog;

--
-- Name: ix_audit_attribute ix_audit_attribute_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_audit_attribute
    ADD CONSTRAINT ix_audit_attribute_name_key UNIQUE (name);


--
-- Name: ix_audit_attribute ix_audit_attribute_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_audit_attribute
    ADD CONSTRAINT ix_audit_attribute_pkey PRIMARY KEY (id);


--
-- Name: ix_audit_fields ix_audit_fields_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_audit_fields
    ADD CONSTRAINT ix_audit_fields_name_key UNIQUE (name);


--
-- Name: ix_audit_fields ix_audit_fields_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_audit_fields
    ADD CONSTRAINT ix_audit_fields_pkey PRIMARY KEY (id);


--
-- Name: ix_badgeid ix_badgeid_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_badgeid
    ADD CONSTRAINT ix_badgeid_name_key UNIQUE (name);


--
-- Name: ix_badgeid ix_badgeid_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_badgeid
    ADD CONSTRAINT ix_badgeid_pkey PRIMARY KEY (id);


--
-- Name: ix_candidate_status ix_candidate_status_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_candidate_status
    ADD CONSTRAINT ix_candidate_status_name_key UNIQUE (name);


--
-- Name: ix_candidate_status ix_candidate_status_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_candidate_status
    ADD CONSTRAINT ix_candidate_status_pkey PRIMARY KEY (id);


--
-- Name: ix_classification ix_classification_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_classification
    ADD CONSTRAINT ix_classification_name_key UNIQUE (name);


--
-- Name: ix_classification ix_classification_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_classification
    ADD CONSTRAINT ix_classification_pkey PRIMARY KEY (id);


--
-- Name: ix_customer_impact ix_customer_impact_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_customer_impact
    ADD CONSTRAINT ix_customer_impact_name_key UNIQUE (name);


--
-- Name: ix_customer_impact ix_customer_impact_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_customer_impact
    ADD CONSTRAINT ix_customer_impact_pkey PRIMARY KEY (id);


--
-- Name: ix_email ix_email_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_email
    ADD CONSTRAINT ix_email_name_key UNIQUE (name);


--
-- Name: ix_email ix_email_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_email
    ADD CONSTRAINT ix_email_pkey PRIMARY KEY (id);


--
-- Name: ix_employee_names ix_employee_names_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_employee_names
    ADD CONSTRAINT ix_employee_names_name_key UNIQUE (name);


--
-- Name: ix_employee_names ix_employee_names_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_employee_names
    ADD CONSTRAINT ix_employee_names_pkey PRIMARY KEY (id);


--
-- Name: ix_escalate_reason ix_escalate_reason_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_escalate_reason
    ADD CONSTRAINT ix_escalate_reason_name_key UNIQUE (name);


--
-- Name: ix_escalate_reason ix_escalate_reason_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_escalate_reason
    ADD CONSTRAINT ix_escalate_reason_pkey PRIMARY KEY (id);


--
-- Name: ix_function ix_function_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_function
    ADD CONSTRAINT ix_function_name_key UNIQUE (name);


--
-- Name: ix_function ix_function_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_function
    ADD CONSTRAINT ix_function_pkey PRIMARY KEY (id);


--
-- Name: ix_functional_area ix_functional_area_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_functional_area
    ADD CONSTRAINT ix_functional_area_name_key UNIQUE (name);


--
-- Name: ix_functional_area ix_functional_area_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_functional_area
    ADD CONSTRAINT ix_functional_area_pkey PRIMARY KEY (id);


--
-- Name: ix_givenname ix_givenname_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_givenname
    ADD CONSTRAINT ix_givenname_name_key UNIQUE (name);


--
-- Name: ix_givenname ix_givenname_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_givenname
    ADD CONSTRAINT ix_givenname_pkey PRIMARY KEY (id);


--
-- Name: ix_group ix_group_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_group
    ADD CONSTRAINT ix_group_name_key UNIQUE (name);


--
-- Name: ix_group ix_group_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_group
    ADD CONSTRAINT ix_group_pkey PRIMARY KEY (id);


--
-- Name: ix_history ix_history_end_tm_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_history
    ADD CONSTRAINT ix_history_end_tm_key UNIQUE (end_tm);


--
-- Name: ix_history ix_history_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_history
    ADD CONSTRAINT ix_history_pkey PRIMARY KEY (id);


--
-- Name: ix_how_found_main ix_how_found_main_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_how_found_main
    ADD CONSTRAINT ix_how_found_main_name_key UNIQUE (name);


--
-- Name: ix_how_found_main ix_how_found_main_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_how_found_main
    ADD CONSTRAINT ix_how_found_main_pkey PRIMARY KEY (id);


--
-- Name: ix_how_found ix_how_found_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_how_found
    ADD CONSTRAINT ix_how_found_name_key UNIQUE (name);


--
-- Name: ix_how_found ix_how_found_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_how_found
    ADD CONSTRAINT ix_how_found_pkey PRIMARY KEY (id);


--
-- Name: ix_major_area ix_major_area_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_major_area
    ADD CONSTRAINT ix_major_area_name_key UNIQUE (name);


--
-- Name: ix_major_area ix_major_area_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_major_area
    ADD CONSTRAINT ix_major_area_pkey PRIMARY KEY (id);


--
-- Name: ix_ntlogin ix_ntlogin_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_ntlogin
    ADD CONSTRAINT ix_ntlogin_name_key UNIQUE (name);


--
-- Name: ix_ntlogin ix_ntlogin_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_ntlogin
    ADD CONSTRAINT ix_ntlogin_pkey PRIMARY KEY (id);


--
-- Name: ix_primus_needed ix_primus_needed_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_primus_needed
    ADD CONSTRAINT ix_primus_needed_name_key UNIQUE (name);


--
-- Name: ix_primus_needed ix_primus_needed_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_primus_needed
    ADD CONSTRAINT ix_primus_needed_pkey PRIMARY KEY (id);


--
-- Name: ix_priority ix_priority_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_priority
    ADD CONSTRAINT ix_priority_name_key UNIQUE (name);


--
-- Name: ix_priority ix_priority_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_priority
    ADD CONSTRAINT ix_priority_pkey PRIMARY KEY (id);


--
-- Name: ix_product_area ix_product_area_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_product_area
    ADD CONSTRAINT ix_product_area_name_key UNIQUE (name);


--
-- Name: ix_product_area ix_product_area_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_product_area
    ADD CONSTRAINT ix_product_area_pkey PRIMARY KEY (id);


--
-- Name: ix_product_family ix_product_family_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_product_family
    ADD CONSTRAINT ix_product_family_name_key UNIQUE (name);


--
-- Name: ix_product_family ix_product_family_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_product_family
    ADD CONSTRAINT ix_product_family_pkey PRIMARY KEY (id);


--
-- Name: ix_product ix_product_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_product
    ADD CONSTRAINT ix_product_name_key UNIQUE (name);


--
-- Name: ix_product ix_product_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_product
    ADD CONSTRAINT ix_product_pkey PRIMARY KEY (id);


--
-- Name: ix_product_release ix_product_release_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_product_release
    ADD CONSTRAINT ix_product_release_name_key UNIQUE (name);


--
-- Name: ix_product_release ix_product_release_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_product_release
    ADD CONSTRAINT ix_product_release_pkey PRIMARY KEY (id);


--
-- Name: ix_relationship_type ix_relationship_type_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_relationship_type
    ADD CONSTRAINT ix_relationship_type_name_key UNIQUE (name);


--
-- Name: ix_relationship_type ix_relationship_type_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_relationship_type
    ADD CONSTRAINT ix_relationship_type_pkey PRIMARY KEY (id);


--
-- Name: ix_release_name ix_release_name_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_release_name
    ADD CONSTRAINT ix_release_name_name_key UNIQUE (name);


--
-- Name: ix_release_name ix_release_name_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_release_name
    ADD CONSTRAINT ix_release_name_pkey PRIMARY KEY (id);


--
-- Name: ix_release_note_needed ix_release_note_needed_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_release_note_needed
    ADD CONSTRAINT ix_release_note_needed_name_key UNIQUE (name);


--
-- Name: ix_release_note_needed ix_release_note_needed_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_release_note_needed
    ADD CONSTRAINT ix_release_note_needed_pkey PRIMARY KEY (id);


--
-- Name: ix_releases_built_in ix_releases_built_in_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_releases_built_in
    ADD CONSTRAINT ix_releases_built_in_name_key UNIQUE (name);


--
-- Name: ix_releases_built_in ix_releases_built_in_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_releases_built_in
    ADD CONSTRAINT ix_releases_built_in_pkey PRIMARY KEY (id);


--
-- Name: ix_request_type ix_request_type_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_request_type
    ADD CONSTRAINT ix_request_type_name_key UNIQUE (name);


--
-- Name: ix_request_type ix_request_type_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_request_type
    ADD CONSTRAINT ix_request_type_pkey PRIMARY KEY (id);


--
-- Name: ix_script_name ix_script_name_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_script_name
    ADD CONSTRAINT ix_script_name_name_key UNIQUE (name);


--
-- Name: ix_script_name ix_script_name_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_script_name
    ADD CONSTRAINT ix_script_name_pkey PRIMARY KEY (id);


--
-- Name: ix_sp_target_release ix_sp_target_release_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_sp_target_release
    ADD CONSTRAINT ix_sp_target_release_name_key UNIQUE (name);


--
-- Name: ix_sp_target_release ix_sp_target_release_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_sp_target_release
    ADD CONSTRAINT ix_sp_target_release_pkey PRIMARY KEY (id);


--
-- Name: ix_status_details ix_status_details_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_status_details
    ADD CONSTRAINT ix_status_details_name_key UNIQUE (name);


--
-- Name: ix_status_details ix_status_details_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_status_details
    ADD CONSTRAINT ix_status_details_pkey PRIMARY KEY (id);


--
-- Name: ix_status ix_status_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_status
    ADD CONSTRAINT ix_status_name_key UNIQUE (name);


--
-- Name: ix_status ix_status_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_status
    ADD CONSTRAINT ix_status_pkey PRIMARY KEY (id);


--
-- Name: ix_surname ix_surname_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_surname
    ADD CONSTRAINT ix_surname_name_key UNIQUE (name);


--
-- Name: ix_surname ix_surname_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_surname
    ADD CONSTRAINT ix_surname_pkey PRIMARY KEY (id);


--
-- Name: ix_type ix_type_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_type
    ADD CONSTRAINT ix_type_name_key UNIQUE (name);


--
-- Name: ix_type ix_type_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY ix_type
    ADD CONSTRAINT ix_type_pkey PRIMARY KEY (id);


--
-- Name: tbl_issue_descriptions tbl_issue_descriptions_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_descriptions
    ADD CONSTRAINT tbl_issue_descriptions_pkey PRIMARY KEY (entryid);


--
-- Name: tbl_issue_tracking tbl_issue_tracking_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_pkey PRIMARY KEY (entryid);


--
-- Name: tbl_other tbl_other_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_other
    ADD CONSTRAINT tbl_other_pkey PRIMARY KEY (entryid);


--
-- Name: tbl_releases tbl_releases_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_releases
    ADD CONSTRAINT tbl_releases_pkey PRIMARY KEY (requestid);


--
-- Name: tbl_share_association tbl_share_association_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_association
    ADD CONSTRAINT tbl_share_association_pkey PRIMARY KEY (requestid);


--
-- Name: tbl_share_audit tbl_share_audit_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_audit
    ADD CONSTRAINT tbl_share_audit_pkey PRIMARY KEY (requestid);


--
-- Name: tbl_share_employee tbl_share_employee_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_employee
    ADD CONSTRAINT tbl_share_employee_pkey PRIMARY KEY (requestid);


--
-- Name: tbl_share_notes tbl_share_notes_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_notes
    ADD CONSTRAINT tbl_share_notes_pkey PRIMARY KEY (requestid);


--
-- Name: tbl_share_release_association tbl_share_release_association_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_release_association
    ADD CONSTRAINT tbl_share_release_association_pkey PRIMARY KEY (requestid);


--
-- Name: tbl_share_user_notification tbl_share_user_notification_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_user_notification
    ADD CONSTRAINT tbl_share_user_notification_pkey PRIMARY KEY (requestid);


--
-- Name: usr_closed_status_detail usr_closed_status_detail_name_key; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_closed_status_detail
    ADD CONSTRAINT usr_closed_status_detail_name_key UNIQUE (name);


--
-- Name: usr_closed_status_detail usr_closed_status_detail_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_closed_status_detail
    ADD CONSTRAINT usr_closed_status_detail_pkey PRIMARY KEY (id);


--
-- Name: usr_report_definitions usr_report_definitions_pkey; Type: CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_report_definitions
    ADD CONSTRAINT usr_report_definitions_pkey PRIMARY KEY (id);


SET search_path = shares, pg_catalog;

--
-- Name: buildsharedirs buildsharedirs_dir_key; Type: CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY buildsharedirs
    ADD CONSTRAINT buildsharedirs_dir_key UNIQUE (dir);


--
-- Name: buildsharedirs buildsharedirs_pkey; Type: CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY buildsharedirs
    ADD CONSTRAINT buildsharedirs_pkey PRIMARY KEY (id);


--
-- Name: cistreams cistreams_name_key; Type: CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY cistreams
    ADD CONSTRAINT cistreams_name_key UNIQUE (name);


--
-- Name: cistreams cistreams_pkey; Type: CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY cistreams
    ADD CONSTRAINT cistreams_pkey PRIMARY KEY (id);


--
-- Name: rpmjobs rpmjobs_pkey; Type: CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY rpmjobs
    ADD CONSTRAINT rpmjobs_pkey PRIMARY KEY (id);


SET search_path = vcenter, pg_catalog;

--
-- Name: adminuser adminuser_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY adminuser
    ADD CONSTRAINT adminuser_name_key UNIQUE (name);


--
-- Name: adminuser adminuser_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY adminuser
    ADD CONSTRAINT adminuser_pkey PRIMARY KEY (id);


--
-- Name: esxservers esx-servers_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY esxservers
    ADD CONSTRAINT "esx-servers_pkey" PRIMARY KEY (id);


--
-- Name: esxservers esxservers_address_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY esxservers
    ADD CONSTRAINT esxservers_address_key UNIQUE (address);


--
-- Name: folders folders_esxservers_id_folderid_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY folders
    ADD CONSTRAINT folders_esxservers_id_folderid_key UNIQUE (esxservers_id, folderid);


--
-- Name: folders folders_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY folders
    ADD CONSTRAINT folders_pkey PRIMARY KEY (id);


--
-- Name: guestid_types guestid_types_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY guestid_types
    ADD CONSTRAINT guestid_types_name_key UNIQUE (name);


--
-- Name: guestid_types guestid_types_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY guestid_types
    ADD CONSTRAINT guestid_types_pkey PRIMARY KEY (id);


--
-- Name: guestos_types guestos_types_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY guestos_types
    ADD CONSTRAINT guestos_types_name_key UNIQUE (name);


--
-- Name: guestos_types guestos_types_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY guestos_types
    ADD CONSTRAINT guestos_types_pkey PRIMARY KEY (id);


--
-- Name: hardware hardware_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY hardware
    ADD CONSTRAINT hardware_name_key UNIQUE (name);


--
-- Name: hardware hardware_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY hardware
    ADD CONSTRAINT hardware_pkey PRIMARY KEY (id);


--
-- Name: ix_cloud_info ix_cloud_info_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_cloud_info
    ADD CONSTRAINT ix_cloud_info_name_key UNIQUE (name);


--
-- Name: ix_cloud_info ix_cloud_info_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_cloud_info
    ADD CONSTRAINT ix_cloud_info_pkey PRIMARY KEY (id);


--
-- Name: ix_cloud ix_cloud_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_cloud
    ADD CONSTRAINT ix_cloud_name_key UNIQUE (name);


--
-- Name: ix_cloud ix_cloud_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_cloud
    ADD CONSTRAINT ix_cloud_pkey PRIMARY KEY (id);


--
-- Name: ix_fld1 ix_fld1_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_fld1
    ADD CONSTRAINT ix_fld1_name_key UNIQUE (name);


--
-- Name: ix_fld1 ix_fld1_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_fld1
    ADD CONSTRAINT ix_fld1_pkey PRIMARY KEY (id);


--
-- Name: ix_fld2 ix_fld2_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_fld2
    ADD CONSTRAINT ix_fld2_name_key UNIQUE (name);


--
-- Name: ix_fld2 ix_fld2_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_fld2
    ADD CONSTRAINT ix_fld2_pkey PRIMARY KEY (id);


--
-- Name: ix_iptype ix_iptype_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_iptype
    ADD CONSTRAINT ix_iptype_name_key UNIQUE (name);


--
-- Name: ix_iptype ix_iptype_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_iptype
    ADD CONSTRAINT ix_iptype_pkey PRIMARY KEY (id);


--
-- Name: ix_site ix_site_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_site
    ADD CONSTRAINT ix_site_name_key UNIQUE (name);


--
-- Name: ix_site ix_site_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_site
    ADD CONSTRAINT ix_site_pkey PRIMARY KEY (id);


--
-- Name: ix_vcenter ix_vcenter_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_vcenter
    ADD CONSTRAINT ix_vcenter_name_key UNIQUE (name);


--
-- Name: ix_vcenter ix_vcenter_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_vcenter
    ADD CONSTRAINT ix_vcenter_pkey PRIMARY KEY (id);


--
-- Name: ix_widget ix_widget_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_widget
    ADD CONSTRAINT ix_widget_name_key UNIQUE (name);


--
-- Name: ix_widget ix_widget_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY ix_widget
    ADD CONSTRAINT ix_widget_pkey PRIMARY KEY (id);


--
-- Name: locations locations_location_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY locations
    ADD CONSTRAINT locations_location_key UNIQUE (location);


--
-- Name: locations locations_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY locations
    ADD CONSTRAINT locations_pkey PRIMARY KEY (id);


--
-- Name: nagios_class nagios_class_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY nagios_class
    ADD CONSTRAINT nagios_class_name_key UNIQUE (name);


--
-- Name: nagios_class nagios_class_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY nagios_class
    ADD CONSTRAINT nagios_class_pkey PRIMARY KEY (id);


--
-- Name: purpose purpose_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY purpose
    ADD CONSTRAINT purpose_name_key UNIQUE (name);


--
-- Name: purpose purpose_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY purpose
    ADD CONSTRAINT purpose_pkey PRIMARY KEY (id);


--
-- Name: rack_location rack_location_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY rack_location
    ADD CONSTRAINT rack_location_name_key UNIQUE (name);


--
-- Name: rack_location rack_location_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY rack_location
    ADD CONSTRAINT rack_location_pkey PRIMARY KEY (id);


--
-- Name: server_scans server_scans_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY server_scans
    ADD CONSTRAINT server_scans_pkey PRIMARY KEY (id);


--
-- Name: server_scans server_scans_scan_time_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY server_scans
    ADD CONSTRAINT server_scans_scan_time_key UNIQUE (scan_time);


--
-- Name: switch switch_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY switch
    ADD CONSTRAINT switch_name_key UNIQUE (name);


--
-- Name: switch switch_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY switch
    ADD CONSTRAINT switch_pkey PRIMARY KEY (id);


--
-- Name: tools_version tools_version_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY tools_version
    ADD CONSTRAINT tools_version_name_key UNIQUE (name);


--
-- Name: tools_version tools_version_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY tools_version
    ADD CONSTRAINT tools_version_pkey PRIMARY KEY (id);


--
-- Name: usr_subnets usr_subnets_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY usr_subnets
    ADD CONSTRAINT usr_subnets_pkey PRIMARY KEY (id);


--
-- Name: usr_subnets usr_subnets_subnet_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY usr_subnets
    ADD CONSTRAINT usr_subnets_subnet_key UNIQUE (subnet);


--
-- Name: vmcategory_types vmcategory_types_name_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vmcategory_types
    ADD CONSTRAINT vmcategory_types_name_key UNIQUE (name);


--
-- Name: vmcategory_types vmcategory_types_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vmcategory_types
    ADD CONSTRAINT vmcategory_types_pkey PRIMARY KEY (id);


--
-- Name: vmcategory vmcategory_vms_id_key; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vmcategory
    ADD CONSTRAINT vmcategory_vms_id_key UNIQUE (vms_id);


--
-- Name: vminfo vminfo_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_pkey PRIMARY KEY (id);


--
-- Name: vms vms_pkey; Type: CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vms
    ADD CONSTRAINT vms_pkey PRIMARY KEY (id);


SET search_path = vdiscover, pg_catalog;

--
-- Name: entities entities_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY entities
    ADD CONSTRAINT entities_pkey PRIMARY KEY (id);


--
-- Name: entity-types entity-types_name_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY "entity-types"
    ADD CONSTRAINT "entity-types_name_key" UNIQUE (name);


--
-- Name: entity-types entity-types_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY "entity-types"
    ADD CONSTRAINT "entity-types_pkey" PRIMARY KEY (id);


--
-- Name: err_errors err_errors_error_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY err_errors
    ADD CONSTRAINT err_errors_error_key UNIQUE (error);


--
-- Name: err_errors err_errors_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY err_errors
    ADD CONSTRAINT err_errors_pkey PRIMARY KEY (id);


--
-- Name: err_files err_files_file_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY err_files
    ADD CONSTRAINT err_files_file_key UNIQUE (file);


--
-- Name: err_files err_files_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY err_files
    ADD CONSTRAINT err_files_pkey PRIMARY KEY (id);


--
-- Name: err_names err_names_name_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY err_names
    ADD CONSTRAINT err_names_name_key UNIQUE (name);


--
-- Name: err_names err_names_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY err_names
    ADD CONSTRAINT err_names_pkey PRIMARY KEY (id);


--
-- Name: esx-servers esx-servers_address_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY "esx-servers"
    ADD CONSTRAINT "esx-servers_address_key" UNIQUE (address);


--
-- Name: esx-servers esx-servers_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY "esx-servers"
    ADD CONSTRAINT "esx-servers_pkey" PRIMARY KEY (id);


--
-- Name: guestid_types guestid_types_name_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY guestid_types
    ADD CONSTRAINT guestid_types_name_key UNIQUE (name);


--
-- Name: guestid_types guestid_types_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY guestid_types
    ADD CONSTRAINT guestid_types_pkey PRIMARY KEY (id);


--
-- Name: guestos_types guestos_types_name_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY guestos_types
    ADD CONSTRAINT guestos_types_name_key UNIQUE (name);


--
-- Name: guestos_types guestos_types_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY guestos_types
    ADD CONSTRAINT guestos_types_pkey PRIMARY KEY (id);


--
-- Name: locations locations_location_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY locations
    ADD CONSTRAINT locations_location_key UNIQUE (location);


--
-- Name: locations locations_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY locations
    ADD CONSTRAINT locations_pkey PRIMARY KEY (id);


--
-- Name: overallstatus_types overallstatus_types_name_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY overallstatus_types
    ADD CONSTRAINT overallstatus_types_name_key UNIQUE (name);


--
-- Name: overallstatus_types overallstatus_types_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY overallstatus_types
    ADD CONSTRAINT overallstatus_types_pkey PRIMARY KEY (id);


--
-- Name: 2015-12-14.Poweroff poweroff-251214_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY "2015-12-14.Poweroff"
    ADD CONSTRAINT "poweroff-251214_pkey" PRIMARY KEY (id);


--
-- Name: server_scans server_scans_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY server_scans
    ADD CONSTRAINT server_scans_pkey PRIMARY KEY (id);


--
-- Name: server_scans server_scans_scan_time_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY server_scans
    ADD CONSTRAINT server_scans_scan_time_key UNIQUE (scan_time);


--
-- Name: vmcategory_types vmcategory_types_name_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmcategory_types
    ADD CONSTRAINT vmcategory_types_name_key UNIQUE (name);


--
-- Name: vmcategory_types vmcategory_types_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmcategory_types
    ADD CONSTRAINT vmcategory_types_pkey PRIMARY KEY (id);


--
-- Name: vminfo vminfo_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_pkey PRIMARY KEY (id);


--
-- Name: vms vms_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vms
    ADD CONSTRAINT vms_pkey PRIMARY KEY (id);


--
-- Name: vms vms_server_id_name_vmpathname_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vms
    ADD CONSTRAINT vms_server_id_name_vmpathname_key UNIQUE (server_id, name, vmpathname);


--
-- Name: vmwaretools_types vmwaretools_types_name_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmwaretools_types
    ADD CONSTRAINT vmwaretools_types_name_key UNIQUE (name);


--
-- Name: vmwaretools_types vmwaretools_types_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmwaretools_types
    ADD CONSTRAINT vmwaretools_types_pkey PRIMARY KEY (id);


--
-- Name: vobject_types vobject_types_name_key; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vobject_types
    ADD CONSTRAINT vobject_types_name_key UNIQUE (name);


--
-- Name: vobject_types vobject_types_pkey; Type: CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vobject_types
    ADD CONSTRAINT vobject_types_pkey PRIMARY KEY (id);


SET search_path = wscommands, pg_catalog;

--
-- Name: baseresults baseresults_id_key; Type: CONSTRAINT; Schema: wscommands; Owner: postgres
--

ALTER TABLE ONLY baseresults
    ADD CONSTRAINT baseresults_id_key UNIQUE (id);


--
-- Name: baseresults baseresults_pkey; Type: CONSTRAINT; Schema: wscommands; Owner: postgres
--

ALTER TABLE ONLY baseresults
    ADD CONSTRAINT baseresults_pkey PRIMARY KEY (id);


--
-- Name: etlresults etlresults_id_key; Type: CONSTRAINT; Schema: wscommands; Owner: postgres
--

ALTER TABLE ONLY etlresults
    ADD CONSTRAINT etlresults_id_key UNIQUE (id);


--
-- Name: hosts hosts_pkey; Type: CONSTRAINT; Schema: wscommands; Owner: postgres
--

ALTER TABLE ONLY hosts
    ADD CONSTRAINT hosts_pkey PRIMARY KEY (host);


SET search_path = accurev, pg_catalog;

--
-- Name: stream_daily_basisstreamnumber_idx; Type: INDEX; Schema: accurev; Owner: postgres
--

CREATE INDEX stream_daily_basisstreamnumber_idx ON stream_daily USING btree (basisstreamnumber);


--
-- Name: stream_daily_name_idx; Type: INDEX; Schema: accurev; Owner: postgres
--

CREATE INDEX stream_daily_name_idx ON stream_daily USING btree (name);


--
-- Name: stream_daily_streamnumber_idx; Type: INDEX; Schema: accurev; Owner: postgres
--

CREATE INDEX stream_daily_streamnumber_idx ON stream_daily USING btree (streamnumber);


--
-- Name: stream_data_basisstreamnumber_idx; Type: INDEX; Schema: accurev; Owner: postgres
--

CREATE INDEX stream_data_basisstreamnumber_idx ON stream_history USING btree (basisstreamnumber);


--
-- Name: stream_data_name_idx; Type: INDEX; Schema: accurev; Owner: postgres
--

CREATE INDEX stream_data_name_idx ON stream_history USING btree (name);


--
-- Name: stream_data_streamnumber_idx; Type: INDEX; Schema: accurev; Owner: postgres
--

CREATE INDEX stream_data_streamnumber_idx ON stream_history USING btree (streamnumber);


SET search_path = buildlog, pg_catalog;

--
-- Name: baseresults_id_idx; Type: INDEX; Schema: buildlog; Owner: postgres
--

CREATE UNIQUE INDEX baseresults_id_idx ON baseresults USING btree (id);


--
-- Name: cmdargs_id_idx; Type: INDEX; Schema: buildlog; Owner: postgres
--

CREATE INDEX cmdargs_id_idx ON cmdargs USING btree (id);


--
-- Name: componentmeta_component_idx; Type: INDEX; Schema: buildlog; Owner: postgres
--

CREATE UNIQUE INDEX componentmeta_component_idx ON componentmeta USING btree (component);


--
-- Name: componentsbyoccurrence_id_idx; Type: INDEX; Schema: buildlog; Owner: postgres
--

CREATE INDEX componentsbyoccurrence_id_idx ON componentsbyoccurrence USING btree (id);


--
-- Name: etlresults_id_idx; Type: INDEX; Schema: buildlog; Owner: postgres
--

CREATE UNIQUE INDEX etlresults_id_idx ON etlresults USING btree (id);


--
-- Name: fault_class_fault_class_idx; Type: INDEX; Schema: buildlog; Owner: postgres
--

CREATE INDEX fault_class_fault_class_idx ON fault_class USING btree (fault_class);


--
-- Name: hosts_host_idx; Type: INDEX; Schema: buildlog; Owner: postgres
--

CREATE UNIQUE INDEX hosts_host_idx ON hosts USING btree (host);


--
-- Name: usermatch_m_id_idx; Type: INDEX; Schema: buildlog; Owner: postgres
--

CREATE INDEX usermatch_m_id_idx ON usermatch USING btree (m_id);


--
-- Name: weekly_week_component_host_class_idx; Type: INDEX; Schema: buildlog; Owner: postgres
--

CREATE INDEX weekly_week_component_host_class_idx ON weekly USING btree (week, component, host_class);


--
-- Name: weekly_week_component_host_class_idx1; Type: INDEX; Schema: buildlog; Owner: postgres
--

CREATE INDEX weekly_week_component_host_class_idx1 ON weekly USING btree (week, component, host_class);


SET search_path = buildlog_new, pg_catalog;

--
-- Name: ix_cloud_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_cloud_name_idx ON ix_cloud USING btree (name);


--
-- Name: ix_cmdargs_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_cmdargs_name_idx ON ix_cmdargs USING btree (name);


--
-- Name: ix_cmdvals_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_cmdvals_name_idx ON ix_cmdvals USING btree (name);


--
-- Name: ix_component_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_component_name_idx ON ix_component USING btree (name);


--
-- Name: ix_env_type_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_env_type_name_idx ON ix_env_type USING btree (name);


--
-- Name: ix_environment_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_environment_name_idx ON ix_environment USING btree (name);


--
-- Name: ix_fault_msg_hash_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_fault_msg_hash_idx ON ix_fault_msg USING btree (hash);


--
-- Name: ix_host_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_host_name_idx ON ix_host USING btree (name);


--
-- Name: ix_ibid_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_ibid_name_idx ON ix_ibid USING btree (name);


--
-- Name: ix_init_val_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_init_val_name_idx ON ix_init_val USING btree (name);


--
-- Name: ix_ipaddress_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_ipaddress_name_idx ON ix_ipaddress USING btree (name);


--
-- Name: ix_ntlogin_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_ntlogin_name_idx ON ix_ntlogin USING btree (name);


--
-- Name: ix_phase_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_phase_name_idx ON ix_phase USING btree (name);


--
-- Name: ix_site_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_site_name_idx ON ix_site USING btree (name);


--
-- Name: ix_stream_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX ix_stream_name_idx ON ix_stream USING btree (name);


--
-- Name: tbl_json_logs_tm_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX tbl_json_logs_tm_idx ON tbl_json_logs USING btree (tm);


--
-- Name: usermatch_id_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX usermatch_id_idx ON usr_match_owner_to_log USING btree (id);


--
-- Name: usr_fault_category_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX usr_fault_category_name_idx ON usr_fault_category USING btree (name);


--
-- Name: usr_fault_class_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX usr_fault_class_name_idx ON usr_fault_class USING btree (name);


--
-- Name: usr_host_category_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX usr_host_category_name_idx ON usr_host_category USING btree (name);


--
-- Name: usr_host_class_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX usr_host_class_name_idx ON usr_host_class USING btree (name);


--
-- Name: usr_locations_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX usr_locations_name_idx ON usr_locations USING btree (name);


--
-- Name: usr_network_location_name_idx; Type: INDEX; Schema: buildlog_new; Owner: postgres
--

CREATE INDEX usr_network_location_name_idx ON usr_network_location USING btree (name);


SET search_path = buildmetrics, pg_catalog;

--
-- Name: ix_build_phase_name_idx; Type: INDEX; Schema: buildmetrics; Owner: postgres
--

CREATE INDEX ix_build_phase_name_idx ON ix_build_phase USING btree (name);


--
-- Name: ix_build_type_name_idx; Type: INDEX; Schema: buildmetrics; Owner: postgres
--

CREATE INDEX ix_build_type_name_idx ON ix_build_type USING btree (name);


--
-- Name: ix_buildall_version_name_idx; Type: INDEX; Schema: buildmetrics; Owner: postgres
--

CREATE INDEX ix_buildall_version_name_idx ON ix_buildall_version USING btree (name);


--
-- Name: ix_components_name_idx; Type: INDEX; Schema: buildmetrics; Owner: postgres
--

CREATE INDEX ix_components_name_idx ON ix_components USING btree (name);


--
-- Name: ix_flavor_name_idx; Type: INDEX; Schema: buildmetrics; Owner: postgres
--

CREATE INDEX ix_flavor_name_idx ON ix_flavor USING btree (name);


--
-- Name: ix_host_ipaddress_name_idx; Type: INDEX; Schema: buildmetrics; Owner: postgres
--

CREATE INDEX ix_host_ipaddress_name_idx ON ix_host_ipaddress USING btree (name);


--
-- Name: ix_product_name_idx; Type: INDEX; Schema: buildmetrics; Owner: postgres
--

CREATE INDEX ix_product_name_idx ON ix_product USING btree (name);


--
-- Name: ix_stream_name_idx; Type: INDEX; Schema: buildmetrics; Owner: postgres
--

CREATE INDEX ix_stream_name_idx ON ix_stream USING btree (name);


--
-- Name: ix_type_name_idx; Type: INDEX; Schema: buildmetrics; Owner: postgres
--

CREATE INDEX ix_type_name_idx ON ix_type USING btree (name);


SET search_path = cateams, pg_catalog;

--
-- Name: rally_info_email_idx; Type: INDEX; Schema: cateams; Owner: postgres
--

CREATE INDEX rally_info_email_idx ON rally_info USING btree (email);


--
-- Name: rally_info_employee_id_idx; Type: INDEX; Schema: cateams; Owner: postgres
--

CREATE INDEX rally_info_employee_id_idx ON rally_info USING btree (employee_id);


--
-- Name: rally_info_ntlogin_idx; Type: INDEX; Schema: cateams; Owner: postgres
--

CREATE INDEX rally_info_ntlogin_idx ON rally_info USING btree (ntlogin);


SET search_path = cateams2, pg_catalog;

--
-- Name: ix_cateams_name_idx; Type: INDEX; Schema: cateams2; Owner: postgres
--

CREATE INDEX ix_cateams_name_idx ON ix_cateams USING btree (name);


--
-- Name: ix_domains_name_idx; Type: INDEX; Schema: cateams2; Owner: postgres
--

CREATE INDEX ix_domains_name_idx ON ix_domains USING btree (name);


--
-- Name: ix_projects_name_idx; Type: INDEX; Schema: cateams2; Owner: postgres
--

CREATE INDEX ix_projects_name_idx ON ix_projects USING btree (name);


--
-- Name: ix_server_scans_scan_time_idx; Type: INDEX; Schema: cateams2; Owner: postgres
--

CREATE INDEX ix_server_scans_scan_time_idx ON ix_server_scans USING btree (scan_time);


SET search_path = empdata, pg_catalog;

--
-- Name: ix_badgeid_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_badgeid_name_idx ON ix_badgeid USING btree (name);


--
-- Name: ix_citys_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_citys_name_idx ON ix_citys USING btree (name);


--
-- Name: ix_countrys_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_countrys_name_idx ON ix_countrys USING btree (name);


--
-- Name: ix_departments_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_departments_name_idx ON ix_departments USING btree (name);


--
-- Name: ix_description_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_description_name_idx ON ix_description USING btree (name);


--
-- Name: ix_displayname_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_displayname_name_idx ON ix_displayname USING btree (name);


--
-- Name: ix_distinguishedname_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_distinguishedname_name_idx ON ix_distinguishedname USING btree (name);


--
-- Name: ix_email_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_email_name_idx ON ix_email USING btree (name);


--
-- Name: ix_employee_name_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_employee_name_name_idx ON ix_employee_name USING btree (name);


--
-- Name: ix_employeetypes_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_employeetypes_name_idx ON ix_employeetypes USING btree (name);


--
-- Name: ix_fullname_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_fullname_name_idx ON ix_fullname USING btree (name);


--
-- Name: ix_givenname_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_givenname_name_idx ON ix_givenname USING btree (name);


--
-- Name: ix_ntlogin_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_ntlogin_name_idx ON ix_ntlogin USING btree (name);


--
-- Name: ix_officenames_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_officenames_name_idx ON ix_officenames USING btree (name);


--
-- Name: ix_phone_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_phone_name_idx ON ix_phone USING btree (name);


--
-- Name: ix_primarygroupids_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_primarygroupids_name_idx ON ix_primarygroupids USING btree (name);


--
-- Name: ix_samaccounttypes_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_samaccounttypes_name_idx ON ix_samaccounttypes USING btree (name);


--
-- Name: ix_states_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_states_name_idx ON ix_states USING btree (name);


--
-- Name: ix_surname_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_surname_name_idx ON ix_surname USING btree (name);


--
-- Name: ix_title_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_title_name_idx ON ix_title USING btree (name);


--
-- Name: ix_useraccountcontrols_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_useraccountcontrols_name_idx ON ix_useraccountcontrols USING btree (name);


--
-- Name: ix_zipcodes_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX ix_zipcodes_name_idx ON ix_zipcodes USING btree (name);


--
-- Name: usr_top_mgrs_name_idx; Type: INDEX; Schema: empdata; Owner: postgres
--

CREATE INDEX usr_top_mgrs_name_idx ON usr_top_mgrs USING btree (name);


SET search_path = github, pg_catalog;

--
-- Name: idx_action; Type: INDEX; Schema: github; Owner: c4dev
--

CREATE INDEX idx_action ON cyclonecommon USING btree (action);


--
-- Name: idx_cyclonecommon; Type: INDEX; Schema: github; Owner: c4dev
--

CREATE INDEX idx_cyclonecommon ON cyclonecommon USING gin (payload);


--
-- Name: idx_github_event; Type: INDEX; Schema: github; Owner: c4dev
--

CREATE INDEX idx_github_event ON cyclonecommon USING btree (x_github_event);


--
-- Name: idx_repo_forks; Type: INDEX; Schema: github; Owner: c4dev
--

CREATE INDEX idx_repo_forks ON cyclonecommon USING btree (repo_forks);


--
-- Name: idx_repo_full_name; Type: INDEX; Schema: github; Owner: c4dev
--

CREATE INDEX idx_repo_full_name ON cyclonecommon USING btree (repo_full_name);


--
-- Name: idx_repo_id; Type: INDEX; Schema: github; Owner: c4dev
--

CREATE INDEX idx_repo_id ON cyclonecommon USING btree (repo_id);


--
-- Name: idx_repo_name; Type: INDEX; Schema: github; Owner: c4dev
--

CREATE INDEX idx_repo_name ON cyclonecommon USING btree (repo_name);


--
-- Name: idx_sender_id; Type: INDEX; Schema: github; Owner: c4dev
--

CREATE INDEX idx_sender_id ON cyclonecommon USING btree (sender_id);


SET search_path = jenkinslogger, pg_catalog;

--
-- Name: baseresults_id_idx; Type: INDEX; Schema: jenkinslogger; Owner: postgres
--

CREATE INDEX baseresults_id_idx ON baseresults USING btree (id);


--
-- Name: parameters_param_idx; Type: INDEX; Schema: jenkinslogger; Owner: postgres
--

CREATE INDEX parameters_param_idx ON parameters USING btree (param);


SET search_path = jira, pg_catalog;

--
-- Name: idx_file_deletion_event_time; Type: INDEX; Schema: jira; Owner: hendrr2
--

CREATE INDEX idx_file_deletion_event_time ON jira_file_deletion USING btree (event_time);


--
-- Name: idx_file_deletion_file_name; Type: INDEX; Schema: jira; Owner: hendrr2
--

CREATE INDEX idx_file_deletion_file_name ON jira_file_deletion USING btree (name);


--
-- Name: idx_file_deletion_initiator_id; Type: INDEX; Schema: jira; Owner: hendrr2
--

CREATE INDEX idx_file_deletion_initiator_id ON jira_file_deletion USING btree (initiator_id);


--
-- Name: idx_file_deletion_issue; Type: INDEX; Schema: jira; Owner: hendrr2
--

CREATE INDEX idx_file_deletion_issue ON jira_file_deletion USING btree (issue);


--
-- Name: idx_file_deletion_owner; Type: INDEX; Schema: jira; Owner: hendrr2
--

CREATE INDEX idx_file_deletion_owner ON jira_file_deletion USING btree (owner);


--
-- Name: idx_file_deletion_rule; Type: INDEX; Schema: jira; Owner: hendrr2
--

CREATE INDEX idx_file_deletion_rule ON jira_file_deletion USING btree (rule);


--
-- Name: idx_file_name; Type: INDEX; Schema: jira; Owner: hendrr2
--

CREATE INDEX idx_file_name ON jira_file_deletion_2018_jan_23__18_04_58_228 USING btree (name);


--
-- Name: idx_issue; Type: INDEX; Schema: jira; Owner: hendrr2
--

CREATE INDEX idx_issue ON jira_file_deletion_2018_jan_23__18_04_58_228 USING btree (issue);


--
-- Name: idx_jira_file_deletion; Type: INDEX; Schema: jira; Owner: hendrr2
--

CREATE INDEX idx_jira_file_deletion ON jira_file_deletion_2018_jan_23__18_04_58_228 USING gin (payload);


--
-- Name: idx_jira_file_deletion_payload; Type: INDEX; Schema: jira; Owner: hendrr2
--

CREATE INDEX idx_jira_file_deletion_payload ON jira_file_deletion USING gin (payload);


SET search_path = netstat, pg_catalog;

--
-- Name: ix_address_name_idx; Type: INDEX; Schema: netstat; Owner: postgres
--

CREATE INDEX ix_address_name_idx ON ix_address USING btree (name);


--
-- Name: ix_port_name_idx; Type: INDEX; Schema: netstat; Owner: postgres
--

CREATE INDEX ix_port_name_idx ON ix_port USING btree (name);


--
-- Name: ix_proto_name_idx; Type: INDEX; Schema: netstat; Owner: postgres
--

CREATE INDEX ix_proto_name_idx ON ix_proto USING btree (name);


--
-- Name: ix_state_name_idx; Type: INDEX; Schema: netstat; Owner: postgres
--

CREATE INDEX ix_state_name_idx ON ix_state USING btree (name);


SET search_path = rally, pg_catalog;

--
-- Name: ix_costcenters_name_idx; Type: INDEX; Schema: rally; Owner: postgres
--

CREATE INDEX ix_costcenters_name_idx ON ix_costcenters USING btree (name);


--
-- Name: ix_domains_name_idx; Type: INDEX; Schema: rally; Owner: postgres
--

CREATE INDEX ix_domains_name_idx ON ix_domains USING btree (name);


--
-- Name: ix_permissions_name_idx; Type: INDEX; Schema: rally; Owner: postgres
--

CREATE INDEX ix_permissions_name_idx ON ix_permissions USING btree (name);


--
-- Name: ix_projects_name_idx; Type: INDEX; Schema: rally; Owner: postgres
--

CREATE INDEX ix_projects_name_idx ON ix_projects USING btree (name);


--
-- Name: ix_roles_name_idx; Type: INDEX; Schema: rally; Owner: postgres
--

CREATE INDEX ix_roles_name_idx ON ix_roles USING btree (name);


SET search_path = remedy, pg_catalog;

--
-- Name: ix_audit_attribute_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_audit_attribute_name_idx ON ix_audit_attribute USING btree (name);


--
-- Name: ix_audit_fields_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_audit_fields_name_idx ON ix_audit_fields USING btree (name);


--
-- Name: ix_badgeid_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_badgeid_name_idx ON ix_badgeid USING btree (name);


--
-- Name: ix_candidate_status_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_candidate_status_name_idx ON ix_candidate_status USING btree (name);


--
-- Name: ix_classification_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_classification_name_idx ON ix_classification USING btree (name);


--
-- Name: ix_customer_impact_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_customer_impact_name_idx ON ix_customer_impact USING btree (name);


--
-- Name: ix_email_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_email_name_idx ON ix_email USING btree (name);


--
-- Name: ix_employee_names_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_employee_names_name_idx ON ix_employee_names USING btree (name);


--
-- Name: ix_escalate_reason_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_escalate_reason_name_idx ON ix_escalate_reason USING btree (name);


--
-- Name: ix_function_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_function_name_idx ON ix_function USING btree (name);


--
-- Name: ix_functional_area_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_functional_area_name_idx ON ix_functional_area USING btree (name);


--
-- Name: ix_givenname_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_givenname_name_idx ON ix_givenname USING btree (name);


--
-- Name: ix_group_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_group_name_idx ON ix_group USING btree (name);


--
-- Name: ix_history_end_tm_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_history_end_tm_idx ON ix_history USING btree (end_tm);


--
-- Name: ix_how_found_main_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_how_found_main_name_idx ON ix_how_found_main USING btree (name);


--
-- Name: ix_how_found_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_how_found_name_idx ON ix_how_found USING btree (name);


--
-- Name: ix_major_area_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_major_area_name_idx ON ix_major_area USING btree (name);


--
-- Name: ix_ntlogin_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_ntlogin_name_idx ON ix_ntlogin USING btree (name);


--
-- Name: ix_primus_needed_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_primus_needed_name_idx ON ix_primus_needed USING btree (name);


--
-- Name: ix_priority_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_priority_name_idx ON ix_priority USING btree (name);


--
-- Name: ix_product_area_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_product_area_name_idx ON ix_product_area USING btree (name);


--
-- Name: ix_product_family_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_product_family_name_idx ON ix_product_family USING btree (name);


--
-- Name: ix_product_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_product_name_idx ON ix_product USING btree (name);


--
-- Name: ix_product_release_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_product_release_name_idx ON ix_product_release USING btree (name);


--
-- Name: ix_relationship_type_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_relationship_type_name_idx ON ix_relationship_type USING btree (name);


--
-- Name: ix_release_name_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_release_name_name_idx ON ix_release_name USING btree (name);


--
-- Name: ix_release_note_needed_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_release_note_needed_name_idx ON ix_release_note_needed USING btree (name);


--
-- Name: ix_releases_built_in_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_releases_built_in_name_idx ON ix_releases_built_in USING btree (name);


--
-- Name: ix_request_type_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_request_type_name_idx ON ix_request_type USING btree (name);


--
-- Name: ix_script_name_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_script_name_name_idx ON ix_script_name USING btree (name);


--
-- Name: ix_sp_target_release_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_sp_target_release_name_idx ON ix_sp_target_release USING btree (name);


--
-- Name: ix_status_details_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_status_details_name_idx ON ix_status_details USING btree (name);


--
-- Name: ix_status_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_status_name_idx ON ix_status USING btree (name);


--
-- Name: ix_surname_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_surname_name_idx ON ix_surname USING btree (name);


--
-- Name: ix_type_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX ix_type_name_idx ON ix_type USING btree (name);


--
-- Name: usr_closed_status_detail_name_idx; Type: INDEX; Schema: remedy; Owner: postgres
--

CREATE INDEX usr_closed_status_detail_name_idx ON usr_closed_status_detail USING btree (name);


SET search_path = shares, pg_catalog;

--
-- Name: buildsharedirs_dir_idx; Type: INDEX; Schema: shares; Owner: postgres
--

CREATE INDEX buildsharedirs_dir_idx ON buildsharedirs USING btree (dir);


SET search_path = vcenter, pg_catalog;

--
-- Name: ix_cloud_info_name_idx; Type: INDEX; Schema: vcenter; Owner: postgres
--

CREATE INDEX ix_cloud_info_name_idx ON ix_cloud_info USING btree (name);


--
-- Name: ix_cloud_name_idx; Type: INDEX; Schema: vcenter; Owner: postgres
--

CREATE INDEX ix_cloud_name_idx ON ix_cloud USING btree (name);


--
-- Name: ix_fld1_name_idx; Type: INDEX; Schema: vcenter; Owner: postgres
--

CREATE INDEX ix_fld1_name_idx ON ix_fld1 USING btree (name);


--
-- Name: ix_fld2_name_idx; Type: INDEX; Schema: vcenter; Owner: postgres
--

CREATE INDEX ix_fld2_name_idx ON ix_fld2 USING btree (name);


--
-- Name: ix_iptype_name_idx; Type: INDEX; Schema: vcenter; Owner: postgres
--

CREATE INDEX ix_iptype_name_idx ON ix_iptype USING btree (name);


--
-- Name: ix_site_name_idx; Type: INDEX; Schema: vcenter; Owner: postgres
--

CREATE INDEX ix_site_name_idx ON ix_site USING btree (name);


--
-- Name: ix_vcenter_name_idx; Type: INDEX; Schema: vcenter; Owner: postgres
--

CREATE INDEX ix_vcenter_name_idx ON ix_vcenter USING btree (name);


--
-- Name: ix_widget_name_idx; Type: INDEX; Schema: vcenter; Owner: postgres
--

CREATE INDEX ix_widget_name_idx ON ix_widget USING btree (name);


--
-- Name: vms_id_idx; Type: INDEX; Schema: vcenter; Owner: postgres
--

CREATE UNIQUE INDEX vms_id_idx ON vms USING btree (id);


SET search_path = vdiscover, pg_catalog;

--
-- Name: vms_id_idx; Type: INDEX; Schema: vdiscover; Owner: postgres
--

CREATE UNIQUE INDEX vms_id_idx ON vms USING btree (id);


--
-- Name: vmwaretools_types_id_idx; Type: INDEX; Schema: vdiscover; Owner: postgres
--

CREATE INDEX vmwaretools_types_id_idx ON vmwaretools_types USING btree (id);


SET search_path = wscommands, pg_catalog;

--
-- Name: baseresults_id_idx; Type: INDEX; Schema: wscommands; Owner: postgres
--

CREATE UNIQUE INDEX baseresults_id_idx ON baseresults USING btree (id);


--
-- Name: cmdargs_id_idx; Type: INDEX; Schema: wscommands; Owner: postgres
--

CREATE INDEX cmdargs_id_idx ON cmdargs USING btree (id);


--
-- Name: etlresults_id_idx; Type: INDEX; Schema: wscommands; Owner: postgres
--

CREATE UNIQUE INDEX etlresults_id_idx ON etlresults USING btree (id);


--
-- Name: hosts_host_idx; Type: INDEX; Schema: wscommands; Owner: postgres
--

CREATE UNIQUE INDEX hosts_host_idx ON hosts USING btree (host);


SET search_path = accurev, pg_catalog;

--
-- Name: filter_data filter_data_filter_comment_id_fkey; Type: FK CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY filter_data
    ADD CONSTRAINT filter_data_filter_comment_id_fkey FOREIGN KEY (filter_comment_id) REFERENCES filter_comments(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: promotion_comments promotion_comments_t_id_fkey; Type: FK CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY promotion_comments
    ADD CONSTRAINT promotion_comments_t_id_fkey FOREIGN KEY (t_id) REFERENCES transactions(t_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: promotion_fileversions promotion_fileversions_t_id_fkey; Type: FK CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY promotion_fileversions
    ADD CONSTRAINT promotion_fileversions_t_id_fkey FOREIGN KEY (t_id) REFERENCES transactions(t_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: promotion_issues promotion_issues_t_id_fkey; Type: FK CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY promotion_issues
    ADD CONSTRAINT promotion_issues_t_id_fkey FOREIGN KEY (t_id) REFERENCES transactions(t_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: stream_daily stream_daily_depotname_fkey; Type: FK CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY stream_daily
    ADD CONSTRAINT stream_daily_depotname_fkey FOREIGN KEY (depotname, basisstreamnumber) REFERENCES stream_daily(depotname, streamnumber) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: stream_meta stream_meta_depot_id_fkey; Type: FK CONSTRAINT; Schema: accurev; Owner: postgres
--

ALTER TABLE ONLY stream_meta
    ADD CONSTRAINT stream_meta_depot_id_fkey FOREIGN KEY (depot_id) REFERENCES depots(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = buildlog, pg_catalog;

--
-- Name: cmdargs cmdargs_id_fkey; Type: FK CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY cmdargs
    ADD CONSTRAINT cmdargs_id_fkey FOREIGN KEY (id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: componentsbyoccurrence componentsbyoccurrence_id_fkey; Type: FK CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY componentsbyoccurrence
    ADD CONSTRAINT componentsbyoccurrence_id_fkey FOREIGN KEY (id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: etlresults etlresults_id_fkey; Type: FK CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY etlresults
    ADD CONSTRAINT etlresults_id_fkey FOREIGN KEY (id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ibidresults ibidresults_endid_fkey; Type: FK CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY ibidresults
    ADD CONSTRAINT ibidresults_endid_fkey FOREIGN KEY (endid) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ibidresults ibidresults_id_fkey; Type: FK CONSTRAINT; Schema: buildlog; Owner: postgres
--

ALTER TABLE ONLY ibidresults
    ADD CONSTRAINT ibidresults_id_fkey FOREIGN KEY (id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = buildlog_new, pg_catalog;

--
-- Name: usr_fault_class ix_fault_class_ix_fault_category_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_fault_class
    ADD CONSTRAINT ix_fault_class_ix_fault_category_id_fkey FOREIGN KEY (usr_fault_category_id) REFERENCES usr_fault_category(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_map_host_to_host_class map_host_class_to_host_category_ix_host_category_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_map_host_to_host_class
    ADD CONSTRAINT map_host_class_to_host_category_ix_host_category_id_fkey FOREIGN KEY (usr_host_category_id) REFERENCES usr_host_category(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_map_host_to_host_class map_host_class_to_host_category_ix_host_class_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_map_host_to_host_class
    ADD CONSTRAINT map_host_class_to_host_category_ix_host_class_id_fkey FOREIGN KEY (usr_host_class_id) REFERENCES usr_host_class(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_cmdargs tbl_cmdargs_ix_cmdargs_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_cmdargs
    ADD CONSTRAINT tbl_cmdargs_ix_cmdargs_id_fkey FOREIGN KEY (ix_cmdargs_id) REFERENCES ix_cmdargs(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_cmdargs tbl_cmdargs_ix_cmdvals_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_cmdargs
    ADD CONSTRAINT tbl_cmdargs_ix_cmdvals_id_fkey FOREIGN KEY (ix_cmdvals_id) REFERENCES ix_cmdvals(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_components tbl_components_ix_component_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_components
    ADD CONSTRAINT tbl_components_ix_component_id_fkey FOREIGN KEY (ix_component_id) REFERENCES ix_component(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_components tbl_components_ix_phase_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_components
    ADD CONSTRAINT tbl_components_ix_phase_id_fkey FOREIGN KEY (ix_phase_id) REFERENCES ix_phase(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_faults tbl_fault_details_ix_fault_class_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_faults
    ADD CONSTRAINT tbl_fault_details_ix_fault_class_id_fkey FOREIGN KEY (usr_fault_class_id) REFERENCES usr_fault_class(id);


--
-- Name: tbl_faults tbl_fault_details_ix_fault_component_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_faults
    ADD CONSTRAINT tbl_fault_details_ix_fault_component_id_fkey FOREIGN KEY (ix_fault_component_id) REFERENCES ix_component(id);


--
-- Name: tbl_faults tbl_fault_details_ix_fault_msg_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_faults
    ADD CONSTRAINT tbl_fault_details_ix_fault_msg_id_fkey FOREIGN KEY (ix_fault_msg_id) REFERENCES ix_fault_msg(id);


--
-- Name: tbl_faults tbl_faults_ix_fault_detail_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_faults
    ADD CONSTRAINT tbl_faults_ix_fault_detail_id_fkey FOREIGN KEY (ix_fault_detail_id) REFERENCES ix_fault_detail(id);


--
-- Name: tbl_hosts tbl_hosts_ix_host_class_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_hosts
    ADD CONSTRAINT tbl_hosts_ix_host_class_id_fkey FOREIGN KEY (usr_host_class_id) REFERENCES usr_host_class(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_hosts tbl_hosts_ix_host_class_id_fkey1; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_hosts
    ADD CONSTRAINT tbl_hosts_ix_host_class_id_fkey1 FOREIGN KEY (usr_host_class_id) REFERENCES usr_host_class(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_hosts tbl_hosts_ix_host_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_hosts
    ADD CONSTRAINT tbl_hosts_ix_host_id_fkey FOREIGN KEY (ix_host_id) REFERENCES ix_host(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_hosts tbl_hosts_ix_hostname_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_hosts
    ADD CONSTRAINT tbl_hosts_ix_hostname_id_fkey FOREIGN KEY (ix_hostname_id) REFERENCES ix_host(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_ibidinfo tbl_ibidinfo_ix_cloud_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_ibidinfo
    ADD CONSTRAINT tbl_ibidinfo_ix_cloud_id_fkey FOREIGN KEY (ix_cloud_id) REFERENCES ix_cloud(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_ibidinfo tbl_ibidinfo_ix_director_ntlogin_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_ibidinfo
    ADD CONSTRAINT tbl_ibidinfo_ix_director_ntlogin_id_fkey FOREIGN KEY (ix_director_ntlogin_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_ibidinfo tbl_ibidinfo_ix_ibid_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_ibidinfo
    ADD CONSTRAINT tbl_ibidinfo_ix_ibid_id_fkey FOREIGN KEY (ix_ibid_id) REFERENCES ix_ibid(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_ibidinfo tbl_ibidinfo_ix_site_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_ibidinfo
    ADD CONSTRAINT tbl_ibidinfo_ix_site_id_fkey FOREIGN KEY (ix_site_id) REFERENCES ix_site(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_results tbl_results_ix_build_class_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_ix_build_class_id_fkey FOREIGN KEY (usr_build_class_id) REFERENCES usr_build_class(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_results tbl_results_ix_env_type_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_ix_env_type_id_fkey FOREIGN KEY (ix_env_type_id) REFERENCES ix_env_type(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_results tbl_results_ix_init_val_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_ix_init_val_id_fkey FOREIGN KEY (ix_init_val_id) REFERENCES ix_init_val(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_results tbl_results_ix_native_environment_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_ix_native_environment_id_fkey FOREIGN KEY (ix_environment_native_id) REFERENCES ix_environment(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_results tbl_results_ix_run_environment_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_ix_run_environment_id_fkey FOREIGN KEY (ix_environment_run_id) REFERENCES ix_environment(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_results tbl_results_ix_stream_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_ix_stream_id_fkey FOREIGN KEY (ix_stream_id) REFERENCES ix_stream(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_results tbl_results_ix_streambasis_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_ix_streambasis_id_fkey FOREIGN KEY (ix_streambasis_id) REFERENCES ix_stream(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_results tbl_results_tbl_hosts_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_tbl_hosts_id_fkey FOREIGN KEY (tbl_hosts_id) REFERENCES tbl_hosts(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_results tbl_results_tbl_ntlogin_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_tbl_ntlogin_id_fkey FOREIGN KEY (tbl_users_id) REFERENCES tbl_users(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_results tbl_results_tbl_usermatch_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_results
    ADD CONSTRAINT tbl_results_tbl_usermatch_id_fkey FOREIGN KEY (usr_match_owner_to_log_id) REFERENCES usr_match_owner_to_log(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_timeslots tbl_timeslots_tbl_results_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_timeslots
    ADD CONSTRAINT tbl_timeslots_tbl_results_id_fkey FOREIGN KEY (tbl_results_id) REFERENCES tbl_results(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_match_owner_to_log tbl_usermatch_ix_build_class_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_match_owner_to_log
    ADD CONSTRAINT tbl_usermatch_ix_build_class_id_fkey FOREIGN KEY (usr_build_class_id) REFERENCES usr_build_class(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_users tbl_users_ix_ntlogin_acuser_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_users
    ADD CONSTRAINT tbl_users_ix_ntlogin_acuser_id_fkey FOREIGN KEY (ix_ntlogin_acuser_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_users tbl_users_ix_ntlogin_owner_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_users
    ADD CONSTRAINT tbl_users_ix_ntlogin_owner_id_fkey FOREIGN KEY (ix_ntlogin_owner_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_users tbl_users_ix_ntlogin_user_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY tbl_users
    ADD CONSTRAINT tbl_users_ix_ntlogin_user_id_fkey FOREIGN KEY (ix_ntlogin_user_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_ipaddress_category_mapping usr_ipaddress_category_mapping_usr_locations_loc1_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_ipaddress_category_mapping
    ADD CONSTRAINT usr_ipaddress_category_mapping_usr_locations_loc1_id_fkey FOREIGN KEY (usr_locations_loc1_id) REFERENCES usr_locations(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_ipaddress_category_mapping usr_ipaddress_category_mapping_usr_locations_loc2_id_fkey; Type: FK CONSTRAINT; Schema: buildlog_new; Owner: postgres
--

ALTER TABLE ONLY usr_ipaddress_category_mapping
    ADD CONSTRAINT usr_ipaddress_category_mapping_usr_locations_loc2_id_fkey FOREIGN KEY (usr_locations_loc2_id) REFERENCES usr_locations(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = buildmetrics, pg_catalog;

--
-- Name: tbl_build_summary tbl_build_summary_ix_components_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_build_summary
    ADD CONSTRAINT tbl_build_summary_ix_components_id_fkey FOREIGN KEY (ix_components_id) REFERENCES ix_components(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_build_summary tbl_build_summary_tbl_buildmetadata_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_build_summary
    ADD CONSTRAINT tbl_build_summary_tbl_buildmetadata_id_fkey FOREIGN KEY (tbl_buildmetadata_id) REFERENCES tbl_buildmetadata(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_buildmetadata tbl_buildmetadata_ix_buildall_version_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_buildmetadata
    ADD CONSTRAINT tbl_buildmetadata_ix_buildall_version_id_fkey FOREIGN KEY (ix_buildall_version_id) REFERENCES ix_buildall_version(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_buildmetadata tbl_buildmetadata_ix_flavor_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_buildmetadata
    ADD CONSTRAINT tbl_buildmetadata_ix_flavor_id_fkey FOREIGN KEY (ix_flavor_id) REFERENCES ix_flavor(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_buildmetadata tbl_buildmetadata_ix_host_ipaddress_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_buildmetadata
    ADD CONSTRAINT tbl_buildmetadata_ix_host_ipaddress_id_fkey FOREIGN KEY (ix_host_ipaddress_id) REFERENCES ix_host_ipaddress(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_host_location_mapping tbl_buildmetadata_ix_host_ipaddress_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY usr_host_location_mapping
    ADD CONSTRAINT tbl_buildmetadata_ix_host_ipaddress_id_fkey FOREIGN KEY (ix_host_ipaddress_id) REFERENCES ix_host_ipaddress(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_buildmetadata tbl_buildmetadata_ix_stream_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_buildmetadata
    ADD CONSTRAINT tbl_buildmetadata_ix_stream_id_fkey FOREIGN KEY (ix_stream_id) REFERENCES ix_stream(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_buildmetadata tbl_buildmetadata_ix_type_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_buildmetadata
    ADD CONSTRAINT tbl_buildmetadata_ix_type_id_fkey FOREIGN KEY (ix_type_id) REFERENCES ix_type(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_component_data tbl_component_data_ix_components_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_component_data
    ADD CONSTRAINT tbl_component_data_ix_components_id_fkey FOREIGN KEY (ix_components_id) REFERENCES ix_components(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_component_data tbl_component_data_ix_flavor_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_component_data
    ADD CONSTRAINT tbl_component_data_ix_flavor_id_fkey FOREIGN KEY (ix_flavor_id) REFERENCES ix_flavor(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_component_data tbl_component_data_ix_product_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_component_data
    ADD CONSTRAINT tbl_component_data_ix_product_id_fkey FOREIGN KEY (ix_product_id) REFERENCES ix_product(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_component_data tbl_component_data_tbl_buildmetadata_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_component_data
    ADD CONSTRAINT tbl_component_data_tbl_buildmetadata_id_fkey FOREIGN KEY (tbl_buildmetadata_id) REFERENCES tbl_buildmetadata(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_cpu_data tbl_cpu_data_tbl_buildmetadata_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_cpu_data
    ADD CONSTRAINT tbl_cpu_data_tbl_buildmetadata_id_fkey FOREIGN KEY (tbl_buildmetadata_id) REFERENCES tbl_buildmetadata(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_disk_freespace tbl_disk_freespace_tbl_buildmetadata_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_disk_freespace
    ADD CONSTRAINT tbl_disk_freespace_tbl_buildmetadata_id_fkey FOREIGN KEY (tbl_buildmetadata_id) REFERENCES tbl_buildmetadata(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_event_data tbl_event_data_ix_build_phase_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_event_data
    ADD CONSTRAINT tbl_event_data_ix_build_phase_id_fkey FOREIGN KEY (ix_build_phase_id) REFERENCES ix_build_phase(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_event_data tbl_event_data_ix_components_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_event_data
    ADD CONSTRAINT tbl_event_data_ix_components_id_fkey FOREIGN KEY (ix_components_id) REFERENCES ix_components(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_event_data tbl_event_data_ix_flavor_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_event_data
    ADD CONSTRAINT tbl_event_data_ix_flavor_id_fkey FOREIGN KEY (ix_flavor_id) REFERENCES ix_flavor(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_event_data tbl_event_data_ix_product_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_event_data
    ADD CONSTRAINT tbl_event_data_ix_product_id_fkey FOREIGN KEY (ix_product_id) REFERENCES ix_product(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_event_data tbl_event_data_tbl_buildmetadata_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_event_data
    ADD CONSTRAINT tbl_event_data_tbl_buildmetadata_id_fkey FOREIGN KEY (tbl_buildmetadata_id) REFERENCES tbl_buildmetadata(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_memory_data tbl_memory_data_tbl_buildmetadata_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_memory_data
    ADD CONSTRAINT tbl_memory_data_tbl_buildmetadata_id_fkey FOREIGN KEY (tbl_buildmetadata_id) REFERENCES tbl_buildmetadata(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_warnings tbl_warnings_ix_build_phase_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_warnings
    ADD CONSTRAINT tbl_warnings_ix_build_phase_id_fkey FOREIGN KEY (ix_build_phase_id) REFERENCES ix_build_phase(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_warnings tbl_warnings_ix_build_type_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_warnings
    ADD CONSTRAINT tbl_warnings_ix_build_type_id_fkey FOREIGN KEY (ix_build_type_id) REFERENCES ix_build_type(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_warnings tbl_warnings_ix_components_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_warnings
    ADD CONSTRAINT tbl_warnings_ix_components_id_fkey FOREIGN KEY (ix_components_id) REFERENCES ix_components(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_warnings tbl_warnings_tbl_buildmetadata_id_fkey; Type: FK CONSTRAINT; Schema: buildmetrics; Owner: postgres
--

ALTER TABLE ONLY tbl_warnings
    ADD CONSTRAINT tbl_warnings_tbl_buildmetadata_id_fkey FOREIGN KEY (tbl_buildmetadata_id) REFERENCES tbl_buildmetadata(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = cateams, pg_catalog;

--
-- Name: cateamleaders cateamleaders_cateams_id_fkey; Type: FK CONSTRAINT; Schema: cateams; Owner: postgres
--

ALTER TABLE ONLY cateamleaders
    ADD CONSTRAINT cateamleaders_cateams_id_fkey FOREIGN KEY (cateams_id) REFERENCES cateams(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = cateams2, pg_catalog;

--
-- Name: tbl_cateamleaders cateamleaders_cateams_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_cateamleaders
    ADD CONSTRAINT cateamleaders_cateams_id_fkey FOREIGN KEY (ix_cateams_id) REFERENCES ix_cateams(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_cateamleaders cateamleaders_server_scans_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_cateamleaders
    ADD CONSTRAINT cateamleaders_server_scans_id_fkey FOREIGN KEY (ix_server_scans_id) REFERENCES ix_server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_cateammembers cateammembers_cateams_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_cateammembers
    ADD CONSTRAINT cateammembers_cateams_id_fkey FOREIGN KEY (ix_cateams_id) REFERENCES ix_cateams(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_cateammembers cateammembers_server_scans_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_cateammembers
    ADD CONSTRAINT cateammembers_server_scans_id_fkey FOREIGN KEY (ix_server_scans_id) REFERENCES ix_server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ix_cateams cateams_domain_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY ix_cateams
    ADD CONSTRAINT cateams_domain_id_fkey FOREIGN KEY (ix_domain_id) REFERENCES ix_domains(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ix_cateams cateams_server_scans_id_fkey1; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY ix_cateams
    ADD CONSTRAINT cateams_server_scans_id_fkey1 FOREIGN KEY (ix_server_scans_id) REFERENCES ix_server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ix_domains domains_server_scans_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY ix_domains
    ADD CONSTRAINT domains_server_scans_id_fkey FOREIGN KEY (ix_server_scans_id) REFERENCES ix_server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ix_projects projects_cateam_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY ix_projects
    ADD CONSTRAINT projects_cateam_id_fkey FOREIGN KEY (ix_cateams_id) REFERENCES ix_cateams(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ix_projects projects_server_scans_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY ix_projects
    ADD CONSTRAINT projects_server_scans_id_fkey FOREIGN KEY (ix_server_scans_id) REFERENCES ix_server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_rally_info rally_info_cateammember_name_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_rally_info
    ADD CONSTRAINT rally_info_cateammember_name_fkey FOREIGN KEY (cateammember_name, ix_server_scans_id) REFERENCES tbl_cateammembers(name, ix_server_scans_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_rally_info rally_info_project_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_rally_info
    ADD CONSTRAINT rally_info_project_id_fkey FOREIGN KEY (ix_project_id) REFERENCES ix_projects(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_rally_info rally_info_server-scans_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_rally_info
    ADD CONSTRAINT "rally_info_server-scans_id_fkey" FOREIGN KEY (ix_server_scans_id) REFERENCES ix_server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_teaminfo teaminfo_server_scans_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_teaminfo
    ADD CONSTRAINT teaminfo_server_scans_id_fkey FOREIGN KEY (ix_server_scans_id) REFERENCES ix_server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_teaminfo teaminfo_team_id_fkey; Type: FK CONSTRAINT; Schema: cateams2; Owner: postgres
--

ALTER TABLE ONLY tbl_teaminfo
    ADD CONSTRAINT teaminfo_team_id_fkey FOREIGN KEY (ix_cateams_id) REFERENCES ix_cateams(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = demo_packaging, pg_catalog;

--
-- Name: demo_buildnumber FK; Type: FK CONSTRAINT; Schema: demo_packaging; Owner: postgres
--

ALTER TABLE ONLY demo_buildnumber
    ADD CONSTRAINT "FK" FOREIGN KEY (uem_version) REFERENCES demo_versions(uem_version);


SET search_path = empdata, pg_catalog;

--
-- Name: tbl_employees_info tbl_employees_info_ix_departments_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_departments_id_fkey FOREIGN KEY (ix_departments_id) REFERENCES ix_departments(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_description_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_description_id_fkey FOREIGN KEY (ix_description_id) REFERENCES ix_description(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_displayname_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_displayname_id_fkey FOREIGN KEY (ix_displayname_id) REFERENCES ix_displayname(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_email_userprincipalname_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_email_userprincipalname_id_fkey FOREIGN KEY (ix_email_userprincipalname_id) REFERENCES ix_email(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_employeetypes_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_employeetypes_id_fkey FOREIGN KEY (ix_employeetypes_id) REFERENCES ix_employeetypes(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_officenames_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_officenames_id_fkey FOREIGN KEY (ix_officenames_id) REFERENCES ix_officenames(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_phone_ipphone_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_phone_ipphone_id_fkey FOREIGN KEY (ix_phone_ipphone_id) REFERENCES ix_phone(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_phone_othertelephone_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_phone_othertelephone_id_fkey FOREIGN KEY (ix_phone_othertelephone_id) REFERENCES ix_phone(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_phone_telephonenumber_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_phone_telephonenumber_id_fkey FOREIGN KEY (ix_phone_telephonenumber_id) REFERENCES ix_phone(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_primarygroupids_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_primarygroupids_id_fkey FOREIGN KEY (ix_primarygroupids_id) REFERENCES ix_primarygroupids(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_samaccounttypes_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_samaccounttypes_id_fkey FOREIGN KEY (ix_samaccounttypes_id) REFERENCES ix_samaccounttypes(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_scans_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_scans_id_fkey FOREIGN KEY (ix_scans_id) REFERENCES ix_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_states_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_states_id_fkey FOREIGN KEY (ix_states_id) REFERENCES ix_states(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_title_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_title_id_fkey FOREIGN KEY (ix_title_id) REFERENCES ix_title(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_useraccountcontrols_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_useraccountcontrols_id_fkey FOREIGN KEY (ix_useraccountcontrols_id) REFERENCES ix_useraccountcontrols(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_info tbl_employees_info_ix_zipcodes_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_info
    ADD CONSTRAINT tbl_employees_info_ix_zipcodes_id_fkey FOREIGN KEY (ix_zipcodes_id) REFERENCES ix_zipcodes(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees tbl_employees_ix_badgeid_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees
    ADD CONSTRAINT tbl_employees_ix_badgeid_id_fkey FOREIGN KEY (ix_badgeid_id) REFERENCES ix_badgeid(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees tbl_employees_ix_distinguishedname_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees
    ADD CONSTRAINT tbl_employees_ix_distinguishedname_id_fkey FOREIGN KEY (ix_distinguishedname_id) REFERENCES ix_distinguishedname(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees tbl_employees_ix_email_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees
    ADD CONSTRAINT tbl_employees_ix_email_id_fkey FOREIGN KEY (ix_email_id) REFERENCES ix_email(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees tbl_employees_ix_givenname_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees
    ADD CONSTRAINT tbl_employees_ix_givenname_id_fkey FOREIGN KEY (ix_givenname_id) REFERENCES ix_givenname(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees tbl_employees_ix_name_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees
    ADD CONSTRAINT tbl_employees_ix_name_id_fkey FOREIGN KEY (ix_fullname_id) REFERENCES ix_fullname(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees tbl_employees_ix_ntlogin_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees
    ADD CONSTRAINT tbl_employees_ix_ntlogin_id_fkey FOREIGN KEY (ix_ntlogin_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees tbl_employees_ix_surname_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees
    ADD CONSTRAINT tbl_employees_ix_surname_id_fkey FOREIGN KEY (ix_surname_id) REFERENCES ix_surname(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_employees_logins tbl_employees_logins_scans_id_fkey; Type: FK CONSTRAINT; Schema: empdata; Owner: postgres
--

ALTER TABLE ONLY tbl_employees_logins
    ADD CONSTRAINT tbl_employees_logins_scans_id_fkey FOREIGN KEY (ix_scans_id) REFERENCES ix_scans(id);


SET search_path = jenkins, pg_catalog;

--
-- Name: cibuilds cibuilds_job_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY cibuilds
    ADD CONSTRAINT cibuilds_job_id_fkey FOREIGN KEY (job_id) REFERENCES cijobs(job_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: cibuilds cibuilds_slave_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY cibuilds
    ADD CONSTRAINT cibuilds_slave_id_fkey FOREIGN KEY (slave_id) REFERENCES cislaves(slave_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ciplugin_history ciplugin_history_ciplugins_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciplugin_history
    ADD CONSTRAINT ciplugin_history_ciplugins_id_fkey FOREIGN KEY (ciplugins_id) REFERENCES ciplugins(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ciplugin_history ciplugin_history_ciplugugin_scan_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciplugin_history
    ADD CONSTRAINT ciplugin_history_ciplugugin_scan_id_fkey FOREIGN KEY (ciplugin_scan_id) REFERENCES ciplugin_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ciplugin_history ciplugin_history_ciservers_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciplugin_history
    ADD CONSTRAINT ciplugin_history_ciservers_id_fkey FOREIGN KEY (ciservers_id) REFERENCES ciservers(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ciserver_info ciserver_info_ciplugin_scans_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciserver_info
    ADD CONSTRAINT ciserver_info_ciplugin_scans_id_fkey FOREIGN KEY (ciplugin_scans_id) REFERENCES ciplugin_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ciserver_info ciserver_info_ciservers_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciserver_info
    ADD CONSTRAINT ciserver_info_ciservers_id_fkey FOREIGN KEY (ciservers_id) REFERENCES ciservers(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ciserver_info ciserver_info_server_versions_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciserver_info
    ADD CONSTRAINT ciserver_info_server_versions_id_fkey FOREIGN KEY (server_versions_id) REFERENCES server_versions(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: ciserver_status ciserver_status_server_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY ciserver_status
    ADD CONSTRAINT ciserver_status_server_id_fkey FOREIGN KEY (server_id) REFERENCES ciservers(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: current_ciadmins current_ciadmins_ciadmins_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY current_ciadmins
    ADD CONSTRAINT current_ciadmins_ciadmins_id_fkey FOREIGN KEY (ciadmins_id) REFERENCES ciadmins(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: current_ciadmins current_ciadmins_ciservers_id_fkey; Type: FK CONSTRAINT; Schema: jenkins; Owner: postgres
--

ALTER TABLE ONLY current_ciadmins
    ADD CONSTRAINT current_ciadmins_ciservers_id_fkey FOREIGN KEY (ciservers_id) REFERENCES ciservers(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = jenkinslogger, pg_catalog;

--
-- Name: etlresults etlresults_cmplt_id_fkey; Type: FK CONSTRAINT; Schema: jenkinslogger; Owner: postgres
--

ALTER TABLE ONLY etlresults
    ADD CONSTRAINT etlresults_cmplt_id_fkey FOREIGN KEY (cmplt_id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: etlresults etlresults_final_id_fkey; Type: FK CONSTRAINT; Schema: jenkinslogger; Owner: postgres
--

ALTER TABLE ONLY etlresults
    ADD CONSTRAINT etlresults_final_id_fkey FOREIGN KEY (final_id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: etlresults etlresults_start_id_fkey; Type: FK CONSTRAINT; Schema: jenkinslogger; Owner: postgres
--

ALTER TABLE ONLY etlresults
    ADD CONSTRAINT etlresults_start_id_fkey FOREIGN KEY (start_id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: parameters parameters_id_fkey; Type: FK CONSTRAINT; Schema: jenkinslogger; Owner: postgres
--

ALTER TABLE ONLY parameters
    ADD CONSTRAINT parameters_id_fkey FOREIGN KEY (id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = netstat, pg_catalog;

--
-- Name: tbl_datamover tbl_datamover_ix_address_local_id_fkey; Type: FK CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY tbl_datamover
    ADD CONSTRAINT tbl_datamover_ix_address_local_id_fkey FOREIGN KEY (ix_address_local_id) REFERENCES ix_address(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_datamover tbl_datamover_ix_address_remote_id_fkey; Type: FK CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY tbl_datamover
    ADD CONSTRAINT tbl_datamover_ix_address_remote_id_fkey FOREIGN KEY (ix_address_remote_id) REFERENCES ix_address(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_datamover tbl_datamover_ix_port_local_id_fkey; Type: FK CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY tbl_datamover
    ADD CONSTRAINT tbl_datamover_ix_port_local_id_fkey FOREIGN KEY (ix_port_local_id) REFERENCES ix_port(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_datamover tbl_datamover_ix_port_remote_id_fkey; Type: FK CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY tbl_datamover
    ADD CONSTRAINT tbl_datamover_ix_port_remote_id_fkey FOREIGN KEY (ix_port_remote_id) REFERENCES ix_port(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_datamover tbl_datamover_ix_proto_id_fkey; Type: FK CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY tbl_datamover
    ADD CONSTRAINT tbl_datamover_ix_proto_id_fkey FOREIGN KEY (ix_proto_id) REFERENCES ix_proto(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_datamover tbl_datamover_ix_state_id_fkey; Type: FK CONSTRAINT; Schema: netstat; Owner: postgres
--

ALTER TABLE ONLY tbl_datamover
    ADD CONSTRAINT tbl_datamover_ix_state_id_fkey FOREIGN KEY (ix_state_id) REFERENCES ix_state(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = rally, pg_catalog;

--
-- Name: tbl_rally_users rally_users_costcenters_id_fkey; Type: FK CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY tbl_rally_users
    ADD CONSTRAINT rally_users_costcenters_id_fkey FOREIGN KEY (ix_costcenters_id) REFERENCES ix_costcenters(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_rally_users rally_users_domains_id_fkey; Type: FK CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY tbl_rally_users
    ADD CONSTRAINT rally_users_domains_id_fkey FOREIGN KEY (ix_domains_id) REFERENCES ix_domains(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_rally_users rally_users_permissions_id_fkey; Type: FK CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY tbl_rally_users
    ADD CONSTRAINT rally_users_permissions_id_fkey FOREIGN KEY (ix_permissions_id) REFERENCES ix_permissions(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_rally_users rally_users_projects_id_fkey; Type: FK CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY tbl_rally_users
    ADD CONSTRAINT rally_users_projects_id_fkey FOREIGN KEY (ix_projects_id) REFERENCES ix_projects(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_rally_users rally_users_roles_id_fkey; Type: FK CONSTRAINT; Schema: rally; Owner: postgres
--

ALTER TABLE ONLY tbl_rally_users
    ADD CONSTRAINT rally_users_roles_id_fkey FOREIGN KEY (ix_roles_id) REFERENCES ix_roles(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = remedy, pg_catalog;

--
-- Name: history_issue_weekly history_issue_weekly_ix_major_area_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_ix_major_area_id_fkey FOREIGN KEY (ix_major_area_id) REFERENCES ix_major_area(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_issue_weekly history_issue_weekly_ix_ntlogin_assigned_to_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_ix_ntlogin_assigned_to_id_fkey FOREIGN KEY (ix_ntlogin_assigned_to_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_issue_weekly history_issue_weekly_ix_priority_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_ix_priority_id_fkey FOREIGN KEY (ix_priority_id) REFERENCES ix_priority(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_issue_weekly history_issue_weekly_ix_product_area_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_ix_product_area_id_fkey FOREIGN KEY (ix_product_area_id) REFERENCES ix_product_area(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_issue_weekly history_issue_weekly_ix_product_family_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_ix_product_family_id_fkey FOREIGN KEY (ix_product_family_id) REFERENCES ix_product_family(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_issue_weekly history_issue_weekly_ix_product_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_ix_product_id_fkey FOREIGN KEY (ix_product_id) REFERENCES ix_product(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_issue_weekly history_issue_weekly_ix_product_release_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_ix_product_release_id_fkey FOREIGN KEY (ix_product_release_id) REFERENCES ix_product_release(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_issue_weekly history_issue_weekly_ix_status_details_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_ix_status_details_id_fkey FOREIGN KEY (ix_status_details_id) REFERENCES ix_status_details(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_issue_weekly history_issue_weekly_ix_status_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_ix_status_id_fkey FOREIGN KEY (ix_status_id) REFERENCES ix_status(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_issue_weekly history_issue_weekly_ix_type_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_ix_type_id_fkey FOREIGN KEY (ix_type_id) REFERENCES ix_type(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_issue_weekly history_issue_weekly_weekly_ix_history_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY history_issue_weekly
    ADD CONSTRAINT history_issue_weekly_weekly_ix_history_id_fkey FOREIGN KEY (ix_history_id) REFERENCES ix_history(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_how_found tbl_how_found_ix_how_found_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_how_found
    ADD CONSTRAINT tbl_how_found_ix_how_found_id_fkey FOREIGN KEY (ix_how_found_id) REFERENCES ix_how_found(id);


--
-- Name: tbl_how_found tbl_how_found_ix_how_found_main_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_how_found
    ADD CONSTRAINT tbl_how_found_ix_how_found_main_id_fkey FOREIGN KEY (ix_how_found_main_id) REFERENCES ix_how_found_main(id);


--
-- Name: tbl_issue_escalation_join tbl_issue_escalation_join_candidate_status_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_escalation_join
    ADD CONSTRAINT tbl_issue_escalation_join_candidate_status_id_fkey FOREIGN KEY (ix_candidate_status_id) REFERENCES ix_candidate_status(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_escalation_join tbl_issue_escalation_join_escalate_by_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_escalation_join
    ADD CONSTRAINT tbl_issue_escalation_join_escalate_by_id_fkey FOREIGN KEY (ix_escalate_by_id) REFERENCES ix_employee_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_escalation_join tbl_issue_escalation_join_escalate_reason_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_escalation_join
    ADD CONSTRAINT tbl_issue_escalation_join_escalate_reason_id_fkey FOREIGN KEY (ix_escalate_reason_id) REFERENCES ix_escalate_reason(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_escalation_join tbl_issue_escalation_join_sp_last_modified_by_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_escalation_join
    ADD CONSTRAINT tbl_issue_escalation_join_sp_last_modified_by_id_fkey FOREIGN KEY (ix_sp_last_modified_by_id) REFERENCES ix_employee_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_escalation_join tbl_issue_escalation_join_sp_target_release_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_escalation_join
    ADD CONSTRAINT tbl_issue_escalation_join_sp_target_release_id_fkey FOREIGN KEY (ix_sp_target_release_id) REFERENCES ix_sp_target_release(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_reported_by_manager_join tbl_issue_reported_by_manager_join_direct_manager_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_reported_by_manager_join
    ADD CONSTRAINT tbl_issue_reported_by_manager_join_direct_manager_id_fkey FOREIGN KEY (ix_direct_manager_id) REFERENCES ix_employee_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_reported_by_manager_join tbl_issue_reported_by_manager_join_senior_manager_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_reported_by_manager_join
    ADD CONSTRAINT tbl_issue_reported_by_manager_join_senior_manager_id_fkey FOREIGN KEY (ix_senior_manager_id) REFERENCES ix_employee_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_assigned_to_function_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_assigned_to_function_id_fkey FOREIGN KEY (ix_assigned_to_function_id) REFERENCES ix_function(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_assigned_to_group_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_assigned_to_group_id_fkey FOREIGN KEY (ix_assigned_to_group_id) REFERENCES ix_group(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_classification_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_classification_id_fkey FOREIGN KEY (ix_classification_id) REFERENCES ix_classification(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_customer_impact_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_customer_impact_id_fkey FOREIGN KEY (ix_customer_impact_id) REFERENCES ix_customer_impact(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_escalate_reason_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_escalate_reason_id_fkey FOREIGN KEY (ix_escalate_reason_id) REFERENCES ix_escalate_reason(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_how_found_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_how_found_id_fkey FOREIGN KEY (ix_how_found_id) REFERENCES ix_how_found(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_ix_ntlogin_assigned_to_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_ix_ntlogin_assigned_to_id_fkey FOREIGN KEY (ix_ntlogin_assigned_to_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_ix_ntlogin_last_modified_by_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_ix_ntlogin_last_modified_by_id_fkey FOREIGN KEY (ix_ntlogin_last_modified_by_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_ix_priority_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_ix_priority_id_fkey FOREIGN KEY (ix_priority_id) REFERENCES ix_priority(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_ix_product_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_ix_product_id_fkey FOREIGN KEY (ix_product_id) REFERENCES ix_product(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_major_area_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_major_area_id_fkey FOREIGN KEY (ix_major_area_id) REFERENCES ix_major_area(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_primus_needed_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_primus_needed_id_fkey FOREIGN KEY (ix_primus_needed_id) REFERENCES ix_primus_needed(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_product_area_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_product_area_id_fkey FOREIGN KEY (ix_product_area_id) REFERENCES ix_product_area(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_product_family_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_product_family_id_fkey FOREIGN KEY (ix_product_family_id) REFERENCES ix_product_family(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_product_release_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_product_release_id_fkey FOREIGN KEY (ix_product_release_id) REFERENCES ix_product_release(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_release_note_needed_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_release_note_needed_id_fkey FOREIGN KEY (ix_release_note_needed_id) REFERENCES ix_release_note_needed(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_releases_built_in_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_releases_built_in_id_fkey FOREIGN KEY (ix_releases_built_in_id) REFERENCES ix_releases_built_in(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_reported_by_function_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_reported_by_function_id_fkey FOREIGN KEY (ix_reported_by_function_id) REFERENCES ix_function(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_reported_by_group_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_reported_by_group_id_fkey FOREIGN KEY (ix_reported_by_group_id) REFERENCES ix_group(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_reported_by_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_reported_by_id_fkey FOREIGN KEY (ix_reported_by_id) REFERENCES ix_employee_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_script_name_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_script_name_id_fkey FOREIGN KEY (ix_script_name_id) REFERENCES ix_script_name(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_status_details_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_status_details_id_fkey FOREIGN KEY (ix_status_details_id) REFERENCES ix_status_details(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_status_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_status_id_fkey FOREIGN KEY (ix_status_id) REFERENCES ix_status(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issue_tracking tbl_issue_tracking_type_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issue_tracking
    ADD CONSTRAINT tbl_issue_tracking_type_id_fkey FOREIGN KEY (ix_type_id) REFERENCES ix_type(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_issuetracking_products tbl_issuetracking_products_ix_product_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_issuetracking_products
    ADD CONSTRAINT tbl_issuetracking_products_ix_product_id_fkey FOREIGN KEY (ix_product_id) REFERENCES ix_product(id);


--
-- Name: tbl_release_engineering_tracker tbl_release_engineering_track_ix_ntlogin_last_modified_by__fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_release_engineering_tracker
    ADD CONSTRAINT tbl_release_engineering_track_ix_ntlogin_last_modified_by__fkey FOREIGN KEY (ix_ntlogin_last_modified_by_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_release_engineering_tracker tbl_release_engineering_tracker_assigned_to_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_release_engineering_tracker
    ADD CONSTRAINT tbl_release_engineering_tracker_assigned_to_id_fkey FOREIGN KEY (ix_assigned_to_id) REFERENCES ix_employee_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_release_engineering_tracker tbl_release_engineering_tracker_functional_area_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_release_engineering_tracker
    ADD CONSTRAINT tbl_release_engineering_tracker_functional_area_id_fkey FOREIGN KEY (ix_functional_area_id) REFERENCES ix_functional_area(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_release_engineering_tracker tbl_release_engineering_tracker_ix_ntlogin_submitter_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_release_engineering_tracker
    ADD CONSTRAINT tbl_release_engineering_tracker_ix_ntlogin_submitter_id_fkey FOREIGN KEY (ix_ntlogin_submitter_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_release_engineering_tracker tbl_release_engineering_tracker_reported_by_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_release_engineering_tracker
    ADD CONSTRAINT tbl_release_engineering_tracker_reported_by_id_fkey FOREIGN KEY (ix_reported_by_id) REFERENCES ix_employee_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_release_engineering_tracker tbl_release_engineering_tracker_request_type_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_release_engineering_tracker
    ADD CONSTRAINT tbl_release_engineering_tracker_request_type_id_fkey FOREIGN KEY (ix_request_type_id) REFERENCES ix_request_type(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_release_engineering_tracker tbl_release_engineering_tracker_status_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_release_engineering_tracker
    ADD CONSTRAINT tbl_release_engineering_tracker_status_id_fkey FOREIGN KEY (ix_status_id) REFERENCES ix_status(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_releases tbl_releases_ix_ntlogin_last_modified_by_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_releases
    ADD CONSTRAINT tbl_releases_ix_ntlogin_last_modified_by_id_fkey FOREIGN KEY (ix_ntlogin_last_modified_by_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_releases tbl_releases_product_family_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_releases
    ADD CONSTRAINT tbl_releases_product_family_id_fkey FOREIGN KEY (ix_product_family_id) REFERENCES ix_product_family(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_releases tbl_releases_product_release_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_releases
    ADD CONSTRAINT tbl_releases_product_release_id_fkey FOREIGN KEY (ix_product_release_id) REFERENCES ix_product_release(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_association tbl_share_association_ix_ntlogin_last_modified_by_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_association
    ADD CONSTRAINT tbl_share_association_ix_ntlogin_last_modified_by_id_fkey FOREIGN KEY (ix_ntlogin_last_modified_by_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_association tbl_share_association_relationship_type_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_association
    ADD CONSTRAINT tbl_share_association_relationship_type_id_fkey FOREIGN KEY (ix_relationship_type_id) REFERENCES ix_relationship_type(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_association tbl_share_association_status_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_association
    ADD CONSTRAINT tbl_share_association_status_id_fkey FOREIGN KEY (ix_status_id) REFERENCES ix_status(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_audit tbl_share_audit_attribute_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_audit
    ADD CONSTRAINT tbl_share_audit_attribute_id_fkey FOREIGN KEY (ix_audit_attribute_id) REFERENCES ix_audit_attribute(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_audit tbl_share_audit_attribute_label_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_audit
    ADD CONSTRAINT tbl_share_audit_attribute_label_id_fkey FOREIGN KEY (ix_audit_attribute_label_id) REFERENCES ix_audit_attribute(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_audit tbl_share_audit_from_value_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_audit
    ADD CONSTRAINT tbl_share_audit_from_value_id_fkey FOREIGN KEY (ix_from_value_id) REFERENCES ix_status_details(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_audit tbl_share_audit_ix_ntlogin_submitter_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_audit
    ADD CONSTRAINT tbl_share_audit_ix_ntlogin_submitter_id_fkey FOREIGN KEY (ix_ntlogin_submitter_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_audit tbl_share_audit_to_value_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_audit
    ADD CONSTRAINT tbl_share_audit_to_value_id_fkey FOREIGN KEY (ix_to_value_id) REFERENCES ix_status_details(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_employee tbl_share_employee_full_name_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_employee
    ADD CONSTRAINT tbl_share_employee_full_name_id_fkey FOREIGN KEY (ix_full_name_id) REFERENCES ix_employee_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_employee tbl_share_employee_group_name_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_employee
    ADD CONSTRAINT tbl_share_employee_group_name_id_fkey FOREIGN KEY (ix_group_name_id) REFERENCES ix_group(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_employee tbl_share_employee_ix_badgeid_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_employee
    ADD CONSTRAINT tbl_share_employee_ix_badgeid_id_fkey FOREIGN KEY (ix_badgeid_id) REFERENCES ix_badgeid(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_employee tbl_share_employee_ix_email_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_employee
    ADD CONSTRAINT tbl_share_employee_ix_email_id_fkey FOREIGN KEY (ix_email_id) REFERENCES ix_email(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_employee tbl_share_employee_ix_function_name_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_employee
    ADD CONSTRAINT tbl_share_employee_ix_function_name_id_fkey FOREIGN KEY (ix_function_name_id) REFERENCES ix_function(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_employee tbl_share_employee_ix_givenname_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_employee
    ADD CONSTRAINT tbl_share_employee_ix_givenname_id_fkey FOREIGN KEY (ix_givenname_id) REFERENCES ix_givenname(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_employee tbl_share_employee_ix_ntlogin_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_employee
    ADD CONSTRAINT tbl_share_employee_ix_ntlogin_id_fkey FOREIGN KEY (ix_ntlogin_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_employee tbl_share_employee_ix_surname_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_employee
    ADD CONSTRAINT tbl_share_employee_ix_surname_id_fkey FOREIGN KEY (ix_surname_id) REFERENCES ix_surname(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_employee tbl_share_employee_status_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_employee
    ADD CONSTRAINT tbl_share_employee_status_id_fkey FOREIGN KEY (ix_status_id) REFERENCES ix_status(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_notes tbl_share_notes_full_name_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_notes
    ADD CONSTRAINT tbl_share_notes_full_name_id_fkey FOREIGN KEY (ix_full_name_id) REFERENCES ix_employee_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_notes tbl_share_notes_ix_ntlogin_last_modified_by_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_notes
    ADD CONSTRAINT tbl_share_notes_ix_ntlogin_last_modified_by_id_fkey FOREIGN KEY (ix_ntlogin_last_modified_by_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_release_association tbl_share_release_association_release_name_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_release_association
    ADD CONSTRAINT tbl_share_release_association_release_name_id_fkey FOREIGN KEY (ix_release_name_id) REFERENCES ix_release_name(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_user_notification tbl_share_user_notification_ix_ntlogin_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_user_notification
    ADD CONSTRAINT tbl_share_user_notification_ix_ntlogin_id_fkey FOREIGN KEY (ix_ntlogin_id) REFERENCES ix_ntlogin(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: tbl_share_user_notification tbl_share_user_notification_name_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY tbl_share_user_notification
    ADD CONSTRAINT tbl_share_user_notification_name_id_fkey FOREIGN KEY (ix_name_id) REFERENCES ix_employee_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_closed_status_detail usr_closed_status_detail_ix_status_details_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_closed_status_detail
    ADD CONSTRAINT usr_closed_status_detail_ix_status_details_id_fkey FOREIGN KEY (ix_status_details_id) REFERENCES ix_status_details(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_issue_tracking_attributes usr_issue_tracking_attributes_ix_audit_attribute_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_issue_tracking_attributes
    ADD CONSTRAINT usr_issue_tracking_attributes_ix_audit_attribute_id_fkey FOREIGN KEY (ix_audit_attribute_id) REFERENCES ix_audit_attribute(id);


--
-- Name: usr_managerspo_priority_offsets usr_managerspo_priority_offse_tbl_share_employee_managersp_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_managerspo_priority_offsets
    ADD CONSTRAINT usr_managerspo_priority_offse_tbl_share_employee_managersp_fkey FOREIGN KEY (tbl_share_employee_managerspo_id) REFERENCES tbl_share_employee(requestid) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_report_definitions usr_report_definitions_ix_product_area_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_report_definitions
    ADD CONSTRAINT usr_report_definitions_ix_product_area_id_fkey FOREIGN KEY (ix_product_area_id) REFERENCES ix_product_area(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_report_definitions usr_report_definitions_ix_product_family_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_report_definitions
    ADD CONSTRAINT usr_report_definitions_ix_product_family_id_fkey FOREIGN KEY (ix_product_family_id) REFERENCES ix_product_family(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_report_definitions usr_report_definitions_ix_product_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_report_definitions
    ADD CONSTRAINT usr_report_definitions_ix_product_id_fkey FOREIGN KEY (ix_product_id) REFERENCES ix_product(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_report_definitions usr_report_definitions_tbl_share_employee_manager_above_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_report_definitions
    ADD CONSTRAINT usr_report_definitions_tbl_share_employee_manager_above_id_fkey FOREIGN KEY (tbl_share_employee_managerabove_id) REFERENCES tbl_share_employee(requestid) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: usr_report_definitions usr_report_definitions_tbl_share_employee_manager_spo_id_fkey; Type: FK CONSTRAINT; Schema: remedy; Owner: postgres
--

ALTER TABLE ONLY usr_report_definitions
    ADD CONSTRAINT usr_report_definitions_tbl_share_employee_manager_spo_id_fkey FOREIGN KEY (tbl_share_employee_managerspo_id) REFERENCES tbl_share_employee(requestid) ON UPDATE SET NULL ON DELETE CASCADE;


SET search_path = shares, pg_catalog;

--
-- Name: current_buildshare current_buildshare_dir_id_fkey; Type: FK CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY current_buildshare
    ADD CONSTRAINT current_buildshare_dir_id_fkey FOREIGN KEY (dir_id) REFERENCES buildsharedirs(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: current_buildshare current_buildshare_target_dirid_fkey; Type: FK CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY current_buildshare
    ADD CONSTRAINT current_buildshare_target_dirid_fkey FOREIGN KEY (target_dirid) REFERENCES buildsharedirs(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: history_buildshare history_buildshare_dir_id_fkey; Type: FK CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY history_buildshare
    ADD CONSTRAINT history_buildshare_dir_id_fkey FOREIGN KEY (dir_id) REFERENCES buildsharedirs(id);


--
-- Name: history_rpmjobs history_rpmjobs_job_id_fkey; Type: FK CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY history_rpmjobs
    ADD CONSTRAINT history_rpmjobs_job_id_fkey FOREIGN KEY (job_id) REFERENCES rpmjobs(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: rpmbuilds rpmbuilds_job_id_fkey; Type: FK CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY rpmbuilds
    ADD CONSTRAINT rpmbuilds_job_id_fkey FOREIGN KEY (job_id) REFERENCES rpmjobs(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: rpmjobs rpmjobs_dir_id_fkey; Type: FK CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY rpmjobs
    ADD CONSTRAINT rpmjobs_dir_id_fkey FOREIGN KEY (dir_id) REFERENCES buildsharedirs(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: rpmjobs rpmjobs_stream_id_fkey; Type: FK CONSTRAINT; Schema: shares; Owner: postgres
--

ALTER TABLE ONLY rpmjobs
    ADD CONSTRAINT rpmjobs_stream_id_fkey FOREIGN KEY (stream_id) REFERENCES cistreams(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = vcenter, pg_catalog;

--
-- Name: esxservers esxservers_locations_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY esxservers
    ADD CONSTRAINT esxservers_locations_id_fkey FOREIGN KEY (locations_id) REFERENCES locations(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: folders folders_esxservers_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY folders
    ADD CONSTRAINT folders_esxservers_id_fkey FOREIGN KEY (esxservers_id) REFERENCES esxservers(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: folders folders_parent_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY folders
    ADD CONSTRAINT folders_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES folders(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: historical_overview historical_overview_esxservers_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY historical_overview
    ADD CONSTRAINT historical_overview_esxservers_id_fkey FOREIGN KEY (esxservers_id) REFERENCES esxservers(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: historical_overview historical_overview_server_scans_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY historical_overview
    ADD CONSTRAINT historical_overview_server_scans_id_fkey FOREIGN KEY (server_scans_id) REFERENCES server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: historical_overview historical_overview_vmcategory_types_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY historical_overview
    ADD CONSTRAINT historical_overview_vmcategory_types_id_fkey FOREIGN KEY (vmcategory_types_id) REFERENCES vmcategory_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_phys2 normalized_re_phys2_adminuser_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_phys2
    ADD CONSTRAINT normalized_re_phys2_adminuser_id_fkey FOREIGN KEY (adminuser_id) REFERENCES adminuser(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_phys2 normalized_re_phys2_guestos_type_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_phys2
    ADD CONSTRAINT normalized_re_phys2_guestos_type_id_fkey FOREIGN KEY (guestos_type_id) REFERENCES guestos_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_phys2 normalized_re_phys2_hardware_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_phys2
    ADD CONSTRAINT normalized_re_phys2_hardware_id_fkey FOREIGN KEY (hardware_id) REFERENCES hardware(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_phys2 normalized_re_phys2_nagios_class_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_phys2
    ADD CONSTRAINT normalized_re_phys2_nagios_class_id_fkey FOREIGN KEY (nagios_class_id) REFERENCES nagios_class(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_phys2 normalized_re_phys2_purpose_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_phys2
    ADD CONSTRAINT normalized_re_phys2_purpose_id_fkey FOREIGN KEY (purpose_id) REFERENCES purpose(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_phys2 normalized_re_phys2_rack_location_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_phys2
    ADD CONSTRAINT normalized_re_phys2_rack_location_id_fkey FOREIGN KEY (rack_location_id) REFERENCES rack_location(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_physical_assets normalized_re_physical_assets_adminuser_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_physical_assets
    ADD CONSTRAINT normalized_re_physical_assets_adminuser_id_fkey FOREIGN KEY (adminuser_id) REFERENCES adminuser(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_physical_assets normalized_re_physical_assets_guestos_type_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_physical_assets
    ADD CONSTRAINT normalized_re_physical_assets_guestos_type_id_fkey FOREIGN KEY (guestos_type_id) REFERENCES guestos_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_physical_assets normalized_re_physical_assets_hardware_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_physical_assets
    ADD CONSTRAINT normalized_re_physical_assets_hardware_id_fkey FOREIGN KEY (hardware_id) REFERENCES hardware(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_physical_assets normalized_re_physical_assets_nagios_class_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_physical_assets
    ADD CONSTRAINT normalized_re_physical_assets_nagios_class_id_fkey FOREIGN KEY (nagios_class_id) REFERENCES nagios_class(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_physical_assets normalized_re_physical_assets_purpose_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_physical_assets
    ADD CONSTRAINT normalized_re_physical_assets_purpose_id_fkey FOREIGN KEY (purpose_id) REFERENCES purpose(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: normalized_re_physical_assets normalized_re_physical_assets_rack_location_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY normalized_re_physical_assets
    ADD CONSTRAINT normalized_re_physical_assets_rack_location_id_fkey FOREIGN KEY (rack_location_id) REFERENCES rack_location(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_subnets usr_subnets_ix_cloud_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY usr_subnets
    ADD CONSTRAINT usr_subnets_ix_cloud_id_fkey FOREIGN KEY (ix_cloud_id) REFERENCES ix_cloud(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_subnets usr_subnets_ix_cloud_info_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY usr_subnets
    ADD CONSTRAINT usr_subnets_ix_cloud_info_id_fkey FOREIGN KEY (ix_cloud_info_id) REFERENCES ix_cloud_info(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_subnets usr_subnets_ix_fld1_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY usr_subnets
    ADD CONSTRAINT usr_subnets_ix_fld1_id_fkey FOREIGN KEY (ix_fld1_id) REFERENCES ix_fld1(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_subnets usr_subnets_ix_fld2_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY usr_subnets
    ADD CONSTRAINT usr_subnets_ix_fld2_id_fkey FOREIGN KEY (ix_fld2_id) REFERENCES ix_fld2(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_subnets usr_subnets_ix_iptype_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY usr_subnets
    ADD CONSTRAINT usr_subnets_ix_iptype_id_fkey FOREIGN KEY (ix_iptype_id) REFERENCES ix_iptype(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_subnets usr_subnets_ix_locations_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY usr_subnets
    ADD CONSTRAINT usr_subnets_ix_locations_id_fkey FOREIGN KEY (ix_locations_id) REFERENCES locations(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_subnets usr_subnets_ix_site_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY usr_subnets
    ADD CONSTRAINT usr_subnets_ix_site_id_fkey FOREIGN KEY (ix_site_id) REFERENCES ix_site(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: usr_subnets usr_subnets_ix_widget_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY usr_subnets
    ADD CONSTRAINT usr_subnets_ix_widget_id_fkey FOREIGN KEY (ix_widget_id) REFERENCES ix_widget(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmcategory vmcategory_vm_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vmcategory
    ADD CONSTRAINT vmcategory_vm_id_fkey FOREIGN KEY (vms_id) REFERENCES vms(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmcategory vmcategory_vmcategory_type_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vmcategory
    ADD CONSTRAINT vmcategory_vmcategory_type_id_fkey FOREIGN KEY (vmcategory_types_id) REFERENCES vmcategory_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmexists vmexists_last_change_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vmexists
    ADD CONSTRAINT vmexists_last_change_fkey FOREIGN KEY (last_change) REFERENCES server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmexists vmexists_vminfo_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vmexists
    ADD CONSTRAINT vmexists_vminfo_id_fkey FOREIGN KEY (vminfo_id) REFERENCES vminfo(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo_history vminfo_data_server_scans_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vminfo_history
    ADD CONSTRAINT vminfo_data_server_scans_id_fkey FOREIGN KEY (server_scans_id) REFERENCES server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo_history vminfo_data_vminfo_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vminfo_history
    ADD CONSTRAINT vminfo_data_vminfo_id_fkey FOREIGN KEY (vminfo_id) REFERENCES vminfo(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo vminfo_folders_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_folders_id_fkey FOREIGN KEY (folders_id) REFERENCES folders(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo vminfo_guestid_types_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_guestid_types_id_fkey FOREIGN KEY (guestid_types_id) REFERENCES guestid_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo vminfo_guestos_types_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_guestos_types_id_fkey FOREIGN KEY (guestos_types_id) REFERENCES guestos_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo vminfo_server_scans_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_server_scans_id_fkey FOREIGN KEY (server_scans_id) REFERENCES server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo vminfo_vms_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_vms_id_fkey FOREIGN KEY (vms_id) REFERENCES vms(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vms vms_esxservers_id_fkey; Type: FK CONSTRAINT; Schema: vcenter; Owner: postgres
--

ALTER TABLE ONLY vms
    ADD CONSTRAINT vms_esxservers_id_fkey FOREIGN KEY (esxservers_id) REFERENCES esxservers(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = vdiscover, pg_catalog;

--
-- Name: historical_overview historical_overview_server_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY historical_overview
    ADD CONSTRAINT historical_overview_server_id_fkey FOREIGN KEY (server_id) REFERENCES "esx-servers"(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: historical_overview historical_overview_server_scan_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY historical_overview
    ADD CONSTRAINT historical_overview_server_scan_id_fkey FOREIGN KEY (server_scan_id) REFERENCES server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: historical_overview historical_overview_vmcategory_type_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY historical_overview
    ADD CONSTRAINT historical_overview_vmcategory_type_id_fkey FOREIGN KEY (vmcategory_type_id) REFERENCES vmcategory_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: 2015-12-14.Poweroff poweroff-251214_vm_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY "2015-12-14.Poweroff"
    ADD CONSTRAINT "poweroff-251214_vm_id_fkey" FOREIGN KEY (vm_id) REFERENCES vms(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmcategory vmcategory_vm_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmcategory
    ADD CONSTRAINT vmcategory_vm_id_fkey FOREIGN KEY (vm_id) REFERENCES vms(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmcategory vmcategory_vmcategory_type_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmcategory
    ADD CONSTRAINT vmcategory_vmcategory_type_id_fkey FOREIGN KEY (vmcategory_type_id) REFERENCES vmcategory_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmerror vmerror_error_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmerror
    ADD CONSTRAINT vmerror_error_id_fkey FOREIGN KEY (error_id) REFERENCES err_errors(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmerror vmerror_file_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmerror
    ADD CONSTRAINT vmerror_file_id_fkey FOREIGN KEY (file_id) REFERENCES err_files(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmerror vmerror_name_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmerror
    ADD CONSTRAINT vmerror_name_id_fkey FOREIGN KEY (name_id) REFERENCES err_names(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmerror vmerror_server_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmerror
    ADD CONSTRAINT vmerror_server_id_fkey FOREIGN KEY (server_id) REFERENCES "esx-servers"(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmerror vmerror_server_scans_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmerror
    ADD CONSTRAINT vmerror_server_scans_id_fkey FOREIGN KEY (server_scans_id) REFERENCES server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo_data vminfo_data_overallstatus_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vminfo_data
    ADD CONSTRAINT vminfo_data_overallstatus_id_fkey FOREIGN KEY (overallstatus_id) REFERENCES overallstatus_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo_data vminfo_data_server_scans_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vminfo_data
    ADD CONSTRAINT vminfo_data_server_scans_id_fkey FOREIGN KEY (server_scans_id) REFERENCES server_scans(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo_data vminfo_data_vm_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vminfo_data
    ADD CONSTRAINT vminfo_data_vm_id_fkey FOREIGN KEY (vm_id) REFERENCES vms(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo vminfo_guestid_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_guestid_id_fkey FOREIGN KEY (guestid_id) REFERENCES guestid_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo vminfo_guestos_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_guestos_id_fkey FOREIGN KEY (guestos_id) REFERENCES guestos_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo vminfo_vm_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_vm_id_fkey FOREIGN KEY (vm_id) REFERENCES vms(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vminfo vminfo_vmwaretools_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vminfo
    ADD CONSTRAINT vminfo_vmwaretools_id_fkey FOREIGN KEY (vmwaretools_id) REFERENCES vmwaretools_types(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vmowner vmowner_vm_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vmowner
    ADD CONSTRAINT vmowner_vm_id_fkey FOREIGN KEY (vm_id) REFERENCES vms(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: vms vms_server_id_fkey; Type: FK CONSTRAINT; Schema: vdiscover; Owner: postgres
--

ALTER TABLE ONLY vms
    ADD CONSTRAINT vms_server_id_fkey FOREIGN KEY (server_id) REFERENCES "esx-servers"(id) ON UPDATE CASCADE ON DELETE CASCADE;


SET search_path = wscommands, pg_catalog;

--
-- Name: cmdargs cmdargs_id_fkey; Type: FK CONSTRAINT; Schema: wscommands; Owner: postgres
--

ALTER TABLE ONLY cmdargs
    ADD CONSTRAINT cmdargs_id_fkey FOREIGN KEY (id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: etlresults etlresults_id_fkey; Type: FK CONSTRAINT; Schema: wscommands; Owner: postgres
--

ALTER TABLE ONLY etlresults
    ADD CONSTRAINT etlresults_id_fkey FOREIGN KEY (id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: messages messages_id_fkey; Type: FK CONSTRAINT; Schema: wscommands; Owner: postgres
--

ALTER TABLE ONLY messages
    ADD CONSTRAINT messages_id_fkey FOREIGN KEY (id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: suspectresults suspectresults_id_fkey; Type: FK CONSTRAINT; Schema: wscommands; Owner: postgres
--

ALTER TABLE ONLY suspectresults
    ADD CONSTRAINT suspectresults_id_fkey FOREIGN KEY (id) REFERENCES baseresults(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: PIE; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA "PIE" TO "SystemsTeam";
GRANT ALL ON SCHEMA "PIE" TO "DevEnablement";
GRANT USAGE ON SCHEMA "PIE" TO PUBLIC;


--
-- Name: accurev; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA accurev FROM postgres;
GRANT USAGE ON SCHEMA accurev TO postgres;
GRANT ALL ON SCHEMA accurev TO "SystemsTeam";
GRANT ALL ON SCHEMA accurev TO "DevEnablement";
GRANT ALL ON SCHEMA accurev TO PUBLIC;


--
-- Name: audit_control; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA audit_control TO PUBLIC;


--
-- Name: buildlog; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA buildlog TO "SystemsTeam";
GRANT USAGE ON SCHEMA buildlog TO PUBLIC;


--
-- Name: buildlog_new; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA buildlog_new TO PUBLIC;
GRANT ALL ON SCHEMA buildlog_new TO "DevEnablement";
GRANT ALL ON SCHEMA buildlog_new TO admins;


--
-- Name: buildmetrics; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA buildmetrics TO PUBLIC;


--
-- Name: cateams; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA cateams TO "SystemsTeam";
GRANT ALL ON SCHEMA cateams TO "DevEnablement";
GRANT USAGE ON SCHEMA cateams TO PUBLIC;


--
-- Name: cyclone; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA cyclone TO PUBLIC;


--
-- Name: demo_packaging; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA demo_packaging TO edakka;
GRANT ALL ON SCHEMA demo_packaging TO hendrr2;


--
-- Name: empdata; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA empdata TO "SystemsTeam";
GRANT ALL ON SCHEMA empdata TO "DevEnablement";
GRANT USAGE ON SCHEMA empdata TO PUBLIC;


--
-- Name: jenkins; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA jenkins TO "SystemsTeam";
GRANT ALL ON SCHEMA jenkins TO "DevEnablement";
GRANT USAGE ON SCHEMA jenkins TO PUBLIC;


--
-- Name: jenkinslogger; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA jenkinslogger TO "FileFoundationTeam";
GRANT USAGE ON SCHEMA jenkinslogger TO PUBLIC;


--
-- Name: remedy; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA remedy TO PUBLIC;
GRANT ALL ON SCHEMA remedy TO "DevEnablement";


--
-- Name: shares; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA shares TO "SystemsTeam";
GRANT ALL ON SCHEMA shares TO "DevEnablement";
GRANT USAGE ON SCHEMA shares TO PUBLIC;


--
-- Name: vcenter; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA vcenter TO PUBLIC;
GRANT ALL ON SCHEMA vcenter TO "DevEnablement";


--
-- Name: vdiscover; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA vdiscover TO PUBLIC;


--
-- Name: wscommands; Type: ACL; Schema: -; Owner: postgres
--

GRANT ALL ON SCHEMA wscommands TO "DevEnablement";
GRANT ALL ON SCHEMA wscommands TO "SystemsTeam";
GRANT USAGE ON SCHEMA wscommands TO PUBLIC;


SET search_path = accurev, pg_catalog;

--
-- Name: allchildstreams(text); Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON FUNCTION allchildstreams(streamname text) TO "SystemsTeam";


--
-- Name: childstreams(text); Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON FUNCTION childstreams(streamname text) TO "SystemsTeam";


--
-- Name: dailycheckins(text); Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON FUNCTION dailycheckins(streamname text) TO "SystemsTeam";


--
-- Name: developers(text); Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON FUNCTION developers(streamname text) TO "SystemsTeam";


--
-- Name: filtered_promotions(bigint, bigint, bigint); Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON FUNCTION filtered_promotions(filter_id bigint, start_trans bigint, end_trans bigint) TO "SystemsTeam";


--
-- Name: filtered_promotions(bigint, timestamp with time zone, timestamp with time zone); Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON FUNCTION filtered_promotions(filter_id bigint, start_datetime timestamp with time zone, end_datetime timestamp with time zone) TO "SystemsTeam";


--
-- Name: getdepotmedian(text); Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON FUNCTION getdepotmedian(depot text) TO "SystemsTeam";


--
-- Name: getuserwcount(text, integer); Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON FUNCTION getuserwcount(depot text, val integer) TO "SystemsTeam";


--
-- Name: streamnumber(text); Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON FUNCTION streamnumber(stream text) TO "SystemsTeam";


--
-- Name: weeklycheckins(text); Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON FUNCTION weeklycheckins(streamname text) TO "SystemsTeam";


SET search_path = buildlog, pg_catalog;

--
-- Name: getfaultclass(text[]); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT ALL ON FUNCTION getfaultclass(faults text[]) TO "SystemsTeam";


--
-- Name: gethostclass(text); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT ALL ON FUNCTION gethostclass(host text) TO "SystemsTeam";


SET search_path = cateams, pg_catalog;

--
-- Name: member(bigint); Type: ACL; Schema: cateams; Owner: postgres
--

REVOKE ALL ON FUNCTION member(employee_id bigint) FROM PUBLIC;
GRANT ALL ON FUNCTION member(employee_id bigint) TO "SystemsTeam";


--
-- Name: member(character varying); Type: ACL; Schema: cateams; Owner: postgres
--

REVOKE ALL ON FUNCTION member(email_or_ntlogin character varying) FROM PUBLIC;
GRANT ALL ON FUNCTION member(email_or_ntlogin character varying) TO "SystemsTeam";


SET search_path = jenkins, pg_catalog;

--
-- Name: getpluginscan(bigint); Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON FUNCTION getpluginscan(scan_id bigint) TO "SystemsTeam";


--
-- Name: getpluginscan(timestamp with time zone); Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON FUNCTION getpluginscan(scan_timedate timestamp with time zone) TO "SystemsTeam";


SET search_path = wscommands, pg_catalog;

--
-- Name: getfield(text, text, text, text); Type: ACL; Schema: wscommands; Owner: postgres
--

REVOKE ALL ON FUNCTION getfield(workspace text, host text, stream text, usr text) FROM PUBLIC;


--
-- Name: getusername(text); Type: ACL; Schema: wscommands; Owner: postgres
--

REVOKE ALL ON FUNCTION getusername(workspace text) FROM PUBLIC;


SET search_path = "PIE", pg_catalog;

--
-- Name: ANT-AR-Escalation; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE "ANT-AR-Escalation" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "ANT-AR-Escalation" TO PUBLIC;
GRANT ALL ON TABLE "ANT-AR-Escalation" TO "DevEnablement";


--
-- Name: AR propagaton; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE "AR propagaton" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "AR propagaton" TO PUBLIC;
GRANT ALL ON TABLE "AR propagaton" TO "DevEnablement";


--
-- Name: Escape_Analysis; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE "Escape_Analysis" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "Escape_Analysis" TO PUBLIC;
GRANT ALL ON TABLE "Escape_Analysis" TO "DevEnablement";


--
-- Name: Promotion_delay_files; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE "Promotion_delay_files" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "Promotion_delay_files" TO PUBLIC;
GRANT ALL ON TABLE "Promotion_delay_files" TO "DevEnablement";


--
-- Name: Promotion_delay_streams; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE "Promotion_delay_streams" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "Promotion_delay_streams" TO PUBLIC;
GRANT ALL ON TABLE "Promotion_delay_streams" TO "DevEnablement";


--
-- Name: error_report; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT SELECT ON TABLE error_report TO PUBLIC;


--
-- Name: streamlock_stat; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE streamlock_stat TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE streamlock_stat TO PUBLIC;
GRANT ALL ON TABLE streamlock_stat TO "DevEnablement";


SET search_path = accurev, pg_catalog;

--
-- Name: promotion_fileversions; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE promotion_fileversions TO "DevEnablement";
GRANT ALL ON TABLE promotion_fileversions TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE promotion_fileversions TO PUBLIC;


--
-- Name: stream_daily; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE stream_daily TO "DevEnablement";
GRANT ALL ON TABLE stream_daily TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE stream_daily TO PUBLIC;


--
-- Name: transactions; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE transactions TO "DevEnablement";
GRANT ALL ON TABLE transactions TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE transactions TO PUBLIC;


SET search_path = cateams, pg_catalog;

--
-- Name: rally_info; Type: ACL; Schema: cateams; Owner: postgres
--

GRANT ALL ON TABLE rally_info TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE rally_info TO PUBLIC;
GRANT ALL ON TABLE rally_info TO "DevEnablement";


SET search_path = "PIE", pg_catalog;

--
-- Name: lock_user_ca; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT SELECT ON TABLE lock_user_ca TO PUBLIC;


--
-- Name: stream_health_summary; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE stream_health_summary TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE stream_health_summary TO PUBLIC;
GRANT ALL ON TABLE stream_health_summary TO "DevEnablement";


--
-- Name: stream_promotion_delivery_streams; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE stream_promotion_delivery_streams TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE stream_promotion_delivery_streams TO PUBLIC;
GRANT ALL ON TABLE stream_promotion_delivery_streams TO "DevEnablement";


--
-- Name: stream_promotion_details; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE stream_promotion_details TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE stream_promotion_details TO PUBLIC;
GRANT ALL ON TABLE stream_promotion_details TO "DevEnablement";


--
-- Name: stream_promotion_usr; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE stream_promotion_usr TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE stream_promotion_usr TO PUBLIC;
GRANT ALL ON TABLE stream_promotion_usr TO "DevEnablement";


--
-- Name: stream_team_lead_map; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE stream_team_lead_map TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE stream_team_lead_map TO PUBLIC;
GRANT ALL ON TABLE stream_team_lead_map TO "DevEnablement";


--
-- Name: streamlock_operation; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE streamlock_operation TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE streamlock_operation TO PUBLIC;
GRANT ALL ON TABLE streamlock_operation TO "DevEnablement";


--
-- Name: triage_accurecy; Type: ACL; Schema: PIE; Owner: postgres
--

GRANT ALL ON TABLE triage_accurecy TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE triage_accurecy TO PUBLIC;
GRANT ALL ON TABLE triage_accurecy TO "DevEnablement";


SET search_path = accurev, pg_catalog;

--
-- Name: apps_acignores; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT SELECT ON TABLE apps_acignores TO PUBLIC;
GRANT ALL ON TABLE apps_acignores TO "SystemsTeam";
GRANT ALL ON TABLE apps_acignores TO "DevEnablement";


--
-- Name: apps_dailycheckins; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE apps_dailycheckins TO "DevEnablement";
GRANT ALL ON TABLE apps_dailycheckins TO "SystemsTeam";
GRANT SELECT ON TABLE apps_dailycheckins TO PUBLIC;


--
-- Name: apps_developers; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE apps_developers TO "DevEnablement";
GRANT ALL ON TABLE apps_developers TO "SystemsTeam";
GRANT SELECT ON TABLE apps_developers TO PUBLIC;


--
-- Name: apps_substreams; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE apps_substreams TO "DevEnablement";
GRANT ALL ON TABLE apps_substreams TO "SystemsTeam";
GRANT SELECT ON TABLE apps_substreams TO PUBLIC;


--
-- Name: apps_weeklycheckins; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE apps_weeklycheckins TO "DevEnablement";
GRANT ALL ON TABLE apps_weeklycheckins TO "SystemsTeam";
GRANT SELECT ON TABLE apps_weeklycheckins TO PUBLIC;


--
-- Name: builders; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE builders TO "DevEnablement";
GRANT ALL ON TABLE builders TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE builders TO PUBLIC;


--
-- Name: default_group; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE default_group TO "DevEnablement";
GRANT ALL ON TABLE default_group TO "SystemsTeam";


--
-- Name: depot_id; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON SEQUENCE depot_id TO PUBLIC;
GRANT ALL ON SEQUENCE depot_id TO "SystemsTeam";


--
-- Name: depots; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE depots TO "DevEnablement";
GRANT ALL ON TABLE depots TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE depots TO PUBLIC;


--
-- Name: domain_streams; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT SELECT ON TABLE domain_streams TO PUBLIC;
GRANT ALL ON TABLE domain_streams TO "SystemsTeam";


--
-- Name: elem_types_id; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON SEQUENCE elem_types_id TO PUBLIC;
GRANT ALL ON SEQUENCE elem_types_id TO "SystemsTeam";


--
-- Name: elem_types; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE elem_types TO "DevEnablement";
GRANT ALL ON TABLE elem_types TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE elem_types TO PUBLIC;


--
-- Name: filter_comments_id; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON SEQUENCE filter_comments_id TO PUBLIC;
GRANT ALL ON SEQUENCE filter_comments_id TO "SystemsTeam";


--
-- Name: filter_comments; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE filter_comments TO "DevEnablement";
GRANT ALL ON TABLE filter_comments TO "SystemsTeam";
GRANT SELECT,UPDATE ON TABLE filter_comments TO PUBLIC;


--
-- Name: filter_data; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE filter_data TO "DevEnablement";
GRANT ALL ON TABLE filter_data TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE filter_data TO PUBLIC;


--
-- Name: filtertype_seq; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON SEQUENCE filtertype_seq TO "DevEnablement";
GRANT ALL ON SEQUENCE filtertype_seq TO "SystemsTeam";
GRANT SELECT ON SEQUENCE filtertype_seq TO PUBLIC;


--
-- Name: initial_checkins; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE initial_checkins TO "DevEnablement";
GRANT ALL ON TABLE initial_checkins TO "SystemsTeam";
GRANT SELECT ON TABLE initial_checkins TO PUBLIC;


--
-- Name: promotion_comments; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE promotion_comments TO "DevEnablement";
GRANT ALL ON TABLE promotion_comments TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE promotion_comments TO PUBLIC;


--
-- Name: promotion_issues; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE promotion_issues TO "DevEnablement";
GRANT ALL ON TABLE promotion_issues TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE promotion_issues TO PUBLIC;


--
-- Name: promotions_daily; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE promotions_daily TO PUBLIC;
GRANT ALL ON TABLE promotions_daily TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE promotions_daily TO "DevEnablement";
GRANT ALL ON TABLE promotions_daily TO "SystemsTeam";


--
-- Name: rebase_info; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE rebase_info TO "DevEnablement";
GRANT ALL ON TABLE rebase_info TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE rebase_info TO PUBLIC;


--
-- Name: stream_history; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE stream_history TO "DevEnablement";
GRANT ALL ON TABLE stream_history TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE stream_history TO PUBLIC;


--
-- Name: stream_meta; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE stream_meta TO "DevEnablement";
GRANT ALL ON TABLE stream_meta TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE stream_meta TO PUBLIC;


--
-- Name: t_usage; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE t_usage TO PUBLIC;
GRANT ALL ON TABLE t_usage TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE t_usage TO "DevEnablement";
GRANT ALL ON TABLE t_usage TO "SystemsTeam";


--
-- Name: wspaces_daily; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE wspaces_daily TO "DevEnablement";
GRANT ALL ON TABLE wspaces_daily TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE wspaces_daily TO PUBLIC;


--
-- Name: wspaces_depots; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE wspaces_depots TO "DevEnablement";
GRANT ALL ON TABLE wspaces_depots TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE wspaces_depots TO PUBLIC;


--
-- Name: wspaces_history; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE wspaces_history TO "DevEnablement";
GRANT ALL ON TABLE wspaces_history TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE wspaces_history TO PUBLIC;


--
-- Name: wspaces_summary; Type: ACL; Schema: accurev; Owner: postgres
--

GRANT ALL ON TABLE wspaces_summary TO "DevEnablement";
GRANT ALL ON TABLE wspaces_summary TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE wspaces_summary TO PUBLIC;


SET search_path = audit_control, pg_catalog;

--
-- Name: accurev_ldap; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE accurev_ldap TO PUBLIC;
GRANT ALL ON TABLE accurev_ldap TO admins WITH GRANT OPTION;


--
-- Name: accurev_live; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE accurev_live TO PUBLIC;
GRANT ALL ON TABLE accurev_live TO admins WITH GRANT OPTION;


--
-- Name: clearcase_block_ldap; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE clearcase_block_ldap TO PUBLIC;
GRANT ALL ON TABLE clearcase_block_ldap TO admins WITH GRANT OPTION;


--
-- Name: clearcase_block_live; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE clearcase_block_live TO PUBLIC;
GRANT ALL ON TABLE clearcase_block_live TO admins WITH GRANT OPTION;


--
-- Name: clearcase_unisphere_ldap; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE clearcase_unisphere_ldap TO PUBLIC;
GRANT ALL ON TABLE clearcase_unisphere_ldap TO admins WITH GRANT OPTION;


--
-- Name: clearcase_unisphere_live; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE clearcase_unisphere_live TO PUBLIC;
GRANT ALL ON TABLE clearcase_unisphere_live TO admins WITH GRANT OPTION;


--
-- Name: cvs_ldap; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE cvs_ldap TO PUBLIC;
GRANT ALL ON TABLE cvs_ldap TO admins WITH GRANT OPTION;


--
-- Name: cvs_live; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE cvs_live TO PUBLIC;
GRANT ALL ON TABLE cvs_live TO admins WITH GRANT OPTION;


--
-- Name: distro_lists_id; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT ALL ON SEQUENCE distro_lists_id TO PUBLIC;


--
-- Name: distro_lists; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE distro_lists TO PUBLIC;
GRANT ALL ON TABLE distro_lists TO admins WITH GRANT OPTION;


--
-- Name: git_ldap; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE git_ldap TO PUBLIC;
GRANT ALL ON TABLE git_ldap TO admins WITH GRANT OPTION;


--
-- Name: git_live; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE git_live TO PUBLIC;
GRANT ALL ON TABLE git_live TO admins WITH GRANT OPTION;


--
-- Name: service_accounts; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE service_accounts TO PUBLIC;
GRANT ALL ON TABLE service_accounts TO admins WITH GRANT OPTION;


--
-- Name: svn_ldap; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE svn_ldap TO PUBLIC;
GRANT ALL ON TABLE svn_ldap TO admins WITH GRANT OPTION;


--
-- Name: svn_live; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE svn_live TO PUBLIC;
GRANT ALL ON TABLE svn_live TO admins WITH GRANT OPTION;


--
-- Name: test_ldap; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE test_ldap TO PUBLIC;
GRANT ALL ON TABLE test_ldap TO admins WITH GRANT OPTION;


--
-- Name: test_live; Type: ACL; Schema: audit_control; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE test_live TO PUBLIC;
GRANT ALL ON TABLE test_live TO admins WITH GRANT OPTION;


SET search_path = buildlog, pg_catalog;

--
-- Name: baseresults_id; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT ALL ON SEQUENCE baseresults_id TO PUBLIC;
GRANT ALL ON SEQUENCE baseresults_id TO "SystemsTeam";


--
-- Name: baseresults; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE baseresults TO PUBLIC;


--
-- Name: etlresults; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE etlresults TO PUBLIC;


--
-- Name: fault_class; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE fault_class TO PUBLIC;


--
-- Name: hosts_id; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT ALL ON SEQUENCE hosts_id TO PUBLIC;


--
-- Name: hosts; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE hosts TO PUBLIC;


--
-- Name: ibidextended; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ibidextended TO PUBLIC;
GRANT ALL ON TABLE ibidextended TO admins WITH GRANT OPTION;


--
-- Name: ibidresults; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ibidresults TO PUBLIC;


--
-- Name: suspectresults; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE suspectresults TO PUBLIC;


--
-- Name: metrics; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE metrics TO PUBLIC;
GRANT ALL ON TABLE metrics TO admins WITH GRANT OPTION;


--
-- Name: ExcelMetrics1; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "ExcelMetrics1" TO PUBLIC;
GRANT ALL ON TABLE "ExcelMetrics1" TO admins WITH GRANT OPTION;


--
-- Name: componentmeta; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE componentmeta TO PUBLIC;


--
-- Name: componentsbyoccurrence; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE componentsbyoccurrence TO PUBLIC;


--
-- Name: metrics_comps; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE metrics_comps TO PUBLIC;
GRANT ALL ON TABLE metrics_comps TO admins WITH GRANT OPTION;


--
-- Name: ExcelMetrics2; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "ExcelMetrics2" TO PUBLIC;
GRANT ALL ON TABLE "ExcelMetrics2" TO admins WITH GRANT OPTION;


--
-- Name: ExcelMetrics3; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "ExcelMetrics3" TO PUBLIC;
GRANT ALL ON TABLE "ExcelMetrics3" TO admins WITH GRANT OPTION;


--
-- Name: ExcelMetrics4; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "ExcelMetrics4" TO PUBLIC;
GRANT ALL ON TABLE "ExcelMetrics4" TO admins WITH GRANT OPTION;


--
-- Name: Indicators Summary; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Indicators Summary" TO PUBLIC;
GRANT ALL ON TABLE "Indicators Summary" TO admins WITH GRANT OPTION;


--
-- Name: Last Weeks biggest changes (CI); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Last Weeks biggest changes (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Last Weeks biggest changes (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Last Weeks biggest changes (DE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Last Weeks biggest changes (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Last Weeks biggest changes (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Last Weeks biggest changes (RE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Last Weeks biggest changes (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Last Weeks biggest changes (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Last weeks faults; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Last weeks faults" TO PUBLIC;
GRANT ALL ON TABLE "Last weeks faults" TO admins WITH GRANT OPTION;


--
-- Name: build-summary2; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "build-summary2" TO PUBLIC;
GRANT ALL ON TABLE "build-summary2" TO admins WITH GRANT OPTION;


--
-- Name: LiveWire-summary; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "LiveWire-summary" TO PUBLIC;
GRANT ALL ON TABLE "LiveWire-summary" TO admins WITH GRANT OPTION;


--
-- Name: PIE_builds; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "PIE_builds" TO PUBLIC;
GRANT ALL ON TABLE "PIE_builds" TO admins WITH GRANT OPTION;


--
-- Name: Reliability; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Reliability" TO PUBLIC;
GRANT ALL ON TABLE "Reliability" TO admins WITH GRANT OPTION;


--
-- Name: Reliability: CI; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Reliability: CI" TO PUBLIC;
GRANT ALL ON TABLE "Reliability: CI" TO admins WITH GRANT OPTION;


--
-- Name: Reliability: DE; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Reliability: DE" TO PUBLIC;
GRANT ALL ON TABLE "Reliability: DE" TO admins WITH GRANT OPTION;


--
-- Name: Reliability: RE; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Reliability: RE" TO PUBLIC;
GRANT ALL ON TABLE "Reliability: RE" TO admins WITH GRANT OPTION;


--
-- Name: Savings; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Savings" TO PUBLIC;
GRANT ALL ON TABLE "Savings" TO admins WITH GRANT OPTION;


--
-- Name: Week over Week delta - components_bld (CI); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Week over Week delta - components_bld (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Week over Week delta - components_bld (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Week over Week delta - components_bld (DE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Week over Week delta - components_bld (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Week over Week delta - components_bld (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Week over Week delta - components_bld (RE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Week over Week delta - components_bld (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Week over Week delta - components_bld (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly Build Counts by Director (xtab); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly Build Counts by Director (xtab)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly Build Counts by Director (xtab)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly statistics values; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly statistics values" TO PUBLIC;
GRANT ALL ON TABLE "Weekly statistics values" TO admins WITH GRANT OPTION;


SET search_path = empdata, pg_catalog;

--
-- Name: ix_badgeid_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_badgeid_id TO PUBLIC;


--
-- Name: ix_badgeid; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_badgeid TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_badgeid TO PUBLIC;


--
-- Name: ix_citys_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_citys_id TO "SystemsTeam";
GRANT ALL ON SEQUENCE ix_citys_id TO PUBLIC;


--
-- Name: ix_citys; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_citys TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_citys TO PUBLIC;


--
-- Name: ix_countrys_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_countrys_id TO "SystemsTeam";
GRANT ALL ON SEQUENCE ix_countrys_id TO PUBLIC;


--
-- Name: ix_countrys; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_countrys TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_countrys TO PUBLIC;


--
-- Name: ix_distinguishedname_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_distinguishedname_id TO PUBLIC;


--
-- Name: ix_distinguishedname; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_distinguishedname TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_distinguishedname TO PUBLIC;


--
-- Name: ix_email_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_email_id TO PUBLIC;


--
-- Name: ix_email; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_email TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_email TO PUBLIC;


--
-- Name: ix_fullname_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_fullname_id TO PUBLIC;


--
-- Name: ix_fullname; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_fullname TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_fullname TO PUBLIC;


--
-- Name: ix_givenname_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_givenname_id TO PUBLIC;


--
-- Name: ix_givenname; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_givenname TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_givenname TO PUBLIC;


--
-- Name: ix_ntlogin_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_ntlogin_id TO PUBLIC;


--
-- Name: ix_ntlogin; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_ntlogin TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_ntlogin TO PUBLIC;


--
-- Name: ix_phone_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_phone_id TO PUBLIC;


--
-- Name: ix_phone; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_phone TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_phone TO PUBLIC;


--
-- Name: ix_scans_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_scans_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_scans_id TO "SystemsTeam";


--
-- Name: ix_scans; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_scans TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_scans TO PUBLIC;


--
-- Name: ix_surname_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_surname_id TO PUBLIC;


--
-- Name: ix_surname; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_surname TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_surname TO PUBLIC;


--
-- Name: tbl_employees_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE tbl_employees_id TO "SystemsTeam";
GRANT ALL ON SEQUENCE tbl_employees_id TO PUBLIC;


--
-- Name: tbl_employees; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE tbl_employees TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE tbl_employees TO PUBLIC;


--
-- Name: tbl_employees_info; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE tbl_employees_info TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE tbl_employees_info TO PUBLIC;


--
-- Name: employee_data; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE employee_data TO PUBLIC;
GRANT ALL ON TABLE employee_data TO admins WITH GRANT OPTION;


SET search_path = buildlog, pg_catalog;

--
-- Name: Weekly Build Stats by Director; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly Build Stats by Director" TO PUBLIC;
GRANT ALL ON TABLE "Weekly Build Stats by Director" TO admins WITH GRANT OPTION;


--
-- Name: Weekly Build Times by Director (xtab); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly Build Times by Director (xtab)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly Build Times by Director (xtab)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - Builds; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - Builds" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - Builds" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - Full Build Times; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - Full Build Times" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - Full Build Times" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - Full Build Times (CEC); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - Full Build Times (CEC)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - Full Build Times (CEC)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - Full Build Times.1; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - Full Build Times.1" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - Full Build Times.1" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - Full Build Times.2; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - Full Build Times.2" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - Full Build Times.2" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - Full Build Times.3; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - Full Build Times.3" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - Full Build Times.3" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - Host Types; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - Host Types" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - Host Types" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - build_all; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - build_all" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - build_all" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_bld (CI); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_bld (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_bld (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_bld (DE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_bld (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_bld (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_bld (RE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_bld (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_bld (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_meta (CI); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_meta (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_meta (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_meta (DE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_meta (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_meta (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_meta (RE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_meta (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_meta (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_pkg (CI); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_pkg (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_pkg (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_pkg (DE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_pkg (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_pkg (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_pkg (RE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_pkg (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_pkg (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Build Types; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Build Types" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Build Types" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Builds; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Builds" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Builds" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Fault-Categories; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Fault-Categories" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Fault-Categories" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Fault-Categories.2; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Fault-Categories.2" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Fault-Categories.2" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Fault-Types; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Fault-Types" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Fault-Types" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Full Build Times; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Full Build Times" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Full Build Times" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Host Types; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Host Types" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Host Types" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Host Types (CI); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Host Types (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Host Types (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Host Types (DE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Host Types (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Host Types (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Host Types (RE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Host Types (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Host Types (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - components; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - components" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - components" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - components_bld (CI); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - components_bld (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - components_bld (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - components_bld (DE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - components_bld (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - components_bld (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - components_bld (RE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - components_bld (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - components_bld (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - components_meta (CI); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - components_meta (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - components_meta (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - components_meta (DE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - components_meta (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - components_meta (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - components_meta (RE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - components_meta (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - components_meta (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - components_pkg (CI); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - components_pkg (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - components_pkg (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - components_pkg (DE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - components_pkg (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - components_pkg (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - components_pkg (RE); Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - components_pkg (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - components_pkg (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts for each Build-User Category; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts for each Build-User Category" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts for each Build-User Category" TO admins WITH GRANT OPTION;


--
-- Name: build-summary; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "build-summary" TO PUBLIC;
GRANT ALL ON TABLE "build-summary" TO admins WITH GRANT OPTION;


--
-- Name: build-summary-data; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "build-summary-data" TO PUBLIC;
GRANT ALL ON TABLE "build-summary-data" TO admins WITH GRANT OPTION;


--
-- Name: cmdargs; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE cmdargs TO PUBLIC;


--
-- Name: component_heatmaps; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE component_heatmaps TO PUBLIC;
GRANT ALL ON TABLE component_heatmaps TO admins WITH GRANT OPTION;


--
-- Name: component_heatmaps2; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE component_heatmaps2 TO PUBLIC;
GRANT ALL ON TABLE component_heatmaps2 TO admins WITH GRANT OPTION;


--
-- Name: component_heatmaps3; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE component_heatmaps3 TO PUBLIC;
GRANT ALL ON TABLE component_heatmaps3 TO admins WITH GRANT OPTION;


--
-- Name: developer-root-data; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "developer-root-data" TO PUBLIC;
GRANT ALL ON TABLE "developer-root-data" TO admins WITH GRANT OPTION;


--
-- Name: developer-root-names; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "developer-root-names" TO PUBLIC;
GRANT ALL ON TABLE "developer-root-names" TO admins WITH GRANT OPTION;


--
-- Name: developer-root-summary; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "developer-root-summary" TO PUBLIC;
GRANT ALL ON TABLE "developer-root-summary" TO admins WITH GRANT OPTION;


--
-- Name: faults_overview; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE faults_overview TO PUBLIC;
GRANT ALL ON TABLE faults_overview TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE faults_overview TO "SystemsTeam";


--
-- Name: host_class_id; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT ALL ON SEQUENCE host_class_id TO PUBLIC;
GRANT ALL ON SEQUENCE host_class_id TO "SystemsTeam";


--
-- Name: host_class; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE host_class TO PUBLIC;


--
-- Name: ibidmaskresults; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ibidmaskresults TO PUBLIC;
GRANT ALL ON TABLE ibidmaskresults TO admins WITH GRANT OPTION;


--
-- Name: idmaskresults; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE idmaskresults TO PUBLIC;
GRANT ALL ON TABLE idmaskresults TO admins WITH GRANT OPTION;


--
-- Name: logrange_info; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE logrange_info TO PUBLIC;


--
-- Name: raw_baseresults; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_baseresults TO PUBLIC;
GRANT ALL ON TABLE raw_baseresults TO admins WITH GRANT OPTION;


--
-- Name: raw_cmdargs; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_cmdargs TO PUBLIC;
GRANT ALL ON TABLE raw_cmdargs TO admins WITH GRANT OPTION;


--
-- Name: raw_componentsbyoccurrence; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_componentsbyoccurrence TO PUBLIC;
GRANT ALL ON TABLE raw_componentsbyoccurrence TO admins WITH GRANT OPTION;


--
-- Name: usermatch; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE usermatch TO PUBLIC;


--
-- Name: weekly; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE weekly TO PUBLIC;
GRANT ALL ON TABLE weekly TO admins WITH GRANT OPTION;


SET search_path = wscommands, pg_catalog;

--
-- Name: baseresults_id; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT ALL ON SEQUENCE baseresults_id TO PUBLIC;
GRANT ALL ON SEQUENCE baseresults_id TO "SystemsTeam";


--
-- Name: baseresults; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE baseresults TO PUBLIC;
GRANT ALL ON TABLE baseresults TO "DevEnablement";


--
-- Name: etlresults; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE etlresults TO PUBLIC;
GRANT ALL ON TABLE etlresults TO "DevEnablement";


SET search_path = buildlog, pg_catalog;

--
-- Name: ws-adoption; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT ALL ON TABLE "ws-adoption" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "ws-adoption" TO PUBLIC;


--
-- Name: ws-adoption2; Type: ACL; Schema: buildlog; Owner: postgres
--

GRANT ALL ON TABLE "ws-adoption2" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "ws-adoption2" TO PUBLIC;


SET search_path = buildlog_new, pg_catalog;

--
-- Name: ix_ipaddress_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_ipaddress_id TO PUBLIC;


--
-- Name: ix_ipaddress; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_ipaddress TO PUBLIC;
GRANT ALL ON TABLE ix_ipaddress TO admins WITH GRANT OPTION;


--
-- Name: IP address ranges; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "IP address ranges" TO PUBLIC;
GRANT ALL ON TABLE "IP address ranges" TO admins WITH GRANT OPTION;


--
-- Name: tbl_faults; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_faults TO PUBLIC;
GRANT ALL ON TABLE tbl_faults TO admins WITH GRANT OPTION;


--
-- Name: tbl_ibidinfo; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_ibidinfo TO PUBLIC;
GRANT ALL ON TABLE tbl_ibidinfo TO admins WITH GRANT OPTION;


--
-- Name: tbl_results; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_results TO PUBLIC;
GRANT ALL ON TABLE tbl_results TO admins WITH GRANT OPTION;


--
-- Name: tbl_timeslots; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_timeslots TO PUBLIC;
GRANT ALL ON TABLE tbl_timeslots TO admins WITH GRANT OPTION;


--
-- Name: usr_build_class_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_build_class_id TO PUBLIC;


--
-- Name: usr_build_class; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_build_class TO PUBLIC;
GRANT ALL ON TABLE usr_build_class TO admins WITH GRANT OPTION;


--
-- Name: usr_fault_category_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_fault_category_id TO PUBLIC;


--
-- Name: usr_fault_category; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_fault_category TO PUBLIC;
GRANT ALL ON TABLE usr_fault_category TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE usr_fault_category TO "DevEnablement";


--
-- Name: usr_fault_class_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_fault_class_id TO PUBLIC;


--
-- Name: usr_fault_class; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_fault_class TO PUBLIC;
GRANT ALL ON TABLE usr_fault_class TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE usr_fault_class TO "DevEnablement";


--
-- Name: Indicators Summary; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Indicators Summary" TO PUBLIC;
GRANT ALL ON TABLE "Indicators Summary" TO admins WITH GRANT OPTION;


--
-- Name: Last weeks faults; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Last weeks faults" TO PUBLIC;
GRANT ALL ON TABLE "Last weeks faults" TO admins WITH GRANT OPTION;


--
-- Name: ix_cloud_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_cloud_id TO PUBLIC;


--
-- Name: ix_cloud; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_cloud TO PUBLIC;
GRANT ALL ON TABLE ix_cloud TO admins WITH GRANT OPTION;


--
-- Name: ix_ntlogin_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_ntlogin_id TO PUBLIC;


--
-- Name: ix_ntlogin; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_ntlogin TO PUBLIC;
GRANT ALL ON TABLE ix_ntlogin TO admins WITH GRANT OPTION;


--
-- Name: tbl_users_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE tbl_users_id TO PUBLIC;


--
-- Name: tbl_users; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_users TO PUBLIC;
GRANT ALL ON TABLE tbl_users TO admins WITH GRANT OPTION;


--
-- Name: build-summary2; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "build-summary2" TO PUBLIC;
GRANT ALL ON TABLE "build-summary2" TO admins WITH GRANT OPTION;


--
-- Name: LiveWire-summary; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "LiveWire-summary" TO PUBLIC;
GRANT ALL ON TABLE "LiveWire-summary" TO admins WITH GRANT OPTION;


--
-- Name: ix_host_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_host_id TO PUBLIC;


--
-- Name: ix_host; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_host TO PUBLIC;
GRANT ALL ON TABLE ix_host TO admins WITH GRANT OPTION;


--
-- Name: tbl_hosts_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE tbl_hosts_id TO PUBLIC;


--
-- Name: tbl_hosts; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_hosts TO PUBLIC;
GRANT ALL ON TABLE tbl_hosts TO admins WITH GRANT OPTION;


--
-- Name: PIE_builds; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "PIE_builds" TO PUBLIC;
GRANT ALL ON TABLE "PIE_builds" TO admins WITH GRANT OPTION;


--
-- Name: Reliability; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Reliability" TO PUBLIC;
GRANT ALL ON TABLE "Reliability" TO admins WITH GRANT OPTION;


--
-- Name: Weekly Build Counts by Director (xtab); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly Build Counts by Director (xtab)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly Build Counts by Director (xtab)" TO admins WITH GRANT OPTION;


--
-- Name: ix_site_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_site_id TO PUBLIC;


--
-- Name: ix_site; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_site TO PUBLIC;
GRANT ALL ON TABLE ix_site TO admins WITH GRANT OPTION;


--
-- Name: Weekly statistics values; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly statistics values" TO PUBLIC;
GRANT ALL ON TABLE "Weekly statistics values" TO admins WITH GRANT OPTION;


--
-- Name: Weekly Build Stats by Director; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly Build Stats by Director" TO PUBLIC;
GRANT ALL ON TABLE "Weekly Build Stats by Director" TO admins WITH GRANT OPTION;


--
-- Name: Weekly Build Times by Director (xtab); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly Build Times by Director (xtab)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly Build Times by Director (xtab)" TO admins WITH GRANT OPTION;


--
-- Name: ix_component_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_component_id TO PUBLIC;


--
-- Name: ix_component; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_component TO PUBLIC;
GRANT ALL ON TABLE ix_component TO admins WITH GRANT OPTION;


--
-- Name: ix_ibid_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_ibid_id TO PUBLIC;


--
-- Name: ix_ibid; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_ibid TO PUBLIC;
GRANT ALL ON TABLE ix_ibid TO admins WITH GRANT OPTION;


--
-- Name: tbl_suspectresults; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_suspectresults TO PUBLIC;
GRANT ALL ON TABLE tbl_suspectresults TO admins WITH GRANT OPTION;


--
-- Name: usr_host_class_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_host_class_id TO PUBLIC;


--
-- Name: usr_host_class; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_host_class TO PUBLIC;
GRANT ALL ON TABLE usr_host_class TO admins WITH GRANT OPTION;


--
-- Name: metrics; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE metrics TO PUBLIC;
GRANT ALL ON TABLE metrics TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - Builds; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - Builds" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - Builds" TO admins WITH GRANT OPTION;


--
-- Name: ix_phase_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_phase_id TO PUBLIC;


--
-- Name: ix_phase; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_phase TO PUBLIC;
GRANT ALL ON TABLE ix_phase TO admins WITH GRANT OPTION;


--
-- Name: tbl_components; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_components TO PUBLIC;
GRANT ALL ON TABLE tbl_components TO admins WITH GRANT OPTION;


--
-- Name: usr_component_class_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_component_class_id TO PUBLIC;


--
-- Name: usr_component_class; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_component_class TO PUBLIC;
GRANT ALL ON TABLE usr_component_class TO admins WITH GRANT OPTION;


--
-- Name: usr_component_info; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_component_info TO PUBLIC;
GRANT ALL ON TABLE usr_component_info TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - Full Build Times; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - Full Build Times" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - Full Build Times" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_bld (CI); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_bld (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_bld (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_bld (DE); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_bld (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_bld (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_bld (RE); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_bld (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_bld (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_pkg (CI); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_pkg (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_pkg (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_pkg (DE); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_pkg (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_pkg (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly averages - components_pkg (RE); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly averages - components_pkg (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly averages - components_pkg (RE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Build Types; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Build Types" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Build Types" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Builds; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Builds" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Builds" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Fault-Categories; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Fault-Categories" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Fault-Categories" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Host Types; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Host Types" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Host Types" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Host Types (CI); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Host Types (CI)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Host Types (CI)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Host Types (DE); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Host Types (DE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Host Types (DE)" TO admins WITH GRANT OPTION;


--
-- Name: Weekly counts - Host Types (RE); Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Weekly counts - Host Types (RE)" TO PUBLIC;
GRANT ALL ON TABLE "Weekly counts - Host Types (RE)" TO admins WITH GRANT OPTION;


--
-- Name: ix_cmdargs_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_cmdargs_id TO PUBLIC;


--
-- Name: ix_cmdargs; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_cmdargs TO PUBLIC;
GRANT ALL ON TABLE ix_cmdargs TO admins WITH GRANT OPTION;


--
-- Name: ix_cmdvals_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_cmdvals_id TO PUBLIC;


--
-- Name: ix_cmdvals; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_cmdvals TO PUBLIC;
GRANT ALL ON TABLE ix_cmdvals TO admins WITH GRANT OPTION;


--
-- Name: ix_env_type_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_env_type_id TO PUBLIC;


--
-- Name: ix_env_type; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_env_type TO PUBLIC;
GRANT ALL ON TABLE ix_env_type TO admins WITH GRANT OPTION;


--
-- Name: ix_environment_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_environment_id TO PUBLIC;


--
-- Name: ix_environment; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_environment TO PUBLIC;
GRANT ALL ON TABLE ix_environment TO admins WITH GRANT OPTION;


--
-- Name: ix_fault_detail_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_fault_detail_id TO PUBLIC;


--
-- Name: ix_fault_detail; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_fault_detail TO PUBLIC;
GRANT ALL ON TABLE ix_fault_detail TO admins WITH GRANT OPTION;


--
-- Name: ix_fault_msg_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_fault_msg_id TO PUBLIC;


--
-- Name: ix_fault_msg; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_fault_msg TO PUBLIC;
GRANT ALL ON TABLE ix_fault_msg TO admins WITH GRANT OPTION;


--
-- Name: ix_init_val_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_init_val_id TO PUBLIC;


--
-- Name: ix_init_val; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_init_val TO PUBLIC;
GRANT ALL ON TABLE ix_init_val TO admins WITH GRANT OPTION;


--
-- Name: ix_stream_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_stream_id TO PUBLIC;


--
-- Name: ix_stream; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_stream TO PUBLIC;
GRANT ALL ON TABLE ix_stream TO admins WITH GRANT OPTION;


--
-- Name: raw_baseresults; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_baseresults TO PUBLIC;
GRANT ALL ON TABLE raw_baseresults TO admins WITH GRANT OPTION;


--
-- Name: raw_cmdargs; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_cmdargs TO PUBLIC;
GRANT ALL ON TABLE raw_cmdargs TO admins WITH GRANT OPTION;


--
-- Name: raw_componentsbyoccurrence; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_componentsbyoccurrence TO PUBLIC;
GRANT ALL ON TABLE raw_componentsbyoccurrence TO admins WITH GRANT OPTION;


--
-- Name: tbl_cmdargs; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_cmdargs TO PUBLIC;
GRANT ALL ON TABLE tbl_cmdargs TO admins WITH GRANT OPTION;


--
-- Name: tbl_fileinfo; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_fileinfo TO PUBLIC;
GRANT ALL ON TABLE tbl_fileinfo TO admins WITH GRANT OPTION;


--
-- Name: tmp_usermatch_results; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tmp_usermatch_results TO PUBLIC;
GRANT ALL ON TABLE tmp_usermatch_results TO admins WITH GRANT OPTION;


--
-- Name: usr_host_category_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_host_category_id TO PUBLIC;


--
-- Name: usr_host_category; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_host_category TO PUBLIC;
GRANT ALL ON TABLE usr_host_category TO admins WITH GRANT OPTION;


--
-- Name: usr_ipaddress_category_mapping; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE usr_ipaddress_category_mapping TO PUBLIC;
GRANT ALL ON TABLE usr_ipaddress_category_mapping TO admins WITH GRANT OPTION;


--
-- Name: usr_locations_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_locations_id TO PUBLIC;


--
-- Name: usr_locations; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_locations TO PUBLIC;
GRANT ALL ON TABLE usr_locations TO admins WITH GRANT OPTION;


--
-- Name: usr_logrange_info_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_logrange_info_id TO PUBLIC;


--
-- Name: usr_logrange_info; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE usr_logrange_info TO PUBLIC;
GRANT ALL ON TABLE usr_logrange_info TO admins WITH GRANT OPTION;


--
-- Name: usr_map_host_to_host_class_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_map_host_to_host_class_id TO PUBLIC;


--
-- Name: usr_map_host_to_host_class; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_map_host_to_host_class TO PUBLIC;
GRANT ALL ON TABLE usr_map_host_to_host_class TO admins WITH GRANT OPTION;


--
-- Name: usr_match_owner_to_log; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE usr_match_owner_to_log TO PUBLIC;
GRANT ALL ON TABLE usr_match_owner_to_log TO admins WITH GRANT OPTION;


--
-- Name: usr_network_location_id; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_network_location_id TO PUBLIC;


--
-- Name: usr_network_location; Type: ACL; Schema: buildlog_new; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_network_location TO PUBLIC;
GRANT ALL ON TABLE usr_network_location TO admins WITH GRANT OPTION;


SET search_path = buildmetrics, pg_catalog;

--
-- Name: ix_buildall_version_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_buildall_version_id TO PUBLIC;


--
-- Name: ix_buildall_version; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_buildall_version TO PUBLIC;
GRANT ALL ON TABLE ix_buildall_version TO admins WITH GRANT OPTION;


--
-- Name: ix_components_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_components_id TO PUBLIC;


--
-- Name: ix_components; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_components TO PUBLIC;
GRANT ALL ON TABLE ix_components TO admins WITH GRANT OPTION;


--
-- Name: ix_flavor_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_flavor_id TO PUBLIC;


--
-- Name: ix_flavor; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_flavor TO PUBLIC;
GRANT ALL ON TABLE ix_flavor TO admins WITH GRANT OPTION;


--
-- Name: ix_host_ipaddress_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_host_ipaddress_id TO PUBLIC;


--
-- Name: ix_host_ipaddress; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_host_ipaddress TO PUBLIC;
GRANT ALL ON TABLE ix_host_ipaddress TO admins WITH GRANT OPTION;


--
-- Name: ix_stream_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_stream_id TO PUBLIC;


--
-- Name: ix_stream; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_stream TO PUBLIC;
GRANT ALL ON TABLE ix_stream TO admins WITH GRANT OPTION;


--
-- Name: ix_type_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_type_id TO PUBLIC;


--
-- Name: ix_type; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_type TO PUBLIC;
GRANT ALL ON TABLE ix_type TO admins WITH GRANT OPTION;


--
-- Name: tbl_build_summary; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_build_summary TO PUBLIC;
GRANT ALL ON TABLE tbl_build_summary TO admins WITH GRANT OPTION;


--
-- Name: tbl_buildmetadata; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_buildmetadata TO PUBLIC;
GRANT ALL ON TABLE tbl_buildmetadata TO admins WITH GRANT OPTION;


--
-- Name: usr_host_location_mapping; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_host_location_mapping TO PUBLIC;
GRANT ALL ON TABLE usr_host_location_mapping TO admins WITH GRANT OPTION;


--
-- Name: Build Summary; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Build Summary" TO PUBLIC;
GRANT ALL ON TABLE "Build Summary" TO admins WITH GRANT OPTION;


--
-- Name: Build Spread; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Build Spread" TO PUBLIC;
GRANT ALL ON TABLE "Build Spread" TO admins WITH GRANT OPTION;


--
-- Name: Build Spread Summary; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Build Spread Summary" TO PUBLIC;
GRANT ALL ON TABLE "Build Spread Summary" TO admins WITH GRANT OPTION;


--
-- Name: Build Summary2; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Build Summary2" TO PUBLIC;
GRANT ALL ON TABLE "Build Summary2" TO admins WITH GRANT OPTION;


--
-- Name: Build Summary22; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Build Summary22" TO PUBLIC;
GRANT ALL ON TABLE "Build Summary22" TO admins WITH GRANT OPTION;


--
-- Name: Build Summary3; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Build Summary3" TO PUBLIC;
GRANT ALL ON TABLE "Build Summary3" TO admins WITH GRANT OPTION;


--
-- Name: BuildMetadataView; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "BuildMetadataView" TO PUBLIC;
GRANT ALL ON TABLE "BuildMetadataView" TO admins WITH GRANT OPTION;


--
-- Name: BuildView; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "BuildView" TO PUBLIC;
GRANT ALL ON TABLE "BuildView" TO admins WITH GRANT OPTION;


--
-- Name: GeoPivot BuildCounts; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "GeoPivot BuildCounts" TO PUBLIC;
GRANT ALL ON TABLE "GeoPivot BuildCounts" TO admins WITH GRANT OPTION;


--
-- Name: GeoPivot BuildTimes; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "GeoPivot BuildTimes" TO PUBLIC;
GRANT ALL ON TABLE "GeoPivot BuildTimes" TO admins WITH GRANT OPTION;


--
-- Name: Reference Builds; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Reference Builds" TO PUBLIC;
GRANT ALL ON TABLE "Reference Builds" TO admins WITH GRANT OPTION;


SET search_path = vcenter, pg_catalog;

--
-- Name: ix_cloud_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_cloud_id TO PUBLIC;


--
-- Name: ix_cloud; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_cloud TO PUBLIC;
GRANT ALL ON TABLE ix_cloud TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ix_cloud TO "DevEnablement";


--
-- Name: ix_cloud_info_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_cloud_info_id TO PUBLIC;


--
-- Name: ix_cloud_info; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_cloud_info TO PUBLIC;
GRANT ALL ON TABLE ix_cloud_info TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ix_cloud_info TO "DevEnablement";


--
-- Name: ix_fld1_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_fld1_id TO PUBLIC;


--
-- Name: ix_fld1; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_fld1 TO PUBLIC;
GRANT ALL ON TABLE ix_fld1 TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ix_fld1 TO "DevEnablement";


--
-- Name: ix_fld2_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_fld2_id TO PUBLIC;


--
-- Name: ix_fld2; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_fld2 TO PUBLIC;
GRANT ALL ON TABLE ix_fld2 TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ix_fld2 TO "DevEnablement";


--
-- Name: ix_iptype_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_iptype_id TO PUBLIC;


--
-- Name: ix_iptype; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_iptype TO PUBLIC;
GRANT ALL ON TABLE ix_iptype TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ix_iptype TO "DevEnablement";


--
-- Name: ix_site_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_site_id TO PUBLIC;


--
-- Name: ix_site; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_site TO PUBLIC;
GRANT ALL ON TABLE ix_site TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ix_site TO "DevEnablement";


--
-- Name: ix_widget_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_widget_id TO PUBLIC;


--
-- Name: ix_widget; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_widget TO PUBLIC;
GRANT ALL ON TABLE ix_widget TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ix_widget TO "DevEnablement";


--
-- Name: locations_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE locations_id TO PUBLIC;
GRANT ALL ON SEQUENCE locations_id TO "SystemsTeam";


--
-- Name: locations; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE locations TO PUBLIC;
GRANT ALL ON TABLE locations TO admins WITH GRANT OPTION;


--
-- Name: usr_subnets_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_subnets_id TO PUBLIC;


--
-- Name: usr_subnets; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_subnets TO PUBLIC;
GRANT ALL ON TABLE usr_subnets TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE usr_subnets TO "DevEnablement";


--
-- Name: subnets; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE subnets TO PUBLIC;
GRANT ALL ON TABLE subnets TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE subnets TO "DevEnablement";


SET search_path = buildmetrics, pg_catalog;

--
-- Name: VM Info; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "VM Info" TO PUBLIC;
GRANT ALL ON TABLE "VM Info" TO admins WITH GRANT OPTION;


--
-- Name: ix_build_phase_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_build_phase_id TO PUBLIC;


--
-- Name: ix_build_phase; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_build_phase TO PUBLIC;
GRANT ALL ON TABLE ix_build_phase TO admins WITH GRANT OPTION;


--
-- Name: ix_build_type_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_build_type_id TO PUBLIC;


--
-- Name: ix_build_type; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_build_type TO PUBLIC;
GRANT ALL ON TABLE ix_build_type TO admins WITH GRANT OPTION;


--
-- Name: ix_product_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_product_id TO PUBLIC;


--
-- Name: ix_product; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_product TO PUBLIC;
GRANT ALL ON TABLE ix_product TO admins WITH GRANT OPTION;


--
-- Name: raw_buildmetadata; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_buildmetadata TO PUBLIC;
GRANT ALL ON TABLE raw_buildmetadata TO admins WITH GRANT OPTION;


--
-- Name: raw_component; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_component TO PUBLIC;
GRANT ALL ON TABLE raw_component TO admins WITH GRANT OPTION;


--
-- Name: raw_cpu; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_cpu TO PUBLIC;
GRANT ALL ON TABLE raw_cpu TO admins WITH GRANT OPTION;


--
-- Name: raw_disk; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_disk TO PUBLIC;
GRANT ALL ON TABLE raw_disk TO admins WITH GRANT OPTION;


--
-- Name: raw_disk2; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_disk2 TO PUBLIC;
GRANT ALL ON TABLE raw_disk2 TO admins WITH GRANT OPTION;


--
-- Name: raw_event; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_event TO PUBLIC;
GRANT ALL ON TABLE raw_event TO admins WITH GRANT OPTION;


--
-- Name: raw_memory; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_memory TO PUBLIC;
GRANT ALL ON TABLE raw_memory TO admins WITH GRANT OPTION;


--
-- Name: raw_memory2; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_memory2 TO PUBLIC;
GRANT ALL ON TABLE raw_memory2 TO admins WITH GRANT OPTION;


--
-- Name: raw_warnings; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_warnings TO PUBLIC;
GRANT ALL ON TABLE raw_warnings TO admins WITH GRANT OPTION;


--
-- Name: tbl_buildmetadata_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT ALL ON SEQUENCE tbl_buildmetadata_id TO PUBLIC;


--
-- Name: tbl_component_data; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_component_data TO PUBLIC;
GRANT ALL ON TABLE tbl_component_data TO admins WITH GRANT OPTION;


--
-- Name: tbl_cpu_data; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_cpu_data TO PUBLIC;
GRANT ALL ON TABLE tbl_cpu_data TO admins WITH GRANT OPTION;


--
-- Name: tbl_disk_freespace; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_disk_freespace TO PUBLIC;
GRANT ALL ON TABLE tbl_disk_freespace TO admins WITH GRANT OPTION;


--
-- Name: tbl_event_data; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_event_data TO PUBLIC;
GRANT ALL ON TABLE tbl_event_data TO admins WITH GRANT OPTION;


--
-- Name: tbl_memory_data; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_memory_data TO PUBLIC;
GRANT ALL ON TABLE tbl_memory_data TO admins WITH GRANT OPTION;


--
-- Name: tbl_warnings; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_warnings TO PUBLIC;
GRANT ALL ON TABLE tbl_warnings TO admins WITH GRANT OPTION;


--
-- Name: tmp_buildmetadata_id; Type: ACL; Schema: buildmetrics; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tmp_buildmetadata_id TO PUBLIC;
GRANT ALL ON TABLE tmp_buildmetadata_id TO admins WITH GRANT OPTION;


SET search_path = cateams, pg_catalog;

--
-- Name: cateamleaders; Type: ACL; Schema: cateams; Owner: postgres
--

GRANT ALL ON TABLE cateamleaders TO "SystemsTeam";


--
-- Name: cateammembers; Type: ACL; Schema: cateams; Owner: postgres
--

GRANT ALL ON TABLE cateammembers TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE cateammembers TO PUBLIC;
GRANT ALL ON TABLE cateammembers TO "DevEnablement";


--
-- Name: cateams; Type: ACL; Schema: cateams; Owner: postgres
--

GRANT ALL ON TABLE cateams TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE cateams TO PUBLIC;
GRANT ALL ON TABLE cateams TO "DevEnablement";


--
-- Name: scrumteams; Type: ACL; Schema: cateams; Owner: postgres
--

GRANT ALL ON TABLE scrumteams TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE scrumteams TO PUBLIC;
GRANT ALL ON TABLE scrumteams TO "DevEnablement";


--
-- Name: team_info_id; Type: ACL; Schema: cateams; Owner: postgres
--

GRANT ALL ON SEQUENCE team_info_id TO "SystemsTeam";
GRANT SELECT ON SEQUENCE team_info_id TO PUBLIC;
GRANT SELECT,UPDATE ON SEQUENCE team_info_id TO "DevEnablement";


--
-- Name: teamdata; Type: ACL; Schema: cateams; Owner: postgres
--

GRANT ALL ON TABLE teamdata TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE teamdata TO PUBLIC;
GRANT ALL ON TABLE teamdata TO "DevEnablement";


--
-- Name: teaminfo; Type: ACL; Schema: cateams; Owner: postgres
--

GRANT ALL ON TABLE teaminfo TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE teaminfo TO PUBLIC;
GRANT ALL ON TABLE teaminfo TO "DevEnablement";


SET search_path = cateams2, pg_catalog;

--
-- Name: ix_cateams_id; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_cateams_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_cateams_id TO "SystemsTeam";


--
-- Name: ix_cateams; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ix_cateams TO PUBLIC;
GRANT ALL ON TABLE ix_cateams TO admins;


--
-- Name: ix_domains_id; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_domains_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_domains_id TO "SystemsTeam";


--
-- Name: ix_domains; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ix_domains TO PUBLIC;
GRANT ALL ON TABLE ix_domains TO admins;


--
-- Name: ix_projects_id; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_projects_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_projects_id TO "SystemsTeam";


--
-- Name: ix_projects; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT ALL ON TABLE ix_projects TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE ix_projects TO PUBLIC;
GRANT ALL ON TABLE ix_projects TO admins;


--
-- Name: ix_server_scans_id; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_server_scans_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_server_scans_id TO "SystemsTeam";


--
-- Name: ix_server_scans; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ix_server_scans TO PUBLIC;
GRANT ALL ON TABLE ix_server_scans TO admins;


--
-- Name: tbl_cateamleaders; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_cateamleaders TO PUBLIC;
GRANT ALL ON TABLE tbl_cateamleaders TO admins;


--
-- Name: tbl_cateammembers; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_cateammembers TO PUBLIC;
GRANT ALL ON TABLE tbl_cateammembers TO admins;


--
-- Name: tbl_rally_info; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT ALL ON TABLE tbl_rally_info TO admins;


--
-- Name: tbl_teaminfo; Type: ACL; Schema: cateams2; Owner: postgres
--

GRANT ALL ON TABLE tbl_teaminfo TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE tbl_teaminfo TO PUBLIC;
GRANT ALL ON TABLE tbl_teaminfo TO admins;


SET search_path = cyclone, pg_catalog;

--
-- Name: raw_pr_ar; Type: ACL; Schema: cyclone; Owner: postgres
--

GRANT SELECT ON TABLE raw_pr_ar TO PUBLIC;


--
-- Name: tbl_pr_ar; Type: ACL; Schema: cyclone; Owner: postgres
--

GRANT SELECT ON TABLE tbl_pr_ar TO PUBLIC;


SET search_path = demo_packaging, pg_catalog;

--
-- Name: demo_buildnumber; Type: ACL; Schema: demo_packaging; Owner: postgres
--

GRANT ALL ON TABLE demo_buildnumber TO PUBLIC;
GRANT ALL ON TABLE demo_buildnumber TO edakka;


--
-- Name: demo_versions; Type: ACL; Schema: demo_packaging; Owner: postgres
--

GRANT ALL ON TABLE demo_versions TO PUBLIC;
GRANT ALL ON TABLE demo_versions TO edakka;


SET search_path = empdata, pg_catalog;

--
-- Name: current_employees; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE current_employees TO PUBLIC;
GRANT ALL ON TABLE current_employees TO admins WITH GRANT OPTION;


--
-- Name: ix_departments_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_departments_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_departments_id TO "SystemsTeam";


--
-- Name: ix_departments; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_departments TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_departments TO PUBLIC;


--
-- Name: ix_description_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_description_id TO PUBLIC;


--
-- Name: ix_description; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_description TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_description TO PUBLIC;


--
-- Name: ix_displayname_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_displayname_id TO PUBLIC;


--
-- Name: ix_displayname; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_displayname TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_displayname TO PUBLIC;


--
-- Name: ix_employee_name_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_employee_name_id TO PUBLIC;


--
-- Name: ix_employee_name; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_employee_name TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_employee_name TO PUBLIC;


--
-- Name: ix_employeetypes_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_employeetypes_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_employeetypes_id TO "SystemsTeam";


--
-- Name: ix_employeetypes; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_employeetypes TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_employeetypes TO PUBLIC;


--
-- Name: ix_officenames_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_officenames_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_officenames_id TO "SystemsTeam";


--
-- Name: ix_officenames; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_officenames TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_officenames TO PUBLIC;


--
-- Name: ix_primarygroupids_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_primarygroupids_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_primarygroupids_id TO "SystemsTeam";


--
-- Name: ix_primarygroupids; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_primarygroupids TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_primarygroupids TO PUBLIC;


--
-- Name: ix_samaccounttypes_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_samaccounttypes_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_samaccounttypes_id TO "SystemsTeam";


--
-- Name: ix_samaccounttypes; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_samaccounttypes TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_samaccounttypes TO PUBLIC;


--
-- Name: ix_states_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_states_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_states_id TO "SystemsTeam";


--
-- Name: ix_states; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_states TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_states TO PUBLIC;


--
-- Name: ix_title_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_title_id TO PUBLIC;


--
-- Name: ix_title; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_title TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_title TO PUBLIC;


--
-- Name: ix_useraccountcontrols_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_useraccountcontrols_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_useraccountcontrols_id TO "SystemsTeam";


--
-- Name: ix_useraccountcontrols; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_useraccountcontrols TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_useraccountcontrols TO PUBLIC;


--
-- Name: ix_zipcodes_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_zipcodes_id TO PUBLIC;
GRANT ALL ON SEQUENCE ix_zipcodes_id TO "SystemsTeam";


--
-- Name: ix_zipcodes; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE ix_zipcodes TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE ix_zipcodes TO PUBLIC;


--
-- Name: raw_ldapdata; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE raw_ldapdata TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE raw_ldapdata TO PUBLIC;
GRANT ALL ON TABLE raw_ldapdata TO "SystemsTeam";


--
-- Name: tbl_employees_logins; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE tbl_employees_logins TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE tbl_employees_logins TO PUBLIC;


--
-- Name: tmp_scan_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE tmp_scan_id TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE tmp_scan_id TO PUBLIC;


--
-- Name: usr_map_directors; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE usr_map_directors TO PUBLIC;
GRANT ALL ON TABLE usr_map_directors TO admins WITH GRANT OPTION;


--
-- Name: usr_top_mgrs_id; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_top_mgrs_id TO PUBLIC;
GRANT ALL ON SEQUENCE usr_top_mgrs_id TO "SystemsTeam";


--
-- Name: usr_top_mgrs; Type: ACL; Schema: empdata; Owner: postgres
--

GRANT ALL ON TABLE usr_top_mgrs TO admins WITH GRANT OPTION;
GRANT SELECT,REFERENCES ON TABLE usr_top_mgrs TO PUBLIC;


SET search_path = jenkins, pg_catalog;

--
-- Name: bak_ciplugin_history; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE bak_ciplugin_history TO PUBLIC;
GRANT ALL ON TABLE bak_ciplugin_history TO admins WITH GRANT OPTION;


--
-- Name: bak_ciplugins; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE bak_ciplugins TO PUBLIC;
GRANT ALL ON TABLE bak_ciplugins TO admins WITH GRANT OPTION;


--
-- Name: bak_ciserver_info; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE bak_ciserver_info TO PUBLIC;
GRANT ALL ON TABLE bak_ciserver_info TO admins WITH GRANT OPTION;


--
-- Name: ciadmins_id; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON SEQUENCE ciadmins_id TO PUBLIC;
GRANT ALL ON SEQUENCE ciadmins_id TO "SystemsTeam";


--
-- Name: ciadmins; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE ciadmins TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE ciadmins TO PUBLIC;
GRANT ALL ON TABLE ciadmins TO "DevEnablement";


--
-- Name: cibuilds; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE cibuilds TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE cibuilds TO PUBLIC;
GRANT ALL ON TABLE cibuilds TO "DevEnablement";


--
-- Name: job_id; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON SEQUENCE job_id TO "SystemsTeam";
GRANT SELECT ON SEQUENCE job_id TO PUBLIC;
GRANT SELECT,UPDATE ON SEQUENCE job_id TO "DevEnablement";


--
-- Name: cijobs; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE cijobs TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE cijobs TO PUBLIC;
GRANT ALL ON TABLE cijobs TO "DevEnablement";


--
-- Name: ciplugin_history; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE ciplugin_history TO "SystemsTeam";


--
-- Name: ciplugin_scans; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE ciplugin_scans TO "SystemsTeam";


--
-- Name: ciplugin_scans_id; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON SEQUENCE ciplugin_scans_id TO PUBLIC;
GRANT ALL ON SEQUENCE ciplugin_scans_id TO "SystemsTeam";


--
-- Name: ciplugins_id; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON SEQUENCE ciplugins_id TO PUBLIC;
GRANT ALL ON SEQUENCE ciplugins_id TO "SystemsTeam";


--
-- Name: ciplugins; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE ciplugins TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE ciplugins TO PUBLIC;
GRANT ALL ON TABLE ciplugins TO "DevEnablement";


--
-- Name: ciservers_id; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON SEQUENCE ciservers_id TO PUBLIC;
GRANT ALL ON SEQUENCE ciservers_id TO "SystemsTeam";


--
-- Name: ciservers; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE ciservers TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE ciservers TO PUBLIC;
GRANT ALL ON TABLE ciservers TO "DevEnablement";


--
-- Name: slave_id; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON SEQUENCE slave_id TO "SystemsTeam";
GRANT SELECT ON SEQUENCE slave_id TO PUBLIC;
GRANT SELECT,UPDATE ON SEQUENCE slave_id TO "DevEnablement";


--
-- Name: cislaves; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE cislaves TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE cislaves TO PUBLIC;
GRANT ALL ON TABLE cislaves TO "DevEnablement";


--
-- Name: ciserver overview; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "ciserver overview" TO PUBLIC;
GRANT ALL ON TABLE "ciserver overview" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "ciserver overview" TO "SystemsTeam";
GRANT ALL ON TABLE "ciserver overview" TO "DevEnablement";


--
-- Name: ciserver-overview; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "ciserver-overview" TO PUBLIC;
GRANT ALL ON TABLE "ciserver-overview" TO admins WITH GRANT OPTION;


--
-- Name: ciserver_status; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE ciserver_status TO admins;
GRANT SELECT,REFERENCES ON TABLE ciserver_status TO PUBLIC;


--
-- Name: ciserver-status; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE "ciserver-status" TO "SystemsTeam";


--
-- Name: ciserver_info; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE ciserver_info TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE ciserver_info TO PUBLIC;
GRANT ALL ON TABLE ciserver_info TO "DevEnablement";


--
-- Name: cislave-scans; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE "cislave-scans" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "cislave-scans" TO PUBLIC;
GRANT ALL ON TABLE "cislave-scans" TO "DevEnablement";


--
-- Name: current_ciadmins; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE current_ciadmins TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE current_ciadmins TO PUBLIC;
GRANT ALL ON TABLE current_ciadmins TO "DevEnablement";


--
-- Name: jenkins-resources; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE "jenkins-resources" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "jenkins-resources" TO PUBLIC;
GRANT ALL ON TABLE "jenkins-resources" TO "DevEnablement";


--
-- Name: plugins-summary; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE "plugins-summary" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "plugins-summary" TO PUBLIC;
GRANT ALL ON TABLE "plugins-summary" TO "DevEnablement";


--
-- Name: rawbuilds; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE rawbuilds TO PUBLIC;
GRANT ALL ON TABLE rawbuilds TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE rawbuilds TO "SystemsTeam";


--
-- Name: rawjobs; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE rawjobs TO PUBLIC;
GRANT ALL ON TABLE rawjobs TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE rawjobs TO "SystemsTeam";


--
-- Name: rawslaves; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE rawslaves TO PUBLIC;
GRANT ALL ON TABLE rawslaves TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE rawslaves TO "SystemsTeam";


--
-- Name: results_overview; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE results_overview TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE results_overview TO PUBLIC;
GRANT ALL ON TABLE results_overview TO "DevEnablement";


--
-- Name: server build counts (xtab); Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "server build counts (xtab)" TO PUBLIC;
GRANT ALL ON TABLE "server build counts (xtab)" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "server build counts (xtab)" TO "SystemsTeam";
GRANT ALL ON TABLE "server build counts (xtab)" TO "DevEnablement";


--
-- Name: server utilization; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "server utilization" TO PUBLIC;
GRANT ALL ON TABLE "server utilization" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "server utilization" TO "SystemsTeam";
GRANT ALL ON TABLE "server utilization" TO "DevEnablement";


--
-- Name: server utilization (xtab); Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "server utilization (xtab)" TO PUBLIC;
GRANT ALL ON TABLE "server utilization (xtab)" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "server utilization (xtab)" TO "SystemsTeam";
GRANT ALL ON TABLE "server utilization (xtab)" TO "DevEnablement";


--
-- Name: server_versions_id; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON SEQUENCE server_versions_id TO PUBLIC;
GRANT ALL ON SEQUENCE server_versions_id TO "SystemsTeam";


--
-- Name: server_versions; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT ALL ON TABLE server_versions TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE server_versions TO PUBLIC;
GRANT ALL ON TABLE server_versions TO "DevEnablement";


--
-- Name: tmp_plugins; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tmp_plugins TO PUBLIC;
GRANT ALL ON TABLE tmp_plugins TO admins WITH GRANT OPTION;


--
-- Name: tmp_scan_timedate; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tmp_scan_timedate TO PUBLIC;
GRANT ALL ON TABLE tmp_scan_timedate TO admins WITH GRANT OPTION;


--
-- Name: tmp_server_versions; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tmp_server_versions TO PUBLIC;
GRANT ALL ON TABLE tmp_server_versions TO admins WITH GRANT OPTION;


--
-- Name: weekly-job-summary; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "weekly-job-summary" TO PUBLIC;
GRANT ALL ON TABLE "weekly-job-summary" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "weekly-job-summary" TO "SystemsTeam";
GRANT ALL ON TABLE "weekly-job-summary" TO "DevEnablement";


--
-- Name: weekly-server-summary; Type: ACL; Schema: jenkins; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "weekly-server-summary" TO PUBLIC;
GRANT ALL ON TABLE "weekly-server-summary" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "weekly-server-summary" TO "SystemsTeam";
GRANT ALL ON TABLE "weekly-server-summary" TO "DevEnablement";


SET search_path = jenkinslogger, pg_catalog;

--
-- Name: baseresults_id; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT ALL ON SEQUENCE baseresults_id TO PUBLIC;
GRANT ALL ON SEQUENCE baseresults_id TO "SystemsTeam";


--
-- Name: baseresults; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE baseresults TO admins;
GRANT ALL ON TABLE baseresults TO PUBLIC;
GRANT ALL ON TABLE baseresults TO "FileFoundationTeam";


--
-- Name: etlresults; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE etlresults TO admins;
GRANT ALL ON TABLE etlresults TO PUBLIC;
GRANT ALL ON TABLE etlresults TO "FileFoundationTeam";


--
-- Name: ExcelMetrics; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT ALL ON TABLE "ExcelMetrics" TO PUBLIC;
GRANT ALL ON TABLE "ExcelMetrics" TO "FileFoundationTeam";


--
-- Name: artifacts; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE artifacts TO admins;
GRANT ALL ON TABLE artifacts TO PUBLIC;
GRANT ALL ON TABLE artifacts TO "FileFoundationTeam";


--
-- Name: ExcelMetricsArtifacts; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT ALL ON TABLE "ExcelMetricsArtifacts" TO PUBLIC;
GRANT ALL ON TABLE "ExcelMetricsArtifacts" TO "FileFoundationTeam";


--
-- Name: parameters; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE parameters TO admins;
GRANT ALL ON TABLE parameters TO PUBLIC;
GRANT ALL ON TABLE parameters TO "FileFoundationTeam";


--
-- Name: ExcelMetricsParameters; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT ALL ON TABLE "ExcelMetricsParameters" TO PUBLIC;
GRANT ALL ON TABLE "ExcelMetricsParameters" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "ExcelMetricsParameters" TO "FileFoundationTeam";


--
-- Name: activityflow; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE activityflow TO admins;
GRANT ALL ON TABLE activityflow TO PUBLIC;
GRANT ALL ON TABLE activityflow TO "FileFoundationTeam";


--
-- Name: array_association; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE array_association TO admins;
GRANT ALL ON TABLE array_association TO PUBLIC;
GRANT ALL ON TABLE array_association TO "FileFoundationTeam";


--
-- Name: arrays; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE arrays TO admins;
GRANT ALL ON TABLE arrays TO PUBLIC;
GRANT ALL ON TABLE arrays TO "FileFoundationTeam";


--
-- Name: builddefinitions; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE builddefinitions TO admins;
GRANT ALL ON TABLE builddefinitions TO PUBLIC;
GRANT ALL ON TABLE builddefinitions TO "FileFoundationTeam";


--
-- Name: celldefinition; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE celldefinition TO admins;
GRANT ALL ON TABLE celldefinition TO PUBLIC;
GRANT ALL ON TABLE celldefinition TO "FileFoundationTeam";


--
-- Name: equipmentdefinition; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE equipmentdefinition TO admins;
GRANT ALL ON TABLE equipmentdefinition TO PUBLIC;
GRANT ALL ON TABLE equipmentdefinition TO "FileFoundationTeam";


--
-- Name: jenkinscluster; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE jenkinscluster TO admins;
GRANT ALL ON TABLE jenkinscluster TO PUBLIC;
GRANT ALL ON TABLE jenkinscluster TO "FileFoundationTeam";


--
-- Name: jobdefinitions; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE jobdefinitions TO admins;
GRANT ALL ON TABLE jobdefinitions TO PUBLIC;
GRANT ALL ON TABLE jobdefinitions TO "FileFoundationTeam";


--
-- Name: pools; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE pools TO admins;
GRANT ALL ON TABLE pools TO PUBLIC;
GRANT ALL ON TABLE pools TO "FileFoundationTeam";


--
-- Name: testbeds; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE testbeds TO admins;
GRANT ALL ON TABLE testbeds TO PUBLIC;
GRANT ALL ON TABLE testbeds TO "FileFoundationTeam";


--
-- Name: testdefinitions; Type: ACL; Schema: jenkinslogger; Owner: postgres
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRUNCATE,UPDATE ON TABLE testdefinitions TO admins;
GRANT ALL ON TABLE testdefinitions TO PUBLIC;
GRANT ALL ON TABLE testdefinitions TO "FileFoundationTeam";


SET search_path = netstat, pg_catalog;

--
-- Name: ix_address_id; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_address_id TO PUBLIC;


--
-- Name: ix_address; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_address TO PUBLIC;
GRANT ALL ON TABLE ix_address TO admins WITH GRANT OPTION;


--
-- Name: ix_port_id; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_port_id TO PUBLIC;


--
-- Name: ix_port; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_port TO PUBLIC;
GRANT ALL ON TABLE ix_port TO admins WITH GRANT OPTION;


--
-- Name: tbl_datamover_id; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT ALL ON SEQUENCE tbl_datamover_id TO PUBLIC;


--
-- Name: tbl_datamover; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_datamover TO PUBLIC;
GRANT ALL ON TABLE tbl_datamover TO admins WITH GRANT OPTION;


--
-- Name: Busy DataMovers; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Busy DataMovers" TO PUBLIC;
GRANT ALL ON TABLE "Busy DataMovers" TO admins WITH GRANT OPTION;


--
-- Name: ix_proto_id; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_proto_id TO PUBLIC;


--
-- Name: ix_proto; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_proto TO PUBLIC;
GRANT ALL ON TABLE ix_proto TO admins WITH GRANT OPTION;


--
-- Name: ix_state_id; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_state_id TO PUBLIC;


--
-- Name: ix_state; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_state TO PUBLIC;
GRANT ALL ON TABLE ix_state TO admins WITH GRANT OPTION;


--
-- Name: DataMovers; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "DataMovers" TO PUBLIC;
GRANT ALL ON TABLE "DataMovers" TO admins WITH GRANT OPTION;


--
-- Name: rawdata; Type: ACL; Schema: netstat; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE rawdata TO PUBLIC;
GRANT ALL ON TABLE rawdata TO admins WITH GRANT OPTION;


SET search_path = public, pg_catalog;

--
-- Name: Build Record Comparison; Type: ACL; Schema: public; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Build Record Comparison" TO PUBLIC;
GRANT ALL ON TABLE "Build Record Comparison" TO admins WITH GRANT OPTION;


SET search_path = vcenter, pg_catalog;

--
-- Name: esxservers_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE esxservers_id TO PUBLIC;
GRANT ALL ON SEQUENCE esxservers_id TO "SystemsTeam";


--
-- Name: esxservers; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE esxservers TO PUBLIC;
GRANT ALL ON TABLE esxservers TO admins WITH GRANT OPTION;


--
-- Name: folders_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE folders_id TO PUBLIC;
GRANT ALL ON SEQUENCE folders_id TO "SystemsTeam";


--
-- Name: folders; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE folders TO PUBLIC;
GRANT ALL ON TABLE folders TO admins WITH GRANT OPTION;


--
-- Name: guestid_types_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE guestid_types_id TO PUBLIC;
GRANT ALL ON SEQUENCE guestid_types_id TO "SystemsTeam";


--
-- Name: guestid_types; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE guestid_types TO PUBLIC;
GRANT ALL ON TABLE guestid_types TO admins WITH GRANT OPTION;


--
-- Name: guestos_types_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE guestos_types_id TO PUBLIC;
GRANT ALL ON SEQUENCE guestos_types_id TO "SystemsTeam";


--
-- Name: guestos_types; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE guestos_types TO PUBLIC;
GRANT ALL ON TABLE guestos_types TO admins WITH GRANT OPTION;


--
-- Name: server_scans_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE server_scans_id TO PUBLIC;
GRANT ALL ON SEQUENCE server_scans_id TO "SystemsTeam";


--
-- Name: server_scans; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE server_scans TO PUBLIC;
GRANT ALL ON TABLE server_scans TO admins WITH GRANT OPTION;


--
-- Name: vminfo_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE vminfo_id TO PUBLIC;
GRANT ALL ON SEQUENCE vminfo_id TO "SystemsTeam";


--
-- Name: vminfo; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vminfo TO PUBLIC;
GRANT ALL ON TABLE vminfo TO admins WITH GRANT OPTION;


--
-- Name: vminfo_history; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vminfo_history TO PUBLIC;
GRANT ALL ON TABLE vminfo_history TO admins WITH GRANT OPTION;


--
-- Name: vms_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE vms_id TO PUBLIC;
GRANT ALL ON SEQUENCE vms_id TO "SystemsTeam";


--
-- Name: vms; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vms TO PUBLIC;
GRANT ALL ON TABLE vms TO admins WITH GRANT OPTION;


--
-- Name: current_vms; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE current_vms TO PUBLIC;
GRANT ALL ON TABLE current_vms TO admins WITH GRANT OPTION;


--
-- Name: Jenkins Servers; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Jenkins Servers" TO PUBLIC;
GRANT ALL ON TABLE "Jenkins Servers" TO "DevEnablement";
GRANT ALL ON TABLE "Jenkins Servers" TO admins WITH GRANT OPTION;


SET search_path = public, pg_catalog;

--
-- Name: ciservers; Type: ACL; Schema: public; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ciservers TO PUBLIC;
GRANT ALL ON TABLE ciservers TO admins WITH GRANT OPTION;


--
-- Name: daily_promotions; Type: ACL; Schema: public; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE daily_promotions TO PUBLIC;
GRANT ALL ON TABLE daily_promotions TO admins WITH GRANT OPTION;


SET search_path = rally, pg_catalog;

--
-- Name: ix_domains_id; Type: ACL; Schema: rally; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_domains_id TO PUBLIC;


--
-- Name: ix_domains; Type: ACL; Schema: rally; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ix_domains TO PUBLIC;
GRANT ALL ON TABLE ix_domains TO admins WITH GRANT OPTION;


--
-- Name: ix_rally_users_id; Type: ACL; Schema: rally; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_rally_users_id TO PUBLIC;


--
-- Name: tbl_rally_users; Type: ACL; Schema: rally; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_rally_users TO PUBLIC;
GRANT ALL ON TABLE tbl_rally_users TO admins WITH GRANT OPTION;


SET search_path = public, pg_catalog;

--
-- Name: domain_info; Type: ACL; Schema: public; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE domain_info TO PUBLIC;
GRANT ALL ON TABLE domain_info TO admins WITH GRANT OPTION;


--
-- Name: list_schema; Type: ACL; Schema: public; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE list_schema TO PUBLIC;
GRANT ALL ON TABLE list_schema TO admins WITH GRANT OPTION;


--
-- Name: ws-adoption; Type: ACL; Schema: public; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "ws-adoption" TO PUBLIC;
GRANT ALL ON TABLE "ws-adoption" TO admins WITH GRANT OPTION;


--
-- Name: ws-adoption2; Type: ACL; Schema: public; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "ws-adoption2" TO PUBLIC;
GRANT ALL ON TABLE "ws-adoption2" TO admins WITH GRANT OPTION;


SET search_path = rally, pg_catalog;

--
-- Name: ix_roles_id; Type: ACL; Schema: rally; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_roles_id TO PUBLIC;


--
-- Name: ix_roles; Type: ACL; Schema: rally; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ix_roles TO PUBLIC;
GRANT ALL ON TABLE ix_roles TO admins WITH GRANT OPTION;


--
-- Name: Domain Product Owners; Type: ACL; Schema: rally; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Domain Product Owners" TO PUBLIC;
GRANT ALL ON TABLE "Domain Product Owners" TO admins WITH GRANT OPTION;


--
-- Name: ix_costcenters_id; Type: ACL; Schema: rally; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_costcenters_id TO PUBLIC;


--
-- Name: ix_costcenters; Type: ACL; Schema: rally; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ix_costcenters TO PUBLIC;
GRANT ALL ON TABLE ix_costcenters TO admins WITH GRANT OPTION;


--
-- Name: ix_permissions_id; Type: ACL; Schema: rally; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_permissions_id TO PUBLIC;


--
-- Name: ix_permissions; Type: ACL; Schema: rally; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ix_permissions TO PUBLIC;
GRANT ALL ON TABLE ix_permissions TO admins WITH GRANT OPTION;


--
-- Name: ix_projects_id; Type: ACL; Schema: rally; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_projects_id TO PUBLIC;


--
-- Name: ix_projects; Type: ACL; Schema: rally; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ix_projects TO PUBLIC;
GRANT ALL ON TABLE ix_projects TO admins WITH GRANT OPTION;


--
-- Name: raw_rally; Type: ACL; Schema: rally; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_rally TO PUBLIC;
GRANT ALL ON TABLE raw_rally TO admins WITH GRANT OPTION;


--
-- Name: tbl_psi_timeboxes; Type: ACL; Schema: rally; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_psi_timeboxes TO PUBLIC;
GRANT ALL ON TABLE tbl_psi_timeboxes TO admins WITH GRANT OPTION;


SET search_path = remedy, pg_catalog;

--
-- Name: ix_major_area_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_major_area_id TO PUBLIC;


--
-- Name: ix_major_area; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_major_area TO PUBLIC;
GRANT ALL ON TABLE ix_major_area TO admins WITH GRANT OPTION;


--
-- Name: ix_ntlogin_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_ntlogin_id TO PUBLIC;


--
-- Name: ix_ntlogin; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_ntlogin TO PUBLIC;
GRANT ALL ON TABLE ix_ntlogin TO "DevEnablement";
GRANT ALL ON TABLE ix_ntlogin TO admins WITH GRANT OPTION;


--
-- Name: ix_priority_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_priority_id TO PUBLIC;


--
-- Name: ix_priority; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_priority TO PUBLIC;
GRANT ALL ON TABLE ix_priority TO "DevEnablement";
GRANT ALL ON TABLE ix_priority TO admins WITH GRANT OPTION;


--
-- Name: ix_product_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_product_id TO PUBLIC;


--
-- Name: ix_product; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_product TO PUBLIC;
GRANT ALL ON TABLE ix_product TO "DevEnablement";
GRANT ALL ON TABLE ix_product TO admins WITH GRANT OPTION;


--
-- Name: ix_product_area_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_product_area_id TO PUBLIC;


--
-- Name: ix_product_area; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_product_area TO PUBLIC;
GRANT ALL ON TABLE ix_product_area TO admins WITH GRANT OPTION;


--
-- Name: ix_product_family_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_product_family_id TO PUBLIC;


--
-- Name: ix_product_family; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_product_family TO PUBLIC;
GRANT ALL ON TABLE ix_product_family TO admins WITH GRANT OPTION;


--
-- Name: ix_product_release_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_product_release_id TO PUBLIC;


--
-- Name: ix_product_release; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_product_release TO PUBLIC;
GRANT ALL ON TABLE ix_product_release TO admins WITH GRANT OPTION;


--
-- Name: ix_status_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_status_id TO PUBLIC;


--
-- Name: ix_status; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_status TO PUBLIC;
GRANT ALL ON TABLE ix_status TO admins WITH GRANT OPTION;


--
-- Name: ix_status_details_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_status_details_id TO PUBLIC;


--
-- Name: ix_status_details; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_status_details TO PUBLIC;
GRANT ALL ON TABLE ix_status_details TO admins WITH GRANT OPTION;


--
-- Name: ix_type_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_type_id TO PUBLIC;


--
-- Name: ix_type; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_type TO PUBLIC;
GRANT ALL ON TABLE ix_type TO admins WITH GRANT OPTION;


--
-- Name: Current Issues; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Current Issues" TO PUBLIC;
GRANT ALL ON TABLE "Current Issues" TO "DevEnablement";
GRANT ALL ON TABLE "Current Issues" TO admins WITH GRANT OPTION;


--
-- Name: ix_classification_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_classification_id TO PUBLIC;


--
-- Name: ix_classification; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_classification TO PUBLIC;
GRANT ALL ON TABLE ix_classification TO admins WITH GRANT OPTION;


--
-- Name: ix_customer_impact_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_customer_impact_id TO PUBLIC;


--
-- Name: ix_customer_impact; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_customer_impact TO PUBLIC;
GRANT ALL ON TABLE ix_customer_impact TO admins WITH GRANT OPTION;


--
-- Name: ix_employee_names_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_employee_names_id TO PUBLIC;


--
-- Name: ix_employee_names; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_employee_names TO PUBLIC;
GRANT ALL ON TABLE ix_employee_names TO admins WITH GRANT OPTION;


--
-- Name: ix_escalate_reason_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_escalate_reason_id TO PUBLIC;


--
-- Name: ix_escalate_reason; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_escalate_reason TO PUBLIC;
GRANT ALL ON TABLE ix_escalate_reason TO admins WITH GRANT OPTION;


--
-- Name: ix_function_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_function_id TO PUBLIC;


--
-- Name: ix_function; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_function TO PUBLIC;
GRANT ALL ON TABLE ix_function TO admins WITH GRANT OPTION;


--
-- Name: ix_group_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_group_id TO PUBLIC;


--
-- Name: ix_group; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_group TO PUBLIC;
GRANT ALL ON TABLE ix_group TO admins WITH GRANT OPTION;


--
-- Name: ix_how_found_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_how_found_id TO PUBLIC;


--
-- Name: ix_how_found; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_how_found TO PUBLIC;
GRANT ALL ON TABLE ix_how_found TO admins WITH GRANT OPTION;


--
-- Name: ix_primus_needed_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_primus_needed_id TO PUBLIC;


--
-- Name: ix_primus_needed; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_primus_needed TO PUBLIC;
GRANT ALL ON TABLE ix_primus_needed TO admins WITH GRANT OPTION;


--
-- Name: ix_release_note_needed_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_release_note_needed_id TO PUBLIC;


--
-- Name: ix_release_note_needed; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_release_note_needed TO PUBLIC;
GRANT ALL ON TABLE ix_release_note_needed TO admins WITH GRANT OPTION;


--
-- Name: ix_releases_built_in_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_releases_built_in_id TO PUBLIC;


--
-- Name: ix_releases_built_in; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_releases_built_in TO PUBLIC;
GRANT ALL ON TABLE ix_releases_built_in TO admins WITH GRANT OPTION;


--
-- Name: ix_script_name_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_script_name_id TO PUBLIC;


--
-- Name: ix_script_name; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_script_name TO PUBLIC;
GRANT ALL ON TABLE ix_script_name TO admins WITH GRANT OPTION;


--
-- Name: tbl_issue_tracking; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_issue_tracking TO PUBLIC;
GRANT ALL ON TABLE tbl_issue_tracking TO "DevEnablement";
GRANT ALL ON TABLE tbl_issue_tracking TO admins WITH GRANT OPTION;


--
-- Name: tbl_share_audit; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_share_audit TO PUBLIC;
GRANT ALL ON TABLE tbl_share_audit TO admins WITH GRANT OPTION;


--
-- Name: Cyclone ARs; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Cyclone ARs" TO PUBLIC;
GRANT ALL ON TABLE "Cyclone ARs" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "Cyclone ARs" TO "DevEnablement";


--
-- Name: DevEcosystem ARs; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "DevEcosystem ARs" TO PUBLIC;
GRANT ALL ON TABLE "DevEcosystem ARs" TO "DevEnablement";
GRANT ALL ON TABLE "DevEcosystem ARs" TO admins WITH GRANT OPTION;


--
-- Name: Development Enablement; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Development Enablement" TO PUBLIC;
GRANT ALL ON TABLE "Development Enablement" TO "DevEnablement";
GRANT ALL ON TABLE "Development Enablement" TO admins WITH GRANT OPTION;


--
-- Name: ix_candidate_status_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_candidate_status_id TO PUBLIC;


--
-- Name: ix_candidate_status; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_candidate_status TO PUBLIC;
GRANT ALL ON TABLE ix_candidate_status TO admins WITH GRANT OPTION;


--
-- Name: ix_sp_target_release_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_sp_target_release_id TO PUBLIC;


--
-- Name: ix_sp_target_release; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_sp_target_release TO PUBLIC;
GRANT ALL ON TABLE ix_sp_target_release TO admins WITH GRANT OPTION;


--
-- Name: tbl_issue_escalation_join; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_issue_escalation_join TO PUBLIC;
GRANT ALL ON TABLE tbl_issue_escalation_join TO admins WITH GRANT OPTION;


--
-- Name: EMC:Issue Escalation Join; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:Issue Escalation Join" TO PUBLIC;
GRANT ALL ON TABLE "EMC:Issue Escalation Join" TO "DevEnablement";
GRANT ALL ON TABLE "EMC:Issue Escalation Join" TO admins WITH GRANT OPTION;


--
-- Name: tbl_issue_reported_by_manager_join; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_issue_reported_by_manager_join TO PUBLIC;
GRANT ALL ON TABLE tbl_issue_reported_by_manager_join TO admins WITH GRANT OPTION;


--
-- Name: EMC:Issue Reported by Manager Join; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:Issue Reported by Manager Join" TO PUBLIC;
GRANT ALL ON TABLE "EMC:Issue Reported by Manager Join" TO "DevEnablement";
GRANT ALL ON TABLE "EMC:Issue Reported by Manager Join" TO admins WITH GRANT OPTION;


--
-- Name: tbl_issue_descriptions; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_issue_descriptions TO PUBLIC;
GRANT ALL ON TABLE tbl_issue_descriptions TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE tbl_issue_descriptions TO "DevEnablement";


--
-- Name: EMC:Issue Tracking; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:Issue Tracking" TO PUBLIC;
GRANT ALL ON TABLE "EMC:Issue Tracking" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "EMC:Issue Tracking" TO "DevEnablement";


--
-- Name: ix_functional_area_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_functional_area_id TO PUBLIC;


--
-- Name: ix_functional_area; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_functional_area TO PUBLIC;
GRANT ALL ON TABLE ix_functional_area TO admins WITH GRANT OPTION;


--
-- Name: ix_request_type_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_request_type_id TO PUBLIC;


--
-- Name: ix_request_type; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_request_type TO PUBLIC;
GRANT ALL ON TABLE ix_request_type TO admins WITH GRANT OPTION;


--
-- Name: tbl_release_engineering_tracker; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_release_engineering_tracker TO PUBLIC;
GRANT ALL ON TABLE tbl_release_engineering_tracker TO admins WITH GRANT OPTION;


--
-- Name: EMC:Release Engineering Tracker; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:Release Engineering Tracker" TO PUBLIC;
GRANT ALL ON TABLE "EMC:Release Engineering Tracker" TO "DevEnablement";
GRANT ALL ON TABLE "EMC:Release Engineering Tracker" TO admins WITH GRANT OPTION;


--
-- Name: tbl_releases; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_releases TO PUBLIC;
GRANT ALL ON TABLE tbl_releases TO admins WITH GRANT OPTION;


--
-- Name: EMC:Releases; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:Releases" TO PUBLIC;
GRANT ALL ON TABLE "EMC:Releases" TO "DevEnablement";
GRANT ALL ON TABLE "EMC:Releases" TO admins WITH GRANT OPTION;


--
-- Name: ix_relationship_type_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_relationship_type_id TO PUBLIC;


--
-- Name: ix_relationship_type; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_relationship_type TO PUBLIC;
GRANT ALL ON TABLE ix_relationship_type TO admins WITH GRANT OPTION;


--
-- Name: tbl_share_association; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_share_association TO PUBLIC;
GRANT ALL ON TABLE tbl_share_association TO admins WITH GRANT OPTION;


--
-- Name: EMC:SHARE Association; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:SHARE Association" TO PUBLIC;
GRANT ALL ON TABLE "EMC:SHARE Association" TO "DevEnablement";
GRANT ALL ON TABLE "EMC:SHARE Association" TO admins WITH GRANT OPTION;


--
-- Name: ix_audit_attribute_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_audit_attribute_id TO PUBLIC;


--
-- Name: ix_audit_attribute; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_audit_attribute TO PUBLIC;
GRANT ALL ON TABLE ix_audit_attribute TO admins WITH GRANT OPTION;


--
-- Name: EMC:SHARE Audit; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:SHARE Audit" TO PUBLIC;
GRANT ALL ON TABLE "EMC:SHARE Audit" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "EMC:SHARE Audit" TO "DevEnablement";


--
-- Name: ix_badgeid_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_badgeid_id TO PUBLIC;


--
-- Name: ix_badgeid; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_badgeid TO PUBLIC;
GRANT ALL ON TABLE ix_badgeid TO "DevEnablement";
GRANT ALL ON TABLE ix_badgeid TO admins WITH GRANT OPTION;


--
-- Name: ix_email_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_email_id TO PUBLIC;


--
-- Name: ix_email; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_email TO PUBLIC;
GRANT ALL ON TABLE ix_email TO "DevEnablement";
GRANT ALL ON TABLE ix_email TO admins WITH GRANT OPTION;


--
-- Name: ix_givenname_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_givenname_id TO PUBLIC;


--
-- Name: ix_givenname; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_givenname TO PUBLIC;
GRANT ALL ON TABLE ix_givenname TO "DevEnablement";
GRANT ALL ON TABLE ix_givenname TO admins WITH GRANT OPTION;


--
-- Name: ix_surname_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_surname_id TO PUBLIC;


--
-- Name: ix_surname; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_surname TO PUBLIC;
GRANT ALL ON TABLE ix_surname TO "DevEnablement";
GRANT ALL ON TABLE ix_surname TO admins WITH GRANT OPTION;


--
-- Name: tbl_share_employee; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_share_employee TO PUBLIC;
GRANT ALL ON TABLE tbl_share_employee TO admins WITH GRANT OPTION;


--
-- Name: EMC:SHARE Employee; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:SHARE Employee" TO PUBLIC;
GRANT ALL ON TABLE "EMC:SHARE Employee" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "EMC:SHARE Employee" TO "DevEnablement";


--
-- Name: tbl_share_notes; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_share_notes TO PUBLIC;
GRANT ALL ON TABLE tbl_share_notes TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE tbl_share_notes TO "DevEnablement";


--
-- Name: EMC:SHARE Notes; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:SHARE Notes" TO PUBLIC;
GRANT ALL ON TABLE "EMC:SHARE Notes" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "EMC:SHARE Notes" TO "DevEnablement";


--
-- Name: ix_release_name_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_release_name_id TO PUBLIC;


--
-- Name: ix_release_name; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_release_name TO PUBLIC;
GRANT ALL ON TABLE ix_release_name TO admins WITH GRANT OPTION;


--
-- Name: tbl_share_release_association; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_share_release_association TO PUBLIC;
GRANT ALL ON TABLE tbl_share_release_association TO admins WITH GRANT OPTION;


--
-- Name: EMC:SHARE Release Association; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:SHARE Release Association" TO PUBLIC;
GRANT ALL ON TABLE "EMC:SHARE Release Association" TO "DevEnablement";
GRANT ALL ON TABLE "EMC:SHARE Release Association" TO admins WITH GRANT OPTION;


--
-- Name: tbl_share_user_notification; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_share_user_notification TO PUBLIC;
GRANT ALL ON TABLE tbl_share_user_notification TO admins WITH GRANT OPTION;


--
-- Name: EMC:SHARE User Notification; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "EMC:SHARE User Notification" TO PUBLIC;
GRANT ALL ON TABLE "EMC:SHARE User Notification" TO "DevEnablement";
GRANT ALL ON TABLE "EMC:SHARE User Notification" TO admins WITH GRANT OPTION;


--
-- Name: ix_how_found_main_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_how_found_main_id TO PUBLIC;


--
-- Name: ix_how_found_main; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_how_found_main TO PUBLIC;
GRANT ALL ON TABLE ix_how_found_main TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ix_how_found_main TO "DevEnablement";


--
-- Name: tbl_how_found; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_how_found TO PUBLIC;
GRANT ALL ON TABLE tbl_how_found TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE tbl_how_found TO "DevEnablement";


--
-- Name: How Found; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "How Found" TO PUBLIC;
GRANT ALL ON TABLE "How Found" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "How Found" TO "DevEnablement";


--
-- Name: NON-AR audit records; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "NON-AR audit records" TO PUBLIC;
GRANT ALL ON TABLE "NON-AR audit records" TO "DevEnablement";
GRANT ALL ON TABLE "NON-AR audit records" TO admins WITH GRANT OPTION;


--
-- Name: tbl_ret_overview; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_ret_overview TO PUBLIC;
GRANT ALL ON TABLE tbl_ret_overview TO "DevEnablement";
GRANT ALL ON TABLE tbl_ret_overview TO admins WITH GRANT OPTION;


--
-- Name: RETs Overview; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "RETs Overview" TO PUBLIC;
GRANT ALL ON TABLE "RETs Overview" TO "DevEnablement";
GRANT ALL ON TABLE "RETs Overview" TO admins WITH GRANT OPTION;


--
-- Name: Release Engineering: Activity all; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Release Engineering: Activity all" TO PUBLIC;
GRANT ALL ON TABLE "Release Engineering: Activity all" TO "DevEnablement";
GRANT ALL ON TABLE "Release Engineering: Activity all" TO admins WITH GRANT OPTION;


--
-- Name: Release Engineering: Activity last week; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Release Engineering: Activity last week" TO PUBLIC;
GRANT ALL ON TABLE "Release Engineering: Activity last week" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "Release Engineering: Activity last week" TO "DevEnablement";


--
-- Name: Release Engineering: Open RET Aging; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Release Engineering: Open RET Aging" TO PUBLIC;
GRANT ALL ON TABLE "Release Engineering: Open RET Aging" TO "DevEnablement";
GRANT ALL ON TABLE "Release Engineering: Open RET Aging" TO admins WITH GRANT OPTION;


--
-- Name: Release Engineering: Overview; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Release Engineering: Overview" TO PUBLIC;
GRANT ALL ON TABLE "Release Engineering: Overview" TO "DevEnablement";
GRANT ALL ON TABLE "Release Engineering: Overview" TO admins WITH GRANT OPTION;


--
-- Name: usr_report_definitions_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_report_definitions_id TO PUBLIC;


--
-- Name: usr_report_definitions; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE usr_report_definitions TO PUBLIC;
GRANT ALL ON TABLE usr_report_definitions TO "DevEnablement";
GRANT ALL ON TABLE usr_report_definitions TO admins WITH GRANT OPTION;


--
-- Name: User Report Definitions; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "User Report Definitions" TO PUBLIC;
GRANT ALL ON TABLE "User Report Definitions" TO "DevEnablement";
GRANT ALL ON TABLE "User Report Definitions" TO admins WITH GRANT OPTION;


--
-- Name: history_issue_weekly; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE history_issue_weekly TO PUBLIC;
GRANT ALL ON TABLE history_issue_weekly TO "DevEnablement";
GRANT ALL ON TABLE history_issue_weekly TO admins WITH GRANT OPTION;


--
-- Name: ix_audit_fields_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_audit_fields_id TO PUBLIC;


--
-- Name: ix_audit_fields; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_audit_fields TO PUBLIC;
GRANT ALL ON TABLE ix_audit_fields TO "DevEnablement";
GRANT ALL ON TABLE ix_audit_fields TO admins WITH GRANT OPTION;


--
-- Name: ix_history; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_history TO PUBLIC;
GRANT ALL ON TABLE ix_history TO "DevEnablement";
GRANT ALL ON TABLE ix_history TO admins WITH GRANT OPTION;


--
-- Name: raw_how_found; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_how_found TO PUBLIC;
GRANT ALL ON TABLE raw_how_found TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE raw_how_found TO "DevEnablement";


--
-- Name: raw_issue_descriptions; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_issue_descriptions TO PUBLIC;
GRANT ALL ON TABLE raw_issue_descriptions TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE raw_issue_descriptions TO "DevEnablement";


--
-- Name: raw_issue_escalation_join; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_issue_escalation_join TO PUBLIC;
GRANT ALL ON TABLE raw_issue_escalation_join TO admins WITH GRANT OPTION;


--
-- Name: raw_issue_notify_list; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_issue_notify_list TO PUBLIC;
GRANT ALL ON TABLE raw_issue_notify_list TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE raw_issue_notify_list TO "DevEnablement";


--
-- Name: raw_issue_reported_by_manager_join; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_issue_reported_by_manager_join TO PUBLIC;
GRANT ALL ON TABLE raw_issue_reported_by_manager_join TO admins WITH GRANT OPTION;


--
-- Name: raw_issue_tracking; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_issue_tracking TO PUBLIC;
GRANT ALL ON TABLE raw_issue_tracking TO "DevEnablement";
GRANT ALL ON TABLE raw_issue_tracking TO admins WITH GRANT OPTION;


--
-- Name: raw_jira_ars; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_jira_ars TO PUBLIC;
GRANT ALL ON TABLE raw_jira_ars TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE raw_jira_ars TO "DevEnablement";


--
-- Name: raw_other; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_other TO PUBLIC;
GRANT ALL ON TABLE raw_other TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE raw_other TO "DevEnablement";


--
-- Name: raw_release_engineering_tracker; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_release_engineering_tracker TO PUBLIC;
GRANT ALL ON TABLE raw_release_engineering_tracker TO admins WITH GRANT OPTION;


--
-- Name: raw_releases; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_releases TO PUBLIC;
GRANT ALL ON TABLE raw_releases TO admins WITH GRANT OPTION;


--
-- Name: raw_report_definitions; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_report_definitions TO PUBLIC;
GRANT ALL ON TABLE raw_report_definitions TO "DevEnablement";
GRANT ALL ON TABLE raw_report_definitions TO admins WITH GRANT OPTION;


--
-- Name: raw_share_association; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_share_association TO PUBLIC;
GRANT ALL ON TABLE raw_share_association TO admins WITH GRANT OPTION;


--
-- Name: raw_share_audit; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_share_audit TO PUBLIC;
GRANT ALL ON TABLE raw_share_audit TO admins WITH GRANT OPTION;


--
-- Name: raw_share_employee; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_share_employee TO PUBLIC;
GRANT ALL ON TABLE raw_share_employee TO admins WITH GRANT OPTION;


--
-- Name: raw_share_notes; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_share_notes TO PUBLIC;
GRANT ALL ON TABLE raw_share_notes TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE raw_share_notes TO "DevEnablement";


--
-- Name: raw_share_release_association; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_share_release_association TO PUBLIC;
GRANT ALL ON TABLE raw_share_release_association TO admins WITH GRANT OPTION;


--
-- Name: raw_share_user_notification; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_share_user_notification TO PUBLIC;
GRANT ALL ON TABLE raw_share_user_notification TO admins WITH GRANT OPTION;


--
-- Name: tbl_issue_status; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE tbl_issue_status TO PUBLIC;
GRANT ALL ON TABLE tbl_issue_status TO "DevEnablement";
GRANT ALL ON TABLE tbl_issue_status TO admins WITH GRANT OPTION;


--
-- Name: tbl_issuetracking_products; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_issuetracking_products TO PUBLIC;
GRANT ALL ON TABLE tbl_issuetracking_products TO "DevEnablement";
GRANT ALL ON TABLE tbl_issuetracking_products TO admins WITH GRANT OPTION;


--
-- Name: tbl_other; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tbl_other TO PUBLIC;
GRANT ALL ON TABLE tbl_other TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE tbl_other TO "DevEnablement";


--
-- Name: tmp_entryid_20170927; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tmp_entryid_20170927 TO PUBLIC;
GRANT ALL ON TABLE tmp_entryid_20170927 TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE tmp_entryid_20170927 TO "DevEnablement";


--
-- Name: tmp_entryid_20170928; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tmp_entryid_20170928 TO PUBLIC;
GRANT ALL ON TABLE tmp_entryid_20170928 TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE tmp_entryid_20170928 TO "DevEnablement";


--
-- Name: tmp_entryid_20171009; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tmp_entryid_20171009 TO PUBLIC;
GRANT ALL ON TABLE tmp_entryid_20171009 TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE tmp_entryid_20171009 TO "DevEnablement";


--
-- Name: tmp_ix_history; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON TABLE tmp_ix_history TO "DevEnablement";
GRANT ALL ON TABLE tmp_ix_history TO admins WITH GRANT OPTION;
GRANT SELECT,INSERT,REFERENCES,TRUNCATE,UPDATE ON TABLE tmp_ix_history TO PUBLIC;


--
-- Name: usr_closed_status_detail_id; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT ALL ON SEQUENCE usr_closed_status_detail_id TO PUBLIC;


--
-- Name: usr_closed_status_detail; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_closed_status_detail TO PUBLIC;
GRANT ALL ON TABLE usr_closed_status_detail TO "DevEnablement";
GRANT ALL ON TABLE usr_closed_status_detail TO admins WITH GRANT OPTION;


--
-- Name: usr_issue_tracking_attributes; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE usr_issue_tracking_attributes TO PUBLIC;
GRANT ALL ON TABLE usr_issue_tracking_attributes TO "DevEnablement";
GRANT ALL ON TABLE usr_issue_tracking_attributes TO admins WITH GRANT OPTION;


--
-- Name: usr_managerspo_priority_offsets; Type: ACL; Schema: remedy; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE usr_managerspo_priority_offsets TO PUBLIC;
GRANT ALL ON TABLE usr_managerspo_priority_offsets TO "DevEnablement";
GRANT ALL ON TABLE usr_managerspo_priority_offsets TO admins WITH GRANT OPTION;


SET search_path = shares, pg_catalog;

--
-- Name: rpmdir; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON SEQUENCE rpmdir TO "SystemsTeam";
GRANT SELECT ON SEQUENCE rpmdir TO PUBLIC;
GRANT SELECT,UPDATE ON SEQUENCE rpmdir TO "DevEnablement";


--
-- Name: buildsharedirs; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE buildsharedirs TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE buildsharedirs TO PUBLIC;
GRANT ALL ON TABLE buildsharedirs TO "DevEnablement";


--
-- Name: current_buildshare; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE current_buildshare TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE current_buildshare TO PUBLIC;
GRANT ALL ON TABLE current_buildshare TO "DevEnablement";


--
-- Name: builddirs; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE builddirs TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE builddirs TO PUBLIC;


--
-- Name: stream_id; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON SEQUENCE stream_id TO "SystemsTeam";
GRANT SELECT ON SEQUENCE stream_id TO PUBLIC;
GRANT SELECT,UPDATE ON SEQUENCE stream_id TO "DevEnablement";


--
-- Name: cistreams; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE cistreams TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE cistreams TO PUBLIC;
GRANT ALL ON TABLE cistreams TO "DevEnablement";


--
-- Name: current_rpmjobs; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE current_rpmjobs TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE current_rpmjobs TO PUBLIC;
GRANT ALL ON TABLE current_rpmjobs TO "DevEnablement";


--
-- Name: rpmbuilds; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE rpmbuilds TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE rpmbuilds TO PUBLIC;
GRANT ALL ON TABLE rpmbuilds TO "DevEnablement";


--
-- Name: rpmjob; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON SEQUENCE rpmjob TO "SystemsTeam";
GRANT SELECT ON SEQUENCE rpmjob TO PUBLIC;
GRANT SELECT,UPDATE ON SEQUENCE rpmjob TO "DevEnablement";


--
-- Name: rpmjobs; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE rpmjobs TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE rpmjobs TO PUBLIC;
GRANT ALL ON TABLE rpmjobs TO "DevEnablement";


--
-- Name: rpmlocations; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE rpmlocations TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE rpmlocations TO PUBLIC;
GRANT ALL ON TABLE rpmlocations TO "DevEnablement";


--
-- Name: builds info; Type: ACL; Schema: shares; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "builds info" TO PUBLIC;
GRANT ALL ON TABLE "builds info" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "builds info" TO "SystemsTeam";
GRANT ALL ON TABLE "builds info" TO "DevEnablement";


--
-- Name: builds overview; Type: ACL; Schema: shares; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "builds overview" TO PUBLIC;
GRANT ALL ON TABLE "builds overview" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "builds overview" TO "SystemsTeam";
GRANT ALL ON TABLE "builds overview" TO "DevEnablement";


--
-- Name: builds_info; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE builds_info TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE builds_info TO PUBLIC;
GRANT ALL ON TABLE builds_info TO "DevEnablement";


--
-- Name: builds_overview; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE builds_overview TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE builds_overview TO PUBLIC;
GRANT ALL ON TABLE builds_overview TO "DevEnablement";


--
-- Name: rpmscans; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE rpmscans TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE rpmscans TO PUBLIC;
GRANT ALL ON TABLE rpmscans TO "DevEnablement";


--
-- Name: filescan.csv; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE "filescan.csv" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "filescan.csv" TO PUBLIC;
GRANT ALL ON TABLE "filescan.csv" TO "DevEnablement";


--
-- Name: history_buildshare; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE history_buildshare TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE history_buildshare TO PUBLIC;
GRANT ALL ON TABLE history_buildshare TO "DevEnablement";


--
-- Name: history_rpmjobs; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE history_rpmjobs TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE history_rpmjobs TO PUBLIC;
GRANT ALL ON TABLE history_rpmjobs TO "DevEnablement";


--
-- Name: rpmbuild.csv; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE "rpmbuild.csv" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "rpmbuild.csv" TO PUBLIC;
GRANT ALL ON TABLE "rpmbuild.csv" TO "DevEnablement";


--
-- Name: rpmjob.csv; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE "rpmjob.csv" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "rpmjob.csv" TO PUBLIC;
GRANT ALL ON TABLE "rpmjob.csv" TO "DevEnablement";


--
-- Name: rpmscan; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON SEQUENCE rpmscan TO "SystemsTeam";
GRANT SELECT ON SEQUENCE rpmscan TO PUBLIC;
GRANT SELECT,UPDATE ON SEQUENCE rpmscan TO "DevEnablement";


--
-- Name: rpmscan.csv; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE "rpmscan.csv" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "rpmscan.csv" TO PUBLIC;
GRANT ALL ON TABLE "rpmscan.csv" TO "DevEnablement";


--
-- Name: sharedirs overview; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE "sharedirs overview" TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE "sharedirs overview" TO PUBLIC;


--
-- Name: validfiles; Type: ACL; Schema: shares; Owner: postgres
--

GRANT ALL ON TABLE validfiles TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE validfiles TO PUBLIC;
GRANT ALL ON TABLE validfiles TO "DevEnablement";


SET search_path = vcenter, pg_catalog;

--
-- Name: 2015-12-14.Poweroff; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "2015-12-14.Poweroff" TO PUBLIC;
GRANT ALL ON TABLE "2015-12-14.Poweroff" TO admins WITH GRANT OPTION;


--
-- Name: 2016-01-29.VMs for deletion; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "2016-01-29.VMs for deletion" TO PUBLIC;
GRANT ALL ON TABLE "2016-01-29.VMs for deletion" TO admins WITH GRANT OPTION;


--
-- Name: 2016-02-14.VMs for deletion; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "2016-02-14.VMs for deletion" TO PUBLIC;
GRANT ALL ON TABLE "2016-02-14.VMs for deletion" TO admins WITH GRANT OPTION;


--
-- Name: 2016-02-29.Categories; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "2016-02-29.Categories" TO PUBLIC;
GRANT ALL ON TABLE "2016-02-29.Categories" TO admins WITH GRANT OPTION;


--
-- Name: 2016-04-18.ip reassignments; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "2016-04-18.ip reassignments" TO PUBLIC;
GRANT ALL ON TABLE "2016-04-18.ip reassignments" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "2016-04-18.ip reassignments" TO "DevEnablement";


--
-- Name: 2016-10-06.usd_cloud powered-off vms; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "2016-10-06.usd_cloud powered-off vms" TO PUBLIC;
GRANT ALL ON TABLE "2016-10-06.usd_cloud powered-off vms" TO "DevEnablement";
GRANT ALL ON TABLE "2016-10-06.usd_cloud powered-off vms" TO admins WITH GRANT OPTION;


--
-- Name: 2017-11-06.usd_cloud_master; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "2017-11-06.usd_cloud_master" TO PUBLIC;
GRANT ALL ON TABLE "2017-11-06.usd_cloud_master" TO "DevEnablement";
GRANT ALL ON TABLE "2017-11-06.usd_cloud_master" TO admins WITH GRANT OPTION;


--
-- Name: tools_status_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE tools_status_id TO PUBLIC;


--
-- Name: tools_status; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tools_status TO PUBLIC;
GRANT ALL ON TABLE tools_status TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE tools_status TO "DevEnablement";


--
-- Name: tools_version_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE tools_version_id TO PUBLIC;


--
-- Name: tools_version; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tools_version TO PUBLIC;
GRANT ALL ON TABLE tools_version TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE tools_version TO "DevEnablement";


--
-- Name: tools_version_status_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE tools_version_status_id TO PUBLIC;


--
-- Name: tools_version_status; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE tools_version_status TO PUBLIC;
GRANT ALL ON TABLE tools_version_status TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE tools_version_status TO "DevEnablement";


--
-- Name: vmcategory; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vmcategory TO PUBLIC;
GRANT ALL ON TABLE vmcategory TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE vmcategory TO "DevEnablement";


--
-- Name: vmcategory_types_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE vmcategory_types_id TO PUBLIC;
GRANT ALL ON SEQUENCE vmcategory_types_id TO "SystemsTeam";


--
-- Name: vmcategory_types; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vmcategory_types TO PUBLIC;
GRANT ALL ON TABLE vmcategory_types TO admins WITH GRANT OPTION;


--
-- Name: All VMs; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "All VMs" TO PUBLIC;
GRANT ALL ON TABLE "All VMs" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "All VMs" TO "DevEnablement";


--
-- Name: Current Categorized VMs; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Current Categorized VMs" TO PUBLIC;
GRANT ALL ON TABLE "Current Categorized VMs" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "Current Categorized VMs" TO "DevEnablement";


--
-- Name: RE physical assets; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "RE physical assets" TO PUBLIC;
GRANT ALL ON TABLE "RE physical assets" TO admins WITH GRANT OPTION;


--
-- Name: Hopkinton All VMs; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Hopkinton All VMs" TO PUBLIC;
GRANT ALL ON TABLE "Hopkinton All VMs" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "Hopkinton All VMs" TO "DevEnablement";


--
-- Name: IP address ranges; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "IP address ranges" TO PUBLIC;
GRANT ALL ON TABLE "IP address ranges" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "IP address ranges" TO "DevEnablement";


--
-- Name: Name Lookup; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Name Lookup" TO PUBLIC;
GRANT ALL ON TABLE "Name Lookup" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "Name Lookup" TO "DevEnablement";


--
-- Name: SLES12 Migration; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "SLES12 Migration" TO PUBLIC;
GRANT ALL ON TABLE "SLES12 Migration" TO admins WITH GRANT OPTION;


--
-- Name: SLES12 Migration Info; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "SLES12 Migration Info" TO PUBLIC;
GRANT ALL ON TABLE "SLES12 Migration Info" TO admins WITH GRANT OPTION;


--
-- Name: Powered-On SELS11; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Powered-On SELS11" TO PUBLIC;
GRANT ALL ON TABLE "Powered-On SELS11" TO admins WITH GRANT OPTION;


--
-- Name: RE phys 2; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "RE phys 2" TO PUBLIC;
GRANT ALL ON TABLE "RE phys 2" TO admins WITH GRANT OPTION;


--
-- Name: SLES12 SignUp; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "SLES12 SignUp" TO PUBLIC;
GRANT ALL ON TABLE "SLES12 SignUp" TO admins WITH GRANT OPTION;


--
-- Name: SLES12 trade ins; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "SLES12 trade ins" TO PUBLIC;
GRANT ALL ON TABLE "SLES12 trade ins" TO "DevEnablement";
GRANT ALL ON TABLE "SLES12 trade ins" TO admins WITH GRANT OPTION;


--
-- Name: hardware_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE hardware_id TO PUBLIC;


--
-- Name: hardware; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE hardware TO PUBLIC;
GRANT ALL ON TABLE hardware TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE hardware TO "DevEnablement";


--
-- Name: historical_overview; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE historical_overview TO PUBLIC;
GRANT ALL ON TABLE historical_overview TO admins WITH GRANT OPTION;


--
-- Name: ipaddresses; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE ipaddresses TO PUBLIC;
GRANT ALL ON TABLE ipaddresses TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ipaddresses TO "DevEnablement";


--
-- Name: ix_vcenter_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE ix_vcenter_id TO PUBLIC;


--
-- Name: ix_vcenter; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES,TRIGGER ON TABLE ix_vcenter TO PUBLIC;
GRANT ALL ON TABLE ix_vcenter TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE ix_vcenter TO "DevEnablement";


--
-- Name: raw_data; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_data TO PUBLIC;
GRANT ALL ON TABLE raw_data TO admins WITH GRANT OPTION;


--
-- Name: vmexists; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vmexists TO PUBLIC;
GRANT ALL ON TABLE vmexists TO admins WITH GRANT OPTION;


--
-- Name: overview; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE overview TO PUBLIC;
GRANT ALL ON TABLE overview TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE overview TO "DevEnablement";


--
-- Name: purpose_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE purpose_id TO PUBLIC;


--
-- Name: purpose; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE purpose TO PUBLIC;
GRANT ALL ON TABLE purpose TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE purpose TO "DevEnablement";


--
-- Name: rack_location_id; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE rack_location_id TO PUBLIC;


--
-- Name: rack_location; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE rack_location TO PUBLIC;
GRANT ALL ON TABLE rack_location TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE rack_location TO "DevEnablement";


--
-- Name: raw_data_normalized; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_data_normalized TO PUBLIC;
GRANT ALL ON TABLE raw_data_normalized TO admins WITH GRANT OPTION;


--
-- Name: raw_folders; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_folders TO PUBLIC;
GRANT ALL ON TABLE raw_folders TO admins WITH GRANT OPTION;


--
-- Name: raw_subnets; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_subnets TO PUBLIC;
GRANT ALL ON TABLE raw_subnets TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE raw_subnets TO "DevEnablement";


--
-- Name: releng_vminfo; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE releng_vminfo TO PUBLIC;
GRANT ALL ON TABLE releng_vminfo TO admins WITH GRANT OPTION;


--
-- Name: summary; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE summary TO PUBLIC;
GRANT ALL ON TABLE summary TO admins WITH GRANT OPTION;


--
-- Name: summary2; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE summary2 TO PUBLIC;
GRANT ALL ON TABLE summary2 TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE summary2 TO "DevEnablement";


--
-- Name: vminfo_history_distribution; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vminfo_history_distribution TO PUBLIC;
GRANT ALL ON TABLE vminfo_history_distribution TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE vminfo_history_distribution TO "DevEnablement";


--
-- Name: xxx; Type: ACL; Schema: vcenter; Owner: postgres
--

GRANT ALL ON SEQUENCE xxx TO PUBLIC;


SET search_path = vdiscover, pg_catalog;

--
-- Name: poweroff_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE poweroff_id TO PUBLIC;
GRANT ALL ON SEQUENCE poweroff_id TO "SystemsTeam";


--
-- Name: 2015-12-14.Poweroff; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON TABLE "2015-12-14.Poweroff" TO admins;
GRANT SELECT,REFERENCES ON TABLE "2015-12-14.Poweroff" TO PUBLIC;


--
-- Name: 2016-01-29.VMs for deletion; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "2016-01-29.VMs for deletion" TO PUBLIC;
GRANT ALL ON TABLE "2016-01-29.VMs for deletion" TO admins WITH GRANT OPTION;


--
-- Name: err_errors_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE err_errors_id TO PUBLIC;


--
-- Name: err_errors; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE err_errors TO PUBLIC;
GRANT ALL ON TABLE err_errors TO admins;


--
-- Name: err_files_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE err_files_id TO PUBLIC;


--
-- Name: err_files; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE err_files TO PUBLIC;
GRANT ALL ON TABLE err_files TO admins;


--
-- Name: err_names_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE err_names_id TO PUBLIC;


--
-- Name: err_names; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE err_names TO PUBLIC;
GRANT ALL ON TABLE err_names TO admins;


--
-- Name: esx-servers; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "esx-servers" TO PUBLIC;
GRANT ALL ON TABLE "esx-servers" TO admins;


--
-- Name: server_scans_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE server_scans_id TO PUBLIC;


--
-- Name: server_scans; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE server_scans TO PUBLIC;
GRANT ALL ON TABLE server_scans TO admins;


--
-- Name: vmerror; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vmerror TO PUBLIC;
GRANT ALL ON TABLE vmerror TO admins;


--
-- Name: allerrors; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE allerrors TO PUBLIC;
GRANT ALL ON TABLE allerrors TO admins WITH GRANT OPTION;


--
-- Name: guestid_types_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE guestid_types_id TO PUBLIC;


--
-- Name: guestid_types; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE guestid_types TO PUBLIC;
GRANT ALL ON TABLE guestid_types TO admins;


--
-- Name: guestos_types_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE guestos_types_id TO PUBLIC;


--
-- Name: guestos_types; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE guestos_types TO PUBLIC;
GRANT ALL ON TABLE guestos_types TO admins;


--
-- Name: vmexists; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vmexists TO PUBLIC;
GRANT ALL ON TABLE vmexists TO admins;


--
-- Name: vminfo_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE vminfo_id TO PUBLIC;


--
-- Name: vminfo; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vminfo TO PUBLIC;
GRANT ALL ON TABLE vminfo TO admins;


--
-- Name: vms_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT ON SEQUENCE vms_id TO PUBLIC;


--
-- Name: vms; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vms TO PUBLIC;
GRANT ALL ON TABLE vms TO admins;


--
-- Name: vmwaretools_types_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE vmwaretools_types_id TO PUBLIC;


--
-- Name: vmwaretools_types; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vmwaretools_types TO PUBLIC;
GRANT ALL ON TABLE vmwaretools_types TO admins;


--
-- Name: current_vms; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE current_vms TO PUBLIC;
GRANT ALL ON TABLE current_vms TO admins WITH GRANT OPTION;


--
-- Name: vmcategory; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vmcategory TO PUBLIC;
GRANT ALL ON TABLE vmcategory TO admins;


--
-- Name: vmcategory_types_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE vmcategory_types_id TO PUBLIC;


--
-- Name: vmcategory_types; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vmcategory_types TO PUBLIC;
GRANT ALL ON TABLE vmcategory_types TO admins;


--
-- Name: current_vms2; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE current_vms2 TO PUBLIC;
GRANT ALL ON TABLE current_vms2 TO admins WITH GRANT OPTION;


--
-- Name: entities; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE entities TO PUBLIC;
GRANT ALL ON TABLE entities TO admins;


--
-- Name: entities_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE entities_id TO PUBLIC;


--
-- Name: entity-types_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE "entity-types_id" TO PUBLIC;


--
-- Name: entity-types; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "entity-types" TO PUBLIC;
GRANT ALL ON TABLE "entity-types" TO admins;


--
-- Name: esx-servers_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE "esx-servers_id" TO PUBLIC;


--
-- Name: historical_overview; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON TABLE historical_overview TO "SystemsTeam";
GRANT ALL ON TABLE historical_overview TO admins;


--
-- Name: locations; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE locations TO PUBLIC;
GRANT ALL ON TABLE locations TO admins;


--
-- Name: locations_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE locations_id TO PUBLIC;


--
-- Name: overallstatus_types_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE overallstatus_types_id TO PUBLIC;


--
-- Name: overallstatus_types; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE overallstatus_types TO PUBLIC;
GRANT ALL ON TABLE overallstatus_types TO admins;


--
-- Name: vminfo_raw; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vminfo_raw TO PUBLIC;
GRANT ALL ON TABLE vminfo_raw TO admins;


--
-- Name: overview; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE overview TO PUBLIC;
GRANT ALL ON TABLE overview TO admins WITH GRANT OPTION;


--
-- Name: summary; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE summary TO PUBLIC;
GRANT ALL ON TABLE summary TO admins WITH GRANT OPTION;


--
-- Name: summary2; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE summary2 TO PUBLIC;
GRANT ALL ON TABLE summary2 TO admins WITH GRANT OPTION;


--
-- Name: vdiscovery; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vdiscovery TO PUBLIC;
GRANT ALL ON TABLE vdiscovery TO admins;


--
-- Name: vobject_types_id; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON SEQUENCE vobject_types_id TO PUBLIC;


--
-- Name: vobject_types; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vobject_types TO PUBLIC;
GRANT ALL ON TABLE vobject_types TO admins;


--
-- Name: vdiscover_tree; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vdiscover_tree TO PUBLIC;
GRANT ALL ON TABLE vdiscover_tree TO admins WITH GRANT OPTION;


--
-- Name: vdiscovery_raw; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vdiscovery_raw TO PUBLIC;
GRANT ALL ON TABLE vdiscovery_raw TO admins;


--
-- Name: vmerror_raw; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vmerror_raw TO PUBLIC;
GRANT ALL ON TABLE vmerror_raw TO admins;


--
-- Name: vminfo_data; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE vminfo_data TO PUBLIC;
GRANT ALL ON TABLE vminfo_data TO admins;


--
-- Name: vmowner; Type: ACL; Schema: vdiscover; Owner: postgres
--

GRANT ALL ON TABLE vmowner TO "SystemsTeam";
GRANT SELECT,REFERENCES ON TABLE vmowner TO PUBLIC;
GRANT ALL ON TABLE vmowner TO admins;


SET search_path = wscommands, pg_catalog;

--
-- Name: suspectresults; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE suspectresults TO PUBLIC;
GRANT ALL ON TABLE suspectresults TO "DevEnablement";


--
-- Name: ExcelMetrics-Current; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "ExcelMetrics-Current" TO PUBLIC;
GRANT ALL ON TABLE "ExcelMetrics-Current" TO "DevEnablement";


--
-- Name: ExcelMetrics1; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "ExcelMetrics1" TO PUBLIC;
GRANT ALL ON TABLE "ExcelMetrics1" TO admins WITH GRANT OPTION;
GRANT ALL ON TABLE "ExcelMetrics1" TO "DevEnablement";


--
-- Name: Reliable_Build_Users; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE "Reliable_Build_Users" TO PUBLIC;
GRANT ALL ON TABLE "Reliable_Build_Users" TO "DevEnablement";


--
-- Name: cmdargs; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE cmdargs TO PUBLIC;
GRANT ALL ON TABLE cmdargs TO "DevEnablement";


--
-- Name: host_class; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE host_class TO PUBLIC;
GRANT ALL ON TABLE host_class TO "DevEnablement";


--
-- Name: hosts; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE hosts TO PUBLIC;
GRANT ALL ON TABLE hosts TO "DevEnablement";


--
-- Name: messages; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE messages TO PUBLIC;
GRANT ALL ON TABLE messages TO "DevEnablement";


--
-- Name: raw_baseresults; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_baseresults TO PUBLIC;
GRANT ALL ON TABLE raw_baseresults TO admins WITH GRANT OPTION;


--
-- Name: raw_cmdargs; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_cmdargs TO PUBLIC;
GRANT ALL ON TABLE raw_cmdargs TO admins WITH GRANT OPTION;


--
-- Name: raw_messages; Type: ACL; Schema: wscommands; Owner: postgres
--

GRANT SELECT,REFERENCES ON TABLE raw_messages TO PUBLIC;
GRANT ALL ON TABLE raw_messages TO admins WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: -; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 GRANT ALL ON SEQUENCES  TO PUBLIC;


SET search_path = accurev, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: accurev; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA accurev REVOKE ALL ON FUNCTIONS  FROM ballab1;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: accurev; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA accurev REVOKE ALL ON TABLES  FROM ballab1;
ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA accurev GRANT SELECT ON TABLES  TO PUBLIC;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: -; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 GRANT SELECT,REFERENCES ON TABLES  TO PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 GRANT ALL ON TABLES  TO "DevEnablement";
ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 GRANT ALL ON TABLES  TO admins WITH GRANT OPTION;


SET search_path = cyclone, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: cyclone; Owner: ravalh1
--

ALTER DEFAULT PRIVILEGES FOR ROLE ravalh1 IN SCHEMA cyclone REVOKE ALL ON TABLES  FROM ravalh1;
ALTER DEFAULT PRIVILEGES FOR ROLE ravalh1 IN SCHEMA cyclone GRANT SELECT ON TABLES  TO PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE ravalh1 IN SCHEMA cyclone GRANT ALL ON TABLES  TO "CycloneDevOps";


SET search_path = jenkinslogger, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: jenkinslogger; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA jenkinslogger REVOKE ALL ON TABLES  FROM ballab1;
ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA jenkinslogger GRANT SELECT,REFERENCES ON TABLES  TO PUBLIC;


SET search_path = public, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA public REVOKE ALL ON TABLES  FROM ballab1;
ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA public GRANT SELECT,REFERENCES ON TABLES  TO PUBLIC;


SET search_path = remedy, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: remedy; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA remedy REVOKE ALL ON TABLES  FROM ballab1;
ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA remedy GRANT ALL ON TABLES  TO "DevEnablement";


SET search_path = vcenter, pg_catalog;

--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: vcenter; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA vcenter REVOKE ALL ON TABLES  FROM ballab1;
ALTER DEFAULT PRIVILEGES FOR ROLE ballab1 IN SCHEMA vcenter GRANT ALL ON TABLES  TO "DevEnablement";


--
-- PostgreSQL database dump complete
--


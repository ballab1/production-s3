#!/bin/bash

#############################################################################
#
#   deploy.bashlib; basic functions to run a cluster environment
#
#############################################################################

#----------------------------------------------------------------------------------------------
function deploy.__initGlobals()
{
    local -r base_dir=${1:?}
    local -r container_tag=${2:-}

    export START_TIME=$(date)

    [ -e "${base_dir}/.git" ] || trap.die "invalid base directory specified"


    # setup environment

    export CONFIG_DIR="${base_dir}"
    readonly CONFIG_DIR


    # verify our basic setup is good
    [ -f "${CONFIG_DIR}/container.os" ] || trap.die "missing 'container.os' file"
    export CONTAINER_OS="$(< "${CONFIG_DIR}/container.os")"
    readonly CONTAINER_OS

    # verify docker-compose.yml in 'config' dir
    export CONFIG_YAML="${CONFIG_DIR}/docker-compose.yml"
    readonly CONFIG_YAML
    [ -e "$CONFIG_YAML" ] || trap.die "Invalid configuration - no $CONFIG_YAML"


    export WORKSPACE_DIR="$(deploy.workspace "$base_dir")"
    readonly WORKSPACE_DIR
    local -i file_count=0
    if [ -d "$WORKSPACE_DIR" ]; then
        local -a files
        mapfile -t files < <(sudo find "$WORKSPACE_DIR" -maxdepth 1 -type f ! -name '*.log' ||:)
        file_count="${#files[*]}"
    fi
    [ $file_count -gt 0 ] || deploy.showInitializationBanner


    export VERSIONS_INFO="${CONFIG_DIR}/.versions"
    readonly VERSIONS_INFO

    export LOG_DIR="${base_dir}/logs"
    readonly LOG_DIR

    export SECRETS_DIR="${WORKSPACE_DIR}/.secrets"
    readonly SECRETS_DIR

    export CONTAINER_TAG="$(deploy.containerTag "$container_tag")"

    export CFG_USER
    : ${CFG_USER:=$(git.user)}
    : ${CFG_USER:=${USERNAME:-}}
    : ${CFG_USER:=${USER:-}}
    CFG_USER="${CFG_USER%@*}"
    readonly CFG_USER

    export CFG_NAME="${CFG_NAME:-$(git.userName)}"
    readonly CFG_NAME

    export CFG_EMAIL="${CFG_EMAIL:-$(git.userEmail)}"
    readonly CFG_EMAIL


    # enable container logging during startup
    : ${DEBUG_TRACE:=0}
    export DEBUG_TRACE=$(( DEBUG_TRACE++ )) ||:
}
export -f deploy.__initGlobals

#----------------------------------------------------------------------------------------------
function deploy.clean()
{
    local -r workspace=${1:?}

    local network="$(basename "${workspace}")_default"
    network="${network//./}"
    local -i networks=$(docker network ls | grep "$network" | wc -l ||:)
    if [ $networks -gt 0 ]; then
        mkdir -p "$workspace" ||:
        local -r dc_yaml="${workspace}/docker-compose.yml"
        sudo cp "${CONFIG_DIR}/docker-compose.yml" "$dc_yaml"

        term.log 'INFO: bringing down containers to allow "workspace" to be cleaned5\n' 'lt_magenta'
        term.log '$ docker-compose down\n'
        docker-compose --file "$dc_yaml" down ||:
    fi

    term.log "\$ rm -rf $workspace"'\n'
    sudo rm -rf "$workspace"
}
export -f deploy.clean

#----------------------------------------------------------------------------------------------
function deploy.containerTag()
{
    local -r container_tag=${1:-}

    case $(git.branch) in
        dev)                       echo 'dev';;
        master|integration)        echo "$container_tag";;
        *)                         echo 'latest';;
    esac
}
export -f deploy.containerTag

#----------------------------------------------------------------------------------------------
function deploy.containerVersion()
{
    local -r line=${1:?}
    local -r json=${2:?}

    local awkCode
    read -r -d '?' awkCode <<'EOF'
split($0,arr,"$");
for (i in arr) {
  if (i == 1)
    x = arr[i];
  else if (i == 2)
    x = x "$" arr[i];
  else {
    sub("{.+-", "", arr[i]);
    sub("}", "", arr[i]);
    x = x arr[i];
  }
}
print x;
?
EOF

    local container newimage orgimage service srvc version

    local -r image="$(sed -E 's|\s+image:\s+(.+)$|\1|' <<< "$line")"
    while read -r srvc; do
        service=$(jq ".services.$srvc" <<< "$json")
        [ $(jq -r '.image' <<< "$service") = "$image" ] || continue

        container=$(jq -r '.container_name' <<< "$service")
        version=$(docker inspect "$container" | jq -r '.[].Config.Labels."container.fingerprint"')
        [ "$version" != 'null' ] || break
        orgimage="$(docker inspect "$container" | jq -r '.[].Config.Image')"

        newline="$line"
        [ $(grep -sc 'CONTAINER_TAG' <<< "$newline") -eq 0 ] || newline="${line%\${CONTAINER_TAG*}"'${CONTAINER_TAG:-'$version'}'

        echo -n '{'
        echo -n '"orgline":"'${line}'",'
        echo -n '"orgimage":"'$(eval echo $image)'",'
        echo -n '"version":"'$version'",'
        echo -n '"newline":"'"$newline"'",'

        [ $(grep -sc 'CONTAINER_TAG' <<< "$newline") -eq 0 ] || newline="${line%\${CONTAINER_TAG*}"
        [ $(grep -sc "$version" <<< "$newline") -eq 0 ]      || newline="${newline%:*}:"
        newline="${newline%:*}:$version"
        echo -n '"promoted":"'$(awk -f awkCode.txt <<< "$newline")'",'
#        echo -n '"promoted":"'$(awk -f <(echo $awkCode) <<< "$$newline")'",'
        echo '"newimage":"'${orgimage%:*}:$version'"}'
        break

    done < <(jq -r '.services|keys[]' <<< "$json")
}
export -f deploy.containerVersion

#----------------------------------------------------------------------------------------------
function deploy.createVolumeFolders()
{
    local json="${1:?}"
    local service_name="${2:?}"

    local -a dirs=(jq '.' "$json" )
    mapfile -t dirs < <(jq -r ".services.${service_name}.volumes[]?" <<< "$json" \
                       | awk -F ':' '{print $1}' \
                       | grep -v '/docker' \
                       | grep -Ev '^~' \
                       | sort -u ||:)
    [ "${#dirs[*]}" -gt 0 ] || continue

    local dir
    for dir in "${dirs[@]}"; do
        [ "${dir:0:2}" = './' ] && dir="${dir:2}"                        # remove './' prefix
        # initialize dir when needed
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir" ||:
            sudo chown "$EUID" "$dir"
            [ "$dir" = "${service_name}/log" ] && chmod 777 "$dir"
        fi

        # ensure log symlinks are setup
        if [ "$dir" = "${service_name}/log" ] && [ "$(readlink "${LOG_DIR}/$service_name")" != "${WORKSPACE_DIR}/$dir" ]; then
            # get rid of any old stuff that may prevent us creating symlink
            [ -f "${LOG_DIR}/$service_name" ] && sudo rm "${LOG_DIR}/$service_name"
            [ -h "${LOG_DIR}/$service_name" ] && sudo rm "${LOG_DIR}/$service_name"
            ln -s "${WORKSPACE_DIR}/$dir" "${LOG_DIR}/$service_name"
        fi
    done
}
export -f deploy.createVolumeFolders

#----------------------------------------------------------------------------------------------
function deploy.generateSSL()
{
    local -r secretDir=${1:?}

    mkdir -p "$secretDir" ||:
    pushd "$secretDir" >/dev/null
    if [ ! -e dhparam.pem ] || [ ! -e server.key ] || [ ! -e server.crt ] || [ ! -e server.csr ]; then

        term.log '>> GENERATING SSL CERT\n' 'lt_magenta'
        openssl genrsa -des3 -passout pass:x -out server.pass.key 2048
        openssl rsa -passin pass:x -in server.pass.key -out server.key
        rm server.pass.key

        openssl dhparam -out dhparam.pem 2048
        openssl req -new -key server.key -out server.csr -subj "/C=US/ST=Massachusetts/L=Hopkinton/O=DELL_EMC/OU=com/OU=docker.nginx.io/CN=$(hostname -s)"
        openssl x509 -req -sha256 -days 300065 -in server.csr -signkey server.key -out server.crt
        term.log '>> GENERATING SSL CERT ... DONE\n' 'lt_magenta'
    fi
    popd >/dev/null
}
export -f deploy.generateSSL

#----------------------------------------------------------------------------------------------
# setup workspace if it does not exist
function deploy.initialize()
{
    local -r base=${1:?}

    # import our setup configuration
    local -r setup_config="${CONFIG_DIR}/setup.cfg"
    if [ -e "$setup_config" ]; then
        while read -r line; do
            eval "export $line"
        done < <(cat "$setup_config")
    fi

    : ${HOST_IP:?"HOST_IP has not been configured. Please update '$setup_config'"}
    : ${HOST_NAME:?"HOST_NAME has not been configured. Please update '$setup_config'"}
# these need to be external
    : ${KAFKA_ID:?"KAFKA_ID has not been configured. Please update '$setup_config'"}
    : ${GRAFANA_UID:?"GRAFANA_UID has not been configured. Please update '$setup_config'"}


    # ensure our log dir exists
    [ -d "$LOG_DIR" ] || mkdir -p "$LOG_DIR" ||:

    mkdir -p "$WORKSPACE_DIR" ||:
    cd "$WORKSPACE_DIR"

    # copy docker-compose.yml to workspace
    local -r dc_yaml="${WORKSPACE_DIR}/docker-compose.yml"
    deploy.updateDockerComposeYaml "$dc_yaml"
    local json="$(docker.yamlToJson "$dc_yaml")"


    local -ri num_secrets=$(jq '.services[]|select(has("secrets"))|.secrets[]' <<< "$json" | wc -l)
    [ "$num_secrets" -eq 0 ] || [ -d "$SECRETS_DIR" ] || deploy.populateSecrets "$SECRETS_DIR"


    # create the folders which are mounted by containers (defined in docker-compose volumes)
    local -A service_tasks=()
    for service_name in $(docker.services "$dc_yaml"); do

        # look for individual service tasks (to run later)
        if [ ! -d "$service_name" ]; then
            local initFunction="${CONFIG_DIR}/${service_name}.setup"
            [ -e  "$initFunction" ] && service_tasks["$service_name"]="$initFunction"
        fi

        # get any defined volumes
        deploy.createVolumeFolders "$json" "$service_name"
    done


    # now run our service tasks
    for task in $(printf '%s\n' "${!service_tasks[@]}" | sort); do
        chmod a+rx "${service_tasks[$task]}"
        "${service_tasks[$task]}" ||:
    done

    # update secret references (cannot apply these with other docker-compose.yml updates)
    [ "$num_secrets" -eq 0 ] || deploy.updateSecretRefs "$dc_yaml"
}
export -f deploy.initialize

#----------------------------------------------------------------------------------------------
function deploy.main()
{
    local -A opts
    eval opts=( ${1:?} )
    readonly opts
    shift
    local -ra args=( "$@" )

    deploy.__initGlobals "${opts['base']}" "${opts['latest']:-}"

    local workspace="$(deploy.workspace "${opts['base']}")"
    [ -z "${opts['clean']:-}" ] || deploy.clean "$workspace"
    mkdir -p "$workspace" ||:


    # temporarily reduce DEBUG_TRACE to prevent 'git' tracing
    (( DEBUG_TRACE-- )) ||:
    versions.data "$VERSIONS_INFO" "${CONTAINER_TAG:-}"
    versions.get "$CONTAINER_OS" 'export'
    (( DEBUG_TRACE++ )) ||:

    if [ "${opts['init']:-}" ]; then
        #  initialize devops_container_environment
        term.log '\n$ deploy.initialize 2>&1 | tee setup.log\n'
        deploy.initialize "${opts['base']}" 2>&1 | tee "${workspace}/setup.log"
        exit 0
    fi

    local dc_yaml="${workspace}/docker-compose.yml"
    if [ "${opts['down']:-}" ] && [ -f "$dc_yaml" ]; then
        # stop any running containers
        term.log '\n'" docker-compose --file $dc_yaml down"'\n'
        docker-compose --file "$dc_yaml" down ||:
        exit 0
    fi

    #  restart devops_container_environment  (performs configuration if needed)
    term.log '\n$ deploy.restart 2>&1 | tee restart.log\n'
    deploy.restart "${opts['base']}" 2>&1 | tee "${workspace}/restart.log"

    #  update main docker-compose.yml if this is for promotion
    if [ "${CONTAINER_TAG:-}" != 'latest' ] && [ "${opts['promote']:-}" ]; then
        deploy.reTagImages "$dc_yaml"
        # Updating reference docker-compose.yml
        deploy.updateContainerReference "$CONFIG_YAML" "${opts['promote']}"
        # now update docker registry
        deploy.pushImages "$dc_yaml"
    fi
}
export -f deploy.main

#----------------------------------------------------------------------------------------------
function deploy.passwordSecret()
{
    local -r json=${1:?}
    local -r service=${2:?}
    local -r pwdVar=${3:?}

    local secret jqquery
    local password="$(jq -r '.services.'${service}'.environment.'${pwdVar} <<< "$json" )"
    if [ "$password" = 'null' ];then
        password="$(jq -r '.services.'${service}'.environment.'${pwdVar}'_FILE' <<< "$json" )"
        secret="$(basename "$password")"
        jqquery='.secrets."'"${secret}"'".file'
        local pwd_file="$(eval echo "$(jq -r "$jqquery" <<< "$json" )")"
        [ -e "$pwd_file" ] || trap.die "Password file: '$pwd_file' not found. Used by startup of service: $service"
        password=$(< "$pwd_file")
    fi
    echo "$password"
}
export -f deploy.passwordSecret

#----------------------------------------------------------------------------------------------
function deploy.populateSecrets()
{
    local -r secrets_dir=${1:-}

    term.log 'populating secrets\n'
    if [ -z "${CFG_USER_SECRETS:-}" ]; then
        [ "${OPEN_SECRETS_REPO:-}" ] || trap.die  "no definition provided for 'secrets'"
        mkdir -p "$(dirname "$secrets_dir")"
        git.clone "$OPEN_SECRETS_REPO" "$secrets_dir"

    elif [ -d "${CFG_USER_SECRETS}" ] &&  [ "$(readlink -f "$CFG_USER_SECRETS")" != "$(readlink -f "$secrets_dir")" ]; then
        mkdir -p "$secrets_dir"
        cp -r "${CFG_USER_SECRETS}"/* "$secrets_dir"/

    elif git.lsRemote "${CFG_USER_SECRETS}" &> /dev/null ; then
        mkdir -p "$(dirname "$secrets_dir")"
        git.clone "$CFG_USER_SECRETS" "$secrets_dir" --quiet
        if [ "$(grep -sc 'git-crypt' "${secrets_dir}/.gitattributes")" -gt 0 ]; then
            [ -e "${CRYPT_FILE:-}" ] || trap.die "secrets are encoded, but CRYPT_FILE: '${CRYPT_FILE:-}' does not exist"
            (cd "$secrets_dir"; git.cryptUnlock )
        fi

    else
        trap.die  "missing 'secrets' directory in workspace"
    fi

    # ensure we have self signed certs (incase they are not include in secrets dir
    deploy.generateSSL "$secrets_dir"
}
export -f deploy.populateSecrets

#----------------------------------------------------------------------------------------------
function deploy.pushImages()
{
    local -r dc_yaml=${1:?}

    local image service srvc
    local -a images=()

    local -r json=$(docker.yamlToJson "$dc_yaml")

    # extract images from docker-compose
    while read -r srvc; do
        service=$(jq ".services.$srvc" <<< "$json")
        image="$(eval echo "$(jq -r '.image' <<< "$service")" )"
        images+=( "$image" )
    done < <(jq -r '.services|keys[]' <<< "$json")

    registry.push 1 "${images[@]}"
}
export -f deploy.pushImages

#----------------------------------------------------------------------------------------------
function deploy.refreshContainers()
{
    local -r dc_yaml=${1:?}

    # make sure we start the correct versions
    if [ "${CONTAINER_TAG:-}" = 'latest' ]; then
        term.log '\nINFO: updating containers to latest versions\n' 'white'
    else
        term.log '\n'"INFO: using container fingerprints defined in docker-compose.yml"'\n' 'white'
    fi
    term.log " docker-compose --file $dc_yaml pull"
    docker-compose --file "$dc_yaml" pull || return 1
    docker.rmOldContainers
}
export -f deploy.refreshContainers

#----------------------------------------------------------------------------------------------
function deploy.removeCBFlogs()
{
    for dir in $(find "$WORKSPACE_DIR" -mindepth 2 -maxdepth 2 -type d -name log); do
        [ -f "${dir}/cbf.log" ] || continue
        sudo rm "${dir}/cbf.log"
    done
}
export -f deploy.removeCBFlogs

#----------------------------------------------------------------------------------------------
function deploy.replaceIpAddresses()
{
    local -r filename=${1:?}
    local -r host_ip=${2:?}

    if [ -e "$filename" ]; then
        local -r ip_match_rgx='((1?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9][0-9]?|2[0-4][0-9]|25[0-5])'
        local expr="'s#${ip_match_rgx}#${host_ip}#g'"
        eval sed -i -r -e "$expr" "$filename"
    fi
}
export -f deploy.replaceIpAddresses

#----------------------------------------------------------------------------------------------
function deploy.restart()
{
    local -r base=${1:-}

    # initialize workspace if required 'docker-compose.yml' is missing
    local -r dc_yaml="${WORKSPACE_DIR}/docker-compose.yml"
    [ -f "$dc_yaml" ] || deploy.initialize "$base"
    deploy.removeCBFlogs

    # restart our environment
    if ! deploy.restartContainers "$dc_yaml"; then
        term.log 'Failed to succussfully deploy container services.\n' 'white'
        exit 1
    fi

    local -r run_log="${WORKSPACE_DIR}/run.log"
    deploy.waitForInitializationComplete "$dc_yaml" "$run_log"

    docker.showProcessReport
    echo

    if [ "${INITIALIZATION:-}" ]; then
        term.log "Initializing complete. If this setup includes a web server, please open the following URL in your browser: http://$HOST_IP"'\n' 'white'
    fi
    exit 0
}
export -f deploy.restart

#----------------------------------------------------------------------------------------------
function deploy.restartContainers()
{
    local -r dc_yaml=${1:?}
    local -i status

    # stop any running containers
    term.log " docker-compose --file $dc_yaml down"'\n'
    docker-compose --file "$dc_yaml" down ||:
    set -o verbose
    sudo find -L "$LOG_DIR" -type f ! -name '.*' -delete
    set +o verbose

    deploy.refreshContainers "$dc_yaml" && status=$? || status=$?
    [ $status -eq 0 ] || return $status

    term.log 'INFO: bringing up containers\n' 'white'
    term.log " docker-compose --file $dc_yaml up --detach"'\n'
    # docker-compose v1.17.0 does not like '--detach'!
    docker-compose --file "$dc_yaml" up -d  && status=$? || status=$?

    # fixup docker-compose.yml to reflect the image versions in use
    if [ "${CONTAINER_TAG:-}" = 'latest' ]; then
        # Updating reference docker-compose.yml
        deploy.updateContainerReference "$CONFIG_YAML"
        deploy.updateContainerReference "$dc_yaml"
    fi
    return $status
}
export -f deploy.restartContainers

#----------------------------------------------------------------------------------------------
function deploy.reTagImages()
{
    local -r dc_yaml=${1:?}

    local image tag
    local orgtag=$(git.branch)
    while read -r image; do
        image="$(eval echo $image)"
        if [ $(docker images | grep -cs "$image") -gt 0 ]; then
#            image="${image%=*}"
#           tag="${image##*=}"
            term.log "renaming $image to ${image%=*}:$CONTAINER_TAG"'\n' 'warn'
            docker tag "$image" "${image%=*}:$CONTAINER_TAG"
        else
            term.log "no images matching $image"'\n' 'warn'
        fi
    done < <(grep -E '^\s+image:\s' "$dc_yaml" | sed -E -e 's|^\s+image:\s+||' )
}
export -f deploy.reTagImages

#----------------------------------------------------------------------------------------------
function deploy.showInitializationBanner()
{
    term.log '******************************************************************************\n' 'white'
    term.log '*                                                                            *\n' 'white'
    term.log "*  initializing DevOps Container Environment on $(environ.ipAddress)"'\n'         'white'
    term.log '*                                                                            *\n' 'white'
    term.log '******************************************************************************\n' 'white'
    export INITIALIZATION='true'
}

#----------------------------------------------------------------------------------------------
function deploy.updateContainerReference()
{
    local -r dc_yaml=${1:?}
    local -r promoted=${2:-}

    local line newline promote tmp_yaml

    [ "${promoted:-}" ] || term.log '   Updating '"$dc_yaml"'\n'

    # create backup of file before we modify it
    tmp_yaml="${dc_yaml}.$(date +"%Y%m%d%H%M%S").bak"
    cp "$dc_yaml" "$tmp_yaml"

    local -r json=$(docker.yamlToJson "$dc_yaml")

    # update image definition
    while read -r line; do
        local elm='.newline'
        [ "${promoted:-}" ] && elm='.promoted'
        newline=$(deploy.containerVersion "$line" "$json" | jq -r "$elm")

        # update workspace/docker-compose.yml when we pull latest images
        [[ -z "$newline"  ||  "$line" = "$newline" ]] && continue

        # skip update if nothing changed
        sed -i -e "s|$line|$newline|" "$dc_yaml"
    done < <(cat "$dc_yaml" | grep -E '^\s+image:\s' ||:)

    # update any versions
    while read -r line; do
        local keyName=$(sed -E 's|^\s+.+\$\{([A-Z0-9]+_VERSION):-[^}]+}.*$|\1|' <<< "$line")
        newline=$(sed -E 's|^(\s+.*\$\{'${keyName}':-)[^\}]+(}.*)$|\1'${!keyName}'\2|' <<< "$line")

        # skip update if nothing changed
        [[ -z "$newline"  ||  "$line" = "$newline" ]] && continue

        # update workspace/docker-compose.yml when we pull latest images
        sed -i -e "s|$line|$newline|" "$dc_yaml"
    done < <(cat "$dc_yaml" | grep -E '^\s+.+\${[A-Z0-9]+_VERSION:-' ||:)

    # remove backup if there are no changes
    [ $(sha256sum "$dc_yaml" | cut -d' ' -f1) != $(sha256sum "$tmp_yaml" | cut -d' ' -f1) ] || rm "$tmp_yaml"
}
export -f deploy.updateContainerReference

#----------------------------------------------------------------------------------------------
function deploy.updateDockerComposeYaml()
{
    local -r dc_yaml=${1:?}
    local -r host_ip=${2:-$HOST_IP}
    local -r this_host=${3:-$HOST_NAME}

    local -r id=${4:-$KAFKA_ID}
    local -r grafana_uid=${5:-$GRAFANA_UID}
    local -r email=${6:-$CFG_EMAIL}
    local -r user=${7:-$CFG_USER}
    local -r github_name=${5:-$CFG_NAME}

# TODO: always update docker-compose and skip.wait. move current to *.YYYYMMDDhhmmss.bak, and delete *.bak files if there is no change

    term.log "updating $dc_yaml:\n" 'white'

    # update copy of docker-compose
    cp "${CONFIG_DIR}/skip.wait" "${WORKSPACE_DIR}/skip.wait"
    term.log "    removing unneeded comments\n" 'grey'
    grep -vE '^\s*#' "$CONFIG_YAML" ||: > "$dc_yaml"

    term.log "    updating VERSIONS referenced\n" 'grey'
    for version in $(versions.get "$CONTAINER_OS" 'echo'); do
        var="${version%=*}"
        val="${version##*=}"
        eval sed -i -r -e "'s|(\\\$\{${var}:-)[^\}]+\}|\1${val}\}|g'" "$dc_yaml"
    done

    [ $(grep -scE '255\.255\.255\.255' "$dc_yaml") -gt 0 ] && term.log "    updating IP to $host_ip\n" 'grey'
    [ $(grep -scE 'alpine' "$dc_yaml") -gt 0 ]             && term.log "    updating CONTAINER_OS to ${CONTAINER_OS}\n" 'grey'
# TODO: the following needs abstracted to setup folders
    [ $(grep -scE 'KAFKA_BROKER_ID:' "$dc_yaml") -gt 0 ]   && term.log "    updating KAFKA_BROKER_ID to ${id}\n" 'grey'
    [ $(grep -scE 'ZOOKEEPER_MY_ID:' "$dc_yaml") -gt 0 ]   && term.log "    updating ZOOKEEPER_MY_ID to ${id}\n" 'grey'
    [ $(grep -scE 'user:' "$dc_yaml") -gt 0 ]              && term.log "    updating GRAFANA_UID to ${grafana_uid}\n" 'grey'
    sed -i -r -e 's|255.255.255.255|'"${host_ip}"'|g' \
              -e 's|alpine|'"${CONTAINER_OS}"'|g' \
              -e 's|(KAFKA_BROKER_ID: ).*$|\1'"${id}"'|' \
              -e 's|(ZOOKEEPER_MY_ID: ).*$|\1'"${id}"'|' \
              -e 's|user:\s+"?1000"?|user: "'"${grafana_uid}"'"|' \
             "$dc_yaml"
    [ -z "${CFG_EMAIL:-}" ] || sed -i -r -e 's|\$\{CFG_EMAIL:-\}|${CFG_EMAIL:-'"${email}"'}|g' "$dc_yaml"
    [ -z "${CFG_NAME:-}" ]  || sed -i -r -e 's|\$\{CFG_NAME:-\}|${CFG_NAME:-'"${github_name}"'}|g' "$dc_yaml"
    [ -z "${CFG_USER:-}" ]  || sed -i -r -e 's|\$\{CFG_USER:-\}|${CFG_USER:-'"${user}"'}|g' "$dc_yaml"

}
export -f deploy.updateDockerComposeYaml

#----------------------------------------------------------------------------------------------
function deploy.updateSecretRefs()
{
    local -r dc_yaml=${1:?}
    sed -i -r -e "s|file:\s+~/|file: /home/bobb/|"   "$dc_yaml"
}
export -f deploy.updateSecretRefs

#----------------------------------------------------------------------------------------------
function deploy.validateDockerComposeYaml()
{
    local -r dc_yaml=${1:?}
    [ $(jq '.services[].ports[]' <<< "$dc_yaml" | sort | wc -l) -eq $(jq '.services[].ports[]' <<< "$dc_yaml"| sort -u) ] || return 1
}
export -f deploy.validateDockerComposeYaml

#----------------------------------------------------------------------------------------------
function deploy.waitForInitializationComplete()
{
    local -r dc_yaml=${1:?}
    local -r run_log=${2:?}

    # get the list of containers we will be checking
    local -a containers
    mapfile -t containers < <(docker.services "$dc_yaml")


    # initialize the log
    echo "Started at: ${START_TIME}" > "$run_log"

    local -A finished=( )
    local -a lines=()
    local container line
    local -i index=1

    term.log '\n'"INFO: waiting for ${#containers[*]} containers to complete their startup"'\n' 'white'
    while [ ${#finished[*]} -lt ${#containers[*]} ]; do
        sleep 5
        lines=()
        for container in "${containers[@]}"; do
            if [ $(grep -sc "$container" "${WORKSPACE_DIR}/skip.wait") -gt 0 ] && [ -z "${finished[${container,,}]:-}" ]; then
                printf '%02d. %s: skipping wait.\n' $(( index++ )) "${container^^}"
                finished[$container]='0'
            fi

            local text="$(docker logs "${container,,}" 2>&1 | grep -s "Finished executing startup" | head -1 ||: )"
            [ "$text" ] || continue                                        # ignore blank lines
            [ "${container,,}" ] || continue                               # ignore invalid container
            [ -z "${finished[${container,,}]:-}" ] || continue             # ignore if we already have this result

            finished[${container,,}]="$text"
            lines+=( "$(sed -Ee 's|^.+Finished executing startup scripts after ||' <<< "$text" | awk -F ':' '{ print ((($1 * 60) + $2) * 60) + $3 }')_${container,,}" )
        done
        [ ${#lines[*]} -gt 0 ] || continue

        for line in $(printf '%s\n' "${lines[@]}" | sort -t '_' -k 1n,2); do   # sort by time taken to finish startup
            container="${line##*_}"                                            # extract container name
            container="${container,,}"
            printf '%02d. %s\n' $(( index++ )) "${finished[${container}]:-}"
            docker logs "${container}" >> "$run_log" 2>&1                      # grab the log
        done
    done

    for container in "${containers[@]}"; do
        if [ $(grep -sc "$container" "${WORKSPACE_DIR}/skip.wait") -gt 0 ]; then
            echo >> "$run_log" 2>&1
            echo '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>' >> "$run_log" 2>&1
            echo "${container}" >> "$run_log" 2>&1
            echo >> "$run_log" 2>&1
            docker logs "${container}" >> "$run_log" 2>&1                      # grab the log
        fi
    done
}
export -f deploy.waitForInitializationComplete

#----------------------------------------------------------------------------------------------
function deploy.workspace()
{
    local -r base_dir=${1:?}
    echo "${base_dir}/workspace.$(basename "$base_dir")"
}
export -f deploy.workspace

#----------------------------------------------------------------------------------------------
